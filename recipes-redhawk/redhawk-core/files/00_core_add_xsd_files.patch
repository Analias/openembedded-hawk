diff --git src/base/include/xsd/LICENSE src/base/include/xsd/LICENSE
new file mode 100644
index 0000000..3912109
--- /dev/null
+++ src/base/include/xsd/LICENSE
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+                       51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
diff --git src/base/include/xsd/cxx/auto-array.hxx src/base/include/xsd/cxx/auto-array.hxx
new file mode 100644
index 0000000..2b4e100
--- /dev/null
+++ src/base/include/xsd/cxx/auto-array.hxx
@@ -0,0 +1,114 @@
+// file      : xsd/cxx/auto-array.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_AUTO_ARRAY_HXX
+#define XSD_CXX_AUTO_ARRAY_HXX
+
+#include <cstddef> // std::size_t
+
+namespace xsd
+{
+  namespace cxx
+  {
+    template <typename T>
+    struct std_deallocator
+    {
+      void
+      deallocate (T* p)
+      {
+        delete[] p;
+      }
+    };
+
+    // Simple automatic array. The second template parameter is
+    // an optional deallocator type. If not specified, delete[]
+    // is used.
+    //
+    template <typename T, typename D = std_deallocator<T> >
+    struct auto_array
+    {
+      auto_array (T a[])
+          : a_ (a), d_ (0)
+      {
+      }
+
+      auto_array (T a[], D& d)
+          : a_ (a), d_ (&d)
+      {
+      }
+
+      ~auto_array ()
+      {
+        if (d_ != 0)
+          d_->deallocate (a_);
+        else
+          delete[] a_;
+      }
+
+      T&
+      operator[] (std::size_t index) const
+      {
+        return a_[index];
+      }
+
+      T*
+      get () const
+      {
+        return a_;
+      }
+
+      T*
+      release ()
+      {
+        T* tmp (a_);
+        a_ = 0;
+        return tmp;
+      }
+
+      void
+      reset (T a[] = 0)
+      {
+        if (a_ != a)
+        {
+          if (d_ != 0)
+            d_->deallocate (a_);
+          else
+            delete[] a_;
+
+          a_ = a;
+        }
+      }
+
+      typedef void (auto_array::*bool_convertible)();
+
+      operator bool_convertible () const
+      {
+        return a_ ? &auto_array<T, D>::true_ : 0;
+      }
+
+    private:
+      auto_array (const auto_array&);
+
+      auto_array&
+      operator= (const auto_array&);
+
+    private:
+      void
+      true_ ();
+
+    private:
+      T* a_;
+      D* d_;
+    };
+
+    template <typename T, typename D>
+    void auto_array<T, D>::
+    true_ ()
+    {
+    }
+  }
+}
+
+#endif  // XSD_CXX_AUTO_ARRAY_HXX
diff --git src/base/include/xsd/cxx/compilers/vc-7/post.hxx src/base/include/xsd/cxx/compilers/vc-7/post.hxx
new file mode 100644
index 0000000..5357cd4
--- /dev/null
+++ src/base/include/xsd/cxx/compilers/vc-7/post.hxx
@@ -0,0 +1,6 @@
+// file      : xsd/cxx/compilers/vc-7/post.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#pragma warning (pop)
diff --git src/base/include/xsd/cxx/compilers/vc-7/pre.hxx src/base/include/xsd/cxx/compilers/vc-7/pre.hxx
new file mode 100644
index 0000000..6b9b5fb
--- /dev/null
+++ src/base/include/xsd/cxx/compilers/vc-7/pre.hxx
@@ -0,0 +1,36 @@
+// file      : xsd/cxx/compilers/vc-7/pre.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+
+#if (_MSC_VER < 1310)
+#  error Microsoft Visual C++ 7.0 (.NET 2002) is not supported.
+#endif
+
+
+// These warnings had to be disabled "for good".
+//
+#pragma warning (disable:4250) // inherits via dominance
+#pragma warning (disable:4505) // unreferenced local function has been removed
+#pragma warning (disable:4661) // no definition for explicit instantiation
+
+
+// Push warning state.
+//
+#pragma warning (push, 3)
+
+
+// Disabled warnings.
+//
+#pragma warning (disable:4355) // passing 'this' to a member
+#pragma warning (disable:4584) // is already a base-class
+#pragma warning (disable:4800) // forcing value to bool
+#pragma warning (disable:4275) // non dll-interface base
+#pragma warning (disable:4251) // base needs to have dll-interface
+#pragma warning (disable:4224) // nonstandard extension (/Za option)
+
+
+// Elevated warnings.
+//
+#pragma warning (2:4239) // standard doesn't allow this conversion
diff --git src/base/include/xsd/cxx/compilers/vc-8/post.hxx src/base/include/xsd/cxx/compilers/vc-8/post.hxx
new file mode 100644
index 0000000..c7d3b3f
--- /dev/null
+++ src/base/include/xsd/cxx/compilers/vc-8/post.hxx
@@ -0,0 +1,6 @@
+// file      : xsd/cxx/compilers/vc-8/post.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#pragma warning (pop)
diff --git src/base/include/xsd/cxx/compilers/vc-8/pre.hxx src/base/include/xsd/cxx/compilers/vc-8/pre.hxx
new file mode 100644
index 0000000..02161a4
--- /dev/null
+++ src/base/include/xsd/cxx/compilers/vc-8/pre.hxx
@@ -0,0 +1,28 @@
+// file      : xsd/cxx/compilers/vc-8/pre.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+// These warnings had to be disabled "for good".
+//
+#pragma warning (disable:4250) // inherits via dominance
+#pragma warning (disable:4661) // no definition for explicit instantiation
+
+
+// Push warning state.
+//
+#pragma warning (push, 3)
+
+
+// Disabled warnings.
+//
+#pragma warning (disable:4355) // passing 'this' to a member
+#pragma warning (disable:4800) // forcing value to bool
+#pragma warning (disable:4275) // non dll-interface base
+#pragma warning (disable:4251) // base needs to have dll-interface
+#pragma warning (disable:4224) // nonstandard extension  (/Za option)
+
+
+// Elevated warnings.
+//
+#pragma warning (2:4239) // standard doesn't allow this conversion
diff --git src/base/include/xsd/cxx/config.hxx src/base/include/xsd/cxx/config.hxx
new file mode 100644
index 0000000..badfe03
--- /dev/null
+++ src/base/include/xsd/cxx/config.hxx
@@ -0,0 +1,15 @@
+// file      : xsd/cxx/config.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_CONFIG_HXX
+#define XSD_CXX_CONFIG_HXX
+
+#include <xsd/cxx/version.hxx>
+
+// Macro to suppress unused variable warning.
+//
+#define XSD_UNUSED(x) (void)x
+
+#endif // XSD_CXX_CONFIG_HXX
diff --git src/base/include/xsd/cxx/exceptions.hxx src/base/include/xsd/cxx/exceptions.hxx
new file mode 100644
index 0000000..d5f01c1
--- /dev/null
+++ src/base/include/xsd/cxx/exceptions.hxx
@@ -0,0 +1,21 @@
+// file      : xsd/cxx/exceptions.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_EXCEPTIONS_HXX
+#define XSD_CXX_EXCEPTIONS_HXX
+
+#include <exception> // std::exception
+
+namespace xsd
+{
+  namespace cxx
+  {
+    struct exception: std::exception
+    {
+    };
+  }
+}
+
+#endif  // XSD_CXX_EXCEPTIONS_HXX
diff --git src/base/include/xsd/cxx/parser/document.hxx src/base/include/xsd/cxx/parser/document.hxx
new file mode 100644
index 0000000..992b800
--- /dev/null
+++ src/base/include/xsd/cxx/parser/document.hxx
@@ -0,0 +1,90 @@
+// file      : xsd/cxx/parser/document.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_PARSER_DOCUMENT_HXX
+#define XSD_CXX_PARSER_DOCUMENT_HXX
+
+#include <string>
+#include <cstddef> // std::size_t
+
+#include <xsd/cxx/ro-string.hxx>
+#include <xsd/cxx/parser/elements.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      // If you want to use a different underlying XML parser, all you
+      // need to do is to route events to this interface.
+      //
+      template <typename C>
+      class document
+      {
+      public:
+        virtual
+        ~document ();
+
+        document (parser_base<C>& root,
+                  const std::basic_string<C>& ns,
+                  const std::basic_string<C>& name);
+
+      public:
+        // The type argument is a type name and namespace from the
+        // xsi:type attribute in the form "<name> <namespace>" with
+        // the space and namespace part absent if the type does not
+        // have a namespace or 0 if xsi:type is not present.
+        //
+        void
+        start_element (const ro_string<C>& ns,
+                       const ro_string<C>& name,
+                       const ro_string<C>* type);
+
+        void
+        end_element (const ro_string<C>& ns, const ro_string<C>& name);
+
+        void
+        attribute (const ro_string<C>& ns,
+                   const ro_string<C>& name,
+                   const ro_string<C>& value);
+
+        void
+        characters (const ro_string<C>&);
+
+      protected:
+        document ();
+
+        // This function is called to obtain the root element type parser.
+        // If the returned pointed is 0 then the whole document content
+        // is ignored.
+        //
+        virtual parser_base<C>*
+        start_root_element (const ro_string<C>& ns,
+                            const ro_string<C>& name,
+                            const ro_string<C>* type);
+
+        // This function is called to indicate the completion of document
+        // parsing. The parser argument contains the pointer returned by
+        // start_root_element.
+        //
+        virtual void
+        end_root_element (const ro_string<C>& ns,
+                          const ro_string<C>& name,
+                          parser_base<C>* parser);
+
+      private:
+        parser_base<C>* root_;
+        std::basic_string<C> ns_;
+        std::basic_string<C> name_;
+        std::size_t depth_;
+      };
+    }
+  }
+}
+
+#include <xsd/cxx/parser/document.txx>
+
+#endif  // XSD_CXX_PARSER_DOCUMENT_HXX
diff --git src/base/include/xsd/cxx/parser/document.txx src/base/include/xsd/cxx/parser/document.txx
new file mode 100644
index 0000000..cad49ce
--- /dev/null
+++ src/base/include/xsd/cxx/parser/document.txx
@@ -0,0 +1,129 @@
+// file      : xsd/cxx/parser/document.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#include <cassert>
+
+#include <xsd/cxx/parser/schema-exceptions.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      // document
+      //
+      template <typename C>
+      document<C>::
+      ~document ()
+      {
+      }
+
+      template <typename C>
+      document<C>::
+      document (parser_base<C>& root,
+                const std::basic_string<C>& ns,
+                const std::basic_string<C>& name)
+          : root_ (&root), ns_ (ns), name_ (name), depth_ (0)
+      {
+      }
+
+      template <typename C>
+      document<C>::
+      document ()
+          : root_ (0), depth_ (0)
+      {
+      }
+
+      template <typename C>
+      void document<C>::
+      start_element (const ro_string<C>& ns,
+                     const ro_string<C>& name,
+                     const ro_string<C>* type)
+      {
+        if (depth_++ > 0)
+        {
+          if (root_)
+            root_->_start_element (ns, name, type);
+        }
+        else
+        {
+          root_ = start_root_element (ns, name, type);
+
+          if (root_)
+          {
+            // pre () is called by the user.
+            //
+            root_->_pre_impl ();
+          }
+        }
+      }
+
+      template <typename C>
+      void document<C>::
+      end_element (const ro_string<C>& ns, const ro_string<C>& name)
+      {
+        assert (depth_ > 0);
+
+        if (--depth_ > 0)
+        {
+          if (root_)
+            root_->_end_element (ns, name);
+        }
+        else
+        {
+          if (root_)
+          {
+	    root_->_post_impl ();
+            //
+            // post() is called by the user.
+          }
+
+          end_root_element (ns, name, root_);
+        }
+      }
+
+      template <typename C>
+      void document<C>::
+      attribute (const ro_string<C>& ns,
+                 const ro_string<C>& name,
+                 const ro_string<C>& value)
+      {
+        if (root_)
+          root_->_attribute (ns, name, value);
+      }
+
+      template <typename C>
+      void document<C>::
+      characters (const ro_string<C>& s)
+      {
+        if (root_)
+          root_->_characters (s);
+      }
+
+      template <typename C>
+      parser_base<C>* document<C>::
+      start_root_element (const ro_string<C>& ns,
+                          const ro_string<C>& name,
+                          const ro_string<C>*)
+      {
+        if (name_ == name && ns_ == ns)
+        {
+          return root_;
+        }
+        else
+          throw expected_element<C> (ns_, name_, ns, name);
+      }
+
+      template <typename C>
+      void document<C>::
+      end_root_element (const ro_string<C>&,
+                        const ro_string<C>&,
+                        parser_base<C>*)
+      {
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/parser/elements.hxx src/base/include/xsd/cxx/parser/elements.hxx
new file mode 100644
index 0000000..5f0bead
--- /dev/null
+++ src/base/include/xsd/cxx/parser/elements.hxx
@@ -0,0 +1,95 @@
+// file      : xsd/cxx/parser/elements.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_PARSER_ELEMENTS_HXX
+#define XSD_CXX_PARSER_ELEMENTS_HXX
+
+#include <xsd/cxx/ro-string.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      // pre() and post() are overridable pre/post callbacks, i.e., the
+      // derived parser can override them without calling the base version.
+      // _pre() and _post() are not overridable pre/post callbacks in the
+      // sense that the derived parser may override them but has to call
+      // the base version. The call sequence is as shown below:
+      //
+      // pre ()
+      // _pre ()
+      // _post ()
+      // post ()
+      //
+      template <typename C>
+      class parser_base
+      {
+      public:
+        virtual
+        ~parser_base ();
+
+        virtual void
+        pre ();
+
+        virtual void
+        _pre ();
+
+        // The type argument is a type name and namespace from the
+        // xsi:type attribute in the form "<name> <namespace>" with
+        // the space and namespace part absent if the type does not
+        // have a namespace or 0 if xsi:type is not present.
+        //
+        virtual void
+        _start_element (const ro_string<C>& ns,
+                        const ro_string<C>& name,
+                        const ro_string<C>* type) = 0;
+
+        virtual void
+        _end_element (const ro_string<C>& ns,
+                      const ro_string<C>& name) = 0;
+
+        virtual void
+        _attribute (const ro_string<C>& ns,
+                    const ro_string<C>& name,
+                    const ro_string<C>& value) = 0;
+
+        virtual void
+        _characters (const ro_string<C>&) = 0;
+
+        virtual void
+        _post ();
+
+        // The post() signature varies depending on the parser return
+        // type.
+        //
+
+        // Implementation callbacks for _pre and _post. The _pre and _post
+        // callbacks should never be called directly. Instead, the *_impl
+        // versions should be used. By default _pre_impl and _post_impl
+        // simply call _pre and _post respectively.
+        //
+        virtual void
+        _pre_impl ();
+
+        virtual void
+        _post_impl ();
+
+      public:
+        // Dynamic type in the form "<name> <namespace>" with
+        // the space and namespace part absent if the type does
+        // not have a namespace. Used in polymorphism-aware code.
+        //
+        virtual const C*
+        _dynamic_type () const;
+      };
+    }
+  }
+}
+
+#include <xsd/cxx/parser/elements.txx>
+
+#endif  // XSD_CXX_PARSER_ELEMENTS_HXX
diff --git src/base/include/xsd/cxx/parser/elements.txx src/base/include/xsd/cxx/parser/elements.txx
new file mode 100644
index 0000000..5706107
--- /dev/null
+++ src/base/include/xsd/cxx/parser/elements.txx
@@ -0,0 +1,60 @@
+// file      : xsd/cxx/parser/elements.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      // parser_base
+      //
+      template <typename C>
+      parser_base<C>::
+      ~parser_base ()
+      {
+      }
+
+      template <typename C>
+      void parser_base<C>::
+      pre ()
+      {
+      }
+
+      template <typename C>
+      void parser_base<C>::
+      _pre ()
+      {
+      }
+
+      template <typename C>
+      void parser_base<C>::
+      _post ()
+      {
+      }
+
+      template <typename C>
+      void parser_base<C>::
+      _pre_impl ()
+      {
+        _pre ();
+      }
+
+      template <typename C>
+      void parser_base<C>::
+      _post_impl ()
+      {
+        _post ();
+      }
+
+      template <typename C>
+      const C* parser_base<C>::
+      _dynamic_type () const
+      {
+        return 0;
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/parser/error-handler.hxx src/base/include/xsd/cxx/parser/error-handler.hxx
new file mode 100644
index 0000000..b83c0a8
--- /dev/null
+++ src/base/include/xsd/cxx/parser/error-handler.hxx
@@ -0,0 +1,57 @@
+// file      : xsd/cxx/parser/error-handler.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_PARSER_ERROR_HANDLER_HXX
+#define XSD_CXX_PARSER_ERROR_HANDLER_HXX
+
+#include <xsd/cxx/xml/error-handler.hxx>
+
+#include <xsd/cxx/parser/exceptions.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      template <typename C>
+      class error_handler: public xml::error_handler<C>
+      {
+      public:
+        typedef typename xml::error_handler<C>::severity severity;
+
+        error_handler ()
+            : failed_ (false)
+        {
+        }
+
+        virtual bool
+        handle (const std::basic_string<C>& id,
+                unsigned long line,
+                unsigned long column,
+                severity s,
+                const std::basic_string<C>& message);
+
+        void
+        throw_if_failed () const;
+
+        void
+        reset ()
+        {
+          failed_ = false;
+          diagnostics_.clear ();
+        }
+
+      private:
+        bool failed_;
+        diagnostics<C> diagnostics_;
+      };
+    }
+  }
+}
+
+#include <xsd/cxx/parser/error-handler.txx>
+
+#endif  // XSD_CXX_PARSER_ERROR_HANDLER_HXX
diff --git src/base/include/xsd/cxx/parser/error-handler.txx src/base/include/xsd/cxx/parser/error-handler.txx
new file mode 100644
index 0000000..23751d2
--- /dev/null
+++ src/base/include/xsd/cxx/parser/error-handler.txx
@@ -0,0 +1,41 @@
+// file      : xsd/cxx/parser/error-handler.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      template <typename C>
+      bool error_handler<C>::
+      handle (const std::basic_string<C>& id,
+              unsigned long line,
+              unsigned long column,
+              severity s,
+              const std::basic_string<C>& message)
+      {
+        diagnostics_.push_back (
+          error<C> (s == severity::warning
+                    ? cxx::parser::severity::warning
+                    : cxx::parser::severity::error,
+                    id, line, column, message));
+
+        if (!failed_ && s != severity::warning)
+          failed_ = true;
+
+        return true;
+      }
+
+      template <typename C>
+      void error_handler<C>::
+      throw_if_failed () const
+      {
+        if (failed_)
+          throw parsing<C> (diagnostics_);
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/parser/exceptions.hxx src/base/include/xsd/cxx/parser/exceptions.hxx
new file mode 100644
index 0000000..c0e90dd
--- /dev/null
+++ src/base/include/xsd/cxx/parser/exceptions.hxx
@@ -0,0 +1,153 @@
+// file      : xsd/cxx/parser/exceptions.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_PARSER_EXCEPTIONS_HXX
+#define XSD_CXX_PARSER_EXCEPTIONS_HXX
+
+#include <string>
+#include <vector>
+#include <ostream>
+
+#include <xsd/cxx/exceptions.hxx>       // xsd::cxx::exception
+#include <xsd/cxx/ro-string.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      //
+      //
+      template <typename C>
+      struct exception: xsd::cxx::exception
+      {
+        friend
+        std::basic_ostream<C>&
+        operator<< (std::basic_ostream<C>& os, const exception& e)
+        {
+          e.print (os);
+          return os;
+        }
+
+      protected:
+        virtual void
+        print (std::basic_ostream<C>&) const = 0;
+      };
+
+
+      //
+      //
+      struct severity
+      {
+        enum value
+        {
+          warning,
+          error
+        };
+
+        severity (value v) : v_ (v) {}
+        operator value () const { return v_; }
+
+      private:
+        value v_;
+      };
+
+      template <typename C>
+      struct error
+      {
+        error (cxx::parser::severity,
+               const std::basic_string<C>& id,
+               unsigned long line,
+               unsigned long column,
+               const std::basic_string<C>& message);
+
+        cxx::parser::severity
+        severity () const
+        {
+          return severity_;
+        }
+
+        const std::basic_string<C>&
+        id () const
+        {
+          return id_;
+        }
+
+        unsigned long
+        line () const
+        {
+          return line_;
+        }
+
+        unsigned long
+        column () const
+        {
+          return column_;
+        }
+
+        const std::basic_string<C>&
+        message () const
+        {
+          return message_;
+        }
+
+      private:
+        cxx::parser::severity severity_;
+        std::basic_string<C> id_;
+        unsigned long line_;
+        unsigned long column_;
+        std::basic_string<C> message_;
+      };
+
+      // See exceptions.ixx for operator<< (error).
+
+
+      //
+      //
+      template <typename C>
+      struct diagnostics: std::vector<error<C> >
+      {
+      };
+
+      // See exceptions.ixx for operator<< (diagnostics).
+
+      //
+      //
+      template <typename C>
+      struct parsing: exception<C>
+      {
+        virtual
+        ~parsing () throw ();
+
+        parsing ();
+
+        parsing (const cxx::parser::diagnostics<C>&);
+
+        const cxx::parser::diagnostics<C>&
+        diagnostics () const
+        {
+          return diagnostics_;
+        }
+
+        virtual const char*
+        what () const throw ();
+
+      protected:
+        virtual void
+        print (std::basic_ostream<C>&) const;
+
+      private:
+        cxx::parser::diagnostics<C> diagnostics_;
+      };
+    }
+  }
+}
+
+#include <xsd/cxx/parser/exceptions.txx>
+
+#endif  // XSD_CXX_PARSER_EXCEPTIONS_HXX
+
+#include <xsd/cxx/parser/exceptions.ixx>
diff --git src/base/include/xsd/cxx/parser/exceptions.ixx src/base/include/xsd/cxx/parser/exceptions.ixx
new file mode 100644
index 0000000..d4e13f3
--- /dev/null
+++ src/base/include/xsd/cxx/parser/exceptions.ixx
@@ -0,0 +1,129 @@
+// file      : xsd/cxx/parser/exceptions.ixx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#if defined(XSD_CXX_PARSER_USE_CHAR) || !defined(XSD_CXX_PARSER_USE_WCHAR)
+
+#ifndef XSD_CXX_PARSER_EXCEPTIONS_IXX_CHAR
+#define XSD_CXX_PARSER_EXCEPTIONS_IXX_CHAR
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      // error
+      //
+      inline
+      std::basic_ostream<char>&
+      operator<< (std::basic_ostream<char>& os, const error<char>& e)
+      {
+        return os << e.id () << ':' << e.line () << ':' << e.column ()
+                  << (e.severity () == severity::error
+                      ? " error: "
+                      : " warning: ") << e.message ();
+      }
+
+
+      // diagnostics
+      //
+      inline
+      std::basic_ostream<char>&
+      operator<< (std::basic_ostream<char>& os, const diagnostics<char>& d)
+      {
+        for (diagnostics<char>::const_iterator b (d.begin ()), i (b);
+             i != d.end ();
+             ++i)
+        {
+          if (i != b)
+            os << "\n";
+
+          os << *i;
+        }
+
+        return os;
+      }
+
+      // parsing
+      //
+      template<>
+      inline
+      void parsing<char>::
+      print (std::basic_ostream<char>& os) const
+      {
+        if (diagnostics_.empty ())
+          os << "instance document parsing failed";
+        else
+          os << diagnostics_;
+      }
+    }
+  }
+}
+
+#endif // XSD_CXX_PARSER_EXCEPTIONS_IXX_CHAR
+#endif // XSD_CXX_PARSER_USE_CHAR
+
+
+#if defined(XSD_CXX_PARSER_USE_WCHAR) || !defined(XSD_CXX_PARSER_USE_CHAR)
+
+#ifndef XSD_CXX_PARSER_EXCEPTIONS_IXX_WCHAR
+#define XSD_CXX_PARSER_EXCEPTIONS_IXX_WCHAR
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      // error
+      //
+      inline
+      std::basic_ostream<wchar_t>&
+      operator<< (std::basic_ostream<wchar_t>& os, const error<wchar_t>& e)
+      {
+        return os << e.id () << L':' << e.line () << L':' << e.column ()
+                  << (e.severity () == severity::error
+                      ? L" error: "
+                      : L" warning: ") << e.message ();
+      }
+
+      // diagnostics
+      //
+      inline
+      std::basic_ostream<wchar_t>&
+      operator<< (std::basic_ostream<wchar_t>& os,
+                  const diagnostics<wchar_t>& d)
+      {
+        for (diagnostics<wchar_t>::const_iterator b (d.begin ()), i (b);
+             i != d.end ();
+             ++i)
+        {
+          if (i != b)
+            os << L"\n";
+
+          os << *i;
+        }
+
+        return os;
+      }
+
+      // parsing
+      //
+      template<>
+      inline
+      void parsing<wchar_t>::
+      print (std::basic_ostream<wchar_t>& os) const
+      {
+        if (diagnostics_.empty ())
+          os << L"instance document parsing failed";
+        else
+          os << diagnostics_;
+      }
+    }
+  }
+}
+
+#endif // XSD_CXX_PARSER_EXCEPTIONS_IXX_WCHAR
+#endif // XSD_CXX_PARSER_USE_WCHAR
diff --git src/base/include/xsd/cxx/parser/exceptions.txx src/base/include/xsd/cxx/parser/exceptions.txx
new file mode 100644
index 0000000..5423cdd
--- /dev/null
+++ src/base/include/xsd/cxx/parser/exceptions.txx
@@ -0,0 +1,59 @@
+// file      : xsd/cxx/parser/exceptions.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      // error
+      //
+      template <typename C>
+      error<C>::
+      error (cxx::parser::severity s,
+             const std::basic_string<C>& id,
+             unsigned long line,
+             unsigned long column,
+             const std::basic_string<C>& message)
+          : severity_ (s),
+            id_ (id),
+            line_ (line),
+            column_ (column),
+            message_ (message)
+      {
+      }
+
+
+      // parsing
+      //
+      template <typename C>
+      parsing<C>::
+      ~parsing () throw ()
+      {
+      }
+
+      template <typename C>
+      parsing<C>::
+      parsing ()
+      {
+      }
+
+      template <typename C>
+      parsing<C>::
+      parsing (const cxx::parser::diagnostics<C>& diagnostics)
+          : diagnostics_ (diagnostics)
+      {
+      }
+
+      template <typename C>
+      const char* parsing<C>::
+      what () const throw ()
+      {
+        return "instance document parsing failed";
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/parser/expat/elements.hxx src/base/include/xsd/cxx/parser/expat/elements.hxx
new file mode 100644
index 0000000..c9f3de0
--- /dev/null
+++ src/base/include/xsd/cxx/parser/expat/elements.hxx
@@ -0,0 +1,344 @@
+// file      : xsd/cxx/parser/expat/elements.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_PARSER_EXPAT_ELEMENTS_HXX
+#define XSD_CXX_PARSER_EXPAT_ELEMENTS_HXX
+
+#include <string>
+#include <iosfwd>
+#include <cstddef> // std::size_t
+#include <vector>
+
+#include <expat.h>
+
+// We only support UTF-8 expat for now.
+//
+#ifdef XML_UNICODE
+#error UTF-16 expat (XML_UNICODE defined) is not supported
+#endif
+
+#include <xsd/cxx/xml/error-handler.hxx>
+
+#include <xsd/cxx/parser/exceptions.hxx>
+#include <xsd/cxx/parser/elements.hxx>
+#include <xsd/cxx/parser/document.hxx>
+#include <xsd/cxx/parser/error-handler.hxx>
+#include <xsd/cxx/parser/schema-exceptions.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      namespace expat
+      {
+        // Simple auto pointer for Expat's XML_Parser object.
+        //
+        struct parser_auto_ptr
+        {
+          ~parser_auto_ptr ()
+          {
+            if (parser_ != 0)
+              XML_ParserFree (parser_);
+          }
+
+          explicit
+          parser_auto_ptr (XML_Parser parser = 0)
+              : parser_ (parser)
+          {
+          }
+
+          parser_auto_ptr&
+          operator= (XML_Parser parser)
+          {
+            if (parser_ != 0)
+              XML_ParserFree (parser_);
+
+            parser_ = parser;
+            return *this;
+          }
+
+        public:
+          operator XML_Parser ()
+          {
+            return parser_;
+          }
+
+        private:
+          parser_auto_ptr (const parser_auto_ptr&);
+
+          parser_auto_ptr&
+          operator= (const parser_auto_ptr&);
+
+        private:
+          XML_Parser parser_;
+        };
+
+
+        //
+        //
+        template <typename C>
+        struct document: cxx::parser::document<C> // VC 7.1 likes it qualified
+        {
+        public:
+          document (parser_base<C>&,
+                    const C* root_element_name,
+                    bool polymorphic = false);
+
+          document (parser_base<C>&,
+                    const std::basic_string<C>& root_element_name,
+                    bool polymorphic = false);
+
+          document (parser_base<C>&,
+                    const C* root_element_namespace,
+                    const C* root_element_name,
+                    bool polymorphic = false);
+
+          document (parser_base<C>&,
+                    const std::basic_string<C>& root_element_namespace,
+                    const std::basic_string<C>& root_element_name,
+                    bool polymorphic = false);
+
+        protected:
+          document (bool polymorphic = false);
+
+        public:
+          // Parse a local file. The file is accessed with std::ifstream
+          // in binary mode. The std::ios_base::failure exception is used
+          // to report io errors (badbit and failbit).
+          void
+          parse (const std::basic_string<C>& file);
+
+          // Parse a local file with a user-provided error_handler
+          // object. The file is accessed with std::ifstream in binary
+          // mode. The std::ios_base::failure exception is used to report
+          // io errors (badbit and failbit).
+          //
+          void
+          parse (const std::basic_string<C>& file, xml::error_handler<C>&);
+
+        public:
+          // System id is a "system" identifier of the resources (e.g.,
+          // URI or a full file path). Public id is a "public" identifier
+          // of the resource (e.g., application-specific name or relative
+          // file path). System id is used to resolve relative paths.
+          // In diagnostics messages system id is used if public id is
+          // not available. Otherwise public id is used.
+          //
+
+          // Parse std::istream.
+          //
+          void
+          parse (std::istream&);
+
+          // Parse std::istream with a user-provided error_handler object.
+          //
+          void
+          parse (std::istream&, xml::error_handler<C>&);
+
+          // Parse std::istream with a system id.
+          //
+          void
+          parse (std::istream&, const std::basic_string<C>& system_id);
+
+          // Parse std::istream with a system id and a user-provided
+          // error_handler object.
+          //
+          void
+          parse (std::istream&,
+                 const std::basic_string<C>& system_id,
+                 xml::error_handler<C>&);
+
+          // Parse std::istream with system and public ids.
+          //
+          void
+          parse (std::istream&,
+                 const std::basic_string<C>& system_id,
+                 const std::basic_string<C>& public_id);
+
+          // Parse std::istream with system and public ids and a user-provided
+          // error_handler object.
+          //
+          void
+          parse (std::istream&,
+                 const std::basic_string<C>& system_id,
+                 const std::basic_string<C>& public_id,
+                 xml::error_handler<C>&);
+
+        public:
+          // Parse a chunk of input. You can call these functions multiple
+          // times with the last call having the last argument true.
+          //
+          void
+          parse (const void* data, std::size_t size, bool last);
+
+          void
+          parse (const void* data, std::size_t size, bool last,
+                 xml::error_handler<C>&);
+
+          void
+          parse (const void* data, std::size_t size, bool last,
+                 const std::basic_string<C>& system_id);
+
+          void
+          parse (const void* data, std::size_t size, bool last,
+                 const std::basic_string<C>& system_id,
+                 xml::error_handler<C>&);
+
+          void
+          parse (const void* data, std::size_t size, bool last,
+                 const std::basic_string<C>& system_id,
+                 const std::basic_string<C>& public_id);
+
+          void
+          parse (const void* data, std::size_t size, bool last,
+                 const std::basic_string<C>& system_id,
+                 const std::basic_string<C>& public_id,
+                 xml::error_handler<C>&);
+
+        public:
+          // Low-level Expat-specific parsing API. A typical use case
+          // would look like this (pseudo-code):
+          //
+          // xxx_pimpl root;
+          // document doc (root, "root");
+          //
+          // root.pre ();
+          // doc.parse_begin (xml_parser, "file.xml");
+          //
+          // while (more_stuff_to_parse &&)
+          // {
+          //    // Call XML_Parse or XML_ParseBuffer.
+          //
+          //    if (status == XML_STATUS_ERROR)
+          //      break;
+          // }
+          //
+          // // Call parse_end even in case of an error to translate
+          // // XML and Schema errors to exceptions or error_handler
+          // // calls.
+          // //
+          // doc.parse_end ();
+          // result_type result (root.post_xxx ());
+          //
+          // Notes:
+          //
+          // 1. If your XML instances use XML namespaces, the
+          //    XML_ParserCreateNS functions should be used to create the
+          //    XML parser. Space (XML_Char (' ')) should be used as a
+          //    separator (the second argument to XML_ParserCreateNS).
+          //
+          void
+          parse_begin (XML_Parser);
+
+          void
+          parse_begin (XML_Parser, const std::basic_string<C>& public_id);
+
+          void
+          parse_begin (XML_Parser, xml::error_handler<C>&);
+
+          void
+          parse_begin (XML_Parser,
+                       const std::basic_string<C>& public_id,
+                       xml::error_handler<C>&);
+          void
+          parse_end ();
+
+          // Event routing.
+          //
+        public:
+          static void XMLCALL
+          start_element_thunk_ (void*, const XML_Char*, const XML_Char**);
+
+          static void XMLCALL
+          end_element_thunk_ (void*, const XML_Char*);
+
+          static void XMLCALL
+          characters_thunk_ (void*, const XML_Char*, int);
+
+          static void XMLCALL
+          start_namespace_decl_thunk_ (
+            void*, const XML_Char*, const XML_Char*);
+
+          static void XMLCALL
+          end_namespace_decl_thunk_ (void*, const XML_Char*);
+
+        protected:
+          void
+          start_element_ (const XML_Char* ns_name, const XML_Char** atts);
+
+          void
+          end_element_ (const XML_Char* ns_name);
+
+          void
+          characters_ (const XML_Char* s, std::size_t n);
+
+          void
+          start_namespace_decl_ (const XML_Char* prefix, const XML_Char* ns);
+
+          void
+          end_namespace_decl_ (const XML_Char* prefix);
+
+        protected:
+          void
+          set ();
+
+          void
+          clear ();
+
+          bool
+          parse (std::istream&,
+                 const std::basic_string<C>* system_id,
+                 const std::basic_string<C>* public_id,
+                 xml::error_handler<C>&);
+
+          bool
+          parse (const void* data, std::size_t size, bool last,
+                 const std::basic_string<C>* system_id,
+                 const std::basic_string<C>* public_id,
+                 xml::error_handler<C>&);
+
+
+          void
+          translate_schema_exception (const schema_exception<C>& e);
+
+        protected:
+          XML_Parser xml_parser_;
+          parser_auto_ptr auto_xml_parser_;
+
+          xml::error_handler<C>* eh_;
+          error_handler<C> default_eh_;
+          std::basic_string<C> public_id_;
+
+          bool polymorphic_;
+
+          // Namespace-prefix mapping. Only maintained in the polymorphic
+          // case.
+          //
+          struct ns_decl
+          {
+            ns_decl (const std::basic_string<C>& p,
+                     const std::basic_string<C>& n)
+                : prefix (p), ns (n)
+            {
+            }
+
+            std::basic_string<C> prefix;
+            std::basic_string<C> ns;
+          };
+
+          typedef std::vector<ns_decl> ns_decls;
+
+          ns_decls ns_decls_;
+        };
+      }
+    }
+  }
+}
+
+#include <xsd/cxx/parser/expat/elements.txx>
+
+#endif  // XSD_CXX_PARSER_EXPAT_ELEMENTS_HXX
diff --git src/base/include/xsd/cxx/parser/expat/elements.txx src/base/include/xsd/cxx/parser/expat/elements.txx
new file mode 100644
index 0000000..08ecf21
--- /dev/null
+++ src/base/include/xsd/cxx/parser/expat/elements.txx
@@ -0,0 +1,822 @@
+// file      : xsd/cxx/parser/expat/elements.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#include <new>     // std::bad_alloc
+#include <istream>
+#include <fstream>
+#include <cstring> // std::strchr
+#include <cassert>
+
+#include <xsd/cxx/xml/bits/literals.hxx> // xml::bits::{xml_prefix, etc}
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      namespace expat
+      {
+
+        // document
+        //
+
+        template <typename C>
+        document<C>::
+        document (parser_base<C>& p,
+                  const std::basic_string<C>& name,
+                  bool polymorphic)
+            : cxx::parser::document<C> (p, std::basic_string<C> (), name),
+              xml_parser_ (0),
+              eh_ (0),
+              polymorphic_ (polymorphic)
+        {
+        }
+
+        template <typename C>
+        document<C>::
+        document (parser_base<C>& p,
+                  const C* name,
+                  bool polymorphic)
+            : cxx::parser::document<C> (p, std::basic_string<C> (), name),
+              xml_parser_ (0),
+              eh_ (0),
+              polymorphic_ (polymorphic)
+        {
+        }
+
+        template <typename C>
+        document<C>::
+        document (parser_base<C>& p,
+                  const C* ns,
+                  const C* name,
+                  bool polymorphic)
+            : cxx::parser::document<C> (p, ns, name),
+              xml_parser_ (0),
+              eh_ (0),
+              polymorphic_ (polymorphic)
+        {
+        }
+
+        template <typename C>
+        document<C>::
+        document (parser_base<C>& p,
+                  const std::basic_string<C>& ns,
+                  const std::basic_string<C>& name,
+                  bool polymorphic)
+            : cxx::parser::document<C> (p, ns, name),
+              xml_parser_ (0),
+              eh_ (0),
+              polymorphic_ (polymorphic)
+        {
+        }
+
+        template <typename C>
+        document<C>::
+        document (bool polymorphic)
+            : xml_parser_ (0),
+              eh_ (0),
+              polymorphic_ (polymorphic)
+        {
+        }
+
+        // file
+        //
+
+        template <typename C>
+        void document<C>::
+        parse (const std::basic_string<C>& file)
+        {
+          std::ifstream ifs;
+          ifs.exceptions (std::ios_base::badbit | std::ios_base::failbit);
+          ifs.open (file.c_str (), std::ios_base::in | std::ios_base::binary);
+
+          parse (ifs, file);
+        }
+
+        template <typename C>
+        void document<C>::
+        parse (const std::basic_string<C>& file, xml::error_handler<C>& eh)
+        {
+          std::ifstream ifs;
+          ifs.exceptions (std::ios_base::badbit | std::ios_base::failbit);
+          ifs.open (file.c_str (), std::ios_base::in | std::ios_base::binary);
+
+          parse (ifs, file, eh);
+        }
+
+
+        // istream
+        //
+
+        template <typename C>
+        void document<C>::
+        parse (std::istream& is)
+        {
+          parse (is, 0, 0, default_eh_);
+        }
+
+        template <typename C>
+        void document<C>::
+        parse (std::istream& is, xml::error_handler<C>& eh)
+        {
+          if (!parse (is, 0, 0, eh))
+            throw parsing<C> ();
+        }
+
+        template <typename C>
+        void document<C>::
+        parse (std::istream& is, const std::basic_string<C>& system_id)
+        {
+          default_eh_.reset ();
+          parse (is, &system_id, 0, default_eh_);
+        }
+
+        template <typename C>
+        void document<C>::
+        parse (std::istream& is,
+               const std::basic_string<C>& system_id,
+               xml::error_handler<C>& eh)
+        {
+          if (!parse (is, &system_id, 0, eh))
+            throw parsing<C> ();
+        }
+
+        template <typename C>
+        void document<C>::
+        parse (std::istream& is,
+               const std::basic_string<C>& system_id,
+               const std::basic_string<C>& public_id)
+        {
+          default_eh_.reset ();
+          parse (is, &system_id, &public_id, default_eh_);
+        }
+
+        template <typename C>
+        void document<C>::
+        parse (std::istream& is,
+               const std::basic_string<C>& system_id,
+               const std::basic_string<C>& public_id,
+               xml::error_handler<C>& eh)
+        {
+          if (!parse (is, &system_id, &public_id, eh))
+            throw parsing<C> ();
+        }
+
+        // data
+        //
+
+        template <typename C>
+        void document<C>::
+        parse (const void* data, std::size_t size, bool last)
+        {
+          default_eh_.reset ();
+          parse (data, size, last, 0, 0, default_eh_);
+        }
+
+        template <typename C>
+        void document<C>::
+        parse (const void* data, std::size_t size, bool last,
+               xml::error_handler<C>& eh)
+        {
+          if (!parse (data, size, last, 0, 0, eh))
+            throw parsing<C> ();
+        }
+
+        template <typename C>
+        void document<C>::
+        parse (const void* data, std::size_t size, bool last,
+               const std::basic_string<C>& system_id)
+        {
+          default_eh_.reset ();
+          parse (data, size, last, &system_id, 0, default_eh_);
+        }
+
+        template <typename C>
+        void document<C>::
+        parse (const void* data, std::size_t size, bool last,
+               const std::basic_string<C>& system_id,
+               xml::error_handler<C>& eh)
+        {
+          if (!parse (data, size, last, &system_id, 0, eh))
+            throw parsing<C> ();
+        }
+
+        template <typename C>
+        void document<C>::
+        parse (const void* data, std::size_t size, bool last,
+               const std::basic_string<C>& system_id,
+               const std::basic_string<C>& public_id)
+        {
+          default_eh_.reset ();
+          parse (data, size, last, &system_id, &public_id, default_eh_);
+        }
+
+        template <typename C>
+        void document<C>::
+        parse (const void* data, std::size_t size, bool last,
+               const std::basic_string<C>& system_id,
+               const std::basic_string<C>& public_id,
+               xml::error_handler<C>& eh)
+        {
+          if (!parse (data, size, last, &system_id, &public_id, eh))
+            throw parsing<C> ();
+        }
+
+        // Implementation details.
+        //
+
+        namespace bits
+        {
+          struct stream_exception_controller
+          {
+            ~stream_exception_controller ()
+            {
+              std::ios_base::iostate s = is_.rdstate ();
+              s &= ~std::ios_base::failbit;
+
+              // If our error state (sans failbit) intersects with the
+              // exception state then that means we have an active
+              // exception and changing error/exception state will
+              // cause another to be thrown.
+              //
+              if (!(old_state_ & s))
+              {
+                // Clear failbit if it was caused by eof.
+                //
+                if (is_.fail () && is_.eof ())
+                  is_.clear (s);
+
+                is_.exceptions (old_state_);
+              }
+            }
+
+            stream_exception_controller (std::istream& is)
+                : is_ (is), old_state_ (is_.exceptions ())
+            {
+              is_.exceptions (old_state_ & ~std::ios_base::failbit);
+            }
+
+          private:
+            stream_exception_controller (const stream_exception_controller&);
+
+            stream_exception_controller&
+            operator= (const stream_exception_controller&);
+
+          private:
+            std::istream& is_;
+            std::ios_base::iostate old_state_;
+          };
+        };
+
+        template <typename C>
+        bool document<C>::
+        parse (std::istream& is,
+               const std::basic_string<C>* system_id,
+               const std::basic_string<C>* public_id,
+               xml::error_handler<C>& eh)
+        {
+          parser_auto_ptr parser (XML_ParserCreateNS (0, XML_Char (' ')));
+
+          if (parser == 0)
+            throw std::bad_alloc ();
+
+          if (system_id || public_id)
+            parse_begin (parser, system_id ? *system_id : *public_id, eh);
+          else
+            parse_begin (parser, eh);
+
+          // Temporarily unset the exception failbit. Also clear the
+          // fail bit when we reset the old state if it was caused
+          // by eof.
+          //
+          bits::stream_exception_controller sec (is);
+
+          char buf[16384]; // 4 x page size.
+
+          bool r (true);
+
+          do
+          {
+            is.read (buf, sizeof (buf));
+
+            if (is.bad () || (is.fail () && !is.eof ()))
+            {
+              // If the stream is not using exceptions then the user
+              // will have to test for stream failures before calling
+              // post.
+              //
+              break;
+            }
+
+            if (XML_Parse (
+                  parser, buf, is.gcount (), is.eof ()) == XML_STATUS_ERROR)
+            {
+              r = false;
+              break;
+            }
+          } while (!is.eof ());
+
+          parse_end ();
+          return r;
+        }
+
+        template <typename C>
+        bool document<C>::
+        parse (const void* data,
+               std::size_t size,
+               bool last,
+               const std::basic_string<C>* system_id,
+               const std::basic_string<C>* public_id,
+               xml::error_handler<C>& eh)
+        {
+          // First call.
+          //
+          if (auto_xml_parser_ == 0)
+          {
+            auto_xml_parser_ = XML_ParserCreateNS (0, XML_Char (' '));
+
+            if (auto_xml_parser_ == 0)
+              throw std::bad_alloc ();
+
+            if (system_id || public_id)
+              parse_begin (auto_xml_parser_,
+                           system_id ? *system_id : *public_id, eh);
+            else
+              parse_begin (auto_xml_parser_, eh);
+          }
+
+          bool r (XML_Parse (xml_parser_,
+                             static_cast<const char*> (data),
+                             static_cast<int> (size),
+                             last) != XML_STATUS_ERROR);
+          parse_end ();
+          return r;
+        }
+
+        // XML_Parser
+        //
+
+        template <typename C>
+        void document<C>::
+        parse_begin (XML_Parser parser)
+        {
+          xml_parser_ = parser;
+          eh_ = &default_eh_;
+          public_id_.clear ();
+          set ();
+        }
+
+        template <typename C>
+        void document<C>::
+        parse_begin (XML_Parser parser,
+                     const std::basic_string<C>& public_id)
+        {
+          xml_parser_ = parser;
+          eh_ = &default_eh_;
+          public_id_ = public_id;
+          set ();
+        }
+
+        template <typename C>
+        void document<C>::
+        parse_begin (XML_Parser parser, xml::error_handler<C>& eh)
+        {
+          xml_parser_ = parser;
+          eh_ = &eh;
+          public_id_.clear ();
+          set ();
+        }
+
+        template <typename C>
+        void document<C>::
+        parse_begin (XML_Parser parser,
+                     const std::basic_string<C>& public_id,
+                     xml::error_handler<C>& eh)
+        {
+          xml_parser_ = parser;
+          eh_ = &eh;
+          public_id_ = public_id;
+          set ();
+        }
+
+        template <typename C>
+        void document<C>::
+        parse_end ()
+        {
+          XML_Error e (XML_GetErrorCode (xml_parser_));
+
+          if (e == XML_ERROR_NONE || e == XML_ERROR_ABORTED)
+          {
+            clear ();
+            xml_parser_ = 0;
+            auto_xml_parser_ = 0;
+          }
+          else
+          {
+            unsigned long l = XML_GetCurrentLineNumber (xml_parser_);
+            unsigned long c = XML_GetCurrentColumnNumber (xml_parser_);
+            std::basic_string<C> message (XML_ErrorString (e));
+
+            eh_->handle (public_id_,
+                         l, c,
+                         xml::error_handler<C>::severity::fatal,
+                         message);
+
+            clear ();
+            xml_parser_ = 0;
+            auto_xml_parser_ = 0;
+
+            // We don't want to throw an empty parsing exception here
+            // since the user probably already knows about the error.
+          }
+
+          if (eh_ == &default_eh_)
+            default_eh_.throw_if_failed ();
+        }
+
+        //
+        //
+        template <typename C>
+        void document<C>::
+        set ()
+        {
+          assert (xml_parser_ != 0);
+
+          XML_SetUserData(xml_parser_, this);
+
+          XML_SetStartElementHandler (xml_parser_, start_element_thunk_);
+          XML_SetEndElementHandler (xml_parser_, end_element_thunk_);
+          XML_SetCharacterDataHandler (xml_parser_, characters_thunk_);
+
+          if (polymorphic_)
+          {
+            XML_SetNamespaceDeclHandler (xml_parser_,
+                                         start_namespace_decl_thunk_,
+                                         end_namespace_decl_thunk_);
+          }
+        }
+
+        template <typename C>
+        void document<C>::
+        clear ()
+        {
+          assert (xml_parser_ != 0);
+
+          XML_SetUserData (xml_parser_, 0);
+          XML_SetStartElementHandler (xml_parser_, 0);
+          XML_SetEndElementHandler (xml_parser_, 0);
+          XML_SetCharacterDataHandler (xml_parser_, 0);
+
+          if (polymorphic_)
+            XML_SetNamespaceDeclHandler (xml_parser_, 0, 0);
+        }
+
+        template <typename C>
+        void document<C>::
+        translate_schema_exception (const schema_exception<C>& e)
+        {
+          unsigned long l = XML_GetCurrentLineNumber (xml_parser_);
+          unsigned long c = XML_GetCurrentColumnNumber (xml_parser_);
+
+          eh_->handle (public_id_,
+                       l, c,
+                       xml::error_handler<C>::severity::fatal,
+                       e.message ());
+
+          XML_StopParser (xml_parser_, false);
+        }
+
+        // Event routing.
+        //
+
+        // Expat thunks.
+        //
+        template <typename C>
+        void XMLCALL document<C>::
+        start_element_thunk_ (void* data,
+                              const XML_Char* ns_name,
+                              const XML_Char** atts)
+        {
+          document& d (*reinterpret_cast<document*> (data));
+          d.start_element_ (ns_name, atts);
+        }
+
+        template <typename C>
+        void XMLCALL document<C>::
+        end_element_thunk_ (void* data, const XML_Char* ns_name)
+        {
+          document& d (*reinterpret_cast<document*> (data));
+          d.end_element_ (ns_name);
+        }
+
+        template <typename C>
+        void XMLCALL document<C>::
+        characters_thunk_ (void* data, const XML_Char* s, int n)
+        {
+          document& d (*reinterpret_cast<document*> (data));
+          d.characters_ (s, static_cast<std::size_t> (n));
+        }
+
+        template <typename C>
+        void XMLCALL document<C>::
+        start_namespace_decl_thunk_ (void* data,
+                                     const XML_Char* prefix,
+                                     const XML_Char* ns)
+        {
+          document& d (*reinterpret_cast<document*> (data));
+          d.start_namespace_decl_ (prefix, ns);
+        }
+
+        template <typename C>
+        void XMLCALL document<C>::
+        end_namespace_decl_thunk_ (void* data, const XML_Char* prefix)
+        {
+          document& d (*reinterpret_cast<document*> (data));
+          d.end_namespace_decl_ (prefix);
+        }
+
+        namespace bits
+        {
+          inline void
+          split_name (const XML_Char* s,
+                      const char*& ns, std::size_t& ns_s,
+                      const char*& name, std::size_t& name_s)
+          {
+            const char* p (std::strchr (s, ' '));
+
+            if (p)
+            {
+              ns = s;
+              ns_s = p - s;
+              name = p + 1;
+            }
+            else
+            {
+              ns = s;
+              ns_s = 0;
+              name = s;
+            }
+
+            name_s = std::char_traits<char>::length (name);
+          }
+        }
+
+        template <typename C>
+        void document<C>::
+        start_element_ (const XML_Char* ns_name, const XML_Char** atts)
+        {
+          // Current Expat (2.0.0) has a (mis)-feature of a possibility of
+	  // calling callbacks even after the non-resumable XML_StopParser
+          // call. The following code accounts for this.
+          //
+          {
+            XML_ParsingStatus s;
+            XML_GetParsingStatus (xml_parser_, &s);
+            if (s.parsing == XML_FINISHED)
+              return;
+          }
+
+          typedef std::basic_string<C> string;
+
+          const char* ns_p;
+          const char* name_p;
+          size_t ns_s, name_s;
+
+          bits::split_name (ns_name, ns_p, ns_s, name_p, name_s);
+
+          {
+            const ro_string<C> ns (ns_p, ns_s), name (name_p, name_s);
+
+            if (!polymorphic_)
+            {
+              try
+              {
+                this->start_element (ns, name, 0);
+              }
+              catch (const schema_exception<C>& e)
+              {
+                translate_schema_exception (e);
+                return;
+              }
+            }
+            else
+            {
+              // Search for the xsi:type attribute.
+              //
+              const XML_Char** p = atts; // VC8 can't handle p (atts)
+              for (; *p != 0; p += 2)
+              {
+                bits::split_name (*p, ns_p, ns_s, name_p, name_s);
+                const ro_string<C> ns (ns_p, ns_s), name (name_p, name_s);
+
+                if (name == xml::bits::type<C> () &&
+                    ns == xml::bits::xsi_namespace<C> ())
+                  break;
+              }
+
+              if (*p == 0)
+              {
+                try
+                {
+                  this->start_element (ns, name, 0);
+                }
+                catch (const schema_exception<C>& e)
+                {
+                  translate_schema_exception (e);
+                  return;
+                }
+              }
+              else
+              {
+                // @@ Need proper QName validation.
+                //
+                // Get the qualified type name and try to resolve it.
+                //
+                ro_string<C> qn (*(p + 1));
+
+                ro_string<C> tp, tn;
+                typename ro_string<C>::size_type pos (qn.find (C (':')));
+
+                try
+                {
+                  if (pos != ro_string<C>::npos)
+                  {
+                    tp.assign (qn.data (), pos);
+                    tn.assign (qn.data () + pos + 1);
+
+                    if (tp.empty ())
+                      throw dynamic_type<C> (qn);
+                  }
+                  else
+                    tn.assign (qn.data (), qn.size ());
+
+                  if (tn.empty ())
+                    throw dynamic_type<C> (qn);
+
+                  // Search our namespace declaration stack. Note that
+                  // we need to do this even if prefix is empty. Sun CC
+                  // 5.7 blows if we use const_reverse_iterator.
+                  //
+                  ro_string<C> tns;
+                  for (typename ns_decls::reverse_iterator
+                         it (ns_decls_.rbegin ()), e (ns_decls_.rend ());
+                       it != e; ++it)
+                  {
+                    if (it->prefix == tp)
+                    {
+                      tns.assign (it->ns);
+                      break;
+                    }
+                  }
+
+                  if (!tp.empty () && tns.empty ())
+                  {
+                    // The 'xml' prefix requires special handling.
+                    //
+                    if (tp == xml::bits::xml_prefix<C> ())
+                      tns.assign (xml::bits::xml_namespace<C> ());
+                    else
+                      throw dynamic_type<C> (qn);
+                  }
+
+                  // Construct the compound type id.
+                  //
+                  string id (tn.data (), tn.size ());
+
+                  if (!tns.empty ())
+                  {
+                    id += C (' ');
+                    id.append (tns.data (), tns.size ());
+                  }
+
+                  ro_string<C> ro_id (id);
+                  this->start_element (ns, name, &ro_id);
+                }
+                catch (const schema_exception<C>& e)
+                {
+                  translate_schema_exception (e);
+                  return;
+                }
+              }
+            }
+          }
+
+          for (; *atts != 0; atts += 2)
+          {
+            bits::split_name (*atts, ns_p, ns_s, name_p, name_s);
+
+            const ro_string<C> ns (ns_p, ns_s), name (name_p, name_s);
+            const ro_string<C> value (*(atts + 1));
+
+            try
+            {
+              this->attribute (ns, name, value);
+            }
+            catch (const schema_exception<C>& e)
+            {
+              translate_schema_exception (e);
+              break;
+            }
+          }
+        }
+
+        template <typename C>
+        void document<C>::
+        end_element_ (const XML_Char* ns_name)
+        {
+          // Current Expat (2.0.0) has a (mis)-feature of a possibility of
+	  // calling callbacks even after the non-resumable XML_StopParser
+          // call. The following code accounts for this.
+          //
+          {
+            XML_ParsingStatus s;
+            XML_GetParsingStatus (xml_parser_, &s);
+            if (s.parsing == XML_FINISHED)
+              return;
+          }
+
+          const char* ns_p;
+          const char* name_p;
+          size_t ns_s, name_s;
+
+          bits::split_name (ns_name, ns_p, ns_s, name_p, name_s);
+
+          const ro_string<C> ns (ns_p, ns_s), name (name_p, name_s);
+
+          try
+          {
+            this->end_element (ns, name);
+          }
+          catch (const schema_exception<C>& e)
+          {
+            translate_schema_exception (e);
+          }
+        }
+
+        template <typename C>
+        void document<C>::
+        characters_ (const XML_Char* s, std::size_t n)
+        {
+          // Current Expat (2.0.0) has a (mis)-feature of a possibility of
+	  // calling callbacks even after the non-resumable XML_StopParser
+          // call. The following code accounts for this.
+          //
+          {
+            XML_ParsingStatus s;
+            XML_GetParsingStatus (xml_parser_, &s);
+            if (s.parsing == XML_FINISHED)
+              return;
+          }
+
+          if (n != 0)
+          {
+            const ro_string<C> str (s, n);
+
+            try
+            {
+              this->characters (str);
+            }
+            catch (const schema_exception<C>& e)
+            {
+              translate_schema_exception (e);
+            }
+          }
+        }
+
+        template <typename C>
+        void document<C>::
+        start_namespace_decl_ (const XML_Char* p, const XML_Char* ns)
+        {
+          // prefix is 0 for default namespace
+          // namespace is 0 when unsetting default namespace
+          //
+          if (polymorphic_)
+            ns_decls_.push_back (ns_decl ((p ? p : ""), (ns ? ns : "")));
+        }
+
+        template <typename C>
+        void document<C>::
+        end_namespace_decl_ (const XML_Char* p)
+        {
+          // prefix is 0 for default namespace
+          //
+          if (polymorphic_)
+          {
+            // Here we assume the prefixes are removed in the reverse
+            // order of them being added. This appears to how every
+            // sensible implementation works.
+            //
+            assert (p
+                    ? ns_decls_.back ().prefix == p
+                    : ns_decls_.back ().prefix.empty ());
+
+            ns_decls_.pop_back ();
+          }
+        }
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/parser/map.hxx src/base/include/xsd/cxx/parser/map.hxx
new file mode 100644
index 0000000..663b178
--- /dev/null
+++ src/base/include/xsd/cxx/parser/map.hxx
@@ -0,0 +1,79 @@
+// file      : xsd/cxx/parser/map.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_PARSER_MAP_HXX
+#define XSD_CXX_PARSER_MAP_HXX
+
+#include <map>
+#include <string>
+
+#include <xsd/cxx/ro-string.hxx>
+#include <xsd/cxx/parser/elements.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      // Parser map. Used in the polymorphic document parsing.
+      //
+      template <typename C>
+      struct parser_map
+      {
+        virtual
+        ~parser_map ();
+
+        // The type argument is the type name and namespace from the
+        // xsi:type attribute or substitution group map in the form
+        // "<name> <namespace>" with the space and namespace part
+        // absent if the type does not have a namespace.
+        //
+        virtual parser_base<C>*
+        find (const ro_string<C>& type) const = 0;
+      };
+
+
+      // Parser map implementation.
+      //
+      template <typename C>
+      struct parser_map_impl: parser_map<C>
+      {
+        parser_map_impl ();
+
+        void
+        insert (parser_base<C>&);
+
+        virtual parser_base<C>*
+        find (const ro_string<C>& type) const;
+
+      private:
+        parser_map_impl (const parser_map_impl&);
+
+        parser_map_impl&
+        operator= (const parser_map_impl&);
+
+      private:
+        struct string_comparison
+        {
+          bool
+          operator() (const C* x, const C* y) const
+          {
+            ro_string<C> s (x);
+            return s.compare (y) < 0;
+          }
+        };
+
+        typedef std::map<const C*, parser_base<C>*, string_comparison> map;
+        map map_;
+      };
+    }
+  }
+}
+
+#include <xsd/cxx/parser/map.ixx>
+#include <xsd/cxx/parser/map.txx>
+
+#endif  // XSD_CXX_PARSER_MAP_HXX
diff --git src/base/include/xsd/cxx/parser/map.ixx src/base/include/xsd/cxx/parser/map.ixx
new file mode 100644
index 0000000..0b70680
--- /dev/null
+++ src/base/include/xsd/cxx/parser/map.ixx
@@ -0,0 +1,27 @@
+// file      : xsd/cxx/parser/map.ixx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      // parser_map_impl
+      //
+      template <typename C>
+      inline parser_map_impl<C>::parser_map_impl ()
+      {
+      }
+
+      template <typename C>
+      inline void parser_map_impl<C>::
+      insert (parser_base<C>& parser)
+      {
+        map_[parser._dynamic_type ()] = &parser;
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/parser/map.txx src/base/include/xsd/cxx/parser/map.txx
new file mode 100644
index 0000000..aa7099d
--- /dev/null
+++ src/base/include/xsd/cxx/parser/map.txx
@@ -0,0 +1,31 @@
+// file      : xsd/cxx/parser/map.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      // parser_map
+      //
+      template <typename C>
+      parser_map<C>::
+      ~parser_map ()
+      {
+      }
+
+      // parser_map_impl
+      //
+      template <typename C>
+      parser_base<C>* parser_map_impl<C>::
+      find (const ro_string<C>& type) const
+      {
+        typename map::const_iterator i (map_.find (type.data ()));
+        return i != map_.end () ? i->second : 0;
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/parser/non-validating/parser.hxx src/base/include/xsd/cxx/parser/non-validating/parser.hxx
new file mode 100644
index 0000000..9eda6f4
--- /dev/null
+++ src/base/include/xsd/cxx/parser/non-validating/parser.hxx
@@ -0,0 +1,248 @@
+// file      : xsd/cxx/parser/non-validating/parser.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_PARSER_NON_VALIDATING_PARSER_HXX
+#define XSD_CXX_PARSER_NON_VALIDATING_PARSER_HXX
+
+#include <stack>
+#include <string>
+#include <cstddef> // std::size_t
+
+#include <xsd/cxx/ro-string.hxx>
+#include <xsd/cxx/parser/elements.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      namespace non_validating
+      {
+        //
+        //
+        template <typename C>
+        struct empty_content: parser_base<C>
+        {
+          // The _*_any_* functions are called when wildcard content
+          // is encountered. Use them to handle mixed content models,
+          // any/anyAttribute, and anyType/anySimpleType. By default
+          // these functions do nothing.
+          //
+
+          // The type argument is a type name and namespace from the
+          // xsi:type attribute in the form "<name> <namespace>" with
+          // the space and namespace part absent if the type does not
+          // have a namespace or 0 if xsi:type is not present.
+          //
+          virtual void
+          _start_any_element (const ro_string<C>& ns,
+                              const ro_string<C>& name,
+                              const ro_string<C>* type);
+
+          virtual void
+          _end_any_element (const ro_string<C>& ns,
+                            const ro_string<C>& name);
+
+          virtual void
+          _any_attribute (const ro_string<C>& ns,
+                          const ro_string<C>& name,
+                          const ro_string<C>& value);
+
+          virtual void
+          _any_characters (const ro_string<C>&);
+
+
+          //
+          //
+          virtual bool
+          _start_element_impl (const ro_string<C>&,
+                               const ro_string<C>&,
+                               const ro_string<C>*);
+
+          virtual bool
+          _end_element_impl (const ro_string<C>&,
+                             const ro_string<C>&);
+
+          virtual bool
+          _attribute_impl (const ro_string<C>&,
+                           const ro_string<C>&,
+                           const ro_string<C>&);
+
+          virtual bool
+          _characters_impl (const ro_string<C>&);
+
+
+          //
+          //
+          virtual void
+          _start_element (const ro_string<C>& ns,
+                          const ro_string<C>& name,
+                          const ro_string<C>* type);
+
+          virtual void
+          _end_element (const ro_string<C>& ns,
+                        const ro_string<C>& name);
+
+          virtual void
+          _attribute (const ro_string<C>& ns,
+                      const ro_string<C>& name,
+                      const ro_string<C>& value);
+
+          virtual void
+          _characters (const ro_string<C>& s);
+        };
+
+
+        //
+        //
+        template <typename C>
+        struct simple_content: empty_content<C>
+        {
+          //
+          //
+          virtual void
+          _attribute (const ro_string<C>& ns,
+                      const ro_string<C>& name,
+                      const ro_string<C>& value);
+
+          virtual void
+          _characters (const ro_string<C>&);
+        };
+
+
+        //
+        //
+        template <typename C>
+        struct complex_content: empty_content<C>
+        {
+          //
+          //
+          virtual void
+          _start_element (const ro_string<C>& ns,
+                          const ro_string<C>& name,
+                          const ro_string<C>* type);
+
+          virtual void
+          _end_element (const ro_string<C>& ns,
+                        const ro_string<C>& name);
+
+          virtual void
+          _attribute (const ro_string<C>& ns,
+                      const ro_string<C>& name,
+                      const ro_string<C>& value);
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+
+          //
+          //
+          virtual void
+          _pre_impl ();
+
+          virtual void
+          _post_impl ();
+
+        protected:
+          struct state
+          {
+            state ()
+                : any_ (false), depth_ (0), parser_ (0)
+            {
+            }
+
+            bool any_;
+            std::size_t depth_;
+            parser_base<C>* parser_;
+          };
+
+          // Optimized state stack for non-recursive case (one element).
+          //
+          struct state_stack
+          {
+            state_stack ()
+                : size_ (0)
+            {
+            }
+
+            void
+            push (const state& s)
+            {
+              if (size_ > 0)
+                rest_.push (top_);
+
+              top_ = s;
+              ++size_;
+            }
+
+            void
+            pop ()
+            {
+              if (size_ > 1)
+              {
+                top_ = rest_.top ();
+                rest_.pop ();
+              }
+
+              --size_;
+            }
+
+            const state&
+            top () const
+            {
+              return top_;
+            }
+
+            state&
+            top ()
+            {
+              return top_;
+            }
+
+            state&
+            under_top ()
+            {
+              return rest_.top ();
+            }
+
+          private:
+            state top_;
+            std::stack<state> rest_;
+            std::size_t size_;
+          };
+
+          state_stack context_;
+        };
+
+
+        // Base for xsd:list.
+        //
+        template <typename C>
+        struct list_base: simple_content<C>
+        {
+          virtual void
+          _xsd_parse_item (const ro_string<C>&) = 0;
+
+          virtual void
+          _pre_impl ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual void
+          _post_impl ();
+
+        protected:
+          std::basic_string<C> buf_;
+        };
+      }
+    }
+  }
+}
+
+#include <xsd/cxx/parser/non-validating/parser.txx>
+
+#endif  // XSD_CXX_PARSER_NON_VALIDATING_PARSER_HXX
diff --git src/base/include/xsd/cxx/parser/non-validating/parser.txx src/base/include/xsd/cxx/parser/non-validating/parser.txx
new file mode 100644
index 0000000..c95b92e
--- /dev/null
+++ src/base/include/xsd/cxx/parser/non-validating/parser.txx
@@ -0,0 +1,464 @@
+// file      : xsd/cxx/parser/non-validating/parser.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#include <cassert>
+
+#include <xsd/cxx/xml/bits/literals.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      namespace non_validating
+      {
+
+        // empty_content
+        //
+
+        template <typename C>
+        void empty_content<C>::
+        _start_any_element (const ro_string<C>&,
+                            const ro_string<C>&,
+                            const ro_string<C>*)
+        {
+        }
+
+        template <typename C>
+        void empty_content<C>::
+        _end_any_element (const ro_string<C>&,
+                          const ro_string<C>&)
+        {
+        }
+
+        template <typename C>
+        void empty_content<C>::
+        _any_attribute (const ro_string<C>&,
+                        const ro_string<C>&,
+                        const ro_string<C>&)
+        {
+        }
+
+        template <typename C>
+        void empty_content<C>::
+        _any_characters (const ro_string<C>&)
+        {
+        }
+
+        //
+        //
+        template <typename C>
+        bool empty_content<C>::
+        _start_element_impl (const ro_string<C>&,
+                             const ro_string<C>&,
+                             const ro_string<C>*)
+        {
+          return false;
+        }
+
+        template <typename C>
+        bool empty_content<C>::
+        _end_element_impl (const ro_string<C>&,
+                           const ro_string<C>&)
+        {
+          return false;
+        }
+
+        template <typename C>
+        bool empty_content<C>::
+        _attribute_impl (const ro_string<C>&,
+                         const ro_string<C>&,
+                         const ro_string<C>&)
+        {
+          return false;
+        }
+
+        template <typename C>
+        bool empty_content<C>::
+        _characters_impl (const ro_string<C>&)
+        {
+          return false;
+        }
+
+        template <typename C>
+        void empty_content<C>::
+        _start_element (const ro_string<C>& ns,
+                        const ro_string<C>& name,
+                        const ro_string<C>* type)
+        {
+          if (!_start_element_impl (ns, name, type))
+            _start_any_element (ns, name, type);
+        }
+
+        template <typename C>
+        void empty_content<C>::
+        _end_element (const ro_string<C>& ns,
+                      const ro_string<C>& name)
+        {
+          if (!_end_element_impl (ns, name))
+            _end_any_element (ns, name);
+        }
+
+        template <typename C>
+        void empty_content<C>::
+        _attribute (const ro_string<C>& ns,
+                    const ro_string<C>& name,
+                    const ro_string<C>& value)
+        {
+          // Weed out special attributes: xsi:type, xsi:nil,
+          // xsi:schemaLocation and noNamespaceSchemaLocation.
+          // See section 3.2.7 in Structures for details.
+          //
+          if (ns == xml::bits::xsi_namespace<C> () &&
+              (name == xml::bits::type<C> () ||
+               name == xml::bits::nil_lit<C> () ||
+               name == xml::bits::schema_location<C> () ||
+               name == xml::bits::no_namespace_schema_location<C> ()))
+            return;
+
+          // Also some parsers (notably Xerces-C++) supplies us with
+          // namespace-prefix mapping attributes.
+          //
+          if (ns == xml::bits::xmlns_namespace<C> ())
+            return;
+
+          if (!_attribute_impl (ns, name, value))
+            _any_attribute (ns, name, value);
+        }
+
+        template <typename C>
+        void empty_content<C>::
+        _characters (const ro_string<C>& s)
+        {
+          if (!_characters_impl (s))
+            _any_characters (s);
+        }
+
+
+        // simple_content
+        //
+
+        template <typename C>
+        void simple_content<C>::
+        _attribute (const ro_string<C>& ns,
+                    const ro_string<C>& name,
+                    const ro_string<C>& value)
+        {
+          // Weed out special attributes: xsi:type, xsi:nil,
+          // xsi:schemaLocation and xsi:noNamespaceSchemaLocation.
+          // See section 3.2.7 in Structures for details.
+          //
+          if (ns == xml::bits::xsi_namespace<C> () &&
+              (name == xml::bits::type<C> () ||
+               name == xml::bits::nil_lit<C> () ||
+               name == xml::bits::schema_location<C> () ||
+               name == xml::bits::no_namespace_schema_location<C> ()))
+            return;
+
+          // Also some parsers (notably Xerces-C++) supplies us with
+          // namespace-prefix mapping attributes.
+          //
+          if (ns == xml::bits::xmlns_namespace<C> ())
+            return;
+
+          if (!this->_attribute_impl (ns, name, value))
+            this->_any_attribute (ns, name, value);
+        }
+
+        template <typename C>
+        void simple_content<C>::
+        _characters (const ro_string<C>& str)
+        {
+          this->_characters_impl (str);
+        }
+
+
+        // complex_content
+        //
+
+        template <typename C>
+        void complex_content<C>::
+        _start_element (const ro_string<C>& ns,
+                        const ro_string<C>& name,
+                        const ro_string<C>* type)
+        {
+          state& s (context_.top ());
+
+          if (s.depth_++ > 0)
+          {
+            if (s.any_)
+              this->_start_any_element (ns, name, type);
+            else if (s.parser_)
+              s.parser_->_start_element (ns, name, type);
+          }
+          else
+          {
+            if (!this->_start_element_impl (ns, name, type))
+            {
+              this->_start_any_element (ns, name, type);
+              s.any_ = true;
+            }
+            else if (s.parser_ != 0)
+              s.parser_->_pre_impl ();
+          }
+        }
+
+        template <typename C>
+        void complex_content<C>::
+        _end_element (const ro_string<C>& ns,
+                      const ro_string<C>& name)
+        {
+          // To understand what's going on here it is helpful to think of
+          // a "total depth" as being the sum of individual depths over
+          // all elements.
+          //
+
+          if (context_.top ().depth_ == 0)
+          {
+            state& s (context_.under_top ()); // One before last.
+
+            if (--s.depth_ > 0)
+            {
+              // Indirect recursion.
+              //
+              if (s.parser_)
+                s.parser_->_end_element (ns, name);
+            }
+            else
+            {
+              // Direct recursion.
+              //
+              assert (this == s.parser_);
+
+              this->_post_impl ();
+
+              if (!this->_end_element_impl (ns, name))
+                assert (false);
+            }
+          }
+          else
+          {
+            state& s (context_.top ());
+
+            if (--s.depth_ > 0)
+            {
+              if (s.any_)
+                this->_end_any_element (ns, name);
+              else if (s.parser_)
+                s.parser_->_end_element (ns, name);
+            }
+            else
+            {
+              if (s.parser_ != 0 && !s.any_)
+                s.parser_->_post_impl ();
+
+              if (!this->_end_element_impl (ns, name))
+              {
+                s.any_ = false;
+                this->_end_any_element (ns, name);
+              }
+            }
+          }
+        }
+
+        template <typename C>
+        void complex_content<C>::
+        _attribute (const ro_string<C>& ns,
+                    const ro_string<C>& name,
+                    const ro_string<C>& value)
+        {
+          // Weed out special attributes: xsi:type, xsi:nil,
+          // xsi:schemaLocation and xsi:noNamespaceSchemaLocation.
+          // See section 3.2.7 in Structures for details.
+          //
+          if (ns == xml::bits::xsi_namespace<C> () &&
+              (name == xml::bits::type<C> () ||
+               name == xml::bits::nil_lit<C> () ||
+               name == xml::bits::schema_location<C> () ||
+               name == xml::bits::no_namespace_schema_location<C> ()))
+            return;
+
+          // Also some parsers (notably Xerces-C++) supplies us with
+          // namespace-prefix mapping attributes.
+          //
+          if (ns == xml::bits::xmlns_namespace<C> ())
+            return;
+
+          state& s (context_.top ());
+
+          if (s.depth_ > 0)
+          {
+            if (s.any_)
+              this->_any_attribute (ns, name, value);
+            else if (s.parser_)
+              s.parser_->_attribute (ns, name, value);
+          }
+          else
+          {
+            if (!this->_attribute_impl (ns, name, value))
+              this->_any_attribute (ns, name, value);
+          }
+        }
+
+        template <typename C>
+        void complex_content<C>::
+        _characters (const ro_string<C>& str)
+        {
+          state& s (context_.top ());
+
+          if (s.depth_ > 0)
+          {
+            if (s.any_)
+              this->_any_characters (str);
+            else if (s.parser_)
+              s.parser_->_characters (str);
+          }
+          else
+          {
+            if (!this->_characters_impl (str))
+              this->_any_characters (str);
+          }
+        }
+
+        template <typename C>
+        void complex_content<C>::
+        _pre_impl ()
+        {
+          context_.push (state ());
+          this->_pre ();
+        }
+
+        template <typename C>
+        void complex_content<C>::
+        _post_impl ()
+        {
+          this->_post ();
+          context_.pop ();
+        }
+
+        // list_base
+        //
+        namespace bits
+        {
+          // Find first non-space character.
+          //
+          template <typename C>
+          typename ro_string<C>::size_type
+          find_ns (const C* s,
+                   typename ro_string<C>::size_type size,
+                   typename ro_string<C>::size_type pos)
+          {
+            while (pos < size &&
+                   (s[pos] == C (0x20) || s[pos] == C (0x0A) ||
+                    s[pos] == C (0x0D) || s[pos] == C (0x09)))
+              ++pos;
+
+            return pos < size ? pos : ro_string<C>::npos;
+          }
+
+          // Find first space character.
+          //
+          template <typename C>
+          typename ro_string<C>::size_type
+          find_s (const C* s,
+                  typename ro_string<C>::size_type size,
+                  typename ro_string<C>::size_type pos)
+          {
+            while (pos < size &&
+                   s[pos] != C (0x20) && s[pos] != C (0x0A) &&
+                   s[pos] != C (0x0D) && s[pos] != C (0x09))
+              ++pos;
+
+            return pos < size ? pos : ro_string<C>::npos;
+          }
+        }
+
+        // Relevant XML Schema Part 2: Datatypes sections: 4.2.1.2, 4.3.6.
+        //
+
+        template <typename C>
+        void list_base<C>::
+        _pre_impl ()
+        {
+          simple_content<C>::_pre_impl ();
+          buf_.clear ();
+        }
+
+        template <typename C>
+        void list_base<C>::
+        _characters (const ro_string<C>& s)
+        {
+          typedef typename ro_string<C>::size_type size_type;
+
+          const C* data (s.data ());
+          size_type size (s.size ());
+
+          // Handle the previous chunk if we start with a ws.
+          //
+          if (!buf_.empty () &&
+              (data[0] == C (0x20) || data[0] == C (0x0A) ||
+               data[0] == C (0x0D) || data[0] == C (0x09)))
+          {
+            ro_string<C> tmp (buf_); // Private copy ctor.
+            _xsd_parse_item (tmp);
+            buf_.clear ();
+          }
+
+          // Traverse the data while logically collapsing spaces.
+          //
+          for (size_type i (bits::find_ns (data, size, 0));
+               i != ro_string<C>::npos;)
+          {
+            size_type j (bits::find_s (data, size, i));
+
+            if (j != ro_string<C>::npos)
+            {
+              if (buf_.empty ())
+              {
+                ro_string<C> tmp (data + i, j - i); // Private copy ctor.
+                _xsd_parse_item (tmp);
+              }
+              else
+              {
+                // Assemble the first item in str from buf_ and s.
+                //
+                std::basic_string<C> str;
+                str.swap (buf_);
+                str.append (data + i, j - i);
+                ro_string<C> tmp (str); // Private copy ctor.
+                _xsd_parse_item (tmp);
+              }
+
+              i = bits::find_ns (data, size, j);
+            }
+            else
+            {
+              // Last fragment, append it to the buf_.
+              //
+              buf_.append (data + i, size - i);
+              break;
+            }
+          }
+        }
+
+        template <typename C>
+        void list_base<C>::
+        _post_impl ()
+        {
+          // Handle the last item.
+          //
+          if (!buf_.empty ())
+          {
+            ro_string<C> tmp (buf_); // Private copy ctor.
+            _xsd_parse_item (tmp);
+          }
+
+          simple_content<C>::_post_impl ();
+        }
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/parser/non-validating/xml-schema-pimpl.hxx src/base/include/xsd/cxx/parser/non-validating/xml-schema-pimpl.hxx
new file mode 100644
index 0000000..397386d
--- /dev/null
+++ src/base/include/xsd/cxx/parser/non-validating/xml-schema-pimpl.hxx
@@ -0,0 +1,791 @@
+// file      : xsd/cxx/parser/non-validating/xml-schema-pimpl.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_PARSER_NON_VALIDATING_XML_SCHEMA_PIMPL_HXX
+#define XSD_CXX_PARSER_NON_VALIDATING_XML_SCHEMA_PIMPL_HXX
+
+#include <string>
+
+#include <xsd/cxx/parser/non-validating/xml-schema-pskel.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      namespace non_validating
+      {
+        // any_type
+        //
+        template <typename C>
+        struct any_type_pimpl: virtual any_type_pskel<C>
+        {
+          virtual void
+          post_any_type ();
+        };
+
+        // any_simple_type
+        //
+        template <typename C>
+        struct any_simple_type_pimpl: virtual any_simple_type_pskel<C>
+        {
+          virtual void
+          post_any_simple_type ();
+        };
+
+        // boolean
+        //
+        template <typename C>
+        struct boolean_pimpl: virtual boolean_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual bool
+          post_boolean ();
+
+        protected:
+          std::basic_string<C> str_;
+        };
+
+
+        // 8-bit
+        //
+        template <typename C>
+        struct byte_pimpl: virtual byte_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual signed char
+          post_byte ();
+
+        protected:
+          std::basic_string<C> str_;
+        };
+
+
+        template <typename C>
+        struct unsigned_byte_pimpl: virtual unsigned_byte_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual unsigned char
+          post_unsigned_byte ();
+
+        protected:
+          std::basic_string<C> str_;
+        };
+
+
+        // 16-bit
+        //
+        template <typename C>
+        struct short_pimpl: virtual short_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual short
+          post_short ();
+
+        protected:
+          std::basic_string<C> str_;
+        };
+
+
+        template <typename C>
+        struct unsigned_short_pimpl: virtual unsigned_short_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual unsigned short
+          post_unsigned_short ();
+
+        protected:
+          std::basic_string<C> str_;
+        };
+
+
+        // 32-bit
+        //
+        template <typename C>
+        struct int_pimpl: virtual int_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual int
+          post_int ();
+
+        protected:
+          std::basic_string<C> str_;
+        };
+
+
+        template <typename C>
+        struct unsigned_int_pimpl: virtual unsigned_int_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual unsigned int
+          post_unsigned_int ();
+
+        protected:
+          std::basic_string<C> str_;
+        };
+
+
+        // 64-bit
+        //
+        template <typename C>
+        struct long_pimpl: virtual long_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual long long
+          post_long ();
+
+        protected:
+          std::basic_string<C> str_;
+        };
+
+
+        template <typename C>
+        struct unsigned_long_pimpl: virtual unsigned_long_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual unsigned long long
+          post_unsigned_long ();
+
+        protected:
+          std::basic_string<C> str_;
+        };
+
+
+        // Arbitrary-length integers.
+        //
+        template <typename C>
+        struct integer_pimpl: virtual integer_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual long long
+          post_integer ();
+
+        protected:
+          std::basic_string<C> str_;
+        };
+
+        template <typename C>
+        struct negative_integer_pimpl: virtual negative_integer_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual long long
+          post_negative_integer ();
+
+        protected:
+          std::basic_string<C> str_;
+        };
+
+        template <typename C>
+        struct non_positive_integer_pimpl: virtual non_positive_integer_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual long long
+          post_non_positive_integer ();
+
+        protected:
+          std::basic_string<C> str_;
+        };
+
+        template <typename C>
+        struct positive_integer_pimpl: virtual positive_integer_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual unsigned long long
+          post_positive_integer ();
+
+        protected:
+          std::basic_string<C> str_;
+        };
+
+        template <typename C>
+        struct non_negative_integer_pimpl: virtual non_negative_integer_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual unsigned long long
+          post_non_negative_integer ();
+
+        protected:
+          std::basic_string<C> str_;
+        };
+
+
+        // Floats.
+        //
+        template <typename C>
+        struct float_pimpl: virtual float_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual float
+          post_float ();
+
+        protected:
+          std::basic_string<C> str_;
+        };
+
+
+        template <typename C>
+        struct double_pimpl: virtual double_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual double
+          post_double ();
+
+        protected:
+          std::basic_string<C> str_;
+        };
+
+
+        template <typename C>
+        struct decimal_pimpl: virtual decimal_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual double
+          post_decimal ();
+
+        protected:
+          std::basic_string<C> str_;
+        };
+
+
+        // Strings.
+        //
+        template <typename C>
+        struct string_pimpl: virtual string_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual std::basic_string<C>
+          post_string ();
+
+        protected:
+          std::basic_string<C> str_;
+        };
+
+        template <typename C>
+        struct normalized_string_pimpl: virtual normalized_string_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual std::basic_string<C>
+          post_normalized_string ();
+
+        protected:
+          std::basic_string<C> str_;
+        };
+
+        template <typename C>
+        struct token_pimpl: virtual token_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual std::basic_string<C>
+          post_token ();
+
+        protected:
+          std::basic_string<C> str_;
+        };
+
+        template <typename C>
+        struct name_pimpl: virtual name_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual std::basic_string<C>
+          post_name ();
+
+        protected:
+          std::basic_string<C> str_;
+        };
+
+        template <typename C>
+        struct nmtoken_pimpl: virtual nmtoken_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual std::basic_string<C>
+          post_nmtoken ();
+
+        protected:
+          std::basic_string<C> str_;
+        };
+
+        template <typename C>
+        struct nmtokens_pimpl: virtual nmtokens_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _xsd_parse_item (const ro_string<C>&);
+
+          virtual string_sequence<C>
+          post_nmtokens ();
+
+        protected:
+          string_sequence<C> seq_;
+          nmtoken_pimpl<C> parser_;
+        };
+
+        template <typename C>
+        struct ncname_pimpl: virtual ncname_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual std::basic_string<C>
+          post_ncname ();
+
+        protected:
+          std::basic_string<C> str_;
+        };
+
+        template <typename C>
+        struct id_pimpl: virtual id_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual std::basic_string<C>
+          post_id ();
+
+        protected:
+          std::basic_string<C> str_;
+        };
+
+        template <typename C>
+        struct idref_pimpl: virtual idref_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual std::basic_string<C>
+          post_idref ();
+
+        protected:
+          std::basic_string<C> str_;
+        };
+
+        template <typename C>
+        struct idrefs_pimpl: virtual idrefs_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _xsd_parse_item (const ro_string<C>&);
+
+          virtual string_sequence<C>
+          post_idrefs ();
+
+        protected:
+          string_sequence<C> seq_;
+          idref_pimpl<C> parser_;
+        };
+
+        // language
+        //
+        template <typename C>
+        struct language_pimpl: virtual language_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual std::basic_string<C>
+          post_language ();
+
+        protected:
+          std::basic_string<C> str_;
+        };
+
+        // anyURI
+        //
+        template <typename C>
+        struct uri_pimpl: virtual uri_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual std::basic_string<C>
+          post_uri ();
+
+        protected:
+          std::basic_string<C> str_;
+        };
+
+        // QName
+        //
+        template <typename C>
+        struct qname_pimpl: virtual qname_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual qname<C>
+          post_qname ();
+
+        protected:
+          std::basic_string<C> str_;
+        };
+
+        // base64Binary
+        //
+        template <typename C>
+        struct base64_binary_pimpl: virtual base64_binary_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual std::auto_ptr<buffer>
+          post_base64_binary ();
+
+        protected:
+          std::basic_string<C> str_;
+        };
+
+        // hexBinary
+        //
+        template <typename C>
+        struct hex_binary_pimpl: virtual hex_binary_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual std::auto_ptr<buffer>
+          post_hex_binary ();
+
+        protected:
+          std::basic_string<C> str_;
+        };
+
+        // gday
+        //
+        template <typename C>
+        struct gday_pimpl: virtual gday_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual gday
+          post_gday ();
+
+        protected:
+          std::basic_string<C> str_;
+        };
+
+        // gmonth
+        //
+        template <typename C>
+        struct gmonth_pimpl: virtual gmonth_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual gmonth
+          post_gmonth ();
+
+        protected:
+          std::basic_string<C> str_;
+        };
+
+        // gyear
+        //
+        template <typename C>
+        struct gyear_pimpl: virtual gyear_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual gyear
+          post_gyear ();
+
+        protected:
+          std::basic_string<C> str_;
+        };
+
+        // gmonth_day
+        //
+        template <typename C>
+        struct gmonth_day_pimpl: virtual gmonth_day_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual gmonth_day
+          post_gmonth_day ();
+
+        protected:
+          std::basic_string<C> str_;
+        };
+
+        // gyear_month
+        //
+        template <typename C>
+        struct gyear_month_pimpl: virtual gyear_month_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual gyear_month
+          post_gyear_month ();
+
+        protected:
+          std::basic_string<C> str_;
+        };
+
+        // date
+        //
+        template <typename C>
+        struct date_pimpl: virtual date_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual date
+          post_date ();
+
+        protected:
+          std::basic_string<C> str_;
+        };
+
+        // time
+        //
+        template <typename C>
+        struct time_pimpl: virtual time_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual time
+          post_time ();
+
+        protected:
+          std::basic_string<C> str_;
+        };
+
+        // date_time
+        //
+        template <typename C>
+        struct date_time_pimpl: virtual date_time_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual date_time
+          post_date_time ();
+
+        protected:
+          std::basic_string<C> str_;
+        };
+
+        // duration
+        //
+        template <typename C>
+        struct duration_pimpl: virtual duration_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual duration
+          post_duration ();
+
+        protected:
+          std::basic_string<C> str_;
+        };
+
+        //
+        //
+        namespace bits
+        {
+          // float literals: INF -INF NaN
+          //
+          template<typename C>
+          const C*
+          positive_inf ();
+
+          template<typename C>
+          const C*
+          negative_inf ();
+
+          template<typename C>
+          const C*
+          nan ();
+
+          // boolean literals
+          //
+          template<typename C>
+          const C*
+          true_ ();
+
+          template<typename C>
+          const C*
+          one ();
+        }
+      }
+    }
+  }
+}
+
+#include <xsd/cxx/parser/non-validating/xml-schema-pimpl.txx>
+
+#endif  // XSD_CXX_PARSER_NON_VALIDATING_XML_SCHEMA_PIMPL_HXX
+
+#include <xsd/cxx/parser/non-validating/xml-schema-pimpl.ixx>
diff --git src/base/include/xsd/cxx/parser/non-validating/xml-schema-pimpl.ixx src/base/include/xsd/cxx/parser/non-validating/xml-schema-pimpl.ixx
new file mode 100644
index 0000000..db9a5d1
--- /dev/null
+++ src/base/include/xsd/cxx/parser/non-validating/xml-schema-pimpl.ixx
@@ -0,0 +1,129 @@
+// file      : xsd/cxx/parser/non-validating/xml-schema-pimpl.ixx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#if defined(XSD_CXX_PARSER_USE_CHAR) || !defined(XSD_CXX_PARSER_USE_WCHAR)
+
+#ifndef XSD_CXX_PARSER_NON_VALIDATING_XML_SCHEMA_PIMPL_IXX_CHAR
+#define XSD_CXX_PARSER_NON_VALIDATING_XML_SCHEMA_PIMPL_IXX_CHAR
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      namespace non_validating
+      {
+        namespace bits
+        {
+          //
+          //
+          template<>
+          inline const char*
+          positive_inf<char> ()
+          {
+            return "INF";
+          }
+
+          template<>
+          inline const char*
+          negative_inf<char> ()
+          {
+            return "-INF";
+          }
+
+          template<>
+          inline const char*
+          nan<char> ()
+          {
+            return "NaN";
+          }
+
+          //
+          //
+          template<>
+          inline const char*
+          true_<char> ()
+          {
+            return "true";
+          }
+
+          template<>
+          inline const char*
+          one<char> ()
+          {
+            return "1";
+          }
+        }
+      }
+    }
+  }
+}
+
+#endif // XSD_CXX_PARSER_NON_VALIDATING_XML_SCHEMA_PIMPL_IXX_CHAR
+#endif // XSD_CXX_PARSER_USE_CHAR
+
+
+#if defined(XSD_CXX_PARSER_USE_WCHAR) || !defined(XSD_CXX_PARSER_USE_CHAR)
+
+#ifndef XSD_CXX_PARSER_NON_VALIDATING_XML_SCHEMA_PIMPL_IXX_WCHAR
+#define XSD_CXX_PARSER_NON_VALIDATING_XML_SCHEMA_PIMPL_IXX_WCHAR
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      namespace non_validating
+      {
+        namespace bits
+        {
+          //
+          //
+          template<>
+          inline const wchar_t*
+          positive_inf<wchar_t> ()
+          {
+            return L"INF";
+          }
+
+          template<>
+          inline const wchar_t*
+          negative_inf<wchar_t> ()
+          {
+            return L"-INF";
+          }
+
+          template<>
+          inline const wchar_t*
+          nan<wchar_t> ()
+          {
+            return L"NaN";
+          }
+
+          //
+          //
+          template<>
+          inline const wchar_t*
+          true_<wchar_t> ()
+          {
+            return L"true";
+          }
+
+          template<>
+          inline const wchar_t*
+          one<wchar_t> ()
+          {
+            return L"1";
+          }
+        }
+      }
+    }
+  }
+}
+
+#endif // XSD_CXX_PARSER_NON_VALIDATING_XML_SCHEMA_PIMPL_IXX_WCHAR
+#endif // XSD_CXX_PARSER_USE_WCHAR
diff --git src/base/include/xsd/cxx/parser/non-validating/xml-schema-pimpl.txx src/base/include/xsd/cxx/parser/non-validating/xml-schema-pimpl.txx
new file mode 100644
index 0000000..c430f49
--- /dev/null
+++ src/base/include/xsd/cxx/parser/non-validating/xml-schema-pimpl.txx
@@ -0,0 +1,2068 @@
+// file      : xsd/cxx/parser/non-validating/xml-schema-pimpl.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#include <limits>
+#include <locale>
+
+#include <xsd/cxx/zc-istream.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      namespace non_validating
+      {
+        // Note that most of the types implemented here cannot have
+        // whitespaces in the value. As result we don't need to waste
+        // time collapsing whitespaces. All we need to do is trim the
+        // string representation which can be done without copying.
+        //
+
+        // any_type
+        //
+
+        template <typename C>
+        void any_type_pimpl<C>::
+        post_any_type ()
+        {
+        }
+
+        // any_simple_type
+        //
+
+        template <typename C>
+        void any_simple_type_pimpl<C>::
+        post_any_simple_type ()
+        {
+        }
+
+        // boolean
+        //
+        template <typename C>
+        void boolean_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void boolean_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          str_ += s;
+        }
+
+        template <typename C>
+        bool boolean_pimpl<C>::
+        post_boolean ()
+        {
+          std::basic_string<C> tmp;
+          tmp.swap (str_);
+
+          ro_string<C> str (tmp);
+          trim (str);
+
+          return str == bits::true_<C> () || str == bits::one<C> ();
+        }
+
+        // byte
+        //
+
+        template <typename C>
+        void byte_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void byte_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          str_ += s;
+        }
+
+        template <typename C>
+        signed char byte_pimpl<C>::
+        post_byte ()
+        {
+          std::basic_string<C> tmp;
+          tmp.swap (str_);
+
+          ro_string<C> str (tmp);
+          trim (str);
+
+          short t;
+          zc_istream<C> is (str);
+          is >> t;
+
+          return static_cast<signed char> (t);
+        }
+
+        // unsigned_byte
+        //
+
+        template <typename C>
+        void unsigned_byte_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void unsigned_byte_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          str_ += s;
+        }
+
+        template <typename C>
+        unsigned char unsigned_byte_pimpl<C>::
+        post_unsigned_byte ()
+        {
+          std::basic_string<C> tmp;
+          tmp.swap (str_);
+
+          ro_string<C> str (tmp);
+          trim (str);
+
+          unsigned short t;
+          zc_istream<C> is (str);
+          is >> t;
+
+          return static_cast<unsigned char> (t);
+        }
+
+        // short
+        //
+
+        template <typename C>
+        void short_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void short_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          str_ += s;
+        }
+
+        template <typename C>
+        short short_pimpl<C>::
+        post_short ()
+        {
+          std::basic_string<C> tmp;
+          tmp.swap (str_);
+
+          ro_string<C> str (tmp);
+          trim (str);
+
+          short t;
+          zc_istream<C> is (str);
+          is >> t;
+
+          return t;
+        }
+
+        // unsigned_short
+        //
+
+        template <typename C>
+        void unsigned_short_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void unsigned_short_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          str_ += s;
+        }
+
+        template <typename C>
+        unsigned short unsigned_short_pimpl<C>::
+        post_unsigned_short ()
+        {
+          std::basic_string<C> tmp;
+          tmp.swap (str_);
+
+          ro_string<C> str (tmp);
+          trim (str);
+
+          unsigned short t;
+          zc_istream<C> is (str);
+          is >> t;
+
+          return t;
+        }
+
+        // int
+        //
+
+        template <typename C>
+        void int_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void int_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          str_ += s;
+        }
+
+        template <typename C>
+        int int_pimpl<C>::
+        post_int ()
+        {
+          std::basic_string<C> tmp;
+          tmp.swap (str_);
+
+          ro_string<C> str (tmp);
+          trim (str);
+
+          int t;
+          zc_istream<C> is (str);
+          is >> t;
+
+          return t;
+        }
+
+        // unsigned_int
+        //
+
+        template <typename C>
+        void unsigned_int_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void unsigned_int_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          str_ += s;
+        }
+
+        template <typename C>
+        unsigned int unsigned_int_pimpl<C>::
+        post_unsigned_int ()
+        {
+          std::basic_string<C> tmp;
+          tmp.swap (str_);
+
+          ro_string<C> str (tmp);
+          trim (str);
+
+          unsigned int t;
+          zc_istream<C> is (str);
+          is >> t;
+
+          return t;
+        }
+
+        // long
+        //
+        template <typename C>
+        void long_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void long_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          str_ += s;
+        }
+
+        template <typename C>
+        long long long_pimpl<C>::
+        post_long ()
+        {
+          std::basic_string<C> tmp;
+          tmp.swap (str_);
+
+          ro_string<C> str (tmp);
+          trim (str);
+
+          long long t;
+          zc_istream<C> is (str);
+          is >> t;
+
+          return t;
+        }
+
+        // unsigned_long
+        //
+        template <typename C>
+        void unsigned_long_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void unsigned_long_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          str_ += s;
+        }
+
+        template <typename C>
+        unsigned long long unsigned_long_pimpl<C>::
+        post_unsigned_long ()
+        {
+          std::basic_string<C> tmp;
+          tmp.swap (str_);
+
+          ro_string<C> str (tmp);
+          trim (str);
+
+          unsigned long long t;
+          zc_istream<C> is (str);
+          is >> t;
+
+          return t;
+        }
+
+        // integer
+        //
+        template <typename C>
+        void integer_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void integer_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          str_ += s;
+        }
+
+        template <typename C>
+        long long integer_pimpl<C>::
+        post_integer ()
+        {
+          std::basic_string<C> tmp;
+          tmp.swap (str_);
+
+          ro_string<C> str (tmp);
+          trim (str);
+
+          long long t;
+          zc_istream<C> is (str);
+          is >> t;
+
+          return t;
+        }
+
+        // negative_integer
+        //
+        template <typename C>
+        void negative_integer_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void negative_integer_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          str_ += s;
+        }
+
+        template <typename C>
+        long long negative_integer_pimpl<C>::
+        post_negative_integer ()
+        {
+          std::basic_string<C> tmp;
+          tmp.swap (str_);
+
+          ro_string<C> str (tmp);
+          trim (str);
+
+          long long t;
+          zc_istream<C> is (str);
+          is >> t;
+
+          return t;
+        }
+
+        // non_positive_integer
+        //
+        template <typename C>
+        void non_positive_integer_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void non_positive_integer_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          str_ += s;
+        }
+
+        template <typename C>
+        long long non_positive_integer_pimpl<C>::
+        post_non_positive_integer ()
+        {
+          std::basic_string<C> tmp;
+          tmp.swap (str_);
+
+          ro_string<C> str (tmp);
+          trim (str);
+
+          long long t;
+          zc_istream<C> is (str);
+          is >> t;
+
+          return t;
+        }
+
+        // positive_integer
+        //
+        template <typename C>
+        void positive_integer_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void positive_integer_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          str_ += s;
+        }
+
+        template <typename C>
+        unsigned long long positive_integer_pimpl<C>::
+        post_positive_integer ()
+        {
+          std::basic_string<C> tmp;
+          tmp.swap (str_);
+
+          ro_string<C> str (tmp);
+          trim (str);
+
+          unsigned long long t;
+          zc_istream<C> is (str);
+          is >> t;
+
+          return t;
+        }
+
+        // non_negative_integer
+        //
+        template <typename C>
+        void non_negative_integer_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void non_negative_integer_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          str_ += s;
+        }
+
+        template <typename C>
+        unsigned long long non_negative_integer_pimpl<C>::
+        post_non_negative_integer ()
+        {
+          std::basic_string<C> tmp;
+          tmp.swap (str_);
+
+          ro_string<C> str (tmp);
+          trim (str);
+
+          unsigned long long t;
+          zc_istream<C> is (str);
+          is >> t;
+
+          return t;
+        }
+
+        // float
+        //
+        template <typename C>
+        void float_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void float_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          str_ += s;
+        }
+
+        template <typename C>
+        float float_pimpl<C>::
+        post_float ()
+        {
+          std::basic_string<C> tmp;
+          tmp.swap (str_);
+
+          ro_string<C> str (tmp);
+          trim (str);
+
+          if (str == bits::positive_inf<C> ())
+            return std::numeric_limits<float>::infinity ();
+
+          if (str == bits::negative_inf<C> ())
+            return -std::numeric_limits<float>::infinity ();
+
+          if (str == bits::nan<C> ())
+            return std::numeric_limits<float>::quiet_NaN ();
+
+          float t;
+          zc_istream<C> is (str);
+          is.imbue (std::locale::classic ());
+          is >> t;
+
+          return t;
+        }
+
+        // double
+        //
+        template <typename C>
+        void double_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void double_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          str_ += s;
+        }
+
+        template <typename C>
+        double double_pimpl<C>::
+        post_double ()
+        {
+          std::basic_string<C> tmp;
+          tmp.swap (str_);
+
+          ro_string<C> str (tmp);
+          trim (str);
+
+          if (str == bits::positive_inf<C> ())
+            return std::numeric_limits<double>::infinity ();
+
+          if (str == bits::negative_inf<C> ())
+            return -std::numeric_limits<double>::infinity ();
+
+          if (str == bits::nan<C> ())
+            return std::numeric_limits<double>::quiet_NaN ();
+
+          double t;
+          zc_istream<C> is (str);
+          is.imbue (std::locale::classic ());
+          is >> t;
+
+          return t;
+        }
+
+        // decimal
+        //
+        template <typename C>
+        void decimal_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void decimal_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          str_ += s;
+        }
+
+        template <typename C>
+        double decimal_pimpl<C>::
+        post_decimal ()
+        {
+          std::basic_string<C> tmp;
+          tmp.swap (str_);
+
+          ro_string<C> str (tmp);
+          trim (str);
+
+          double t;
+          zc_istream<C> is (str);
+          is.imbue (std::locale::classic ());
+          is >> t;
+
+          return t;
+        }
+
+
+        // string
+        //
+        template <typename C>
+        void string_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void string_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          str_ += s;
+        }
+
+        template <typename C>
+        std::basic_string<C> string_pimpl<C>::
+        post_string ()
+        {
+          std::basic_string<C> r;
+          r.swap (str_);
+          return r;
+        }
+
+        // normalized_string
+        //
+        template <typename C>
+        void normalized_string_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void normalized_string_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          str_ += s;
+        }
+
+        template <typename C>
+        std::basic_string<C> normalized_string_pimpl<C>::
+        post_normalized_string ()
+        {
+          typedef typename std::basic_string<C>::size_type size_type;
+
+          size_type size (str_.size ());
+
+          for (size_type i (0); i < size; ++i)
+          {
+            C& c = str_[i];
+
+            if (c == C (0x0A) || c == C (0x0D) || c == C (0x09))
+              c = C (0x20);
+          }
+
+          std::basic_string<C> r;
+          r.swap (str_);
+          return r;
+        }
+
+        // token
+        //
+        template <typename C>
+        void token_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void token_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          if (str_.size () == 0)
+          {
+            ro_string<C> tmp (s.data (), s.size ());
+
+            if (trim_left (tmp) != 0)
+              str_ += tmp;
+          }
+          else
+            str_ += s;
+        }
+
+        template <typename C>
+        std::basic_string<C> token_pimpl<C>::
+        post_token ()
+        {
+          typedef typename std::basic_string<C>::size_type size_type;
+
+          size_type size (str_.size ());
+          size_type j (0);
+
+          bool subs (false);
+
+          for (size_type i (0); i < size; ++i)
+          {
+            C c = str_[i];
+
+            if (c == C (0x20) || c == C (0x0A) ||
+                c == C (0x0D) || c == C (0x09))
+            {
+              subs = true;
+            }
+            else
+            {
+              if (subs)
+              {
+                subs = false;
+                str_[j++] = C (0x20);
+              }
+
+              str_[j++] = c;
+            }
+          }
+
+          str_.resize (j);
+
+          std::basic_string<C> r;
+          r.swap (str_);
+          return r;
+        }
+
+        // name
+        //
+        template <typename C>
+        void name_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void name_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          if (str_.size () == 0)
+          {
+            ro_string<C> tmp (s.data (), s.size ());
+
+            if (trim_left (tmp) != 0)
+              str_ += tmp;
+          }
+          else
+            str_ += s;
+        }
+
+        template <typename C>
+        std::basic_string<C> name_pimpl<C>::
+        post_name ()
+        {
+          ro_string<C> tmp (str_);
+          str_.resize (trim_right (tmp));
+
+          std::basic_string<C> r;
+          r.swap (str_);
+          return r;
+        }
+
+        // nmtoken
+        //
+        template <typename C>
+        void nmtoken_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void nmtoken_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          if (str_.size () == 0)
+          {
+            ro_string<C> tmp (s.data (), s.size ());
+
+            if (trim_left (tmp) != 0)
+              str_ += tmp;
+          }
+          else
+            str_ += s;
+        }
+
+        template <typename C>
+        std::basic_string<C> nmtoken_pimpl<C>::
+        post_nmtoken ()
+        {
+          ro_string<C> tmp (str_);
+          str_.resize (trim_right (tmp));
+
+          std::basic_string<C> r;
+          r.swap (str_);
+          return r;
+        }
+
+        // nmtokens
+        //
+        template <typename C>
+        void nmtokens_pimpl<C>::
+        _pre ()
+        {
+          nmtokens_pskel<C>::_pre ();
+          seq_.clear ();
+        }
+
+        template <typename C>
+        string_sequence<C> nmtokens_pimpl<C>::
+        post_nmtokens ()
+        {
+          string_sequence<C> r;
+          r.swap (seq_);
+          return r;
+        }
+
+        template <typename C>
+        void nmtokens_pimpl<C>::
+        _xsd_parse_item (const ro_string<C>& s)
+        {
+          parser_.pre ();
+          parser_._pre ();
+          parser_._characters (s);
+          parser_._post ();
+          seq_.push_back (parser_.post_nmtoken ());
+        }
+
+        // ncname
+        //
+        template <typename C>
+        void ncname_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void ncname_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          if (str_.size () == 0)
+          {
+            ro_string<C> tmp (s.data (), s.size ());
+
+            if (trim_left (tmp) != 0)
+              str_ += tmp;
+          }
+          else
+            str_ += s;
+        }
+
+        template <typename C>
+        std::basic_string<C> ncname_pimpl<C>::
+        post_ncname ()
+        {
+          ro_string<C> tmp (str_);
+          str_.resize (trim_right (tmp));
+
+          std::basic_string<C> r;
+          r.swap (str_);
+          return r;
+        }
+
+        // id
+        //
+        template <typename C>
+        void id_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void id_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          if (str_.size () == 0)
+          {
+            ro_string<C> tmp (s.data (), s.size ());
+
+            if (trim_left (tmp) != 0)
+              str_ += tmp;
+          }
+          else
+            str_ += s;
+        }
+
+        template <typename C>
+        std::basic_string<C> id_pimpl<C>::
+        post_id ()
+        {
+          ro_string<C> tmp (str_);
+          str_.resize (trim_right (tmp));
+
+          std::basic_string<C> r;
+          r.swap (str_);
+          return r;
+        }
+
+        // idref
+        //
+        template <typename C>
+        void idref_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void idref_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          if (str_.size () == 0)
+          {
+            ro_string<C> tmp (s.data (), s.size ());
+
+            if (trim_left (tmp) != 0)
+              str_ += tmp;
+          }
+          else
+            str_ += s;
+        }
+
+        template <typename C>
+        std::basic_string<C> idref_pimpl<C>::
+        post_idref ()
+        {
+          ro_string<C> tmp (str_);
+          str_.resize (trim_right (tmp));
+
+          std::basic_string<C> r;
+          r.swap (str_);
+          return r;
+        }
+
+        // idrefs
+        //
+        template <typename C>
+        void idrefs_pimpl<C>::
+        _pre ()
+        {
+          idrefs_pskel<C>::_pre ();
+          seq_.clear ();
+        }
+
+        template <typename C>
+        string_sequence<C> idrefs_pimpl<C>::
+        post_idrefs ()
+        {
+          string_sequence<C> r;
+          r.swap (seq_);
+          return r;
+        }
+
+        template <typename C>
+        void idrefs_pimpl<C>::
+        _xsd_parse_item (const ro_string<C>& s)
+        {
+          parser_.pre ();
+          parser_._pre ();
+          parser_._characters (s);
+          parser_._post ();
+          seq_.push_back (parser_.post_idref ());
+        }
+
+        // language
+        //
+        template <typename C>
+        void language_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void language_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          if (str_.size () == 0)
+          {
+            ro_string<C> tmp (s.data (), s.size ());
+
+            if (trim_left (tmp) != 0)
+              str_ += tmp;
+          }
+          else
+            str_ += s;
+        }
+
+        template <typename C>
+        std::basic_string<C> language_pimpl<C>::
+        post_language ()
+        {
+          ro_string<C> tmp (str_);
+          str_.resize (trim_right (tmp));
+
+          std::basic_string<C> r;
+          r.swap (str_);
+          return r;
+        }
+
+        // uri
+        //
+        template <typename C>
+        void uri_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void uri_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          if (str_.size () == 0)
+          {
+            ro_string<C> tmp (s.data (), s.size ());
+
+            if (trim_left (tmp) != 0)
+              str_ += tmp;
+          }
+          else
+            str_ += s;
+        }
+
+        template <typename C>
+        std::basic_string<C> uri_pimpl<C>::
+        post_uri ()
+        {
+          ro_string<C> tmp (str_);
+          str_.resize (trim_right (tmp));
+
+          std::basic_string<C> r;
+          r.swap (str_);
+          return r;
+        }
+
+        // qname
+        //
+        template <typename C>
+        void qname_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void qname_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          if (str_.size () == 0)
+          {
+            ro_string<C> tmp (s.data (), s.size ());
+
+            if (trim_left (tmp) != 0)
+              str_ += tmp;
+          }
+          else
+            str_ += s;
+        }
+
+        template <typename C>
+        qname<C> qname_pimpl<C>::
+        post_qname ()
+        {
+          typedef typename ro_string<C>::size_type size_type;
+
+          ro_string<C> tmp (str_);
+          size_type size (trim_right (tmp));
+          size_type pos (tmp.find (C (':')));
+
+          if (pos != ro_string<C>::npos)
+          {
+            std::basic_string<C> prefix (tmp.data (), pos++);
+            std::basic_string<C> name (tmp.data () + pos, size - pos);
+            return qname<C> (prefix, name);
+          }
+          else
+          {
+            str_.resize (size);
+            return qname<C> (str_);
+          }
+        }
+
+        // base64_binary
+        //
+        template <typename C>
+        void base64_binary_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void base64_binary_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          if (str_.size () == 0)
+          {
+            ro_string<C> tmp (s.data (), s.size ());
+
+            if (trim_left (tmp) != 0)
+              str_ += tmp;
+          }
+          else
+            str_ += s;
+        }
+
+        namespace bits
+        {
+          template <typename C>
+          inline unsigned char
+          base64_decode (C c)
+          {
+            unsigned char r (0xFF);
+
+            if (c >= C('A') && c <= C ('Z'))
+              r = static_cast<unsigned char> (c - C ('A'));
+            else if (c >= C('a') && c <= C ('z'))
+              r = static_cast<unsigned char> (c - C ('a') + 26);
+            else if (c >= C('0') && c <= C ('9'))
+              r = static_cast<unsigned char> (c - C ('0') + 52);
+            else if (c == C ('+'))
+              r = 62;
+            else if (c == C ('/'))
+              r = 63;
+
+            return r;
+          }
+        }
+
+        template <typename C>
+        std::auto_ptr<buffer> base64_binary_pimpl<C>::
+        post_base64_binary ()
+        {
+          typedef typename std::basic_string<C>::size_type size_type;
+
+          size_type size (str_.size ());
+          const C* src (str_.c_str ());
+
+          // Remove all whitespaces.
+          //
+          {
+            size_type j (0);
+
+            bool subs (false);
+
+            for (size_type i (0); i < size; ++i)
+            {
+              C c = str_[i];
+
+              if (c == C (0x20) || c == C (0x0A) ||
+                  c == C (0x0D) || c == C (0x09))
+              {
+                subs = true;
+              }
+              else
+              {
+                if (subs)
+                  subs = false;
+
+                str_[j++] = c;
+              }
+            }
+
+            size = j;
+            str_.resize (size);
+          }
+
+          // Our length should be a multiple of four.
+          //
+          size_type quad_count (size / 4);
+          size_type capacity (quad_count * 3 + 1);
+
+          std::auto_ptr<buffer> buf (new buffer (capacity, capacity));
+          char* dst (buf->data ());
+
+          size_type si (0), di (0); // Source and destination indexes.
+
+          // Process all quads except the last one.
+          //
+          unsigned char b1, b2, b3, b4;
+
+          for (size_type q (0); q < quad_count - 1; ++q)
+          {
+            b1 = bits::base64_decode (src[si++]);
+            b2 = bits::base64_decode (src[si++]);
+            b3 = bits::base64_decode (src[si++]);
+            b4 = bits::base64_decode (src[si++]);
+
+            dst[di++] = (b1 << 2) | (b2 >> 4);
+            dst[di++] = (b2 << 4) | (b3 >> 2);
+            dst[di++] = (b3 << 6) | b4;
+          }
+
+          // Process the last quad. The first two octets are always there.
+          //
+          b1 = bits::base64_decode (src[si++]);
+          b2 = bits::base64_decode (src[si++]);
+
+          C e3 (src[si++]);
+          C e4 (src[si++]);
+
+          if (e4 == C ('='))
+          {
+            if (e3 == C ('='))
+            {
+              // Two pads. Last 4 bits in b2 should be zero.
+              //
+              dst[di++] = (b1 << 2) | (b2 >> 4);
+            }
+            else
+            {
+              // One pad. Last 2 bits in b3 should be zero.
+              //
+              b3 = bits::base64_decode (e3);
+
+              dst[di++] = (b1 << 2) | (b2 >> 4);
+              dst[di++] = (b2 << 4) | (b3 >> 2);
+            }
+          }
+          else
+          {
+            // No pads.
+            //
+            b3 = bits::base64_decode (e3);
+            b4 = bits::base64_decode (e4);
+
+            dst[di++] = (b1 << 2) | (b2 >> 4);
+            dst[di++] = (b2 << 4) | (b3 >> 2);
+            dst[di++] = (b3 << 6) | b4;
+          }
+
+          // Set the real size.
+          //
+          buf->size (di);
+
+          return buf;
+        }
+
+        // hex_binary
+        //
+        template <typename C>
+        void hex_binary_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void hex_binary_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          if (str_.size () == 0)
+          {
+            ro_string<C> tmp (s.data (), s.size ());
+
+            if (trim_left (tmp) != 0)
+              str_ += tmp;
+          }
+          else
+            str_ += s;
+        }
+
+        namespace bits
+        {
+          template <typename C>
+          inline unsigned char
+          hex_decode (C c)
+          {
+            unsigned char r (0xFF);
+
+            if (c >= C('0') && c <= C ('9'))
+              r = static_cast<unsigned char> (c - C ('0'));
+            else if (c >= C ('A') && c <= C ('F'))
+              r = static_cast<unsigned char> (10 + (c - C ('A')));
+            else if (c >= C ('a') && c <= C ('f'))
+              r = static_cast<unsigned char> (10 + (c - C ('a')));
+
+            return r;
+          }
+        }
+
+        template <typename C>
+        std::auto_ptr<buffer> hex_binary_pimpl<C>::
+        post_hex_binary ()
+        {
+          typedef typename ro_string<C>::size_type size_type;
+
+          ro_string<C> tmp (str_);
+          size_type size (trim_right (tmp));
+
+          buffer::size_t n (size / 2);
+          std::auto_ptr<buffer> buf (new buffer (n));
+
+          const C* src (tmp.data ());
+          char* dst (buf->data ());
+
+          for (buffer::size_t i (0); i < n; ++i)
+          {
+            unsigned char h (bits::hex_decode (src[2 * i]));
+            unsigned char l (bits::hex_decode (src[2 * i + 1]));
+            dst[i] = (h << 4) | l;
+          }
+
+          return buf;
+        }
+
+        // time_zone
+        //
+        namespace bits
+        {
+          // Datatypes 3.2.7.3.
+          //
+          template <typename C>
+          void
+          parse_tz (const C* s,
+                    typename std::basic_string<C>::size_type n,
+                    short& h, short& m)
+          {
+            // time_zone := Z|(+|-)HH:MM
+            //
+            if (n == 0)
+            {
+              return;
+            }
+            else if (s[0] == 'Z')
+            {
+              h = 0;
+              m = 0;
+            }
+            else if (n == 6)
+            {
+              // Parse hours.
+              //
+              h = 10 * (s[1] - '0') + (s[2] - '0');
+
+              // Parse minutes.
+              //
+              m = 10 * (s[4] - '0') + (s[5] - '0');
+
+              if (s[0] == '-')
+              {
+                h = -h;
+                m = -m;
+              }
+            }
+          }
+        }
+
+        // gday
+        //
+        template <typename C>
+        void gday_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void gday_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          if (str_.size () == 0)
+          {
+            ro_string<C> tmp (s.data (), s.size ());
+
+            if (trim_left (tmp) != 0)
+              str_ += tmp;
+          }
+          else
+            str_ += s;
+        }
+
+        template <typename C>
+        gday gday_pimpl<C>::
+        post_gday ()
+        {
+          typedef typename ro_string<C>::size_type size_type;
+
+          ro_string<C> tmp (str_);
+          size_type size (trim_right (tmp));
+          const C* s (tmp.data ());
+
+          unsigned short day (0);
+          bool z (false);
+          short zh (0), zm (0);
+
+          // gday := ---DD[Z|(+|-)HH:MM]
+          //
+          if (size >= 5)
+          {
+            day = 10 * (s[3] - '0') + (s[4] - '0');
+
+            if (size > 5)
+            {
+              bits::parse_tz (s + 5, size - 5, zh, zm);
+              z = true;
+            }
+          }
+
+          return z ? gday (day, zh, zm) : gday (day);
+        }
+
+        // gmonth
+        //
+        template <typename C>
+        void gmonth_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void gmonth_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          if (str_.size () == 0)
+          {
+            ro_string<C> tmp (s.data (), s.size ());
+
+            if (trim_left (tmp) != 0)
+              str_ += tmp;
+          }
+          else
+            str_ += s;
+        }
+
+        template <typename C>
+        gmonth gmonth_pimpl<C>::
+        post_gmonth ()
+        {
+          typedef typename ro_string<C>::size_type size_type;
+
+          ro_string<C> tmp (str_);
+          size_type size (trim_right (tmp));
+          const C* s (tmp.data ());
+
+          unsigned short month (0);
+          bool z (false);
+          short zh (0), zm (0);
+
+          // gmonth := --MM[Z|(+|-)HH:MM]
+          //
+          if (size >= 4)
+          {
+            month = 10 * (s[2] - '0') + (s[3] - '0');
+
+            if (size > 4)
+            {
+              bits::parse_tz (s + 4, size - 4, zh, zm);
+              z = true;
+            }
+          }
+
+          return z ? gmonth (month, zh, zm) : gmonth (month);
+        }
+
+        // gyear
+        //
+        template <typename C>
+        void gyear_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void gyear_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          if (str_.size () == 0)
+          {
+            ro_string<C> tmp (s.data (), s.size ());
+
+            if (trim_left (tmp) != 0)
+              str_ += tmp;
+          }
+          else
+            str_ += s;
+        }
+
+        template <typename C>
+        gyear gyear_pimpl<C>::
+        post_gyear ()
+        {
+          typedef typename ro_string<C>::size_type size_type;
+
+          ro_string<C> tmp (str_);
+          size_type size (trim_right (tmp));
+          const C* s (tmp.data ());
+
+          int year (0);
+          bool z (false);
+          short zh (0), zm (0);
+
+          // gyear := [-]CCYY[N]*[Z|(+|-)HH:MM]
+          //
+
+          if (size >= 4)
+          {
+            // Find the end of the year token.
+            //
+            size_type pos (4);
+            for (; pos < size; ++pos)
+            {
+              C c (s[pos]);
+
+              if (c == C ('Z') || c == C ('+') || c == C ('-'))
+                break;
+            }
+
+            ro_string<C> year_fragment (s, pos);
+            zc_istream<C> is (year_fragment);
+            is >> year;
+
+            if (pos < size)
+            {
+              bits::parse_tz (s + pos, size - pos, zh, zm);
+              z = true;
+            }
+          }
+
+          return z ? gyear (year, zh, zm) : gyear (year);
+        }
+
+        // gmonth_day
+        //
+        template <typename C>
+        void gmonth_day_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void gmonth_day_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          if (str_.size () == 0)
+          {
+            ro_string<C> tmp (s.data (), s.size ());
+
+            if (trim_left (tmp) != 0)
+              str_ += tmp;
+          }
+          else
+            str_ += s;
+        }
+
+        template <typename C>
+        gmonth_day gmonth_day_pimpl<C>::
+        post_gmonth_day ()
+        {
+          typedef typename ro_string<C>::size_type size_type;
+
+          ro_string<C> tmp (str_);
+          size_type size (trim_right (tmp));
+          const C* s (tmp.data ());
+
+          unsigned short month (0), day (0);
+          bool z (false);
+          short zh (0), zm (0);
+
+          // gmonth_day := --MM-DD[Z|(+|-)HH:MM]
+          //
+          if (size >= 7)
+          {
+            month = 10 * (s[2] - '0') + (s[3] - '0');
+            day = 10 * (s[5] - '0') + (s[6] - '0');
+
+            if (size > 7)
+            {
+              bits::parse_tz (s + 7, size - 7, zh, zm);
+              z = true;
+            }
+          }
+
+          return z
+            ? gmonth_day (month, day, zh, zm)
+            : gmonth_day (month, day);
+        }
+
+        // gyear_month
+        //
+        template <typename C>
+        void gyear_month_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void gyear_month_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          if (str_.size () == 0)
+          {
+            ro_string<C> tmp (s.data (), s.size ());
+
+            if (trim_left (tmp) != 0)
+              str_ += tmp;
+          }
+          else
+            str_ += s;
+        }
+
+        template <typename C>
+        gyear_month gyear_month_pimpl<C>::
+        post_gyear_month ()
+        {
+          typedef typename ro_string<C>::size_type size_type;
+
+          ro_string<C> tmp (str_);
+          size_type size (trim_right (tmp));
+          const C* s (tmp.data ());
+
+          int year (0);
+          unsigned short month (0);
+          bool z (false);
+          short zh (0), zm (0);
+
+          // gyear_month := [-]CCYY[N]*-MM[Z|(+|-)HH:MM]
+          //
+
+          if (size >= 7)
+          {
+            // Find the end of the year token.
+            //
+            size_type pos (tmp.find (C ('-'), 4));
+
+            if (pos != ro_string<C>::npos && (size - pos - 1) >= 2)
+            {
+              ro_string<C> year_fragment (s, pos);
+              zc_istream<C> yis (year_fragment);
+              yis >> year;
+
+              month = 10 * (s[pos + 1] - '0') + (s[pos + 2] - '0');
+
+              pos += 3;
+
+              if (pos < size)
+              {
+                bits::parse_tz (s + pos, size - pos, zh, zm);
+                z = true;
+              }
+            }
+          }
+
+          return z
+            ? gyear_month (year, month, zh, zm)
+            : gyear_month (year, month);
+        }
+
+        // date
+        //
+        template <typename C>
+        void date_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void date_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          if (str_.size () == 0)
+          {
+            ro_string<C> tmp (s.data (), s.size ());
+
+            if (trim_left (tmp) != 0)
+              str_ += tmp;
+          }
+          else
+            str_ += s;
+        }
+
+        template <typename C>
+        date date_pimpl<C>::
+        post_date ()
+        {
+          typedef typename ro_string<C>::size_type size_type;
+
+          ro_string<C> tmp (str_);
+          size_type size (trim_right (tmp));
+          const C* s (tmp.data ());
+
+          int year (0);
+          unsigned short month (0), day (0);
+          bool z (false);
+          short zh (0), zm (0);
+
+          // date := [-]CCYY[N]*-MM-DD[Z|(+|-)HH:MM]
+          //
+
+          if (size >= 10)
+          {
+            // Find the end of the year token.
+            //
+            size_type pos (tmp.find (C ('-'), 4));
+
+            if (pos != ro_string<C>::npos && (size - pos - 1) >= 5)
+            {
+              ro_string<C> year_fragment (s, pos);
+              zc_istream<C> yis (year_fragment);
+              yis >> year;
+
+              month = 10 * (s[pos + 1] - '0') + (s[pos + 2] - '0');
+              day = 10 * (s[pos + 4] - '0') + (s[pos + 5] - '0');
+
+              pos += 6;
+
+              if (pos < size)
+              {
+                bits::parse_tz (s + pos, size - pos, zh, zm);
+                z = true;
+              }
+            }
+          }
+
+          return z
+            ? date (year, month, day, zh, zm)
+            : date (year, month, day);
+        }
+
+        // time
+        //
+        template <typename C>
+        void time_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void time_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          if (str_.size () == 0)
+          {
+            ro_string<C> tmp (s.data (), s.size ());
+
+            if (trim_left (tmp) != 0)
+              str_ += tmp;
+          }
+          else
+            str_ += s;
+        }
+
+        template <typename C>
+        time time_pimpl<C>::
+        post_time ()
+        {
+          typedef typename ro_string<C>::size_type size_type;
+
+          ro_string<C> tmp (str_);
+          size_type size (trim_right (tmp));
+          const C* s (tmp.data ());
+
+          unsigned short hours (0), minutes (0);
+          double seconds (0.0);
+          bool z (false);
+          short zh (0), zm (0);
+
+          // time := HH:MM:SS[.S+][Z|(+|-)HH:MM]
+          //
+
+          if (size >= 8)
+          {
+            hours = 10 * (s[0] - '0') + (s[1] - '0');
+            minutes = 10 * (s[3] - '0') + (s[4] - '0');
+
+            // Find the end of the seconds fragment.
+            //
+            size_type pos (8);
+            for (; pos < size; ++pos)
+            {
+              C c (s[pos]);
+
+              if (c == C ('Z') || c == C ('+') || c == C ('-'))
+                break;
+            }
+
+            ro_string<C> seconds_fragment (s + 6, pos - 6);
+            zc_istream<C> sis (seconds_fragment);
+            sis >> seconds;
+
+            if (pos < size)
+            {
+              bits::parse_tz (s + pos, size - pos, zh, zm);
+              z = true;
+            }
+          }
+
+          return z
+            ? time (hours, minutes, seconds, zh, zm)
+            : time (hours, minutes, seconds);
+        }
+
+
+        // date_time
+        //
+        template <typename C>
+        void date_time_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void date_time_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          if (str_.size () == 0)
+          {
+            ro_string<C> tmp (s.data (), s.size ());
+
+            if (trim_left (tmp) != 0)
+              str_ += tmp;
+          }
+          else
+            str_ += s;
+        }
+
+        template <typename C>
+        date_time date_time_pimpl<C>::
+        post_date_time ()
+        {
+          typedef typename ro_string<C>::size_type size_type;
+
+          ro_string<C> tmp (str_);
+          size_type size (trim_right (tmp));
+          const C* s (tmp.data ());
+
+          int year (0);
+          unsigned short month (0), day (0), hours (0), minutes (0);
+          double seconds (0.0);
+          bool z (false);
+          short zh (0), zm (0);
+
+          // date_time := [-]CCYY[N]*-MM-DDTHH:MM:SS[.S+][Z|(+|-)HH:MM]
+          //
+
+          if (size >= 19)
+          {
+            // Find the end of the year token.
+            //
+            size_type pos (tmp.find (C ('-'), 4));
+
+            if (pos != ro_string<C>::npos && (size - pos - 1) >= 14)
+            {
+              ro_string<C> year_fragment (s, pos);
+              zc_istream<C> yis (year_fragment);
+              yis >> year;
+
+              month = 10 * (s[pos + 1] - '0') + (s[pos + 2] - '0');
+              day = 10 * (s[pos + 4] - '0') + (s[pos + 5] - '0');
+
+              pos += 7; // Point to the first H.
+
+              hours = 10 * (s[pos] - '0') + (s[pos + 1] - '0');
+              minutes = 10 * (s[pos + 3] - '0') + (s[pos + 4] - '0');
+
+              // Find the end of the seconds fragment.
+              //
+              pos += 6; // Point to the first S.
+
+              size_type sec_end (pos + 2);
+              for (; sec_end < size; ++sec_end)
+              {
+                C c (s[sec_end]);
+
+                if (c == C ('Z') || c == C ('+') || c == C ('-'))
+                  break;
+              }
+
+              ro_string<C> seconds_fragment (s + pos, sec_end - pos);
+              zc_istream<C> sis (seconds_fragment);
+              sis >> seconds;
+
+              if (sec_end < size)
+              {
+                bits::parse_tz (s + sec_end, size - sec_end, zh, zm);
+                z = true;
+              }
+            }
+          }
+
+          return z
+            ? date_time (year, month, day, hours, minutes, seconds, zh, zm)
+            : date_time (year, month, day, hours, minutes, seconds);
+        }
+
+        // duration
+        //
+        template <typename C>
+        void duration_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void duration_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          if (str_.size () == 0)
+          {
+            ro_string<C> tmp (s.data (), s.size ());
+
+            if (trim_left (tmp) != 0)
+              str_ += tmp;
+          }
+          else
+            str_ += s;
+        }
+
+        namespace bits
+        {
+          template <typename C>
+          inline typename ro_string<C>::size_type
+          duration_delim (const C* s,
+                          typename ro_string<C>::size_type pos,
+                          typename ro_string<C>::size_type size)
+          {
+            const C* p (s + pos);
+            for (; p < (s + size); ++p)
+            {
+              if (*p == C ('Y') || *p == C ('D') || *p == C ('M') ||
+                  *p == C ('H') || *p == C ('M') || *p == C ('S') ||
+                  *p == C ('T'))
+                break;
+            }
+
+            return p - s;
+          }
+        }
+
+        template <typename C>
+        duration duration_pimpl<C>::
+        post_duration ()
+        {
+          typedef typename ro_string<C>::size_type size_type;
+
+          ro_string<C> tmp (str_);
+          size_type size (trim_right (tmp));
+
+          bool negative (false);
+          unsigned int years (0), months (0), days (0), hours (0), minutes (0);
+          double seconds (0.0);
+
+          // duration := [-]P[nY][nM][nD][TnHnMn[.n+]S]
+          //
+          const C* s (tmp.data ());
+
+          if (size >= 3)
+          {
+            size_type pos (0);
+
+            if (s[0] == C ('-'))
+            {
+              negative = true;
+              pos++;
+            }
+
+            pos++; // Skip 'P'.
+
+            size_type del (bits::duration_delim (s, pos, size));
+
+            if (del != size && s[del] == C ('Y'))
+            {
+              ro_string<C> fragment (s + pos, del - pos);
+              zc_istream<C> is (fragment);
+              is >> years;
+
+              pos = del + 1;
+              del = bits::duration_delim (s, pos, size);
+            }
+
+            if (del != size && s[del] == C ('M'))
+            {
+              ro_string<C> fragment (s + pos, del - pos);
+              zc_istream<C> is (fragment);
+              is >> months;
+
+              pos = del + 1;
+              del = bits::duration_delim (s, pos, size);
+            }
+
+            if (del != size && s[del] == C ('D'))
+            {
+              ro_string<C> fragment (s + pos, del - pos);
+              zc_istream<C> is (fragment);
+              is >> days;
+
+              pos = del + 1;
+              del = bits::duration_delim (s, pos, size);
+            }
+
+            if (del != size && s[del] == C ('T'))
+            {
+              pos = del + 1;
+              del = bits::duration_delim (s, pos, size);
+
+              if (del != size && s[del] == C ('H'))
+              {
+                ro_string<C> fragment (s + pos, del - pos);
+                zc_istream<C> is (fragment);
+                is >> hours;
+
+                pos = del + 1;
+                del = bits::duration_delim (s, pos, size);
+              }
+
+              if (del != size && s[del] == C ('M'))
+              {
+                ro_string<C> fragment (s + pos, del - pos);
+                zc_istream<C> is (fragment);
+                is >> minutes;
+
+                pos = del + 1;
+                del = bits::duration_delim (s, pos, size);
+              }
+
+              if (del != size && s[del] == C ('S'))
+              {
+                ro_string<C> fragment (s + pos, del - pos);
+                zc_istream<C> is (fragment);
+                is >> seconds;
+              }
+            }
+          }
+
+          return duration (
+            negative, years, months, days, hours, minutes, seconds);
+        }
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/parser/non-validating/xml-schema-pskel.hxx src/base/include/xsd/cxx/parser/non-validating/xml-schema-pskel.hxx
new file mode 100644
index 0000000..8e4972a
--- /dev/null
+++ src/base/include/xsd/cxx/parser/non-validating/xml-schema-pskel.hxx
@@ -0,0 +1,647 @@
+// file      : xsd/cxx/parser/non-validating/xml-schema-pskel.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_PARSER_NON_VALIDATING_XML_SCHEMA_PSKEL_HXX
+#define XSD_CXX_PARSER_NON_VALIDATING_XML_SCHEMA_PSKEL_HXX
+
+#include <string>
+#include <memory> // auto_ptr
+
+#include <xsd/cxx/parser/xml-schema.hxx>
+#include <xsd/cxx/parser/non-validating/parser.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      namespace non_validating
+      {
+        // anyType and anySimpleType. All events are routed to the
+        // _any_* callbacks.
+        //
+        template <typename C>
+        struct any_type_pskel: complex_content<C>
+        {
+          virtual bool
+          _start_element_impl (const ro_string<C>&,
+                               const ro_string<C>&,
+                               const ro_string<C>*);
+
+          virtual bool
+          _end_element_impl (const ro_string<C>&,
+                             const ro_string<C>&);
+
+          virtual bool
+          _attribute_impl (const ro_string<C>&,
+                           const ro_string<C>&,
+                           const ro_string<C>&);
+
+          virtual bool
+          _characters_impl (const ro_string<C>&);
+
+          virtual void
+          post_any_type () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct any_simple_type_pskel: simple_content<C>
+        {
+          virtual bool
+          _characters_impl (const ro_string<C>&);
+
+          virtual void
+          post_any_simple_type () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+
+        // Boolean.
+        //
+        template <typename C>
+        struct boolean_pskel: simple_content<C>
+        {
+          virtual bool
+          post_boolean () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+
+        // 8-bit
+        //
+        template <typename C>
+        struct byte_pskel: simple_content<C>
+        {
+          virtual signed char
+          post_byte () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct unsigned_byte_pskel: simple_content<C>
+        {
+          virtual unsigned char
+          post_unsigned_byte () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+
+        // 16-bit
+        //
+        template <typename C>
+        struct short_pskel: simple_content<C>
+        {
+          virtual short
+          post_short () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct unsigned_short_pskel: simple_content<C>
+        {
+          virtual unsigned short
+          post_unsigned_short () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+
+        // 32-bit
+        //
+        template <typename C>
+        struct int_pskel: simple_content<C>
+        {
+          virtual int
+          post_int () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct unsigned_int_pskel: simple_content<C>
+        {
+          virtual unsigned int
+          post_unsigned_int () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+
+        // 64-bit
+        //
+        template <typename C>
+        struct long_pskel: simple_content<C>
+        {
+          virtual long long
+          post_long () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct unsigned_long_pskel: simple_content<C>
+        {
+          virtual unsigned long long
+          post_unsigned_long () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+
+        // Arbitrary-length integers.
+        //
+        template <typename C>
+        struct integer_pskel: simple_content<C>
+        {
+          virtual long long
+          post_integer () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct negative_integer_pskel: simple_content<C>
+        {
+          virtual long long
+          post_negative_integer () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct non_positive_integer_pskel: simple_content<C>
+        {
+          virtual long long
+          post_non_positive_integer () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct positive_integer_pskel: simple_content<C>
+        {
+          virtual unsigned long long
+          post_positive_integer () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct non_negative_integer_pskel: simple_content<C>
+        {
+          virtual unsigned long long
+          post_non_negative_integer () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+
+        // Floats.
+        //
+        template <typename C>
+        struct float_pskel: simple_content<C>
+        {
+          virtual float
+          post_float () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct double_pskel: simple_content<C>
+        {
+          virtual double
+          post_double () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct decimal_pskel: simple_content<C>
+        {
+          virtual double
+          post_decimal () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+
+        // Strings.
+        //
+        template <typename C>
+        struct string_pskel: simple_content<C>
+        {
+          virtual std::basic_string<C>
+          post_string () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct normalized_string_pskel: simple_content<C>
+        {
+          virtual std::basic_string<C>
+          post_normalized_string () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct token_pskel: simple_content<C>
+        {
+          virtual std::basic_string<C>
+          post_token () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct name_pskel: simple_content<C>
+        {
+          virtual std::basic_string<C>
+          post_name () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct nmtoken_pskel: simple_content<C>
+        {
+          virtual std::basic_string<C>
+          post_nmtoken () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct nmtokens_pskel: list_base<C>
+        {
+          virtual string_sequence<C>
+          post_nmtokens () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct ncname_pskel: simple_content<C>
+        {
+          virtual std::basic_string<C>
+          post_ncname () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct id_pskel: simple_content<C>
+        {
+          virtual std::basic_string<C>
+          post_id () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct idref_pskel: simple_content<C>
+        {
+          virtual std::basic_string<C>
+          post_idref () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct idrefs_pskel: list_base<C>
+        {
+          virtual string_sequence<C>
+          post_idrefs () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        // Language.
+        //
+        template <typename C>
+        struct language_pskel: simple_content<C>
+        {
+          virtual std::basic_string<C>
+          post_language () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        // URI.
+        //
+        template <typename C>
+        struct uri_pskel: simple_content<C>
+        {
+          virtual std::basic_string<C>
+          post_uri () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        // QName.
+        //
+        template <typename C>
+        struct qname_pskel: simple_content<C>
+        {
+          virtual qname<C>
+          post_qname () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        // Base64 and hex binaries.
+        //
+        template <typename C>
+        struct base64_binary_pskel: simple_content<C>
+        {
+          virtual std::auto_ptr<buffer>
+          post_base64_binary () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct hex_binary_pskel: simple_content<C>
+        {
+          virtual std::auto_ptr<buffer>
+          post_hex_binary () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        // Time and date types.
+        //
+        template <typename C>
+        struct gday_pskel: simple_content<C>
+        {
+          virtual gday
+          post_gday () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct gmonth_pskel: simple_content<C>
+        {
+          virtual gmonth
+          post_gmonth () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct gyear_pskel: simple_content<C>
+        {
+          virtual gyear
+          post_gyear () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct gmonth_day_pskel: simple_content<C>
+        {
+          virtual gmonth_day
+          post_gmonth_day () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct gyear_month_pskel: simple_content<C>
+        {
+          virtual gyear_month
+          post_gyear_month () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct date_pskel: simple_content<C>
+        {
+          virtual date
+          post_date () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct time_pskel: simple_content<C>
+        {
+          virtual time
+          post_time () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct date_time_pskel: simple_content<C>
+        {
+          virtual date_time
+          post_date_time () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct duration_pskel: simple_content<C>
+        {
+          virtual duration
+          post_duration () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+      }
+    }
+  }
+}
+
+#include <xsd/cxx/parser/non-validating/xml-schema-pskel.txx>
+
+#endif  // XSD_CXX_PARSER_NON_VALIDATING_XML_SCHEMA_PSKEL_HXX
+
+#include <xsd/cxx/parser/non-validating/xml-schema-pskel.ixx>
diff --git src/base/include/xsd/cxx/parser/non-validating/xml-schema-pskel.ixx src/base/include/xsd/cxx/parser/non-validating/xml-schema-pskel.ixx
new file mode 100644
index 0000000..13b1fab
--- /dev/null
+++ src/base/include/xsd/cxx/parser/non-validating/xml-schema-pskel.ixx
@@ -0,0 +1,1249 @@
+// file      : xsd/cxx/parser/non-validating/xml-schema-pskel.ixx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#if defined(XSD_CXX_PARSER_USE_CHAR) || !defined(XSD_CXX_PARSER_USE_WCHAR)
+
+#ifndef XSD_CXX_PARSER_NON_VALIDATING_XML_SCHEMA_PSKEL_IXX_CHAR
+#define XSD_CXX_PARSER_NON_VALIDATING_XML_SCHEMA_PSKEL_IXX_CHAR
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      namespace non_validating
+      {
+        template<>
+        inline const char* any_type_pskel<char>::
+        _static_type ()
+        {
+          return "anyType http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* any_type_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* any_simple_type_pskel<char>::
+        _static_type ()
+        {
+          return "anySimpleType http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* any_simple_type_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* boolean_pskel<char>::
+        _static_type ()
+        {
+          return "boolean http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* boolean_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* byte_pskel<char>::
+        _static_type ()
+        {
+          return "byte http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* byte_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* unsigned_byte_pskel<char>::
+        _static_type ()
+        {
+          return "unsignedByte http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* unsigned_byte_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* short_pskel<char>::
+        _static_type ()
+        {
+          return "short http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* short_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* unsigned_short_pskel<char>::
+        _static_type ()
+        {
+          return "unsignedShort http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* unsigned_short_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* int_pskel<char>::
+        _static_type ()
+        {
+          return "int http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* int_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* unsigned_int_pskel<char>::
+        _static_type ()
+        {
+          return "unsignedInt http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* unsigned_int_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* long_pskel<char>::
+        _static_type ()
+        {
+          return "long http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* long_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* unsigned_long_pskel<char>::
+        _static_type ()
+        {
+          return "unsignedLong http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* unsigned_long_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* integer_pskel<char>::
+        _static_type ()
+        {
+          return "integer http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* integer_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* negative_integer_pskel<char>::
+        _static_type ()
+        {
+          return "negativeInteger http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* negative_integer_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* non_positive_integer_pskel<char>::
+        _static_type ()
+        {
+          return "nonPositiveInteger http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* non_positive_integer_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* positive_integer_pskel<char>::
+        _static_type ()
+        {
+          return "positiveInteger http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* positive_integer_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* non_negative_integer_pskel<char>::
+        _static_type ()
+        {
+          return "nonNegativeInteger http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* non_negative_integer_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* float_pskel<char>::
+        _static_type ()
+        {
+          return "float http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* float_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* double_pskel<char>::
+        _static_type ()
+        {
+          return "double http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* double_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* decimal_pskel<char>::
+        _static_type ()
+        {
+          return "decimal http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* decimal_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* string_pskel<char>::
+        _static_type ()
+        {
+          return "string http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* string_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* normalized_string_pskel<char>::
+        _static_type ()
+        {
+          return "normalizedString http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* normalized_string_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* token_pskel<char>::
+        _static_type ()
+        {
+          return "token http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* token_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* name_pskel<char>::
+        _static_type ()
+        {
+          return "Name http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* name_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* nmtoken_pskel<char>::
+        _static_type ()
+        {
+          return "NMTOKEN http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* nmtoken_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* nmtokens_pskel<char>::
+        _static_type ()
+        {
+          return "NMTOKENS http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* nmtokens_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* ncname_pskel<char>::
+        _static_type ()
+        {
+          return "NCName http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* ncname_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* id_pskel<char>::
+        _static_type ()
+        {
+          return "ID http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* id_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* idref_pskel<char>::
+        _static_type ()
+        {
+          return "IDREF http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* idref_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* idrefs_pskel<char>::
+        _static_type ()
+        {
+          return "IDREFS http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* idrefs_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* language_pskel<char>::
+        _static_type ()
+        {
+          return "language http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* language_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* uri_pskel<char>::
+        _static_type ()
+        {
+          return "anyURI http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* uri_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* qname_pskel<char>::
+        _static_type ()
+        {
+          return "QName http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* qname_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* base64_binary_pskel<char>::
+        _static_type ()
+        {
+          return "base64Binary http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* base64_binary_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* hex_binary_pskel<char>::
+        _static_type ()
+        {
+          return "hexBinary http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* hex_binary_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* gday_pskel<char>::
+        _static_type ()
+        {
+          return "gDay http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* gday_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* gmonth_pskel<char>::
+        _static_type ()
+        {
+          return "gMonth http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* gmonth_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* gyear_pskel<char>::
+        _static_type ()
+        {
+          return "gYear http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* gyear_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* gmonth_day_pskel<char>::
+        _static_type ()
+        {
+          return "gMonthDay http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* gmonth_day_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* gyear_month_pskel<char>::
+        _static_type ()
+        {
+          return "gYearMonth http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* gyear_month_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* date_pskel<char>::
+        _static_type ()
+        {
+          return "date http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* date_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* time_pskel<char>::
+        _static_type ()
+        {
+          return "time http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* time_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* date_time_pskel<char>::
+        _static_type ()
+        {
+          return "dateTime http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* date_time_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* duration_pskel<char>::
+        _static_type ()
+        {
+          return "duration http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* duration_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+      }
+    }
+  }
+}
+
+#endif // XSD_CXX_PARSER_NON_VALIDATING_XML_SCHEMA_PSKEL_IXX_CHAR
+#endif // XSD_CXX_PARSER_USE_CHAR
+
+
+#if defined(XSD_CXX_PARSER_USE_WCHAR) || !defined(XSD_CXX_PARSER_USE_CHAR)
+
+#ifndef XSD_CXX_PARSER_NON_VALIDATING_XML_SCHEMA_PSKEL_IXX_WCHAR
+#define XSD_CXX_PARSER_NON_VALIDATING_XML_SCHEMA_PSKEL_IXX_WCHAR
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      namespace non_validating
+      {
+        template<>
+        inline const wchar_t* any_type_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"anyType http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* any_type_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* any_simple_type_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"anySimpleType http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* any_simple_type_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* boolean_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"boolean http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* boolean_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* byte_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"byte http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* byte_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* unsigned_byte_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"unsignedByte http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* unsigned_byte_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* short_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"short http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* short_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* unsigned_short_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"unsignedShort http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* unsigned_short_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* int_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"int http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* int_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* unsigned_int_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"unsignedInt http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* unsigned_int_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* long_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"long http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* long_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* unsigned_long_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"unsignedLong http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* unsigned_long_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* integer_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"integer http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* integer_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* negative_integer_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"negativeInteger http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* negative_integer_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* non_positive_integer_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"nonPositiveInteger http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* non_positive_integer_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* positive_integer_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"positiveInteger http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* positive_integer_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* non_negative_integer_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"nonNegativeInteger http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* non_negative_integer_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* float_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"float http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* float_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* double_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"double http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* double_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* decimal_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"decimal http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* decimal_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* string_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"string http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* string_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* normalized_string_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"normalizedString http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* normalized_string_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* token_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"token http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* token_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* name_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"Name http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* name_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* nmtoken_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"NMTOKEN http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* nmtoken_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* nmtokens_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"NMTOKENS http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* nmtokens_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* ncname_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"NCName http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* ncname_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* id_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"ID http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* id_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* idref_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"IDREF http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* idref_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* idrefs_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"IDREFS http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* idrefs_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* language_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"language http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* language_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* uri_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"anyURI http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* uri_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* qname_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"QName http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* qname_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* base64_binary_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"base64Binary http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* base64_binary_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* hex_binary_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"hexBinary http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* hex_binary_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* gday_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"gDay http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* gday_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* gmonth_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"gMonth http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* gmonth_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* gyear_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"gYear http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* gyear_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* gmonth_day_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"gMonthDay http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* gmonth_day_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* gyear_month_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"gYearMonth http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* gyear_month_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* date_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"date http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* date_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* time_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"time http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* time_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* date_time_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"dateTime http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* date_time_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* duration_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"duration http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* duration_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+      }
+    }
+  }
+}
+
+#endif // XSD_CXX_PARSER_NON_VALIDATING_XML_SCHEMA_PSKEL_IXX_WCHAR
+#endif // XSD_CXX_PARSER_USE_WCHAR
diff --git src/base/include/xsd/cxx/parser/non-validating/xml-schema-pskel.txx src/base/include/xsd/cxx/parser/non-validating/xml-schema-pskel.txx
new file mode 100644
index 0000000..b6352df
--- /dev/null
+++ src/base/include/xsd/cxx/parser/non-validating/xml-schema-pskel.txx
@@ -0,0 +1,69 @@
+// file      : xsd/cxx/parser/non-validating/xml-schema-pskel.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      namespace non_validating
+      {
+        // any_type
+        //
+
+        template <typename C>
+        bool any_type_pskel<C>::
+        _start_element_impl (const ro_string<C>& ns,
+                             const ro_string<C>& name,
+                             const ro_string<C>* type)
+        {
+          this->_start_any_element (ns, name, type);
+          this->complex_content<C>::context_.top ().any_ = true;
+          return true;
+        }
+
+        template <typename C>
+        bool any_type_pskel<C>::
+        _end_element_impl (const ro_string<C>& ns, const ro_string<C>& name)
+        {
+          this->complex_content<C>::context_.top ().any_ = false;
+          this->_end_any_element (ns, name);
+          return true;
+        }
+
+
+        template <typename C>
+        bool any_type_pskel<C>::
+        _attribute_impl (const ro_string<C>& ns,
+                         const ro_string<C>& name,
+                         const ro_string<C>& value)
+        {
+          this->_any_attribute (ns, name, value);
+          return true;
+        }
+
+        template <typename C>
+        bool any_type_pskel<C>::
+        _characters_impl (const ro_string<C>& s)
+        {
+          this->_any_characters (s);
+          return true;
+        }
+
+        // any_simple_type
+        //
+
+        template <typename C>
+        bool any_simple_type_pskel<C>::
+        _characters_impl (const ro_string<C>& s)
+        {
+          this->_any_characters (s);
+          return true;
+        }
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/parser/schema-exceptions.hxx src/base/include/xsd/cxx/parser/schema-exceptions.hxx
new file mode 100644
index 0000000..9af39d7
--- /dev/null
+++ src/base/include/xsd/cxx/parser/schema-exceptions.hxx
@@ -0,0 +1,187 @@
+// file      : xsd/cxx/parser/schema-exceptions.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_PARSER_SCHEMA_EXCEPTIONS_HXX
+#define XSD_CXX_PARSER_SCHEMA_EXCEPTIONS_HXX
+
+#include <string>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      template <typename C>
+      struct schema_exception
+      {
+      public:
+        virtual
+        ~schema_exception ()
+        {
+        }
+
+        unsigned long
+        line () const
+        {
+          return line_;
+        }
+
+        void
+        line (unsigned long l)
+        {
+          line_ = l;
+        }
+
+        unsigned long
+        column () const
+        {
+          return column_;
+        }
+
+        void
+        column (unsigned long c)
+        {
+          column_ = c;
+        }
+
+        const std::basic_string<C>&
+        id () const
+        {
+          return id_;
+        }
+
+        void
+        id (const std::basic_string<C>& id)
+        {
+          id_ = id;
+        }
+
+        virtual std::basic_string<C>
+        message () const = 0;
+
+      protected:
+        unsigned long line_;
+        unsigned long column_;
+        std::basic_string<C> id_;
+      };
+
+      //
+      //
+      template <typename C>
+      struct expected_element: schema_exception<C>
+      {
+        virtual
+        ~expected_element ();
+
+        expected_element (const std::basic_string<C>& expected_namespace,
+                          const std::basic_string<C>& expected_name);
+
+        expected_element (const std::basic_string<C>& expected_namespace,
+                          const std::basic_string<C>& expected_name,
+                          const std::basic_string<C>& encountered_namespace,
+                          const std::basic_string<C>& encountered_name);
+
+        const std::basic_string<C>&
+        expected_namespace () const
+        {
+          return expected_namespace_;
+        }
+
+        const std::basic_string<C>&
+        expected_name () const
+        {
+          return expected_name_;
+        }
+
+        // Encountered element namespace and name are empty if none
+        // encountered.
+        //
+        const std::basic_string<C>&
+        encountered_namespace () const
+        {
+          return encountered_namespace_;
+        }
+
+        const std::basic_string<C>&
+        encountered_name () const
+        {
+          return encountered_name_;
+        }
+
+        virtual std::basic_string<C>
+        message () const;
+
+      private:
+        std::basic_string<C> expected_namespace_;
+        std::basic_string<C> expected_name_;
+
+        std::basic_string<C> encountered_namespace_;
+        std::basic_string<C> encountered_name_;
+      };
+
+
+      //
+      //
+      template <typename C>
+      struct unexpected_element: schema_exception<C>
+      {
+        virtual
+        ~unexpected_element ();
+
+        unexpected_element (const std::basic_string<C>& encountered_namespace,
+                            const std::basic_string<C>& encountered_name);
+
+        const std::basic_string<C>&
+        encountered_namespace () const
+        {
+          return encountered_namespace_;
+        }
+
+        const std::basic_string<C>&
+        encountered_name () const
+        {
+          return encountered_name_;
+        }
+
+        virtual std::basic_string<C>
+        message () const;
+
+      private:
+        std::basic_string<C> encountered_namespace_;
+        std::basic_string<C> encountered_name_;
+      };
+
+      //
+      //
+      template <typename C>
+      struct dynamic_type: schema_exception<C>
+      {
+        virtual
+        ~dynamic_type () throw ();
+
+        dynamic_type (const std::basic_string<C>& type);
+
+        const std::basic_string<C>&
+        type () const
+        {
+          return type_;
+        }
+
+        virtual std::basic_string<C>
+        message () const;
+
+      private:
+        std::basic_string<C> type_;
+      };
+    }
+  }
+}
+
+#include <xsd/cxx/parser/schema-exceptions.txx>
+
+#endif  // XSD_CXX_PARSER_SCHEMA_EXCEPTIONS_HXX
+
+#include <xsd/cxx/parser/schema-exceptions.ixx>
diff --git src/base/include/xsd/cxx/parser/schema-exceptions.ixx src/base/include/xsd/cxx/parser/schema-exceptions.ixx
new file mode 100644
index 0000000..cfd2d18
--- /dev/null
+++ src/base/include/xsd/cxx/parser/schema-exceptions.ixx
@@ -0,0 +1,145 @@
+// file      : xsd/cxx/parser/schema-exceptions.ixx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#if defined(XSD_CXX_PARSER_USE_CHAR) || !defined(XSD_CXX_PARSER_USE_WCHAR)
+
+#ifndef XSD_CXX_PARSER_SCHEMA_EXCEPTIONS_IXX_CHAR
+#define XSD_CXX_PARSER_SCHEMA_EXCEPTIONS_IXX_CHAR
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      // expected_element
+      //
+      template<>
+      inline
+      std::basic_string<char> expected_element<char>::
+      message () const
+      {
+        std::basic_string<char> r ("expected element '");
+        r += expected_namespace_;
+        r += expected_namespace_.empty () ? "" : "#";
+        r += expected_name_;
+        r += "'";
+
+        if (!encountered_name_.empty ())
+        {
+          r += " instead of '";
+          r +=  encountered_namespace_;
+          r +=  encountered_namespace_.empty () ? "" : "#";
+          r +=  encountered_name_;
+          r += "'";
+        }
+
+        return r;
+      }
+
+      // unexpected_element
+      //
+      template<>
+      inline
+      std::basic_string<char> unexpected_element<char>::
+      message () const
+      {
+        std::basic_string<char> r ("unexpected element '");
+        r += encountered_namespace_;
+        r += encountered_namespace_.empty () ? "" : "#";
+        r += encountered_name_;
+        r += "'";
+        return r;
+      }
+
+      // dynamic_type
+      //
+      template<>
+      inline
+      std::basic_string<char> dynamic_type<char>::
+      message () const
+      {
+        std::basic_string<char> r ("invalid xsi:type '");
+        r += type_;
+        r += "'";
+        return r;
+      }
+    }
+  }
+}
+
+#endif // XSD_CXX_PARSER_SCHEMA_EXCEPTIONS_IXX_CHAR
+#endif // XSD_CXX_PARSER_USE_CHAR
+
+
+#if defined(XSD_CXX_PARSER_USE_WCHAR) || !defined(XSD_CXX_PARSER_USE_CHAR)
+
+#ifndef XSD_CXX_PARSER_SCHEMA_EXCEPTIONS_IXX_WCHAR
+#define XSD_CXX_PARSER_SCHEMA_EXCEPTIONS_IXX_WCHAR
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      // expected_element
+      //
+      template<>
+      inline
+      std::basic_string<wchar_t> expected_element<wchar_t>::
+      message () const
+      {
+        std::basic_string<wchar_t> r (L"expected element '");
+        r += expected_namespace_;
+        r += expected_namespace_.empty () ? L"" : L"#";
+        r += expected_name_;
+        r += L"'";
+
+        if (!encountered_name_.empty ())
+        {
+          r += L" instead of '";
+          r +=  encountered_namespace_;
+          r +=  encountered_namespace_.empty () ? L"" : L"#";
+          r +=  encountered_name_;
+          r += L"'";
+        }
+
+        return r;
+      }
+
+      // unexpected_element
+      //
+      template<>
+      inline
+      std::basic_string<wchar_t> unexpected_element<wchar_t>::
+      message () const
+      {
+        std::basic_string<wchar_t> r (L"unexpected element '");
+        r += encountered_namespace_;
+        r += encountered_namespace_.empty () ? L"" : L"#";
+        r += encountered_name_;
+        r += L"'";
+        return r;
+      }
+
+      // dynamic_type
+      //
+      template<>
+      inline
+      std::basic_string<wchar_t> dynamic_type<wchar_t>::
+      message () const
+      {
+        std::basic_string<wchar_t> r (L"invalid xsi:type '");
+        r += type_;
+        r += L"'";
+        return r;
+      }
+    }
+  }
+}
+
+#endif // XSD_CXX_PARSER_SCHEMA_EXCEPTIONS_IXX_WCHAR
+#endif // XSD_CXX_PARSER_USE_WCHAR
diff --git src/base/include/xsd/cxx/parser/schema-exceptions.txx src/base/include/xsd/cxx/parser/schema-exceptions.txx
new file mode 100644
index 0000000..7ac45ae
--- /dev/null
+++ src/base/include/xsd/cxx/parser/schema-exceptions.txx
@@ -0,0 +1,75 @@
+// file      : xsd/cxx/parser/schema-exceptions.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      // expected_element
+      //
+      template <typename C>
+      expected_element<C>::
+      ~expected_element ()
+      {
+      }
+
+      template <typename C>
+      expected_element<C>::
+      expected_element (const std::basic_string<C>& expected_namespace,
+                        const std::basic_string<C>& expected_name)
+          : expected_namespace_ (expected_namespace),
+            expected_name_ (expected_name)
+      {
+      }
+
+      template <typename C>
+      expected_element<C>::
+      expected_element (const std::basic_string<C>& expected_namespace,
+                        const std::basic_string<C>& expected_name,
+                        const std::basic_string<C>& encountered_namespace,
+                        const std::basic_string<C>& encountered_name)
+          : expected_namespace_ (expected_namespace),
+            expected_name_ (expected_name),
+            encountered_namespace_ (encountered_namespace),
+            encountered_name_ (encountered_name)
+      {
+      }
+
+      // unexpected_element
+      //
+      template <typename C>
+      unexpected_element<C>::
+      ~unexpected_element ()
+      {
+      }
+
+      template <typename C>
+      unexpected_element<C>::
+      unexpected_element (const std::basic_string<C>& encountered_namespace,
+                          const std::basic_string<C>& encountered_name)
+          : encountered_namespace_ (encountered_namespace),
+            encountered_name_ (encountered_name)
+      {
+      }
+
+      // dynamic_type
+      //
+      template <typename C>
+      dynamic_type<C>::
+      ~dynamic_type () throw ()
+      {
+      }
+
+      template <typename C>
+      dynamic_type<C>::
+      dynamic_type (const std::basic_string<C>& type)
+          : type_ (type)
+      {
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/parser/substitution-map.hxx src/base/include/xsd/cxx/parser/substitution-map.hxx
new file mode 100644
index 0000000..416d1ec
--- /dev/null
+++ src/base/include/xsd/cxx/parser/substitution-map.hxx
@@ -0,0 +1,241 @@
+// file      : xsd/cxx/parser/substitution-map.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_PARSER_SUBSTITUTION_MAP_HXX
+#define XSD_CXX_PARSER_SUBSTITUTION_MAP_HXX
+
+#include <map>
+#include <cstddef> // std::size_t
+
+#include <xsd/cxx/ro-string.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      template <typename C>
+      struct substitution_map_key
+      {
+        substitution_map_key (const C* ns, const C* name)
+            : ns_ (ns), name_ (name)
+        {
+        }
+
+        substitution_map_key (const ro_string<C>& ns,
+                              const ro_string<C>& name)
+            : ns_ (ns.data (), ns.size ()),
+              name_ (name.data (), name.size ())
+        {
+        }
+
+        substitution_map_key (const substitution_map_key& x)
+            : ns_ (x.ns_.data (), x.ns_.size ()),
+              name_ (x.name_.data (), x.name_.size ())
+        {
+        }
+
+      private:
+        substitution_map_key&
+        operator= (const substitution_map_key&);
+
+      public:
+        const ro_string<C>&
+        ns () const
+        {
+          return ns_;
+        }
+
+        const ro_string<C>&
+        name () const
+        {
+          return name_;
+        }
+
+      private:
+        const ro_string<C> ns_;
+        const ro_string<C> name_;
+      };
+
+      template <typename C>
+      inline bool
+      operator< (const substitution_map_key<C>& x,
+                 const substitution_map_key<C>& y)
+      {
+        int r (x.name ().compare (y.name ()));
+        return r < 0 || (r == 0 && x.ns () < y.ns ());
+      }
+
+      template <typename C>
+      struct substitution_map_value
+      {
+        substitution_map_value (const C* ns, const C* name, const C* type)
+            : ns_ (ns), name_ (name), type_ (type)
+        {
+        }
+
+        substitution_map_value (const substitution_map_value& x)
+            : ns_ (x.ns_.data (), x.ns_.size ()),
+              name_ (x.name_.data (), x.name_.size ()),
+              type_ (x.type_.data (), x.type_.size ())
+        {
+        }
+
+        substitution_map_value&
+        operator= (const substitution_map_value& x)
+        {
+          if (this != &x)
+          {
+            ns_.assign (x.ns_.data (), x.ns_.size ());
+            name_.assign (x.name_.data (), x.name_.size ());
+            type_.assign (x.type_.data (), x.type_.size ());
+          }
+
+          return *this;
+        }
+
+      public:
+        const ro_string<C>&
+        ns () const
+        {
+          return ns_;
+        }
+
+        const ro_string<C>&
+        name () const
+        {
+          return name_;
+        }
+
+        const ro_string<C>&
+        type () const
+        {
+          return type_;
+        }
+
+      private:
+        ro_string<C> ns_;
+        ro_string<C> name_;
+        ro_string<C> type_;
+      };
+
+      template <typename C>
+      struct substitution_map
+      {
+        void
+        insert (const C* member_ns,
+                const C* member_name,
+                const C* root_ns,
+                const C* root_name,
+                const C* member_type)
+        {
+          key k (member_ns, member_name);
+          value v (root_ns, root_name, member_type);
+          map_.insert (std::pair<key, value> (k, v));
+        }
+
+        void
+        erase (const C* member_ns, const C* member_name)
+        {
+          map_.erase (key (member_ns, member_name));
+        }
+
+        // Check and get the type set if found.
+        //
+        bool
+        check (const ro_string<C>& ns,
+               const ro_string<C>& name,
+               const C* root_ns,
+               const C* root_name,
+               const ro_string<C>*& type) const
+        {
+
+          return map_.empty ()
+            ? false
+            : check_ (ns, name, root_ns, root_name, &type);
+        }
+
+        // Check but don't care about the type.
+        //
+        bool
+        check (const ro_string<C>& ns,
+               const ro_string<C>& name,
+               const C* root_ns,
+               const C* root_name) const
+        {
+
+          return map_.empty ()
+            ? false
+            : check_ (ns, name, root_ns, root_name, 0);
+        }
+
+      private:
+        bool
+        check_ (const ro_string<C>& ns,
+                const ro_string<C>& name,
+                const C* root_ns,
+                const C* root_name,
+                const ro_string<C>** type) const;
+
+      private:
+        typedef substitution_map_key<C> key;
+        typedef substitution_map_value<C> value;
+        typedef std::map<key, value> map;
+
+        map map_;
+      };
+
+
+      // Translation unit initializer.
+      //
+      template<typename C>
+      struct substitution_map_init
+      {
+        static substitution_map<C>* map;
+        static std::size_t count;
+
+        substitution_map_init ();
+        ~substitution_map_init ();
+      };
+
+      template<typename C>
+      substitution_map<C>* substitution_map_init<C>::map = 0;
+
+      template<typename C>
+      std::size_t substitution_map_init<C>::count = 0;
+
+      template<typename C>
+      inline substitution_map<C>&
+      substitution_map_instance ()
+      {
+        return *substitution_map_init<C>::map;
+      }
+
+
+      // Map entry initializer.
+      //
+      template<typename C>
+      struct substitution_map_entry
+      {
+        substitution_map_entry (const C* member_ns,
+                                const C* member_name,
+                                const C* root_ns,
+                                const C* root_name,
+                                const C* member_type);
+
+        ~substitution_map_entry ();
+
+      private:
+        const C* member_ns_;
+        const C* member_name_;
+      };
+    }
+  }
+}
+
+#include <xsd/cxx/parser/substitution-map.txx>
+
+#endif  // XSD_CXX_PARSER_SUBSTITUTION_MAP_HXX
diff --git src/base/include/xsd/cxx/parser/substitution-map.txx src/base/include/xsd/cxx/parser/substitution-map.txx
new file mode 100644
index 0000000..dad0ec6
--- /dev/null
+++ src/base/include/xsd/cxx/parser/substitution-map.txx
@@ -0,0 +1,84 @@
+// file      : xsd/cxx/parser/substitution-map.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      template <typename C>
+      bool substitution_map<C>::
+      check_ (const ro_string<C>& ns,
+              const ro_string<C>& name,
+              const C* root_ns,
+              const C* root_name,
+              const ro_string<C>** type) const
+      {
+        key k (ns, name);
+        typename map::const_iterator i (map_.find (k));
+
+        if (i == map_.end ())
+          return false;
+
+        const value& v (i->second);
+
+        bool r (false);
+
+        if (v.name () == root_name && v.ns () == root_ns)
+          r = true;
+        else
+          r = check_ (v.ns (), v.name (), root_ns, root_name, 0);
+
+        if (r && type != 0 && *type == 0)
+          *type = &v.type ();
+
+        return r;
+      }
+
+      // substitution_map_init
+      //
+      template<typename C>
+      substitution_map_init<C>::
+      substitution_map_init ()
+      {
+        if (count == 0)
+          map = new substitution_map<C>;
+
+        ++count;
+      }
+
+      template<typename C>
+      substitution_map_init<C>::
+      ~substitution_map_init ()
+      {
+        if (--count == 0)
+          delete map;
+      }
+
+      // substitution_map_entry
+      //
+      template<typename C>
+      substitution_map_entry<C>::
+      substitution_map_entry (const C* member_ns,
+                              const C* member_name,
+                              const C* root_ns,
+                              const C* root_name,
+                              const C* member_type)
+          : member_ns_ (member_ns), member_name_ (member_name)
+      {
+        substitution_map_instance<C> ().insert (
+          member_ns, member_name, root_ns, root_name, member_type);
+      }
+
+      template<typename C>
+      substitution_map_entry<C>::
+      ~substitution_map_entry ()
+      {
+        substitution_map_instance<C> ().erase (member_ns_, member_name_);
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/parser/validating/exceptions.hxx src/base/include/xsd/cxx/parser/validating/exceptions.hxx
new file mode 100644
index 0000000..c0efda8
--- /dev/null
+++ src/base/include/xsd/cxx/parser/validating/exceptions.hxx
@@ -0,0 +1,153 @@
+// file      : xsd/cxx/parser/validating/exceptions.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_PARSER_VALIDATING_EXCEPTIONS_HXX
+#define XSD_CXX_PARSER_VALIDATING_EXCEPTIONS_HXX
+
+#include <string>
+
+#include <xsd/cxx/parser/schema-exceptions.hxx>
+#include <xsd/cxx/ro-string.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      namespace validating
+      {
+        //
+        //
+        template <typename C>
+        struct expected_attribute: schema_exception<C>
+        {
+          virtual
+          ~expected_attribute ();
+
+          expected_attribute (const std::basic_string<C>& expected_namespace,
+                              const std::basic_string<C>& expected_name);
+
+          const std::basic_string<C>&
+          expected_namespace () const
+          {
+            return expected_namespace_;
+          }
+
+          const std::basic_string<C>&
+          expected_name () const
+          {
+            return expected_name_;
+          }
+
+          virtual std::basic_string<C>
+          message () const;
+
+        private:
+          std::basic_string<C> expected_namespace_;
+          std::basic_string<C> expected_name_;
+        };
+
+        //
+        //
+        template <typename C>
+        struct unexpected_attribute: schema_exception<C>
+        {
+          virtual
+          ~unexpected_attribute ();
+
+          unexpected_attribute (
+            const std::basic_string<C>& encountered_namespace,
+            const std::basic_string<C>& encountered_name);
+
+
+          const std::basic_string<C>&
+          encountered_namespace () const
+          {
+            return encountered_namespace_;
+          }
+
+          const std::basic_string<C>&
+          encountered_name () const
+          {
+            return encountered_name_;
+          }
+
+          virtual std::basic_string<C>
+          message () const;
+
+        private:
+          std::basic_string<C> encountered_namespace_;
+          std::basic_string<C> encountered_name_;
+        };
+
+
+        //
+        //
+        template <typename C>
+        struct unexpected_characters: schema_exception<C>
+        {
+          virtual
+          ~unexpected_characters ();
+
+          unexpected_characters (const std::basic_string<C>& s);
+
+          const std::basic_string<C>&
+          characters () const
+          {
+            return characters_;
+          }
+
+          virtual std::basic_string<C>
+          message () const;
+
+        private:
+          std::basic_string<C> characters_;
+        };
+
+        //
+        //
+        template <typename C>
+        struct invalid_value: schema_exception<C>
+        {
+          virtual
+          ~invalid_value ();
+
+          invalid_value (const C* type, const std::basic_string<C>& value);
+
+          invalid_value (const C* type, const ro_string<C>& value);
+
+          invalid_value (const std::basic_string<C>& type,
+                         const std::basic_string<C>& value);
+
+          const std::basic_string<C>&
+          type () const
+          {
+            return type_;
+          }
+
+          const std::basic_string<C>&
+          value () const
+          {
+            return value_;
+          }
+
+          virtual std::basic_string<C>
+          message () const;
+
+        private:
+          std::basic_string<C> type_;
+          std::basic_string<C> value_;
+        };
+      }
+    }
+  }
+}
+
+#include <xsd/cxx/parser/validating/exceptions.txx>
+
+#endif  // XSD_CXX_PARSER_VALIDATING_EXCEPTIONS_HXX
+
+#include <xsd/cxx/parser/validating/exceptions.ixx>
diff --git src/base/include/xsd/cxx/parser/validating/exceptions.ixx src/base/include/xsd/cxx/parser/validating/exceptions.ixx
new file mode 100644
index 0000000..74bb909
--- /dev/null
+++ src/base/include/xsd/cxx/parser/validating/exceptions.ixx
@@ -0,0 +1,163 @@
+// file      : xsd/cxx/parser/validating/exceptions.ixx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#if defined(XSD_CXX_PARSER_USE_CHAR) || !defined(XSD_CXX_PARSER_USE_WCHAR)
+
+#ifndef XSD_CXX_PARSER_VALIDATING_EXCEPTIONS_IXX_CHAR
+#define XSD_CXX_PARSER_VALIDATING_EXCEPTIONS_IXX_CHAR
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      namespace validating
+      {
+        // expected_attribute
+        //
+        template<>
+        inline
+        std::basic_string<char> expected_attribute<char>::
+        message () const
+        {
+          std::basic_string<char> r ("expected attribute '");
+          r += expected_namespace_;
+          r += expected_namespace_.empty () ? "" : "#";
+          r += expected_name_;
+          r += "'";
+          return r;
+        }
+
+        // unexpected_attribute
+        //
+        template<>
+        inline
+        std::basic_string<char> unexpected_attribute<char>::
+        message () const
+        {
+          std::basic_string<char> r ("unexpected attribute '");
+          r += encountered_namespace_;
+          r += encountered_namespace_.empty () ? "" : "#";
+          r += encountered_name_;
+          r += "'";
+          return r;
+        }
+
+        // unexpected_characters
+        //
+        template<>
+        inline
+        std::basic_string<char> unexpected_characters<char>::
+        message () const
+        {
+          std::basic_string<char> r ("unexpected characters '");
+          r += characters_;
+          r += "'";
+          return r;
+        }
+
+        // invalid_value
+        //
+        template<>
+        inline
+        std::basic_string<char> invalid_value<char>::
+        message () const
+        {
+          std::basic_string<char> r ("'");
+          r += value_;
+          r += "' is not a valid value representation ";
+          r += "for type '";
+          r += type_;
+          r += "'";
+          return r;
+        }
+      }
+    }
+  }
+}
+
+#endif // XSD_CXX_PARSER_VALIDATING_EXCEPTIONS_IXX_CHAR
+#endif // XSD_CXX_PARSER_USE_CHAR
+
+
+#if defined(XSD_CXX_PARSER_USE_WCHAR) || !defined(XSD_CXX_PARSER_USE_CHAR)
+
+#ifndef XSD_CXX_PARSER_VALIDATING_EXCEPTIONS_IXX_WCHAR
+#define XSD_CXX_PARSER_VALIDATING_EXCEPTIONS_IXX_WCHAR
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      namespace validating
+      {
+        // expected_attribute
+        //
+        template<>
+        inline
+        std::basic_string<wchar_t> expected_attribute<wchar_t>::
+        message () const
+        {
+          std::basic_string<wchar_t> r (L"expected attribute '");
+          r += expected_namespace_;
+          r += expected_namespace_.empty () ? L"" : L"#";
+          r += expected_name_;
+          r += L"'";
+          return r;
+        }
+
+        // unexpected_attribute
+        //
+        template<>
+        inline
+        std::basic_string<wchar_t> unexpected_attribute<wchar_t>::
+        message () const
+        {
+          std::basic_string<wchar_t> r (L"unexpected attribute '");
+          r += encountered_namespace_;
+          r += encountered_namespace_.empty () ? L"" : L"#";
+          r += encountered_name_;
+          r += L"'";
+          return r;
+        }
+
+        // unexpected_characters
+        //
+        template<>
+        inline
+        std::basic_string<wchar_t> unexpected_characters<wchar_t>::
+        message () const
+        {
+          std::basic_string<wchar_t> r (L"unexpected characters '");
+          r += characters_;
+          r += L"'";
+          return r;
+        }
+
+        // invalid_value
+        //
+        template<>
+        inline
+        std::basic_string<wchar_t> invalid_value<wchar_t>::
+        message () const
+        {
+          std::basic_string<wchar_t> r (L"'");
+          r += value_;
+          r += L"' is not a valid value representation ";
+          r += L"for type '";
+          r += type_;
+          r += L"'";
+          return r;
+        }
+      }
+    }
+  }
+}
+
+#endif // XSD_CXX_PARSER_VALIDATING_EXCEPTIONS_IXX_WCHAR
+#endif // XSD_CXX_PARSER_USE_WCHAR
diff --git src/base/include/xsd/cxx/parser/validating/exceptions.txx src/base/include/xsd/cxx/parser/validating/exceptions.txx
new file mode 100644
index 0000000..6205215
--- /dev/null
+++ src/base/include/xsd/cxx/parser/validating/exceptions.txx
@@ -0,0 +1,97 @@
+// file      : xsd/cxx/parser/validating/exceptions.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      namespace validating
+      {
+        // expected_attribute
+        //
+        template <typename C>
+        expected_attribute<C>::
+        ~expected_attribute ()
+        {
+        }
+
+        template <typename C>
+        expected_attribute<C>::
+        expected_attribute (const std::basic_string<C>& expected_namespace,
+                            const std::basic_string<C>& expected_name)
+            : expected_namespace_ (expected_namespace),
+              expected_name_ (expected_name)
+        {
+        }
+
+        // unexpected_attribute
+        //
+        template <typename C>
+        unexpected_attribute<C>::
+        ~unexpected_attribute ()
+        {
+        }
+
+        template <typename C>
+        unexpected_attribute<C>::
+        unexpected_attribute (const std::basic_string<C>& encountered_namespace,
+                              const std::basic_string<C>& encountered_name)
+            : encountered_namespace_ (encountered_namespace),
+              encountered_name_ (encountered_name)
+        {
+        }
+
+        // unexpected_characters
+        //
+        template <typename C>
+        unexpected_characters<C>::
+        ~unexpected_characters ()
+        {
+        }
+
+        template <typename C>
+        unexpected_characters<C>::
+        unexpected_characters (const std::basic_string<C>& s)
+            : characters_ (s)
+        {
+        }
+
+        // invalid_value
+        //
+        template <typename C>
+        invalid_value<C>::
+        ~invalid_value ()
+        {
+        }
+
+        template <typename C>
+        invalid_value<C>::
+        invalid_value (const C* type,
+                       const std::basic_string<C>& value)
+            : type_ (type), value_ (value)
+        {
+        }
+
+        template <typename C>
+        invalid_value<C>::
+        invalid_value (const C* type,
+                       const ro_string<C>& value)
+            : type_ (type), value_ (value)
+        {
+        }
+
+        template <typename C>
+        invalid_value<C>::
+        invalid_value (const std::basic_string<C>& type,
+                       const std::basic_string<C>& value)
+            : type_ (type), value_ (value)
+        {
+        }
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/parser/validating/inheritance-map.hxx src/base/include/xsd/cxx/parser/validating/inheritance-map.hxx
new file mode 100644
index 0000000..d9307b4
--- /dev/null
+++ src/base/include/xsd/cxx/parser/validating/inheritance-map.hxx
@@ -0,0 +1,101 @@
+// file      : xsd/cxx/parser/validating/inheritance-map.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_PARSER_VALIDATING_INHERITANCE_MAP_HXX
+#define XSD_CXX_PARSER_VALIDATING_INHERITANCE_MAP_HXX
+
+#include <map>
+#include <cstddef> // std::size_t
+
+#include <xsd/cxx/ro-string.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      namespace validating
+      {
+        template <typename C>
+        struct string_comparison
+        {
+          bool
+          operator() (const C* x, const C* y) const
+          {
+            ro_string<C> s (x);
+            return s.compare (y) < 0;
+          }
+        };
+
+        template <typename C>
+        struct inheritance_map
+        {
+          void
+          insert (const C* derived, const C* base)
+          {
+            map_[derived] = base;
+          }
+
+          void
+          erase (const C* derived)
+          {
+            map_.erase (derived);
+          }
+
+          bool
+          check (const C* derived, const ro_string<C>& base) const;
+
+        private:
+          typedef std::map<const C*, const C*, string_comparison<C> > map;
+          map map_;
+        };
+
+
+        // Translation unit initializer.
+        //
+        template<typename C>
+        struct inheritance_map_init
+        {
+          static inheritance_map<C>* map;
+          static std::size_t count;
+
+          inheritance_map_init ();
+          ~inheritance_map_init ();
+        };
+
+        template<typename C>
+        inheritance_map<C>* inheritance_map_init<C>::map = 0;
+
+        template<typename C>
+        std::size_t inheritance_map_init<C>::count = 0;
+
+        template<typename C>
+        inline inheritance_map<C>&
+        inheritance_map_instance ()
+        {
+          return *inheritance_map_init<C>::map;
+        }
+
+
+        // Map entry initializer.
+        //
+        template<typename C>
+        struct inheritance_map_entry
+        {
+          inheritance_map_entry (const C* derived, const C* base);
+          ~inheritance_map_entry ();
+
+        private:
+          const C* derived_;
+        };
+      }
+    }
+  }
+}
+
+#include <xsd/cxx/parser/validating/inheritance-map.txx>
+
+#endif  // XSD_CXX_PARSER_VALIDATING_INHERITANCE_MAP_HXX
diff --git src/base/include/xsd/cxx/parser/validating/inheritance-map.txx src/base/include/xsd/cxx/parser/validating/inheritance-map.txx
new file mode 100644
index 0000000..1a63e65
--- /dev/null
+++ src/base/include/xsd/cxx/parser/validating/inheritance-map.txx
@@ -0,0 +1,73 @@
+// file      : xsd/cxx/parser/validating/inheritance-map.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      namespace validating
+      {
+        template <typename C>
+        bool inheritance_map<C>::
+        check (const C* derived, const ro_string<C>& base) const
+        {
+          if (base == derived)
+            return true;
+
+          typename map::const_iterator i (map_.find (derived));
+
+          if (i != map_.end ())
+          {
+            if (base == i->second)
+              return true;
+            else
+              return check (i->second, base);
+          }
+
+          return false;
+        }
+
+        // inheritance_map_init
+        //
+        template<typename C>
+        inheritance_map_init<C>::
+        inheritance_map_init ()
+        {
+          if (count == 0)
+            map = new inheritance_map<C>;
+
+          ++count;
+        }
+
+        template<typename C>
+        inheritance_map_init<C>::
+        ~inheritance_map_init ()
+        {
+          if (--count == 0)
+            delete map;
+        }
+
+        // inheritance_map_entry
+        //
+        template<typename C>
+        inheritance_map_entry<C>::
+        inheritance_map_entry (const C* derived, const C* base)
+            : derived_ (derived)
+        {
+          inheritance_map_instance<C> ().insert (derived, base);
+        }
+
+        template<typename C>
+        inheritance_map_entry<C>::
+        ~inheritance_map_entry ()
+        {
+          inheritance_map_instance<C> ().erase (derived_);
+        }
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/parser/validating/parser.hxx src/base/include/xsd/cxx/parser/validating/parser.hxx
new file mode 100644
index 0000000..da297d9
--- /dev/null
+++ src/base/include/xsd/cxx/parser/validating/parser.hxx
@@ -0,0 +1,471 @@
+// file      : xsd/cxx/parser/validating/parser.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_PARSER_VALIDATING_PARSER_HXX
+#define XSD_CXX_PARSER_VALIDATING_PARSER_HXX
+
+#include <stack>
+#include <cstddef> // std::size_t
+#include <cstring> // std::memcpy
+
+#include <xsd/cxx/ro-string.hxx>
+#include <xsd/cxx/parser/elements.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      namespace validating
+      {
+        //
+        //
+        template <typename C>
+        struct empty_content: parser_base<C>
+        {
+          // These functions are called when wildcard content
+          // is encountered. Use them to handle mixed content
+          // models, any/anyAttribute, and anyType/anySimpleType.
+          // By default these functions do nothing.
+          //
+
+          // The type argument is a type name and namespace from the
+          // xsi:type attribute in the form "<name> <namespace>" with
+          // the space and namespace part absent if the type does not
+          // have a namespace or 0 if xsi:type is not present.
+          //
+          virtual void
+          _start_any_element (const ro_string<C>& ns,
+                              const ro_string<C>& name,
+                              const ro_string<C>* type);
+
+          virtual void
+          _end_any_element (const ro_string<C>& ns,
+                            const ro_string<C>& name);
+
+          virtual void
+          _any_attribute (const ro_string<C>& ns,
+                          const ro_string<C>& name,
+                          const ro_string<C>& value);
+
+          virtual void
+          _any_characters (const ro_string<C>&);
+
+
+          //
+          //
+          virtual bool
+          _start_element_impl (const ro_string<C>&,
+                               const ro_string<C>&,
+                               const ro_string<C>*);
+
+          virtual bool
+          _end_element_impl (const ro_string<C>&,
+                             const ro_string<C>&);
+
+          virtual bool
+          _attribute_impl (const ro_string<C>&,
+                           const ro_string<C>&,
+                           const ro_string<C>&);
+
+          virtual bool
+          _characters_impl (const ro_string<C>&);
+
+
+          //
+          //
+          virtual void
+          _start_element (const ro_string<C>&,
+                          const ro_string<C>&,
+                          const ro_string<C>*);
+
+          virtual void
+          _end_element (const ro_string<C>&,
+                        const ro_string<C>&);
+
+          virtual void
+          _attribute (const ro_string<C>&,
+                      const ro_string<C>&,
+                      const ro_string<C>&);
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+
+          //
+          //
+          virtual void
+          _expected_element (const C* expected_ns,
+                             const C* expected_name);
+
+          virtual void
+          _expected_element (const C* expected_ns,
+                             const C* expected_name,
+                             const ro_string<C>& encountered_ns,
+                             const ro_string<C>& encountered_name);
+
+          virtual void
+          _unexpected_element (const ro_string<C>& ns,
+                               const ro_string<C>& name);
+
+          virtual void
+          _expected_attribute (const C* expected_ns,
+                               const C* expected_name);
+
+          virtual void
+          _unexpected_attribute (const ro_string<C>& ns,
+                                 const ro_string<C>& name,
+                                 const ro_string<C>& value);
+
+          virtual void
+          _unexpected_characters (const ro_string<C>&);
+        };
+
+
+        //
+        //
+        template <typename C>
+        struct simple_content: empty_content<C>
+        {
+          //
+          //
+          virtual void
+          _attribute (const ro_string<C>& ns,
+                      const ro_string<C>& name,
+                      const ro_string<C>& value);
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          //
+          //
+          virtual bool
+          _attribute_impl (const ro_string<C>&,
+                           const ro_string<C>&,
+                           const ro_string<C>&);
+
+          //
+          //
+          virtual void
+          _pre_impl ();
+
+          virtual void
+          _post_impl ();
+
+
+          // Implementation callbacks.
+          //
+          virtual void
+          _pre_a_validate ();
+
+          virtual void
+          _post_a_validate ();
+
+
+          // Attribute validation: during phase one we are searching for
+          // matching attributes (Structures, section 3.4.4, clause 2.1).
+          // During phase two we are searching for attribute wildcards
+          // (section 3.4.4, clause 2.2). Both phases run across
+          // inheritance hierarchy from derived to base for extension
+          // only. Both functions return true if the match was found and
+          // validation has been performed.
+          //
+          virtual bool
+          _attribute_impl_phase_one (const ro_string<C>& ns,
+                                     const ro_string<C>& name,
+                                     const ro_string<C>& value);
+
+          virtual bool
+          _attribute_impl_phase_two (const ro_string<C>& ns,
+                                     const ro_string<C>& name,
+                                     const ro_string<C>& value);
+        };
+
+
+        //
+        //
+        template <typename C>
+        struct complex_content: empty_content<C>
+        {
+          //
+          //
+          virtual void
+          _start_element (const ro_string<C>& ns,
+                          const ro_string<C>& name,
+                          const ro_string<C>* type);
+
+          virtual void
+          _end_element (const ro_string<C>& ns,
+                        const ro_string<C>& name);
+
+          virtual void
+          _attribute (const ro_string<C>& ns,
+                      const ro_string<C>& name,
+                      const ro_string<C>& value);
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          //
+          //
+          virtual bool
+          _attribute_impl (const ro_string<C>&,
+                           const ro_string<C>&,
+                           const ro_string<C>&);
+
+          //
+          //
+          virtual void
+          _pre_impl ();
+
+          virtual void
+          _post_impl ();
+
+
+          // Implementation callbacks.
+          //
+          virtual void
+          _pre_e_validate ();
+
+          virtual void
+          _post_e_validate ();
+
+          virtual void
+          _pre_a_validate ();
+
+          virtual void
+          _post_a_validate ();
+
+
+          // Attribute validation: during phase one we are searching for
+          // matching attributes (Structures, section 3.4.4, clause 2.1).
+          // During phase two we are searching for attribute wildcards
+          // (section 3.4.4, clause 2.2). Both phases run across
+          // inheritance hierarchy from derived to base for extension
+          // only. Both functions return true if the match was found and
+          // validation has been performed.
+          //
+          virtual bool
+          _attribute_impl_phase_one (const ro_string<C>& ns,
+                                     const ro_string<C>& name,
+                                     const ro_string<C>& value);
+
+          virtual bool
+          _attribute_impl_phase_two (const ro_string<C>& ns,
+                                     const ro_string<C>& name,
+                                     const ro_string<C>& value);
+        protected:
+          struct state
+          {
+            state ()
+                : any_ (false), depth_ (0), parser_ (0)
+            {
+            }
+
+            bool any_;
+            std::size_t depth_;
+            parser_base<C>* parser_;
+          };
+
+          // Optimized state stack for non-recursive case (one element).
+          //
+          struct state_stack
+          {
+            state_stack ()
+                : size_ (0)
+            {
+            }
+
+            void
+            push (const state& s)
+            {
+              if (size_ > 0)
+                rest_.push (top_);
+
+              top_ = s;
+              ++size_;
+            }
+
+            void
+            pop ()
+            {
+              if (size_ > 1)
+              {
+                top_ = rest_.top ();
+                rest_.pop ();
+              }
+
+              --size_;
+            }
+
+            const state&
+            top () const
+            {
+              return top_;
+            }
+
+            state&
+            top ()
+            {
+              return top_;
+            }
+
+            state&
+            under_top ()
+            {
+              return rest_.top ();
+            }
+
+          private:
+            state top_;
+            std::stack<state> rest_;
+            std::size_t size_;
+          };
+
+          state_stack context_;
+        };
+
+        // Base for xsd:list.
+        //
+        template <typename C>
+        struct list_base: simple_content<C>
+        {
+          virtual void
+          _xsd_parse_item (const ro_string<C>&) = 0;
+
+          virtual void
+          _pre_impl ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual void
+          _post_impl ();
+
+        protected:
+          std::basic_string<C> buf_;
+        };
+      }
+
+      // POD stack with pre-allocated first element. You may
+      // need to pad your elements to get the proper alignment.
+      //
+      struct pod_stack
+      {
+        ~pod_stack ()
+        {
+          delete[] data_;
+        }
+
+        pod_stack (std::size_t element_size, void* first_element)
+            : el_size_ (element_size), first_ (first_element),
+              data_ (0), size_ (0), capacity_ (0)
+        {
+        }
+
+      public:
+        void
+        pop ()
+        {
+          --size_;
+        }
+
+        void
+        push ()
+        {
+          if (size_ > capacity_)
+            grow ();
+
+          ++size_;
+        }
+
+        void*
+        top ()
+        {
+          return size_ == 1 ? first_ : data_ + (size_ - 1) * el_size_;
+        }
+
+        void*
+        under_top ()
+        {
+          return size_ == 2 ? first_ : data_ + (size_ - 2) * el_size_;
+        }
+
+        std::size_t
+        element_size () const
+        {
+          return el_size_;
+        }
+
+      private:
+        void
+        grow ()
+        {
+          std::size_t c (capacity_ ? capacity_ * 2 : 8);
+          char* d (new char[c * el_size_]);
+
+          if (size_ > 1)
+            std::memcpy (d, data_, (size_ - 1) * el_size_);
+
+          delete[] data_;
+
+          data_ = d;
+          capacity_ = c;
+        }
+
+      private:
+        std::size_t el_size_;
+        void* first_;
+        char* data_;
+        std::size_t size_;
+        std::size_t capacity_;
+      };
+
+      namespace validating
+      {
+        // Validation state stack for the 'all' particle.
+        //
+        struct all_stack
+        {
+          all_stack (std::size_t n, unsigned char* first)
+              : stack_ (n, first)
+          {
+          }
+
+          void
+          push ()
+          {
+            stack_.push ();
+
+            unsigned char* p (static_cast<unsigned char*> (stack_.top ()));
+
+            for (std::size_t i (0); i < stack_.element_size (); ++i)
+              p[i] = 0;
+          }
+
+          void
+          pop ()
+          {
+            stack_.pop ();
+          }
+
+          unsigned char*
+          top ()
+          {
+            return static_cast<unsigned char*> (stack_.top ());
+          }
+
+        private:
+          pod_stack stack_;
+        };
+      }
+    }
+  }
+}
+
+#include <xsd/cxx/parser/validating/parser.txx>
+
+#endif  // XSD_CXX_PARSER_VALIDATING_PARSER_HXX
diff --git src/base/include/xsd/cxx/parser/validating/parser.txx src/base/include/xsd/cxx/parser/validating/parser.txx
new file mode 100644
index 0000000..d447725
--- /dev/null
+++ src/base/include/xsd/cxx/parser/validating/parser.txx
@@ -0,0 +1,667 @@
+// file      : xsd/cxx/parser/validating/parser.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#include <cassert>
+
+#include <xsd/cxx/xml/bits/literals.hxx>
+#include <xsd/cxx/parser/validating/exceptions.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      namespace validating
+      {
+
+        // empty_content
+        //
+
+
+        template <typename C>
+        void empty_content<C>::
+        _start_any_element (const ro_string<C>&,
+                            const ro_string<C>&,
+                            const ro_string<C>*)
+        {
+        }
+
+        template <typename C>
+        void empty_content<C>::
+        _end_any_element (const ro_string<C>&,
+                          const ro_string<C>&)
+        {
+        }
+
+        template <typename C>
+        void empty_content<C>::
+        _any_attribute (const ro_string<C>&,
+                        const ro_string<C>&,
+                        const ro_string<C>&)
+        {
+        }
+
+        template <typename C>
+        void empty_content<C>::
+        _any_characters (const ro_string<C>&)
+        {
+        }
+
+        //
+        //
+        template <typename C>
+        bool empty_content<C>::
+        _start_element_impl (const ro_string<C>&,
+                             const ro_string<C>&,
+                             const ro_string<C>*)
+        {
+          return false;
+        }
+
+        template <typename C>
+        bool empty_content<C>::
+        _end_element_impl (const ro_string<C>&,
+                           const ro_string<C>&)
+        {
+          return false;
+        }
+
+        template <typename C>
+        bool empty_content<C>::
+        _attribute_impl (const ro_string<C>&,
+                         const ro_string<C>&,
+                         const ro_string<C>&)
+        {
+          return false;
+        }
+
+        template <typename C>
+        bool empty_content<C>::
+        _characters_impl (const ro_string<C>&)
+        {
+          return false;
+        }
+
+        //
+        //
+        template <typename C>
+        void empty_content<C>::
+        _start_element (const ro_string<C>& ns,
+                        const ro_string<C>& name,
+                        const ro_string<C>* type)
+        {
+          if (!this->_start_element_impl (ns, name, type))
+            this->_unexpected_element (ns, name);
+        }
+
+        template <typename C>
+        void empty_content<C>::
+        _end_element (const ro_string<C>& ns,
+                      const ro_string<C>& name)
+        {
+          if (!this->_end_element_impl (ns, name))
+            this->_unexpected_element (ns, name);
+        }
+
+        template <typename C>
+        void empty_content<C>::
+        _attribute (const ro_string<C>& ns,
+                    const ro_string<C>& name,
+                    const ro_string<C>& value)
+        {
+          // Weed out special attributes: xsi:type, xsi:nil,
+          // xsi:schemaLocation and noNamespaceSchemaLocation.
+          // See section 3.2.7 in Structures for details.
+          //
+          if (ns == xml::bits::xsi_namespace<C> () &&
+              (name == xml::bits::type<C> () ||
+               name == xml::bits::nil_lit<C> () ||
+               name == xml::bits::schema_location<C> () ||
+               name == xml::bits::no_namespace_schema_location<C> ()))
+            return;
+
+          // Also some parsers (notably Xerces-C++) supplies us with
+          // namespace-prefix mapping attributes.
+          //
+          if (ns == xml::bits::xmlns_namespace<C> ())
+            return;
+
+          if (!this->_attribute_impl (ns, name, value))
+            this->_unexpected_attribute (ns, name, value);
+        }
+
+        template <typename C>
+        void empty_content<C>::
+        _characters (const ro_string<C>& s)
+        {
+          if (!this->_characters_impl (s))
+            this->_unexpected_characters (s);
+        }
+
+        //
+        //
+        template <typename C>
+        void empty_content<C>::
+        _expected_element (const C* ex_ns, const C* ex_name)
+        {
+          throw expected_element<C> (ex_ns, ex_name);
+        }
+
+        template <typename C>
+        void empty_content<C>::
+        _expected_element (const C* ex_ns,
+                           const C* ex_name,
+                           const ro_string<C>& en_ns,
+                           const ro_string<C>& en_name)
+        {
+          throw expected_element<C> (ex_ns, ex_name, en_ns, en_name);
+        }
+
+        template <typename C>
+        void empty_content<C>::
+        _unexpected_element (const ro_string<C>& ns,
+                             const ro_string<C>& name)
+        {
+          throw unexpected_element<C> (ns, name);
+        }
+
+        template <typename C>
+        void empty_content<C>::
+        _expected_attribute (const C* ex_ns, const C* ex_name)
+        {
+          throw expected_attribute<C> (ex_ns, ex_name);
+        }
+
+        template <typename C>
+        void empty_content<C>::
+        _unexpected_attribute (const ro_string<C>& ns,
+                               const ro_string<C>& name,
+                               const ro_string<C>&)
+        {
+          throw unexpected_attribute<C> (ns, name);
+        }
+
+        template <typename C>
+        void empty_content<C>::
+        _unexpected_characters (const ro_string<C>& s)
+        {
+          throw unexpected_characters<C> (s);
+        }
+
+
+        // simple_content
+        //
+
+        template <typename C>
+        void simple_content<C>::
+        _attribute (const ro_string<C>& ns,
+                    const ro_string<C>& name,
+                    const ro_string<C>& value)
+        {
+          // Weed out special attributes: xsi:type, xsi:nil,
+          // xsi:schemaLocation and xsi:noNamespaceSchemaLocation.
+          // See section 3.2.7 in Structures for details.
+          //
+          if (ns == xml::bits::xsi_namespace<C> () &&
+              (name == xml::bits::type<C> () ||
+               name == xml::bits::nil_lit<C> () ||
+               name == xml::bits::schema_location<C> () ||
+               name == xml::bits::no_namespace_schema_location<C> ()))
+            return;
+
+          // Also some parsers (notably Xerces-C++) supplies us with
+          // namespace-prefix mapping attributes.
+          //
+          if (ns == xml::bits::xmlns_namespace<C> ())
+            return;
+
+          if (!this->_attribute_impl (ns, name, value))
+            this->_unexpected_attribute (ns, name, value);
+        }
+
+        template <typename C>
+        void simple_content<C>::
+        _characters (const ro_string<C>& str)
+        {
+          if (!this->_characters_impl (str))
+          {
+            // Mixed content is implemented in the generated code
+            // by overriding _characters_impl and forwarding to
+            // _any_characters.
+            //
+
+            // Scan the string for any non-whitespace characters
+            // (Structures, section 3.4.4, clause 1.3).
+            //
+            for (typename ro_string<C>::size_type i (0), e (str.size ());
+                 i < e; ++i)
+            {
+              C c (str[i]);
+
+              if (c != C (0x20) && // space
+                  c != C (0x0D) && // carriage return
+                  c != C (0x09) && // tab
+                  c != C (0x0A))
+                this->_unexpected_characters (str);
+            }
+          }
+        }
+
+        template <typename C>
+        void simple_content<C>::
+        _pre_impl ()
+        {
+          this->_pre ();
+          _pre_a_validate ();
+        }
+
+        template <typename C>
+        void simple_content<C>::
+        _post_impl ()
+        {
+          _post_a_validate ();
+          this->_post ();
+        }
+
+        template <typename C>
+        void simple_content<C>::
+        _pre_a_validate ()
+        {
+        }
+
+        template <typename C>
+        void simple_content<C>::
+        _post_a_validate ()
+        {
+        }
+
+        template <typename C>
+        bool simple_content<C>::
+        _attribute_impl (const ro_string<C>& ns,
+                         const ro_string<C>& name,
+                         const ro_string<C>& value)
+        {
+          return _attribute_impl_phase_one (ns, name, value) ||
+            _attribute_impl_phase_two (ns, name, value);
+        }
+
+        template <typename C>
+        bool simple_content<C>::
+        _attribute_impl_phase_one (const ro_string<C>&,
+                                   const ro_string<C>&,
+                                   const ro_string<C>&)
+        {
+          return false;
+        }
+
+        template <typename C>
+        bool simple_content<C>::
+        _attribute_impl_phase_two (const ro_string<C>&,
+                                   const ro_string<C>&,
+                                   const ro_string<C>&)
+        {
+          return false;
+        }
+
+
+        // complex_content
+        //
+
+
+        template <typename C>
+        void complex_content<C>::
+        _start_element (const ro_string<C>& ns,
+                        const ro_string<C>& name,
+                        const ro_string<C>* type)
+        {
+          state& s (context_.top ());
+
+          if (s.depth_++ > 0)
+          {
+            if (s.any_)
+              this->_start_any_element (ns, name, type);
+            else if (s.parser_)
+              s.parser_->_start_element (ns, name, type);
+          }
+          else
+          {
+            if (!this->_start_element_impl (ns, name, type))
+              this->_unexpected_element (ns, name);
+            else if (s.parser_ != 0)
+              s.parser_->_pre_impl ();
+          }
+        }
+
+        template <typename C>
+        void complex_content<C>::
+        _end_element (const ro_string<C>& ns,
+                      const ro_string<C>& name)
+        {
+          // To understand what's going on here it is helpful to think of
+          // a "total depth" as being the sum of individual depths over
+          // all elements.
+          //
+
+          if (context_.top ().depth_ == 0)
+          {
+            state& s (context_.under_top ()); // One before last.
+
+            if (--s.depth_ > 0)
+            {
+              // Indirect recursion.
+              //
+              if (s.parser_)
+                s.parser_->_end_element (ns, name);
+            }
+            else
+            {
+              // Direct recursion.
+              //
+              assert (this == s.parser_);
+
+              this->_post_impl ();
+
+              if (!this->_end_element_impl (ns, name))
+                assert (false);
+            }
+          }
+          else
+          {
+            state& s (context_.top ());
+
+            if (--s.depth_ > 0)
+            {
+              if (s.any_)
+                this->_end_any_element (ns, name);
+              else if (s.parser_)
+                s.parser_->_end_element (ns, name);
+            }
+            else
+            {
+              if (s.parser_ != 0 && !s.any_)
+                s.parser_->_post_impl ();
+
+              if (!this->_end_element_impl (ns, name))
+                this->_unexpected_element (ns, name);
+            }
+          }
+        }
+
+        template <typename C>
+        void complex_content<C>::
+        _attribute (const ro_string<C>& ns,
+                    const ro_string<C>& name,
+                    const ro_string<C>& value)
+        {
+          // Weed out special attributes: xsi:type, xsi:nil,
+          // xsi:schemaLocation and xsi:noNamespaceSchemaLocation.
+          // See section 3.2.7 in Structures for details.
+          //
+          if (ns == xml::bits::xsi_namespace<C> () &&
+              (name == xml::bits::type<C> () ||
+               name == xml::bits::nil_lit<C> () ||
+               name == xml::bits::schema_location<C> () ||
+               name == xml::bits::no_namespace_schema_location<C> ()))
+            return;
+
+          // Also some parsers (notably Xerces-C++) supplies us with
+          // namespace-prefix mapping attributes.
+          //
+          if (ns == xml::bits::xmlns_namespace<C> ())
+            return;
+
+          const state& s (context_.top ());
+
+          if (s.depth_ > 0)
+          {
+            if (s.any_)
+              this->_any_attribute (ns, name, value);
+            else if (s.parser_)
+              s.parser_->_attribute (ns, name, value);
+          }
+          else
+          {
+            if (!this->_attribute_impl (ns, name, value))
+              this->_unexpected_attribute (ns, name, value);
+          }
+        }
+
+        template <typename C>
+        void complex_content<C>::
+        _characters (const ro_string<C>& str)
+        {
+          const state& s (context_.top ());
+
+          if (s.depth_ > 0)
+          {
+            if (s.any_)
+              this->_any_characters (str);
+            else if (s.parser_)
+              s.parser_->_characters (str);
+          }
+          else
+          {
+            if (!this->_characters_impl (str))
+            {
+              // Mixed content is implemented in the generated code
+              // by overriding _characters_impl and forwarding to
+              // _any_characters.
+              //
+
+              // Scan the string for any non-whitespace characters
+              // (Structures, section 3.4.4, clause 1.3).
+              //
+              for (typename ro_string<C>::size_type i (0), e (str.size ());
+                   i < e; ++i)
+              {
+                C c (str[i]);
+
+                if (c != C (0x20) && // space
+                    c != C (0x0D) && // carriage return
+                    c != C (0x09) && // tab
+                    c != C (0x0A))
+                  this->_unexpected_characters (str);
+              }
+            }
+          }
+        }
+
+        template <typename C>
+        void complex_content<C>::
+        _pre_impl ()
+        {
+          context_.push (state ());
+          this->_pre ();
+          _pre_a_validate ();
+          _pre_e_validate ();
+        }
+
+        template <typename C>
+        void complex_content<C>::
+        _post_impl ()
+        {
+          _post_e_validate ();
+          _post_a_validate ();
+          this->_post ();
+          context_.pop ();
+        }
+
+        template <typename C>
+        void complex_content<C>::
+        _pre_e_validate ()
+        {
+        }
+
+        template <typename C>
+        void complex_content<C>::
+        _post_e_validate ()
+        {
+        }
+
+        template <typename C>
+        void complex_content<C>::
+        _pre_a_validate ()
+        {
+        }
+
+        template <typename C>
+        void complex_content<C>::
+        _post_a_validate ()
+        {
+        }
+
+        template <typename C>
+        bool complex_content<C>::
+        _attribute_impl (const ro_string<C>& ns,
+                         const ro_string<C>& name,
+                         const ro_string<C>& value)
+        {
+          return _attribute_impl_phase_one (ns, name, value) ||
+            _attribute_impl_phase_two (ns, name, value);
+        }
+
+        template <typename C>
+        bool complex_content<C>::
+        _attribute_impl_phase_one (const ro_string<C>&,
+                                   const ro_string<C>&,
+                                   const ro_string<C>&)
+        {
+          return false;
+        }
+
+        template <typename C>
+        bool complex_content<C>::
+        _attribute_impl_phase_two (const ro_string<C>&,
+                                   const ro_string<C>&,
+                                   const ro_string<C>&)
+        {
+          return false;
+        }
+
+
+        // list_base
+        //
+        namespace bits
+        {
+          // Find first non-space character.
+          //
+          template <typename C>
+          typename ro_string<C>::size_type
+          find_ns (const C* s,
+                   typename ro_string<C>::size_type size,
+                   typename ro_string<C>::size_type pos)
+          {
+            while (pos < size &&
+                   (s[pos] == C (0x20) || s[pos] == C (0x0A) ||
+                    s[pos] == C (0x0D) || s[pos] == C (0x09)))
+              ++pos;
+
+            return pos < size ? pos : ro_string<C>::npos;
+          }
+
+          // Find first space character.
+          //
+          template <typename C>
+          typename ro_string<C>::size_type
+          find_s (const C* s,
+                  typename ro_string<C>::size_type size,
+                  typename ro_string<C>::size_type pos)
+          {
+            while (pos < size &&
+                   s[pos] != C (0x20) && s[pos] != C (0x0A) &&
+                   s[pos] != C (0x0D) && s[pos] != C (0x09))
+              ++pos;
+
+            return pos < size ? pos : ro_string<C>::npos;
+          }
+        }
+
+        // Relevant XML Schema Part 2: Datatypes sections: 4.2.1.2, 4.3.6.
+        //
+
+        template <typename C>
+        void list_base<C>::
+        _pre_impl ()
+        {
+          simple_content<C>::_pre_impl ();
+          buf_.clear ();
+        }
+
+        template <typename C>
+        void list_base<C>::
+        _characters (const ro_string<C>& s)
+        {
+          typedef typename ro_string<C>::size_type size_type;
+
+          const C* data (s.data ());
+          size_type size (s.size ());
+
+          // Handle the previous chunk if we start with a ws.
+          //
+          if (!buf_.empty () &&
+              (data[0] == C (0x20) || data[0] == C (0x0A) ||
+               data[0] == C (0x0D) || data[0] == C (0x09)))
+          {
+            ro_string<C> tmp (buf_); // Private copy ctor.
+            _xsd_parse_item (tmp);
+            buf_.clear ();
+          }
+
+          // Traverse the data while logically collapsing spaces.
+          //
+          for (size_type i (bits::find_ns (data, size, 0));
+               i != ro_string<C>::npos;)
+          {
+            size_type j (bits::find_s (data, size, i));
+
+            if (j != ro_string<C>::npos)
+            {
+              if (buf_.empty ())
+              {
+                ro_string<C> tmp (data + i, j - i); // Private copy ctor.
+                _xsd_parse_item (tmp);
+              }
+              else
+              {
+                // Assemble the first item in str from buf_ and s.
+                //
+                std::basic_string<C> str;
+                str.swap (buf_);
+                str.append (data + i, j - i);
+                ro_string<C> tmp (str); // Private copy ctor.
+                _xsd_parse_item (tmp);
+              }
+
+              i = bits::find_ns (data, size, j);
+            }
+            else
+            {
+              // Last fragment, append it to the buf_.
+              //
+              buf_.append (data + i, size - i);
+              break;
+            }
+          }
+        }
+
+        template <typename C>
+        void list_base<C>::
+        _post_impl ()
+        {
+          // Handle the last item.
+          //
+          if (!buf_.empty ())
+          {
+            ro_string<C> tmp (buf_); // Private copy ctor.
+            _xsd_parse_item (tmp);
+          }
+
+          simple_content<C>::_post_impl ();
+        }
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/parser/validating/xml-schema-pimpl.hxx src/base/include/xsd/cxx/parser/validating/xml-schema-pimpl.hxx
new file mode 100644
index 0000000..619a8c7
--- /dev/null
+++ src/base/include/xsd/cxx/parser/validating/xml-schema-pimpl.hxx
@@ -0,0 +1,1121 @@
+// file      : xsd/cxx/parser/validating/xml-schema-pimpl.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_PARSER_VALIDATING_XML_SCHEMA_PIMPL_HXX
+#define XSD_CXX_PARSER_VALIDATING_XML_SCHEMA_PIMPL_HXX
+
+#include <string>
+
+#include <xsd/cxx/parser/validating/xml-schema-pskel.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      namespace validating
+      {
+        // any_type
+        //
+        template <typename C>
+        struct any_type_pimpl: virtual any_type_pskel<C>
+        {
+          virtual void
+          post_any_type ();
+        };
+
+        // any_simple_type
+        //
+        template <typename C>
+        struct any_simple_type_pimpl: virtual any_simple_type_pskel<C>
+        {
+          virtual void
+          post_any_simple_type ();
+        };
+
+        // boolean
+        //
+        template <typename C>
+        struct boolean_pimpl: virtual boolean_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual void
+          _post ();
+
+          virtual bool
+          post_boolean ();
+
+        protected:
+          std::basic_string<C> str_;
+          bool value_;
+        };
+
+
+        // 8-bit
+        //
+        template <typename C>
+        struct byte_pimpl: virtual byte_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual void
+          _post ();
+
+          virtual signed char
+          post_byte ();
+
+        protected:
+          std::basic_string<C> str_;
+          signed char value_;
+        };
+
+
+        template <typename C>
+        struct unsigned_byte_pimpl: virtual unsigned_byte_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual void
+          _post ();
+
+          virtual unsigned char
+          post_unsigned_byte ();
+
+        protected:
+          std::basic_string<C> str_;
+          unsigned char value_;
+        };
+
+
+        // 16-bit
+        //
+        template <typename C>
+        struct short_pimpl: virtual short_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual void
+          _post ();
+
+          virtual short
+          post_short ();
+
+        protected:
+          std::basic_string<C> str_;
+          short value_;
+        };
+
+
+        template <typename C>
+        struct unsigned_short_pimpl: virtual unsigned_short_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual void
+          _post ();
+
+          virtual unsigned short
+          post_unsigned_short ();
+
+        protected:
+          std::basic_string<C> str_;
+          unsigned short value_;
+        };
+
+
+        // 32-bit
+        //
+        template <typename C>
+        struct int_pimpl: virtual int_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual void
+          _post ();
+
+          virtual int
+          post_int ();
+
+        protected:
+          std::basic_string<C> str_;
+          int value_;
+        };
+
+
+        template <typename C>
+        struct unsigned_int_pimpl: virtual unsigned_int_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual void
+          _post ();
+
+          virtual unsigned int
+          post_unsigned_int ();
+
+        protected:
+          std::basic_string<C> str_;
+          unsigned int value_;
+        };
+
+
+        // 64-bit
+        //
+        template <typename C>
+        struct long_pimpl: virtual long_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual void
+          _post ();
+
+          virtual long long
+          post_long ();
+
+        protected:
+          std::basic_string<C> str_;
+          long long value_;
+        };
+
+
+        template <typename C>
+        struct unsigned_long_pimpl: virtual unsigned_long_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual void
+          _post ();
+
+          virtual unsigned long long
+          post_unsigned_long ();
+
+        protected:
+          std::basic_string<C> str_;
+          unsigned long long value_;
+        };
+
+
+        // Arbitrary-length integers.
+        //
+        template <typename C>
+        struct integer_pimpl: virtual integer_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual void
+          _post ();
+
+          virtual long long
+          post_integer ();
+
+        protected:
+          std::basic_string<C> str_;
+          long long value_;
+        };
+
+        template <typename C>
+        struct negative_integer_pimpl: virtual negative_integer_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual void
+          _post ();
+
+          virtual long long
+          post_negative_integer ();
+
+        protected:
+          std::basic_string<C> str_;
+          long long value_;
+        };
+
+        template <typename C>
+        struct non_positive_integer_pimpl: virtual non_positive_integer_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual void
+          _post ();
+
+          virtual long long
+          post_non_positive_integer ();
+
+        protected:
+          std::basic_string<C> str_;
+          long long value_;
+        };
+
+        template <typename C>
+        struct positive_integer_pimpl: virtual positive_integer_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual void
+          _post ();
+
+          virtual unsigned long long
+          post_positive_integer ();
+
+        protected:
+          std::basic_string<C> str_;
+          unsigned long long value_;
+        };
+
+        template <typename C>
+        struct non_negative_integer_pimpl: virtual non_negative_integer_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual void
+          _post ();
+
+          virtual unsigned long long
+          post_non_negative_integer ();
+
+        protected:
+          std::basic_string<C> str_;
+          unsigned long long value_;
+        };
+
+
+        // Floats.
+        //
+        template <typename C>
+        struct float_pimpl: virtual float_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual void
+          _post ();
+
+          virtual float
+          post_float ();
+
+        protected:
+          std::basic_string<C> str_;
+          float value_;
+        };
+
+
+        template <typename C>
+        struct double_pimpl: virtual double_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual void
+          _post ();
+
+          virtual double
+          post_double ();
+
+        protected:
+          std::basic_string<C> str_;
+          double value_;
+        };
+
+
+        template <typename C>
+        struct decimal_pimpl: virtual decimal_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual void
+          _post ();
+
+          virtual double
+          post_decimal ();
+
+        protected:
+          std::basic_string<C> str_;
+          double value_;
+        };
+
+
+        // Strings.
+        //
+        template <typename C>
+        struct string_pimpl: virtual string_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual std::basic_string<C>
+          post_string ();
+
+        protected:
+          std::basic_string<C> str_;
+        };
+
+        template <typename C>
+        struct normalized_string_pimpl: virtual normalized_string_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual std::basic_string<C>
+          post_normalized_string ();
+
+        protected:
+          std::basic_string<C> str_;
+        };
+
+        template <typename C>
+        struct token_pimpl: virtual token_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual std::basic_string<C>
+          post_token ();
+
+        protected:
+          std::basic_string<C> str_;
+        };
+
+        template <typename C>
+        struct name_pimpl: virtual name_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual void
+          _post ();
+
+          virtual std::basic_string<C>
+          post_name ();
+
+        protected:
+          std::basic_string<C> str_;
+        };
+
+        template <typename C>
+        struct nmtoken_pimpl: virtual nmtoken_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual void
+          _post ();
+
+          virtual std::basic_string<C>
+          post_nmtoken ();
+
+        protected:
+          std::basic_string<C> str_;
+        };
+
+        template <typename C>
+        struct nmtokens_pimpl: virtual nmtokens_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _xsd_parse_item (const ro_string<C>&);
+
+          virtual void
+          _post ();
+
+          virtual string_sequence<C>
+          post_nmtokens ();
+
+        protected:
+          string_sequence<C> seq_;
+          nmtoken_pimpl<C> parser_;
+        };
+
+        template <typename C>
+        struct ncname_pimpl: virtual ncname_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual void
+          _post ();
+
+          virtual std::basic_string<C>
+          post_ncname ();
+
+        protected:
+          std::basic_string<C> str_;
+        };
+
+        template <typename C>
+        struct id_pimpl: virtual id_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual void
+          _post ();
+
+          virtual std::basic_string<C>
+          post_id ();
+
+        protected:
+          std::basic_string<C> str_;
+        };
+
+        template <typename C>
+        struct idref_pimpl: virtual idref_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual void
+          _post ();
+
+          virtual std::basic_string<C>
+          post_idref ();
+
+        protected:
+          std::basic_string<C> str_;
+        };
+
+        template <typename C>
+        struct idrefs_pimpl: virtual idrefs_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _xsd_parse_item (const ro_string<C>&);
+
+          virtual void
+          _post ();
+
+          virtual string_sequence<C>
+          post_idrefs ();
+
+        protected:
+          string_sequence<C> seq_;
+          idref_pimpl<C> parser_;
+        };
+
+        // language
+        //
+        template <typename C>
+        struct language_pimpl: virtual language_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual void
+          _post ();
+
+          virtual std::basic_string<C>
+          post_language ();
+
+        protected:
+          std::basic_string<C> str_;
+        };
+
+        // anyURI
+        //
+        template <typename C>
+        struct uri_pimpl: virtual uri_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual std::basic_string<C>
+          post_uri ();
+
+        protected:
+          std::basic_string<C> str_;
+        };
+
+        // QName
+        //
+        template <typename C>
+        struct qname_pimpl: virtual qname_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual void
+          _post ();
+
+          virtual qname<C>
+          post_qname ();
+
+        protected:
+          std::basic_string<C> str_;
+          std::basic_string<C> name_;
+          std::basic_string<C> prefix_;
+        };
+
+        // base64Binary
+        //
+        template <typename C>
+        struct base64_binary_pimpl: virtual base64_binary_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual void
+          _post ();
+
+          virtual std::auto_ptr<buffer>
+          post_base64_binary ();
+
+        protected:
+          std::basic_string<C> str_;
+          std::auto_ptr<buffer> buf_;
+        };
+
+        // hexBinary
+        //
+        template <typename C>
+        struct hex_binary_pimpl: virtual hex_binary_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual void
+          _post ();
+
+          virtual std::auto_ptr<buffer>
+          post_hex_binary ();
+
+        protected:
+          std::basic_string<C> str_;
+          std::auto_ptr<buffer> buf_;
+        };
+
+        // gday
+        //
+        template <typename C>
+        struct gday_pimpl: virtual gday_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual void
+          _post ();
+
+          virtual gday
+          post_gday ();
+
+        protected:
+          std::basic_string<C> str_;
+          unsigned short day_;
+          bool z_;
+          short zh_, zm_;
+        };
+
+        // gmonth
+        //
+        template <typename C>
+        struct gmonth_pimpl: virtual gmonth_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual void
+          _post ();
+
+          virtual gmonth
+          post_gmonth ();
+
+        protected:
+          std::basic_string<C> str_;
+          unsigned short month_;
+          bool z_;
+          short zh_, zm_;
+        };
+
+        // gyear
+        //
+        template <typename C>
+        struct gyear_pimpl: virtual gyear_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual void
+          _post ();
+
+          virtual gyear
+          post_gyear ();
+
+        protected:
+          std::basic_string<C> str_;
+          int year_;
+          bool z_;
+          short zh_, zm_;
+        };
+
+        // gmonth_day
+        //
+        template <typename C>
+        struct gmonth_day_pimpl: virtual gmonth_day_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual void
+          _post ();
+
+          virtual gmonth_day
+          post_gmonth_day ();
+
+        protected:
+          std::basic_string<C> str_;
+          unsigned short month_;
+          unsigned short day_;
+          bool z_;
+          short zh_, zm_;
+        };
+
+        // gyear_month
+        //
+        template <typename C>
+        struct gyear_month_pimpl: virtual gyear_month_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual void
+          _post ();
+
+          virtual gyear_month
+          post_gyear_month ();
+
+        protected:
+          std::basic_string<C> str_;
+          int year_;
+          unsigned short month_;
+          bool z_;
+          short zh_, zm_;
+        };
+
+        // date
+        //
+        template <typename C>
+        struct date_pimpl: virtual date_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual void
+          _post ();
+
+          virtual date
+          post_date ();
+
+        protected:
+          std::basic_string<C> str_;
+          int year_;
+          unsigned short month_;
+          unsigned short day_;
+          bool z_;
+          short zh_, zm_;
+        };
+
+        // time
+        //
+        template <typename C>
+        struct time_pimpl: virtual time_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual void
+          _post ();
+
+          virtual time
+          post_time ();
+
+        protected:
+          std::basic_string<C> str_;
+          unsigned short hours_;
+          unsigned short minutes_;
+          double seconds_;
+          bool z_;
+          short zh_, zm_;
+        };
+
+        // date_time
+        //
+        template <typename C>
+        struct date_time_pimpl: virtual date_time_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual void
+          _post ();
+
+          virtual date_time
+          post_date_time ();
+
+        protected:
+          std::basic_string<C> str_;
+          int year_;
+          unsigned short month_;
+          unsigned short day_;
+          unsigned short hours_;
+          unsigned short minutes_;
+          double seconds_;
+          bool z_;
+          short zh_, zm_;
+        };
+
+        // duration
+        //
+        template <typename C>
+        struct duration_pimpl: virtual duration_pskel<C>
+        {
+          virtual void
+          _pre ();
+
+          virtual void
+          _characters (const ro_string<C>&);
+
+          virtual void
+          _post ();
+
+          virtual duration
+          post_duration ();
+
+        protected:
+          std::basic_string<C> str_;
+          bool negative_;
+          unsigned int years_;
+          unsigned int months_;
+          unsigned int days_;
+          unsigned int hours_;
+          unsigned int minutes_;
+          double seconds_;
+        };
+
+        // Literals.
+        //
+        namespace bits
+        {
+          template<typename C>
+          const C*
+          boolean ();
+
+          template<typename C>
+          const C*
+          byte ();
+
+          template<typename C>
+          const C*
+          unsigned_byte ();
+
+          template<typename C>
+          const C*
+          short_ ();
+
+          template<typename C>
+          const C*
+          unsigned_short ();
+
+          template<typename C>
+          const C*
+          int_ ();
+
+          template<typename C>
+          const C*
+          unsigned_int ();
+
+          template<typename C>
+          const C*
+          long_ ();
+
+          template<typename C>
+          const C*
+          unsigned_long ();
+
+          template<typename C>
+          const C*
+          integer ();
+
+          template<typename C>
+          const C*
+          negative_integer ();
+
+          template<typename C>
+          const C*
+          non_positive_integer ();
+
+          template<typename C>
+          const C*
+          non_negative_integer ();
+
+          template<typename C>
+          const C*
+          positive_integer ();
+
+          template<typename C>
+          const C*
+          float_ ();
+
+          template<typename C>
+          const C*
+          double_ ();
+
+          template<typename C>
+          const C*
+          decimal ();
+
+          template<typename C>
+          const C*
+          name ();
+
+          template<typename C>
+          const C*
+          nmtoken ();
+
+          template<typename C>
+          const C*
+          nmtokens ();
+
+          template<typename C>
+          const C*
+          ncname ();
+
+          template<typename C>
+          const C*
+          id ();
+
+          template<typename C>
+          const C*
+          idref ();
+
+          template<typename C>
+          const C*
+          idrefs ();
+
+          template<typename C>
+          const C*
+          language ();
+
+          template<typename C>
+          const C*
+          qname ();
+
+          template<typename C>
+          const C*
+          base64_binary ();
+
+          template<typename C>
+          const C*
+          hex_binary ();
+
+          template<typename C>
+          const C*
+          gday ();
+
+          template<typename C>
+          const C*
+          gmonth ();
+
+          template<typename C>
+          const C*
+          gyear ();
+
+          template<typename C>
+          const C*
+          gmonth_day ();
+
+          template<typename C>
+          const C*
+          gyear_month ();
+
+          template<typename C>
+          const C*
+          date ();
+
+          template<typename C>
+          const C*
+          time ();
+
+          template<typename C>
+          const C*
+          date_time ();
+
+          template<typename C>
+          const C*
+          duration ();
+
+          // float literals: INF -INF NaN
+          //
+          template<typename C>
+          const C*
+          positive_inf ();
+
+          template<typename C>
+          const C*
+          negative_inf ();
+
+          template<typename C>
+          const C*
+          nan ();
+
+          // boolean literals
+          //
+          template<typename C>
+          const C*
+          true_ ();
+
+          template<typename C>
+          const C*
+          false_ ();
+
+          template<typename C>
+          const C*
+          one ();
+
+          template<typename C>
+          const C*
+          zero ();
+        }
+      }
+    }
+  }
+}
+
+#include <xsd/cxx/parser/validating/xml-schema-pimpl.txx>
+
+#endif  // XSD_CXX_PARSER_VALIDATING_XML_SCHEMA_PIMPL_HXX
+
+#include <xsd/cxx/parser/validating/xml-schema-pimpl.ixx>
diff --git src/base/include/xsd/cxx/parser/validating/xml-schema-pimpl.ixx src/base/include/xsd/cxx/parser/validating/xml-schema-pimpl.ixx
new file mode 100644
index 0000000..c6f8127
--- /dev/null
+++ src/base/include/xsd/cxx/parser/validating/xml-schema-pimpl.ixx
@@ -0,0 +1,676 @@
+// file      : xsd/cxx/parser/validating/xml-schema-pimpl.ixx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#if defined(XSD_CXX_PARSER_USE_CHAR) || !defined(XSD_CXX_PARSER_USE_WCHAR)
+
+#ifndef XSD_CXX_PARSER_VALIDATING_XML_SCHEMA_PIMPL_IXX_CHAR
+#define XSD_CXX_PARSER_VALIDATING_XML_SCHEMA_PIMPL_IXX_CHAR
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      namespace validating
+      {
+        namespace bits
+        {
+          template<>
+          inline const char*
+          boolean<char> ()
+          {
+            return "boolean";
+          }
+
+          template<>
+          inline const char*
+          byte<char> ()
+          {
+            return "byte";
+          }
+
+          template<>
+          inline const char*
+          unsigned_byte<char> ()
+          {
+            return "unsignedByte";
+          }
+
+          template<>
+          inline const char*
+          short_<char> ()
+          {
+            return "short";
+          }
+
+          template<>
+          inline const char*
+          unsigned_short<char> ()
+          {
+            return "unsignedShort";
+          }
+
+          template<>
+          inline const char*
+          int_<char> ()
+          {
+            return "int";
+          }
+
+          template<>
+          inline const char*
+          unsigned_int<char> ()
+          {
+            return "unsignedInt";
+          }
+
+          template<>
+          inline const char*
+          long_<char> ()
+          {
+            return "long";
+          }
+
+          template<>
+          inline const char*
+          unsigned_long<char> ()
+          {
+            return "unsignedLong";
+          }
+
+          template<>
+          inline const char*
+          integer<char> ()
+          {
+            return "integer";
+          }
+
+          template<>
+          inline const char*
+          negative_integer<char> ()
+          {
+            return "negativeInteger";
+          }
+
+          template<>
+          inline const char*
+          non_positive_integer<char> ()
+          {
+            return "nonPositiveInteger";
+          }
+
+          template<>
+          inline const char*
+          non_negative_integer<char> ()
+          {
+            return "nonNegativeInteger";
+          }
+
+          template<>
+          inline const char*
+          positive_integer<char> ()
+          {
+            return "positiveInteger";
+          }
+
+          template<>
+          inline const char*
+          float_<char> ()
+          {
+            return "float";
+          }
+
+          template<>
+          inline const char*
+          double_<char> ()
+          {
+            return "double";
+          }
+
+          template<>
+          inline const char*
+          decimal<char> ()
+          {
+            return "decimal";
+          }
+
+          template<>
+          inline const char*
+          name<char> ()
+          {
+            return "Name";
+          }
+
+          template<>
+          inline const char*
+          nmtoken<char> ()
+          {
+            return "NMTOKEN";
+          }
+
+          template<>
+          inline const char*
+          nmtokens<char> ()
+          {
+            return "NMTOKENS";
+          }
+
+          template<>
+          inline const char*
+          ncname<char> ()
+          {
+            return "NCName";
+          }
+
+          template<>
+          inline const char*
+          id<char> ()
+          {
+            return "ID";
+          }
+
+          template<>
+          inline const char*
+          idref<char> ()
+          {
+            return "IDREF";
+          }
+
+          template<>
+          inline const char*
+          idrefs<char> ()
+          {
+            return "IDREFS";
+          }
+
+          template<>
+          inline const char*
+          language<char> ()
+          {
+            return "language";
+          }
+
+          template<>
+          inline const char*
+          qname<char> ()
+          {
+            return "QName";
+          }
+
+          template<>
+          inline const char*
+          base64_binary<char> ()
+          {
+            return "base64Binary";
+          }
+
+          template<>
+          inline const char*
+          hex_binary<char> ()
+          {
+            return "hexBinary";
+          }
+
+          template<>
+          inline const char*
+          gday<char> ()
+          {
+            return "gDay";
+          }
+
+          template<>
+          inline const char*
+          gmonth<char> ()
+          {
+            return "gMonth";
+          }
+
+          template<>
+          inline const char*
+          gyear<char> ()
+          {
+            return "gYear";
+          }
+
+          template<>
+          inline const char*
+          gmonth_day<char> ()
+          {
+            return "gMonthDay";
+          }
+
+          template<>
+          inline const char*
+          gyear_month<char> ()
+          {
+            return "gYearMonth";
+          }
+
+          template<>
+          inline const char*
+          date<char> ()
+          {
+            return "date";
+          }
+
+          template<>
+          inline const char*
+          time<char> ()
+          {
+            return "time";
+          }
+
+          template<>
+          inline const char*
+          date_time<char> ()
+          {
+            return "dateTime";
+          }
+
+          template<>
+          inline const char*
+          duration<char> ()
+          {
+            return "duration";
+          }
+
+          //
+          //
+          template<>
+          inline const char*
+          positive_inf<char> ()
+          {
+            return "INF";
+          }
+
+          template<>
+          inline const char*
+          negative_inf<char> ()
+          {
+            return "-INF";
+          }
+
+          template<>
+          inline const char*
+          nan<char> ()
+          {
+            return "NaN";
+          }
+
+          //
+          //
+          template<>
+          inline const char*
+          true_<char> ()
+          {
+            return "true";
+          }
+
+          template<>
+          inline const char*
+          false_<char> ()
+          {
+            return "false";
+          }
+
+          template<>
+          inline const char*
+          one<char> ()
+          {
+            return "1";
+          }
+
+          template<>
+          inline const char*
+          zero<char> ()
+          {
+            return "0";
+          }
+        }
+      }
+    }
+  }
+}
+
+#endif // XSD_CXX_PARSER_VALIDATING_XML_SCHEMA_PIMPL_IXX_CHAR
+#endif // XSD_CXX_PARSER_USE_CHAR
+
+
+#if defined(XSD_CXX_PARSER_USE_WCHAR) || !defined(XSD_CXX_PARSER_USE_CHAR)
+
+#ifndef XSD_CXX_PARSER_VALIDATING_XML_SCHEMA_PIMPL_IXX_WCHAR
+#define XSD_CXX_PARSER_VALIDATING_XML_SCHEMA_PIMPL_IXX_WCHAR
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      namespace validating
+      {
+        namespace bits
+        {
+          template<>
+          inline const wchar_t*
+          boolean<wchar_t> ()
+          {
+            return L"boolean";
+          }
+
+          template<>
+          inline const wchar_t*
+          byte<wchar_t> ()
+          {
+            return L"byte";
+          }
+
+          template<>
+          inline const wchar_t*
+          unsigned_byte<wchar_t> ()
+          {
+            return L"unsignedByte";
+          }
+
+          template<>
+          inline const wchar_t*
+          short_<wchar_t> ()
+          {
+            return L"short";
+          }
+
+          template<>
+          inline const wchar_t*
+          unsigned_short<wchar_t> ()
+          {
+            return L"unsignedShort";
+          }
+
+          template<>
+          inline const wchar_t*
+          int_<wchar_t> ()
+          {
+            return L"int";
+          }
+
+          template<>
+          inline const wchar_t*
+          unsigned_int<wchar_t> ()
+          {
+            return L"unsignedInt";
+          }
+
+          template<>
+          inline const wchar_t*
+          long_<wchar_t> ()
+          {
+            return L"long";
+          }
+
+          template<>
+          inline const wchar_t*
+          unsigned_long<wchar_t> ()
+          {
+            return L"unsignedLong";
+          }
+
+          template<>
+          inline const wchar_t*
+          integer<wchar_t> ()
+          {
+            return L"integer";
+          }
+
+          template<>
+          inline const wchar_t*
+          negative_integer<wchar_t> ()
+          {
+            return L"negativeInteger";
+          }
+
+          template<>
+          inline const wchar_t*
+          non_positive_integer<wchar_t> ()
+          {
+            return L"nonPositiveInteger";
+          }
+
+          template<>
+          inline const wchar_t*
+          non_negative_integer<wchar_t> ()
+          {
+            return L"nonNegativeInteger";
+          }
+
+          template<>
+          inline const wchar_t*
+          positive_integer<wchar_t> ()
+          {
+            return L"positiveInteger";
+          }
+
+          template<>
+          inline const wchar_t*
+          float_<wchar_t> ()
+          {
+            return L"float";
+          }
+
+          template<>
+          inline const wchar_t*
+          double_<wchar_t> ()
+          {
+            return L"double";
+          }
+
+          template<>
+          inline const wchar_t*
+          decimal<wchar_t> ()
+          {
+            return L"decimal";
+          }
+
+          template<>
+          inline const wchar_t*
+          name<wchar_t> ()
+          {
+            return L"Name";
+          }
+
+          template<>
+          inline const wchar_t*
+          nmtoken<wchar_t> ()
+          {
+            return L"NMTOKEN";
+          }
+
+          template<>
+          inline const wchar_t*
+          nmtokens<wchar_t> ()
+          {
+            return L"NMTOKENS";
+          }
+
+          template<>
+          inline const wchar_t*
+          ncname<wchar_t> ()
+          {
+            return L"NCName";
+          }
+
+          template<>
+          inline const wchar_t*
+          id<wchar_t> ()
+          {
+            return L"ID";
+          }
+
+          template<>
+          inline const wchar_t*
+          idref<wchar_t> ()
+          {
+            return L"IDREF";
+          }
+
+          template<>
+          inline const wchar_t*
+          idrefs<wchar_t> ()
+          {
+            return L"IDREFS";
+          }
+
+          template<>
+          inline const wchar_t*
+          language<wchar_t> ()
+          {
+            return L"language";
+          }
+
+          template<>
+          inline const wchar_t*
+          qname<wchar_t> ()
+          {
+            return L"QName";
+          }
+
+          template<>
+          inline const wchar_t*
+          base64_binary<wchar_t> ()
+          {
+            return L"base64Binary";
+          }
+
+          template<>
+          inline const wchar_t*
+          hex_binary<wchar_t> ()
+          {
+            return L"hexBinary";
+          }
+
+          template<>
+          inline const wchar_t*
+          gday<wchar_t> ()
+          {
+            return L"gDay";
+          }
+
+          template<>
+          inline const wchar_t*
+          gmonth<wchar_t> ()
+          {
+            return L"gMonth";
+          }
+
+          template<>
+          inline const wchar_t*
+          gyear<wchar_t> ()
+          {
+            return L"gYear";
+          }
+
+          template<>
+          inline const wchar_t*
+          gmonth_day<wchar_t> ()
+          {
+            return L"gMonthDay";
+          }
+
+          template<>
+          inline const wchar_t*
+          gyear_month<wchar_t> ()
+          {
+            return L"gYearMonth";
+          }
+
+          template<>
+          inline const wchar_t*
+          date<wchar_t> ()
+          {
+            return L"date";
+          }
+
+          template<>
+          inline const wchar_t*
+          time<wchar_t> ()
+          {
+            return L"time";
+          }
+
+          template<>
+          inline const wchar_t*
+          date_time<wchar_t> ()
+          {
+            return L"dateTime";
+          }
+
+          template<>
+          inline const wchar_t*
+          duration<wchar_t> ()
+          {
+            return L"duration";
+          }
+
+
+          //
+          //
+          template<>
+          inline const wchar_t*
+          positive_inf<wchar_t> ()
+          {
+            return L"INF";
+          }
+
+          template<>
+          inline const wchar_t*
+          negative_inf<wchar_t> ()
+          {
+            return L"-INF";
+          }
+
+          template<>
+          inline const wchar_t*
+          nan<wchar_t> ()
+          {
+            return L"NaN";
+          }
+
+          //
+          //
+          template<>
+          inline const wchar_t*
+          true_<wchar_t> ()
+          {
+            return L"true";
+          }
+
+          template<>
+          inline const wchar_t*
+          false_<wchar_t> ()
+          {
+            return L"false";
+          }
+
+          template<>
+          inline const wchar_t*
+          one<wchar_t> ()
+          {
+            return L"1";
+          }
+
+          template<>
+          inline const wchar_t*
+          zero<wchar_t> ()
+          {
+            return L"0";
+          }
+        }
+      }
+    }
+  }
+}
+
+#endif // XSD_CXX_PARSER_VALIDATING_XML_SCHEMA_PIMPL_IXX_WCHAR
+#endif // XSD_CXX_PARSER_USE_WCHAR
diff --git src/base/include/xsd/cxx/parser/validating/xml-schema-pimpl.txx src/base/include/xsd/cxx/parser/validating/xml-schema-pimpl.txx
new file mode 100644
index 0000000..55121c2
--- /dev/null
+++ src/base/include/xsd/cxx/parser/validating/xml-schema-pimpl.txx
@@ -0,0 +1,2746 @@
+// file      : xsd/cxx/parser/validating/xml-schema-pimpl.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#include <limits>
+#include <locale>
+
+#include <xsd/cxx/zc-istream.hxx>
+#include <xsd/cxx/parser/validating/exceptions.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      namespace validating
+      {
+        // Note that most of the types implemented here cannot have
+        // whitespaces in the value. As result we don't need to waste
+        // time collapsing whitespaces. All we need to do is trim the
+        // string representation which can be done without copying.
+        //
+
+        // Character table.
+        //
+        namespace bits
+        {
+          const unsigned char ncname_mask     = 0x1;
+          const unsigned char name_first_mask = 0x2;
+          const unsigned char name_mask       = 0x4;
+
+          template <typename C>
+          struct char_table
+          {
+            static C table[0x80];
+          };
+
+          template <typename C>
+          C char_table<C>::table[0x80] =
+          {
+            0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD8, 0xD0, 0x00, 0x00, 0xD0, 0x00, 0x00,
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+            0xD8, 0x48, 0x58, 0x48, 0x48, 0x48, 0x40, 0x58, 0x48, 0x48, 0x48, 0x48, 0x48, 0x4D, 0x4D, 0x58,
+            0x4D, 0x4D, 0x4D, 0x4D, 0x4D, 0x4D, 0x4D, 0x4D, 0x4D, 0x4D, 0x4E, 0x48, 0x50, 0x48, 0x58, 0x48,
+            0x48, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F,
+            0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x48, 0x48, 0x40, 0x48, 0x4F,
+            0x48, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F,
+            0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x48, 0x48, 0x48, 0x48, 0x48
+          };
+        }
+
+        // any_type
+        //
+
+        template <typename C>
+        void any_type_pimpl<C>::
+        post_any_type ()
+        {
+        }
+
+        // any_simple_type
+        //
+
+        template <typename C>
+        void any_simple_type_pimpl<C>::
+        post_any_simple_type ()
+        {
+        }
+
+        // boolean
+        //
+
+        template <typename C>
+        void boolean_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void boolean_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          str_ += s;
+        }
+
+        template <typename C>
+        void boolean_pimpl<C>::
+        _post ()
+        {
+          ro_string<C> str (str_);
+          trim (str);
+
+          if (str == bits::true_<C> () || str == bits::one<C> ())
+            value_ = true;
+          else if (str == bits::false_<C> () || str == bits::zero<C> ())
+            value_ = false;
+          else
+            throw invalid_value<C> (bits::boolean<C> (), str);
+        }
+
+        template <typename C>
+        bool boolean_pimpl<C>::
+        post_boolean ()
+        {
+          return value_;
+        }
+
+        // byte
+        //
+
+        template <typename C>
+        void byte_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void byte_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          str_ += s;
+        }
+
+        template <typename C>
+        void byte_pimpl<C>::
+        _post ()
+        {
+          ro_string<C> str (str_);
+          trim (str);
+
+          short t;
+          zc_istream<C> is (str);
+
+          if (is >> t && is.exhausted () && t >= -128 && t <= 127)
+            value_ = static_cast<signed char> (t);
+          else
+            throw invalid_value<C> (bits::byte<C> (), str);
+        }
+
+        template <typename C>
+        signed char byte_pimpl<C>::
+        post_byte ()
+        {
+          return value_;
+        }
+
+        // unsigned_byte
+        //
+
+        template <typename C>
+        void unsigned_byte_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void unsigned_byte_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          str_ += s;
+        }
+
+        template <typename C>
+        void unsigned_byte_pimpl<C>::
+        _post ()
+        {
+          ro_string<C> str (str_);
+          trim (str);
+
+          unsigned short t;
+          zc_istream<C> is (str);
+
+          if (is >> t && is.exhausted () && t <= 255)
+            value_ = static_cast<unsigned char> (t);
+          else
+            throw invalid_value<C> (bits::unsigned_byte<C> (), str);
+        }
+
+        template <typename C>
+        unsigned char unsigned_byte_pimpl<C>::
+        post_unsigned_byte ()
+        {
+          return value_;
+        }
+
+        // short
+        //
+
+        template <typename C>
+        void short_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void short_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          str_ += s;
+        }
+
+        template <typename C>
+        void short_pimpl<C>::
+        _post ()
+        {
+          ro_string<C> str (str_);
+          trim (str);
+
+          zc_istream<C> is (str);
+
+          if (!(is >> value_ && is.exhausted ()))
+            throw invalid_value<C> (bits::short_<C> (), str);
+        }
+
+        template <typename C>
+        short short_pimpl<C>::
+        post_short ()
+        {
+          return value_;
+        }
+
+
+        // unsigned_short
+        //
+
+        template <typename C>
+        void unsigned_short_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void unsigned_short_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          str_ += s;
+        }
+
+        template <typename C>
+        void unsigned_short_pimpl<C>::
+        _post ()
+        {
+          ro_string<C> str (str_);
+          trim (str);
+
+          zc_istream<C> is (str);
+
+          if (!(is >> value_ && is.exhausted ()))
+            throw invalid_value<C> (bits::unsigned_short<C> (), str);
+        }
+
+        template <typename C>
+        unsigned short unsigned_short_pimpl<C>::
+        post_unsigned_short ()
+        {
+          return value_;
+        }
+
+        // int
+        //
+
+        template <typename C>
+        void int_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void int_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          str_ += s;
+        }
+
+        template <typename C>
+        void int_pimpl<C>::
+        _post ()
+        {
+          ro_string<C> str (str_);
+          trim (str);
+
+          zc_istream<C> is (str);
+
+          if (!(is >> value_ && is.exhausted ()))
+            throw invalid_value<C> (bits::int_<C> (), str);
+        }
+
+        template <typename C>
+        int int_pimpl<C>::
+        post_int ()
+        {
+          return value_;
+        }
+
+
+        // unsigned_int
+        //
+
+        template <typename C>
+        void unsigned_int_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void unsigned_int_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          str_ += s;
+        }
+
+        template <typename C>
+        void unsigned_int_pimpl<C>::
+        _post ()
+        {
+          ro_string<C> str (str_);
+          trim (str);
+
+          zc_istream<C> is (str);
+
+          if (!(is >> value_ && is.exhausted ()))
+            throw invalid_value<C> (bits::unsigned_int<C> (), str);
+        }
+
+        template <typename C>
+        unsigned int unsigned_int_pimpl<C>::
+        post_unsigned_int ()
+        {
+          return value_;
+        }
+
+
+        // long
+        //
+        template <typename C>
+        void long_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void long_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          str_ += s;
+        }
+
+        template <typename C>
+        void long_pimpl<C>::
+        _post ()
+        {
+          ro_string<C> str (str_);
+          trim (str);
+
+          zc_istream<C> is (str);
+
+          if (!(is >> value_ && is.exhausted ()))
+            throw invalid_value<C> (bits::long_<C> (), str);
+        }
+
+        template <typename C>
+        long long long_pimpl<C>::
+        post_long ()
+        {
+          return value_;
+        }
+
+        // unsigned_long
+        //
+        template <typename C>
+        void unsigned_long_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void unsigned_long_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          str_ += s;
+        }
+
+        template <typename C>
+        void unsigned_long_pimpl<C>::
+        _post ()
+        {
+          ro_string<C> str (str_);
+          trim (str);
+
+          zc_istream<C> is (str);
+
+          if (!(is >> value_ && is.exhausted ()))
+            throw invalid_value<C> (bits::unsigned_long<C> (), str);
+        }
+
+        template <typename C>
+        unsigned long long unsigned_long_pimpl<C>::
+        post_unsigned_long ()
+        {
+          return value_;
+        }
+
+
+        // integer
+        //
+        template <typename C>
+        void integer_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void integer_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          str_ += s;
+        }
+
+        template <typename C>
+        void integer_pimpl<C>::
+        _post ()
+        {
+          ro_string<C> str (str_);
+          trim (str);
+
+          zc_istream<C> is (str);
+
+          if (!(is >> value_ && is.exhausted ()))
+            throw invalid_value<C> (bits::integer<C> (), str);
+        }
+
+        template <typename C>
+        long long integer_pimpl<C>::
+        post_integer ()
+        {
+          return value_;
+        }
+
+        // negative_integer
+        //
+        template <typename C>
+        void negative_integer_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void negative_integer_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          str_ += s;
+        }
+
+        template <typename C>
+        void negative_integer_pimpl<C>::
+        _post ()
+        {
+          ro_string<C> str (str_);
+          trim (str);
+
+          zc_istream<C> is (str);
+
+          if (!(is >> value_ && is.exhausted () && value_ < 0))
+            throw invalid_value<C> (bits::negative_integer<C> (), str);
+        }
+
+        template <typename C>
+        long long negative_integer_pimpl<C>::
+        post_negative_integer ()
+        {
+          return value_;
+        }
+
+
+        // non_positive_integer
+        //
+        template <typename C>
+        void non_positive_integer_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void non_positive_integer_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          str_ += s;
+        }
+
+        template <typename C>
+        void non_positive_integer_pimpl<C>::
+        _post ()
+        {
+          ro_string<C> str (str_);
+          trim (str);
+
+          zc_istream<C> is (str);
+
+          if (!(is >> value_ && is.exhausted () && value_ <= 0))
+            throw invalid_value<C> (bits::non_positive_integer<C> (), str);
+        }
+
+        template <typename C>
+        long long non_positive_integer_pimpl<C>::
+        post_non_positive_integer ()
+        {
+          return value_;
+        }
+
+        // positive_integer
+        //
+        template <typename C>
+        void positive_integer_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void positive_integer_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          str_ += s;
+        }
+
+        template <typename C>
+        void positive_integer_pimpl<C>::
+        _post ()
+        {
+          ro_string<C> str (str_);
+          trim (str);
+
+          zc_istream<C> is (str);
+
+          if (!(is >> value_ && is.exhausted () && value_ > 0))
+            throw invalid_value<C> (bits::positive_integer<C> (), str);
+        }
+
+        template <typename C>
+        unsigned long long positive_integer_pimpl<C>::
+        post_positive_integer ()
+        {
+          return value_;
+        }
+
+
+        // non_negative_integer
+        //
+        template <typename C>
+        void non_negative_integer_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void non_negative_integer_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          str_ += s;
+        }
+
+        template <typename C>
+        void non_negative_integer_pimpl<C>::
+        _post ()
+        {
+          ro_string<C> str (str_);
+          trim (str);
+
+          zc_istream<C> is (str);
+
+          if (!(is >> value_ && is.exhausted ()))
+            throw invalid_value<C> (bits::non_negative_integer<C> (), str);
+        }
+
+        template <typename C>
+        unsigned long long non_negative_integer_pimpl<C>::
+        post_non_negative_integer ()
+        {
+          return value_;
+        }
+
+
+        // float
+        //
+        template <typename C>
+        void float_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void float_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          str_ += s;
+        }
+
+        template <typename C>
+        void float_pimpl<C>::
+        _post ()
+        {
+          ro_string<C> str (str_);
+          trim (str);
+
+          if (str == bits::positive_inf<C> ())
+            value_ = std::numeric_limits<float>::infinity ();
+          else if (str == bits::negative_inf<C> ())
+            value_ = -std::numeric_limits<float>::infinity ();
+          else if (str == bits::nan<C> ())
+            value_ = std::numeric_limits<float>::quiet_NaN ();
+          else
+          {
+            zc_istream<C> is (str);
+            is.imbue (std::locale::classic ());
+
+            if (!(is >> value_ && is.exhausted ()))
+              throw invalid_value<C> (bits::float_<C> (), str);
+          }
+        }
+
+        template <typename C>
+        float float_pimpl<C>::
+        post_float ()
+        {
+          return value_;
+        }
+
+
+        // double
+        //
+        template <typename C>
+        void double_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void double_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          str_ += s;
+        }
+
+        template <typename C>
+        void double_pimpl<C>::
+        _post ()
+        {
+          ro_string<C> str (str_);
+          trim (str);
+
+          if (str == bits::positive_inf<C> ())
+            value_ = std::numeric_limits<double>::infinity ();
+          else if (str == bits::negative_inf<C> ())
+            value_ = -std::numeric_limits<double>::infinity ();
+          else if (str == bits::nan<C> ())
+            value_ = std::numeric_limits<double>::quiet_NaN ();
+          else
+          {
+            zc_istream<C> is (str);
+            is.imbue (std::locale::classic ());
+
+            if (!(is >> value_ && is.exhausted ()))
+              throw invalid_value<C> (bits::double_<C> (), str);
+          }
+        }
+
+        template <typename C>
+        double double_pimpl<C>::
+        post_double ()
+        {
+          return value_;
+        }
+
+        // decimal
+        //
+        template <typename C>
+        void decimal_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void decimal_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          str_ += s;
+        }
+
+        template <typename C>
+        void decimal_pimpl<C>::
+        _post ()
+        {
+          ro_string<C> str (str_);
+          trim (str);
+
+          zc_istream<C> is (str);
+          is.imbue (std::locale::classic ());
+
+          //@@ TODO: now we accept scientific notations and INF/NaN.
+          //
+          if (!(is >> value_ && is.exhausted ()))
+            throw invalid_value<C> (bits::decimal<C> (), str);
+        }
+
+        template <typename C>
+        double decimal_pimpl<C>::
+        post_decimal ()
+        {
+          return value_;
+        }
+
+        // string
+        //
+        template <typename C>
+        void string_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void string_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          str_ += s;
+        }
+
+        template <typename C>
+        std::basic_string<C> string_pimpl<C>::
+        post_string ()
+        {
+          std::basic_string<C> r;
+          r.swap (str_);
+          return r;
+        }
+
+        // normalized_string
+        //
+        template <typename C>
+        void normalized_string_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void normalized_string_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          str_ += s;
+        }
+
+        template <typename C>
+        std::basic_string<C> normalized_string_pimpl<C>::
+        post_normalized_string ()
+        {
+          typedef typename std::basic_string<C>::size_type size_type;
+
+          size_type size (str_.size ());
+
+          for (size_type i (0); i < size; ++i)
+          {
+            C& c = str_[i];
+
+            if (c == C (0x0A) || c == C (0x0D) || c == C (0x09))
+              c = C (0x20);
+          }
+
+          std::basic_string<C> r;
+          r.swap (str_);
+          return r;
+        }
+
+        // token
+        //
+        template <typename C>
+        void token_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void token_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          if (str_.size () == 0)
+          {
+            ro_string<C> tmp (s.data (), s.size ());
+
+            if (trim_left (tmp) != 0)
+              str_ += tmp;
+          }
+          else
+            str_ += s;
+        }
+
+        template <typename C>
+        std::basic_string<C> token_pimpl<C>::
+        post_token ()
+        {
+          typedef typename std::basic_string<C>::size_type size_type;
+
+          size_type size (str_.size ());
+          size_type j (0);
+
+          bool subs (false);
+
+          for (size_type i (0); i < size; ++i)
+          {
+            C c = str_[i];
+
+            if (c == C (0x20) || c == C (0x0A) ||
+                c == C (0x0D) || c == C (0x09))
+            {
+              subs = true;
+            }
+            else
+            {
+              if (subs)
+              {
+                subs = false;
+                str_[j++] = C (0x20);
+              }
+
+              str_[j++] = c;
+            }
+          }
+
+          str_.resize (j);
+
+          std::basic_string<C> r;
+          r.swap (str_);
+          return r;
+        }
+
+        // name
+        //
+        template <typename C>
+        void name_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void name_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          if (str_.size () == 0)
+          {
+            ro_string<C> tmp (s.data (), s.size ());
+
+            if (trim_left (tmp) != 0)
+              str_ += tmp;
+          }
+          else
+            str_ += s;
+        }
+
+        template <typename C>
+        void name_pimpl<C>::
+        _post ()
+        {
+          typedef typename ro_string<C>::size_type size_type;
+
+          ro_string<C> tmp (str_);
+          size_type size (trim_right (tmp));
+
+          // For now we are only checking the US-ASCII characters.
+          //
+
+          bool ok (size != 0);
+
+          if (ok)
+          {
+            unsigned int c (static_cast<unsigned int> (str_[0]));
+
+            ok = c >= 0x80 ||
+              (bits::char_table<unsigned char>::table[c] &
+               bits::name_first_mask);
+
+            if (ok)
+            {
+              for (size_type i (1); i < size; ++i)
+              {
+                c = static_cast<unsigned int> (str_[i]);
+
+                if (c < 0x80 &&
+                    !(bits::char_table<unsigned char>::table[c] &
+                      bits::name_mask))
+                {
+                  ok = false;
+                  break;
+                }
+              }
+            }
+          }
+
+          if (!ok)
+            throw invalid_value<C> (bits::name<C> (), tmp);
+
+          str_.resize (size);
+        }
+
+        template <typename C>
+        std::basic_string<C> name_pimpl<C>::
+        post_name ()
+        {
+          std::basic_string<C> r;
+          r.swap (str_);
+          return r;
+        }
+
+        // nmtoken
+        //
+        template <typename C>
+        void nmtoken_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void nmtoken_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          if (str_.size () == 0)
+          {
+            ro_string<C> tmp (s.data (), s.size ());
+
+            if (trim_left (tmp) != 0)
+              str_ += tmp;
+          }
+          else
+            str_ += s;
+        }
+
+        template <typename C>
+        void nmtoken_pimpl<C>::
+        _post ()
+        {
+          typedef typename ro_string<C>::size_type size_type;
+
+          ro_string<C> tmp (str_);
+          size_type size (trim_right (tmp));
+
+          // For now we are only checking the US-ASCII characters.
+          //
+
+          bool ok (size != 0);
+
+          if (ok)
+          {
+            for (size_type i (0); i < size; ++i)
+            {
+              unsigned int c (static_cast<unsigned int> (str_[i]));
+
+              if (c < 0x80 &&
+                  !(bits::char_table<unsigned char>::table[c] &
+                    bits::name_mask))
+              {
+                ok = false;
+                break;
+              }
+            }
+          }
+
+          if (!ok)
+            throw invalid_value<C> (bits::nmtoken<C> (), tmp);
+
+          str_.resize (size);
+        }
+
+        template <typename C>
+        std::basic_string<C> nmtoken_pimpl<C>::
+        post_nmtoken ()
+        {
+          std::basic_string<C> r;
+          r.swap (str_);
+          return r;
+        }
+
+        // nmtokens
+        //
+        template <typename C>
+        void nmtokens_pimpl<C>::
+        _pre ()
+        {
+          nmtokens_pskel<C>::_pre ();
+          seq_.clear ();
+        }
+
+        template <typename C>
+        void nmtokens_pimpl<C>::
+        _post ()
+        {
+          nmtokens_pskel<C>::_post ();
+
+          // Should have at least one element.
+          //
+          if (seq_.size () < 1)
+          {
+            ro_string<C> tmp;
+            throw invalid_value<C> (bits::nmtokens<C> (), tmp);
+          }
+        }
+
+        template <typename C>
+        string_sequence<C> nmtokens_pimpl<C>::
+        post_nmtokens ()
+        {
+          string_sequence<C> r;
+          r.swap (seq_);
+          return r;
+        }
+
+        template <typename C>
+        void nmtokens_pimpl<C>::
+        _xsd_parse_item (const ro_string<C>& s)
+        {
+          parser_.pre ();
+          parser_._pre ();
+          parser_._characters (s);
+          parser_._post ();
+          seq_.push_back (parser_.post_nmtoken ());
+        }
+
+        // ncname
+        //
+        namespace bits
+        {
+          template <typename C>
+          bool
+          valid_ncname (const C* s, typename ro_string<C>::size_type size)
+          {
+            typedef typename ro_string<C>::size_type size_type;
+
+            // For now we are only checking the US-ASCII characters.
+            //
+            bool ok (size != 0);
+
+            if (ok)
+            {
+              unsigned int c (static_cast<unsigned int> (s[0]));
+
+              ok = c >= 0x80 ||
+                ((bits::char_table<unsigned char>::table[c] &
+                  bits::name_first_mask) && c != C (':'));
+
+              if (ok)
+              {
+                for (size_type i (1); i < size; ++i)
+                {
+                  c = static_cast<unsigned int> (s[i]);
+
+                  if (c < 0x80 &&
+                      !(bits::char_table<unsigned char>::table[c] &
+                        bits::ncname_mask))
+                  {
+                    ok = false;
+                    break;
+                  }
+                }
+              }
+            }
+
+            return ok;
+          }
+        }
+
+        template <typename C>
+        void ncname_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void ncname_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          if (str_.size () == 0)
+          {
+            ro_string<C> tmp (s.data (), s.size ());
+
+            if (trim_left (tmp) != 0)
+              str_ += tmp;
+          }
+          else
+            str_ += s;
+        }
+
+        template <typename C>
+        void ncname_pimpl<C>::
+        _post ()
+        {
+          typedef typename ro_string<C>::size_type size_type;
+
+          ro_string<C> tmp (str_);
+          size_type size (trim_right (tmp));
+
+          if (!bits::valid_ncname (tmp.data (), size))
+            throw invalid_value<C> (bits::ncname<C> (), tmp);
+
+          str_.resize (size);
+        }
+
+        template <typename C>
+        std::basic_string<C> ncname_pimpl<C>::
+        post_ncname ()
+        {
+          std::basic_string<C> r;
+          r.swap (str_);
+          return r;
+        }
+
+        // id
+        //
+        template <typename C>
+        void id_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void id_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          if (str_.size () == 0)
+          {
+            ro_string<C> tmp (s.data (), s.size ());
+
+            if (trim_left (tmp) != 0)
+              str_ += tmp;
+          }
+          else
+            str_ += s;
+        }
+
+        template <typename C>
+        void id_pimpl<C>::
+        _post ()
+        {
+          typedef typename ro_string<C>::size_type size_type;
+
+          ro_string<C> tmp (str_);
+          size_type size (trim_right (tmp));
+
+          if (!bits::valid_ncname (tmp.data (), size))
+            throw invalid_value<C> (bits::id<C> (), tmp);
+
+          str_.resize (size);
+        }
+
+        template <typename C>
+        std::basic_string<C> id_pimpl<C>::
+        post_id ()
+        {
+          std::basic_string<C> r;
+          r.swap (str_);
+          return r;
+        }
+
+        // idref
+        //
+        template <typename C>
+        void idref_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void idref_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          if (str_.size () == 0)
+          {
+            ro_string<C> tmp (s.data (), s.size ());
+
+            if (trim_left (tmp) != 0)
+              str_ += tmp;
+          }
+          else
+            str_ += s;
+        }
+
+        template <typename C>
+        void idref_pimpl<C>::
+        _post ()
+        {
+          typedef typename ro_string<C>::size_type size_type;
+
+          ro_string<C> tmp (str_);
+          size_type size (trim_right (tmp));
+
+          if (!bits::valid_ncname (tmp.data (), size))
+            throw invalid_value<C> (bits::idref<C> (), tmp);
+
+          str_.resize (size);
+        }
+
+        template <typename C>
+        std::basic_string<C> idref_pimpl<C>::
+        post_idref ()
+        {
+          std::basic_string<C> r;
+          r.swap (str_);
+          return r;
+        }
+
+        // idrefs
+        //
+        template <typename C>
+        void idrefs_pimpl<C>::
+        _pre ()
+        {
+          idrefs_pskel<C>::_pre ();
+          seq_.clear ();
+        }
+
+        template <typename C>
+        void idrefs_pimpl<C>::
+        _post ()
+        {
+          idrefs_pskel<C>::_post ();
+
+          // Should have at least one element.
+          //
+          if (seq_.size () < 1)
+          {
+            ro_string<C> tmp;
+            throw invalid_value<C> (bits::idrefs<C> (), tmp);
+          }
+        }
+
+        template <typename C>
+        string_sequence<C> idrefs_pimpl<C>::
+        post_idrefs ()
+        {
+          string_sequence<C> r;
+          r.swap (seq_);
+          return r;
+        }
+
+        template <typename C>
+        void idrefs_pimpl<C>::
+        _xsd_parse_item (const ro_string<C>& s)
+        {
+          parser_.pre ();
+          parser_._pre ();
+          parser_._characters (s);
+          parser_._post ();
+          seq_.push_back (parser_.post_idref ());
+        }
+
+        // language
+        //
+        template <typename C>
+        void language_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void language_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          if (str_.size () == 0)
+          {
+            ro_string<C> tmp (s.data (), s.size ());
+
+            if (trim_left (tmp) != 0)
+              str_ += tmp;
+          }
+          else
+            str_ += s;
+        }
+
+        template <typename C>
+        void language_pimpl<C>::
+        _post ()
+        {
+          typedef typename ro_string<C>::size_type size_type;
+
+          ro_string<C> tmp (str_);
+          size_type size (trim_right (tmp));
+
+          // language := ALPHA{1,8} *(-(ALPHA | DIGIT){1,8})
+          //
+          bool ok (true);
+
+          for (size_type tag (0), i (0); ; ++tag)
+          {
+            size_type n (0);
+
+            for (; i < size && n < 8; ++n, ++i)
+            {
+              C c (tmp[i]);
+
+              if (!((c >= C ('a') && c <= C ('z')) ||
+                    (c >= C ('A') && c <= C ('Z')) ||
+                    (tag != 0 && c >= C ('0') && c <= C ('9'))))
+                break;
+            }
+
+            if (n == 0)
+            {
+              ok = false;
+              break;
+            }
+
+            if (i == size)
+              break;
+
+            if (tmp[i++] != C ('-'))
+            {
+              ok = false;
+              break;
+            }
+          }
+
+          if (!ok)
+            throw invalid_value<C> (bits::language<C> (), tmp);
+
+          str_.resize (size);
+        }
+
+        template <typename C>
+        std::basic_string<C> language_pimpl<C>::
+        post_language ()
+        {
+          std::basic_string<C> r;
+          r.swap (str_);
+          return r;
+        }
+
+        // uri
+        //
+        template <typename C>
+        void uri_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void uri_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          if (str_.size () == 0)
+          {
+            ro_string<C> tmp (s.data (), s.size ());
+
+            if (trim_left (tmp) != 0)
+              str_ += tmp;
+          }
+          else
+            str_ += s;
+        }
+
+        template <typename C>
+        std::basic_string<C> uri_pimpl<C>::
+        post_uri ()
+        {
+          // According to Datatypes 3.2.17 and RFC2396 pretty much anything
+          // can be a URI and conforming processors do not need to figure
+          // out and verify particular URI schemes.
+          //
+          ro_string<C> tmp (str_);
+          str_.resize (trim_right (tmp));
+
+          std::basic_string<C> r;
+          r.swap (str_);
+          return r;
+        }
+
+        // qname
+        //
+        template <typename C>
+        void qname_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void qname_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          if (str_.size () == 0)
+          {
+            ro_string<C> tmp (s.data (), s.size ());
+
+            if (trim_left (tmp) != 0)
+              str_ += tmp;
+          }
+          else
+            str_ += s;
+        }
+
+        template <typename C>
+        void qname_pimpl<C>::
+        _post ()
+        {
+          typedef typename ro_string<C>::size_type size_type;
+
+          ro_string<C> tmp (str_);
+          size_type size (trim_right (tmp));
+          size_type pos (tmp.find (C (':')));
+
+          const C* s (tmp.data ());
+
+          if (pos != ro_string<C>::npos)
+          {
+            if (!bits::valid_ncname (s, pos) ||
+                !bits::valid_ncname (s + pos + 1, size - pos - 1))
+              throw invalid_value<C> (bits::qname<C> (), tmp);
+
+            prefix_.assign (s, pos);
+            name_.assign (s + pos + 1, size - pos - 1);
+          }
+          else
+          {
+            if (!bits::valid_ncname (s, size))
+              throw invalid_value<C> (bits::qname<C> (), tmp);
+
+            prefix_.clear ();
+            str_.resize (size);
+            name_.swap (str_);
+          }
+        }
+
+        template <typename C>
+        qname<C> qname_pimpl<C>::
+        post_qname ()
+        {
+          return prefix_.empty ()
+            ? qname<C> (name_)
+            : qname<C> (prefix_, name_);
+        }
+
+        // base64_binary
+        //
+        template <typename C>
+        void base64_binary_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void base64_binary_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          if (str_.size () == 0)
+          {
+            ro_string<C> tmp (s.data (), s.size ());
+
+            if (trim_left (tmp) != 0)
+              str_ += tmp;
+          }
+          else
+            str_ += s;
+        }
+
+        namespace bits
+        {
+          template <typename C>
+          inline unsigned char
+          base64_decode (C c)
+          {
+            unsigned char r (0xFF);
+
+            if (c >= C('A') && c <= C ('Z'))
+              r = static_cast<unsigned char> (c - C ('A'));
+            else if (c >= C('a') && c <= C ('z'))
+              r = static_cast<unsigned char> (c - C ('a') + 26);
+            else if (c >= C('0') && c <= C ('9'))
+              r = static_cast<unsigned char> (c - C ('0') + 52);
+            else if (c == C ('+'))
+              r = 62;
+            else if (c == C ('/'))
+              r = 63;
+
+            return r;
+          }
+        }
+
+        template <typename C>
+        void base64_binary_pimpl<C>::
+        _post ()
+        {
+          typedef typename std::basic_string<C>::size_type size_type;
+
+          size_type size (str_.size ());
+          const C* src (str_.c_str ());
+
+          // Remove all whitespaces.
+          //
+          {
+            size_type j (0);
+
+            bool subs (false);
+
+            for (size_type i (0); i < size; ++i)
+            {
+              C c = str_[i];
+
+              if (c == C (0x20) || c == C (0x0A) ||
+                  c == C (0x0D) || c == C (0x09))
+              {
+                subs = true;
+              }
+              else
+              {
+                if (subs)
+                  subs = false;
+
+                str_[j++] = c;
+              }
+            }
+
+            size = j;
+            str_.resize (size);
+          }
+
+          // Our length should be a multiple of four.
+          //
+          if (size == 0 || size % 4 != 0)
+            throw invalid_value<C> (bits::base64_binary<C> (), str_);
+
+          size_type quad_count (size / 4);
+          size_type capacity (quad_count * 3 + 1);
+
+          buf_.reset (new buffer (capacity, capacity));
+          char* dst (buf_->data ());
+
+          size_type si (0), di (0); // Source and destination indexes.
+
+          // Process all quads except the last one.
+          //
+          unsigned char b1, b2, b3, b4;
+
+          for (size_type q (0); q < quad_count - 1; ++q)
+          {
+            b1 = bits::base64_decode (src[si++]);
+            b2 = bits::base64_decode (src[si++]);
+            b3 = bits::base64_decode (src[si++]);
+            b4 = bits::base64_decode (src[si++]);
+
+            if (b1 == 0xFF || b2 == 0xFF || b3 == 0xFF || b4 == 0xFF)
+              throw invalid_value<C> (bits::base64_binary<C> (), str_);
+
+            dst[di++] = (b1 << 2) | (b2 >> 4);
+            dst[di++] = (b2 << 4) | (b3 >> 2);
+            dst[di++] = (b3 << 6) | b4;
+          }
+
+          // Process the last quad. The first two octets are always there.
+          //
+          b1 = bits::base64_decode (src[si++]);
+          b2 = bits::base64_decode (src[si++]);
+
+          if (b1 == 0xFF || b2 == 0xFF)
+            throw invalid_value<C> (bits::base64_binary<C> (), str_);
+
+          C e3 (src[si++]);
+          C e4 (src[si++]);
+
+          if (e4 == C ('='))
+          {
+            if (e3 == C ('='))
+            {
+              // Two pads. Last 4 bits in b2 should be zero.
+              //
+              if ((b2 & 0x0F) != 0)
+                throw invalid_value<C> (bits::base64_binary<C> (), str_);
+
+              dst[di++] = (b1 << 2) | (b2 >> 4);
+            }
+            else
+            {
+              // One pad. Last 2 bits in b3 should be zero.
+              //
+              b3 = bits::base64_decode (e3);
+
+              if (b3 == 0xFF || (b3 & 0x03) != 0)
+                throw invalid_value<C> (bits::base64_binary<C> (), str_);
+
+              dst[di++] = (b1 << 2) | (b2 >> 4);
+              dst[di++] = (b2 << 4) | (b3 >> 2);
+            }
+          }
+          else
+          {
+            // No pads.
+            //
+            b3 = bits::base64_decode (e3);
+            b4 = bits::base64_decode (e4);
+
+            if (b3 == 0xFF || b4 == 0xFF)
+              throw invalid_value<C> (bits::base64_binary<C> (), str_);
+
+            dst[di++] = (b1 << 2) | (b2 >> 4);
+            dst[di++] = (b2 << 4) | (b3 >> 2);
+            dst[di++] = (b3 << 6) | b4;
+          }
+
+          // Set the real size.
+          //
+          buf_->size (di);
+        }
+
+        template <typename C>
+        std::auto_ptr<buffer> base64_binary_pimpl<C>::
+        post_base64_binary ()
+        {
+          return buf_;
+        }
+
+        // hex_binary
+        //
+        template <typename C>
+        void hex_binary_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void hex_binary_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          if (str_.size () == 0)
+          {
+            ro_string<C> tmp (s.data (), s.size ());
+
+            if (trim_left (tmp) != 0)
+              str_ += tmp;
+          }
+          else
+            str_ += s;
+        }
+
+        namespace bits
+        {
+          template <typename C>
+          inline unsigned char
+          hex_decode (C c)
+          {
+            unsigned char r (0xFF);
+
+            if (c >= C('0') && c <= C ('9'))
+              r = static_cast<unsigned char> (c - C ('0'));
+            else if (c >= C ('A') && c <= C ('F'))
+              r = static_cast<unsigned char> (10 + (c - C ('A')));
+            else if (c >= C ('a') && c <= C ('f'))
+              r = static_cast<unsigned char> (10 + (c - C ('a')));
+
+            return r;
+          }
+        }
+
+        template <typename C>
+        void hex_binary_pimpl<C>::
+        _post ()
+        {
+          typedef typename ro_string<C>::size_type size_type;
+
+          ro_string<C> tmp (str_);
+          size_type size (trim_right (tmp));
+
+          if (size % 2 != 0)
+            throw invalid_value<C> (bits::hex_binary<C> (), tmp);
+
+          buffer::size_t n (size / 2);
+          buf_.reset (new buffer (n));
+
+          if (n != 0)
+          {
+            const C* src (tmp.data ());
+            char* dst (buf_->data ());
+            buffer::size_t i (0);
+
+            for (; i < n; ++i)
+            {
+              unsigned char h (bits::hex_decode (src[2 * i]));
+              unsigned char l (bits::hex_decode (src[2 * i + 1]));
+
+              if (h == 0xFF || l == 0xFF)
+                break;
+
+              dst[i] = (h << 4) | l;
+            }
+
+            if (i != n)
+              throw invalid_value<C> (bits::hex_binary<C> (), tmp);
+          }
+        }
+
+        template <typename C>
+        std::auto_ptr<buffer> hex_binary_pimpl<C>::
+        post_hex_binary ()
+        {
+          return buf_;
+        }
+
+        // time_zone
+        //
+        namespace bits
+        {
+          // Datatypes 3.2.7.3. Return false if time zone is invalid.
+          //
+          template <typename C>
+          bool
+          parse_tz (const C* s,
+                    typename std::basic_string<C>::size_type n,
+                    short& h, short& m)
+          {
+            // time_zone := Z|(+|-)HH:MM
+            //
+            if (n == 0)
+            {
+              return false;
+            }
+            else if (s[0] == 'Z')
+            {
+              if (n != 1)
+                return false;
+
+              h = 0;
+              m = 0;
+            }
+            else
+            {
+              if (n != 6 || (s[0] != '-' && s[0] != '+') || s[3] != ':')
+                return false;
+
+              // Parse hours.
+              //
+              char d1 = s[1];
+              char d2 = s[2];
+
+              if (d1 < '0' || d1 > '9' || d2 < '0' || d2 > '9')
+                return false;
+
+              h = 10 * (d1 - '0') + (d2 - '0');
+
+              if (h > 14)
+                return false;
+
+              // Parse minutes.
+              //
+              d1 = s[4];
+              d2 = s[5];
+
+              if (d1 < '0' || d1 > '9' || d2 < '0' || d2 > '9')
+                return false;
+
+              m = 10 * (d1 - '0') + (d2 - '0');
+
+              if (m > 59 || (h == 14 && m != 0))
+                return false;
+
+              if (s[0] == '-')
+              {
+                h = -h;
+                m = -m;
+              }
+            }
+
+            return true;
+          }
+        }
+
+        // gday
+        //
+        template <typename C>
+        void gday_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void gday_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          if (str_.size () == 0)
+          {
+            ro_string<C> tmp (s.data (), s.size ());
+
+            if (trim_left (tmp) != 0)
+              str_ += tmp;
+          }
+          else
+            str_ += s;
+        }
+
+        template <typename C>
+        void gday_pimpl<C>::
+        _post ()
+        {
+          typedef typename ro_string<C>::size_type size_type;
+
+          ro_string<C> tmp (str_);
+          size_type size (trim_right (tmp));
+          const C* s (tmp.data ());
+
+          // gday := ---DD[Z|(+|-)HH:MM]
+          //
+          if (size < 5 ||
+              s[0] != C ('-') || s[1] != C ('-') || s[2] != C ('-'))
+            throw invalid_value<C> (bits::gday<C> (), tmp);
+
+          C d1 (s[3]), d2 (s[4]);
+
+          if (d1 < '0' || d1 > '9' || d2 < '0' || d2 > '9')
+            throw invalid_value<C> (bits::gday<C> (), tmp);
+
+          day_ = 10 * (d1 - '0') + (d2 - '0');
+
+          if (day_ < 1 || day_ > 31)
+            throw invalid_value<C> (bits::gday<C> (), tmp);
+
+          if (size > 5)
+          {
+            if (!bits::parse_tz (s + 5, size - 5, zh_, zm_))
+              throw invalid_value<C> (bits::gday<C> (), tmp);
+
+            z_ = true;
+          }
+          else
+            z_ = false;
+        }
+
+        template <typename C>
+        gday gday_pimpl<C>::
+        post_gday ()
+        {
+          return z_ ? gday (day_, zh_, zm_) : gday (day_);
+        }
+
+        // gmonth
+        //
+        template <typename C>
+        void gmonth_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void gmonth_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          if (str_.size () == 0)
+          {
+            ro_string<C> tmp (s.data (), s.size ());
+
+            if (trim_left (tmp) != 0)
+              str_ += tmp;
+          }
+          else
+            str_ += s;
+        }
+
+        template <typename C>
+        void gmonth_pimpl<C>::
+        _post ()
+        {
+          typedef typename ro_string<C>::size_type size_type;
+
+          ro_string<C> tmp (str_);
+          size_type size (trim_right (tmp));
+          const C* s (tmp.data ());
+
+          // gmonth := --MM[Z|(+|-)HH:MM]
+          //
+          if (size < 4 || s[0] != C ('-') || s[1] != C ('-'))
+            throw invalid_value<C> (bits::gmonth<C> (), tmp);
+
+          C d1 (s[2]), d2 (s[3]);
+
+          if (d1 < '0' || d1 > '9' || d2 < '0' || d2 > '9')
+            throw invalid_value<C> (bits::gmonth<C> (), tmp);
+
+          month_ = 10 * (d1 - '0') + (d2 - '0');
+
+          if (month_ < 1 || month_ > 12)
+            throw invalid_value<C> (bits::gmonth<C> (), tmp);
+
+          if (size > 4)
+          {
+            if (!bits::parse_tz (s + 4, size - 4, zh_, zm_))
+              throw invalid_value<C> (bits::gmonth<C> (), tmp);
+
+            z_ = true;
+          }
+          else
+            z_ = false;
+        }
+
+        template <typename C>
+        gmonth gmonth_pimpl<C>::
+        post_gmonth ()
+        {
+          return z_ ? gmonth (month_, zh_, zm_) : gmonth (month_);
+        }
+
+        // gyear
+        //
+        template <typename C>
+        void gyear_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void gyear_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          if (str_.size () == 0)
+          {
+            ro_string<C> tmp (s.data (), s.size ());
+
+            if (trim_left (tmp) != 0)
+              str_ += tmp;
+          }
+          else
+            str_ += s;
+        }
+
+        template <typename C>
+        void gyear_pimpl<C>::
+        _post ()
+        {
+          typedef typename ro_string<C>::size_type size_type;
+
+          ro_string<C> tmp (str_);
+          size_type size (trim_right (tmp));
+          const C* s (tmp.data ());
+
+          // gyear := [-]CCYY[N]*[Z|(+|-)HH:MM]
+          //
+
+          if (size < 4 || (s[0] == C ('-') && size < 5))
+            throw invalid_value<C> (bits::gyear<C> (), tmp);
+
+          // Find the end of the year token.
+          //
+          size_type pos (s[0] == C ('-') ? 5 : 4);
+          for (; pos < size; ++pos)
+          {
+            C c (s[pos]);
+
+            if (c == C ('Z') || c == C ('+') || c == C ('-'))
+              break;
+          }
+
+          ro_string<C> year_fragment (s, pos);
+          zc_istream<C> is (year_fragment);
+
+          if (!(is >> year_ && is.exhausted () && year_ != 0))
+            throw invalid_value<C> (bits::gyear<C> (), tmp);
+
+          if (pos < size)
+          {
+            if (!bits::parse_tz (s + pos, size - pos, zh_, zm_))
+              throw invalid_value<C> (bits::gyear<C> (), tmp);
+
+            z_ = true;
+          }
+          else
+            z_ = false;
+        }
+
+        template <typename C>
+        gyear gyear_pimpl<C>::
+        post_gyear ()
+        {
+          return z_ ? gyear (year_, zh_, zm_) : gyear (year_);
+        }
+
+        // gmonth_day
+        //
+        template <typename C>
+        void gmonth_day_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void gmonth_day_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          if (str_.size () == 0)
+          {
+            ro_string<C> tmp (s.data (), s.size ());
+
+            if (trim_left (tmp) != 0)
+              str_ += tmp;
+          }
+          else
+            str_ += s;
+        }
+
+        template <typename C>
+        void gmonth_day_pimpl<C>::
+        _post ()
+        {
+          typedef typename ro_string<C>::size_type size_type;
+
+          ro_string<C> tmp (str_);
+          size_type size (trim_right (tmp));
+          const C* s (tmp.data ());
+
+          // gmonth_day := --MM-DD[Z|(+|-)HH:MM]
+          //
+          if (size < 7 ||
+              s[0] != C ('-') || s[1] != C ('-') || s[4] != C ('-'))
+            throw invalid_value<C> (bits::gmonth_day<C> (), tmp);
+
+          // month
+          //
+          C d1 (s[2]), d2 (s[3]);
+
+          if (d1 < '0' || d1 > '9' || d2 < '0' || d2 > '9')
+            throw invalid_value<C> (bits::gmonth_day<C> (), tmp);
+
+          month_ = 10 * (d1 - '0') + (d2 - '0');
+
+          if (month_ < 1 || month_ > 12)
+            throw invalid_value<C> (bits::gmonth_day<C> (), tmp);
+
+          // day
+          //
+          d1 = s[5];
+          d2 = s[6];
+
+          if (d1 < '0' || d1 > '9' || d2 < '0' || d2 > '9')
+            throw invalid_value<C> (bits::gmonth_day<C> (), tmp);
+
+          day_ = 10 * (d1 - '0') + (d2 - '0');
+
+          if (day_ < 1 || day_ > 31)
+            throw invalid_value<C> (bits::gmonth_day<C> (), tmp);
+
+          // zone
+          //
+          if (size > 7)
+          {
+            if (!bits::parse_tz (s + 7, size - 7, zh_, zm_))
+              throw invalid_value<C> (bits::gmonth_day<C> (), tmp);
+
+            z_ = true;
+          }
+          else
+            z_ = false;
+        }
+
+        template <typename C>
+        gmonth_day gmonth_day_pimpl<C>::
+        post_gmonth_day ()
+        {
+          return z_
+            ? gmonth_day (month_, day_, zh_, zm_)
+            : gmonth_day (month_, day_);
+        }
+
+        // gyear_month
+        //
+        template <typename C>
+        void gyear_month_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void gyear_month_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          if (str_.size () == 0)
+          {
+            ro_string<C> tmp (s.data (), s.size ());
+
+            if (trim_left (tmp) != 0)
+              str_ += tmp;
+          }
+          else
+            str_ += s;
+        }
+
+        template <typename C>
+        void gyear_month_pimpl<C>::
+        _post ()
+        {
+          typedef typename ro_string<C>::size_type size_type;
+
+          ro_string<C> tmp (str_);
+          size_type size (trim_right (tmp));
+          const C* s (tmp.data ());
+
+          // gyear_month := [-]CCYY[N]*-MM[Z|(+|-)HH:MM]
+          //
+
+          if (size < 7 || (s[0] == C ('-') && size < 8))
+            throw invalid_value<C> (bits::gyear_month<C> (), tmp);
+
+          // Find the end of the year token.
+          //
+          size_type pos (tmp.find (C ('-'), s[0] == C ('-') ? 5 : 4));
+
+          if (pos == ro_string<C>::npos || (size - pos - 1) < 2)
+            throw invalid_value<C> (bits::gyear_month<C> (), tmp);
+
+          ro_string<C> year_fragment (s, pos);
+          zc_istream<C> yis (year_fragment);
+
+          if (!(yis >> year_ && yis.exhausted () && year_ != 0))
+            throw invalid_value<C> (bits::gyear_month<C> (), tmp);
+
+          // month
+          //
+          C d1 (s[pos + 1]), d2 (s[pos + 2]);
+
+          if (d1 < '0' || d1 > '9' || d2 < '0' || d2 > '9')
+            throw invalid_value<C> (bits::gyear_month<C> (), tmp);
+
+          month_ = 10 * (d1 - '0') + (d2 - '0');
+
+          if (month_ < 1 || month_ > 12)
+            throw invalid_value<C> (bits::gyear_month<C> (), tmp);
+
+          // zone
+          //
+          pos += 3;
+
+          if (pos < size)
+          {
+            if (!bits::parse_tz (s + pos, size - pos, zh_, zm_))
+              throw invalid_value<C> (bits::gyear_month<C> (), tmp);
+
+            z_ = true;
+          }
+          else
+            z_ = false;
+        }
+
+        template <typename C>
+        gyear_month gyear_month_pimpl<C>::
+        post_gyear_month ()
+        {
+          return z_
+            ? gyear_month (year_, month_, zh_, zm_)
+            : gyear_month (year_, month_);
+        }
+
+        // date
+        //
+        template <typename C>
+        void date_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void date_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          if (str_.size () == 0)
+          {
+            ro_string<C> tmp (s.data (), s.size ());
+
+            if (trim_left (tmp) != 0)
+              str_ += tmp;
+          }
+          else
+            str_ += s;
+        }
+
+        template <typename C>
+        void date_pimpl<C>::
+        _post ()
+        {
+          typedef typename ro_string<C>::size_type size_type;
+
+          ro_string<C> tmp (str_);
+          size_type size (trim_right (tmp));
+          const C* s (tmp.data ());
+
+          // date := [-]CCYY[N]*-MM-DD[Z|(+|-)HH:MM]
+          //
+
+          if (size < 10 || (s[0] == C ('-') && size < 11))
+            throw invalid_value<C> (bits::date<C> (), tmp);
+
+          // Find the end of the year token.
+          //
+          size_type pos (tmp.find (C ('-'), s[0] == C ('-') ? 5 : 4));
+
+          if (pos == ro_string<C>::npos
+              || (size - pos - 1) < 5
+              || s[pos + 3] != C ('-'))
+            throw invalid_value<C> (bits::date<C> (), tmp);
+
+          ro_string<C> year_fragment (s, pos);
+          zc_istream<C> yis (year_fragment);
+
+          if (!(yis >> year_ && yis.exhausted () && year_ != 0))
+            throw invalid_value<C> (bits::date<C> (), tmp);
+
+          // month
+          //
+          C d1 (s[pos + 1]), d2 (s[pos + 2]);
+
+          if (d1 < '0' || d1 > '9' || d2 < '0' || d2 > '9')
+            throw invalid_value<C> (bits::date<C> (), tmp);
+
+          month_ = 10 * (d1 - '0') + (d2 - '0');
+
+          if (month_ < 1 || month_ > 12)
+            throw invalid_value<C> (bits::date<C> (), tmp);
+
+          // day
+          //
+          d1 = s[pos + 4];
+          d2 = s[pos + 5];
+
+          if (d1 < '0' || d1 > '9' || d2 < '0' || d2 > '9')
+            throw invalid_value<C> (bits::date<C> (), tmp);
+
+          day_ = 10 * (d1 - '0') + (d2 - '0');
+
+          if (day_ < 1 || day_ > 31)
+            throw invalid_value<C> (bits::date<C> (), tmp);
+
+          // zone
+          //
+          pos += 6;
+
+          if (pos < size)
+          {
+            if (!bits::parse_tz (s + pos, size - pos, zh_, zm_))
+              throw invalid_value<C> (bits::date<C> (), tmp);
+
+            z_ = true;
+          }
+          else
+            z_ = false;
+        }
+
+        template <typename C>
+        date date_pimpl<C>::
+        post_date ()
+        {
+          return z_
+            ? date (year_, month_, day_, zh_, zm_)
+            : date (year_, month_, day_);
+        }
+
+        // time
+        //
+        template <typename C>
+        void time_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void time_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          if (str_.size () == 0)
+          {
+            ro_string<C> tmp (s.data (), s.size ());
+
+            if (trim_left (tmp) != 0)
+              str_ += tmp;
+          }
+          else
+            str_ += s;
+        }
+
+        template <typename C>
+        void time_pimpl<C>::
+        _post ()
+        {
+          typedef typename ro_string<C>::size_type size_type;
+
+          ro_string<C> tmp (str_);
+          size_type size (trim_right (tmp));
+          const C* s (tmp.data ());
+
+          // time := HH:MM:SS[.S+][Z|(+|-)HH:MM]
+          //
+
+          if (size < 8 || s[2] != C (':') || s[5] != C (':'))
+            throw invalid_value<C> (bits::time<C> (), tmp);
+
+          // hours
+          //
+          C d1 (s[0]), d2 (s[1]);
+
+          if (d1 < '0' || d1 > '9' || d2 < '0' || d2 > '9')
+            throw invalid_value<C> (bits::time<C> (), tmp);
+
+          hours_ = 10 * (d1 - '0') + (d2 - '0');
+
+          if (hours_ > 24)
+            throw invalid_value<C> (bits::time<C> (), tmp);
+
+          // minutes
+          //
+          d1 = s[3];
+          d2 = s[4];
+
+          if (d1 < '0' || d1 > '9' || d2 < '0' || d2 > '9')
+            throw invalid_value<C> (bits::time<C> (), tmp);
+
+          minutes_ = 10 * (d1 - '0') + (d2 - '0');
+
+          if (minutes_ > 59)
+            throw invalid_value<C> (bits::time<C> (), tmp);
+
+          // Find the end of the seconds fragment.
+          //
+          size_type pos (8);
+          for (; pos < size; ++pos)
+          {
+            C c (s[pos]);
+
+            if (c == C ('Z') || c == C ('+') || c == C ('-'))
+              break;
+          }
+
+          // At least one digit should follow the fraction point.
+          //
+          if ((pos - 6) == 3)
+            throw invalid_value<C> (bits::time<C> (), tmp);
+
+          ro_string<C> seconds_fragment (s + 6, pos - 6);
+          zc_istream<C> sis (seconds_fragment);
+
+          if (!(sis >> seconds_ && sis.exhausted () && seconds_ < 60.0))
+            throw invalid_value<C> (bits::time<C> (), tmp);
+
+          if (hours_ == 24 && (minutes_ != 0 || seconds_ != 0.0))
+            throw invalid_value<C> (bits::time<C> (), tmp);
+
+          // zone
+          //
+          if (pos < size)
+          {
+            if (!bits::parse_tz (s + pos, size - pos, zh_, zm_))
+              throw invalid_value<C> (bits::time<C> (), tmp);
+
+            z_ = true;
+          }
+          else
+            z_ = false;
+        }
+
+        template <typename C>
+        time time_pimpl<C>::
+        post_time ()
+        {
+          return z_
+            ? time (hours_, minutes_, seconds_, zh_, zm_)
+            : time (hours_, minutes_, seconds_);
+        }
+
+
+        // date_time
+        //
+        template <typename C>
+        void date_time_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void date_time_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          if (str_.size () == 0)
+          {
+            ro_string<C> tmp (s.data (), s.size ());
+
+            if (trim_left (tmp) != 0)
+              str_ += tmp;
+          }
+          else
+            str_ += s;
+        }
+
+        template <typename C>
+        void date_time_pimpl<C>::
+        _post ()
+        {
+          typedef typename ro_string<C>::size_type size_type;
+
+          ro_string<C> tmp (str_);
+          size_type size (trim_right (tmp));
+          const C* s (tmp.data ());
+
+          // date_time := [-]CCYY[N]*-MM-DDTHH:MM:SS[.S+][Z|(+|-)HH:MM]
+          //
+
+          if (size < 19 || (s[0] == C ('-') && size < 20))
+            throw invalid_value<C> (bits::date_time<C> (), tmp);
+
+          // Find the end of the year token.
+          //
+          size_type pos (tmp.find (C ('-'), s[0] == C ('-') ? 5 : 4));
+
+          if (pos == ro_string<C>::npos || (size - pos - 1) < 14
+              || s[pos + 3] != C ('-') || s[pos + 6] != C ('T')
+              || s[pos + 9] != C (':') || s[pos + 12] != C (':'))
+            throw invalid_value<C> (bits::date_time<C> (), tmp);
+
+          // year
+          //
+          ro_string<C> year_fragment (s, pos);
+          zc_istream<C> yis (year_fragment);
+
+          if (!(yis >> year_ && yis.exhausted () && year_ != 0))
+            throw invalid_value<C> (bits::date_time<C> (), tmp);
+
+          // month
+          //
+          C d1 (s[pos + 1]), d2 (s[pos + 2]);
+
+          if (d1 < '0' || d1 > '9' || d2 < '0' || d2 > '9')
+            throw invalid_value<C> (bits::date_time<C> (), tmp);
+
+          month_ = 10 * (d1 - '0') + (d2 - '0');
+
+          if (month_ < 1 || month_ > 12)
+            throw invalid_value<C> (bits::date_time<C> (), tmp);
+
+          // day
+          //
+          d1 = s[pos + 4];
+          d2 = s[pos + 5];
+
+          if (d1 < '0' || d1 > '9' || d2 < '0' || d2 > '9')
+            throw invalid_value<C> (bits::date_time<C> (), tmp);
+
+          day_ = 10 * (d1 - '0') + (d2 - '0');
+
+          if (day_ < 1 || day_ > 31)
+            throw invalid_value<C> (bits::date_time<C> (), tmp);
+
+          pos += 7; // Point to the first H.
+
+          // hours
+          //
+          d1 = s[pos];
+          d2 = s[pos + 1];
+
+          if (d1 < '0' || d1 > '9' || d2 < '0' || d2 > '9')
+            throw invalid_value<C> (bits::date_time<C> (), tmp);
+
+          hours_ = 10 * (d1 - '0') + (d2 - '0');
+
+          if (hours_ > 24)
+            throw invalid_value<C> (bits::date_time<C> (), tmp);
+
+          // minutes
+          //
+          d1 = s[pos + 3];
+          d2 = s[pos + 4];
+
+          if (d1 < '0' || d1 > '9' || d2 < '0' || d2 > '9')
+            throw invalid_value<C> (bits::date_time<C> (), tmp);
+
+          minutes_ = 10 * (d1 - '0') + (d2 - '0');
+
+          if (minutes_ > 59)
+            throw invalid_value<C> (bits::date_time<C> (), tmp);
+
+          // Find the end of the seconds fragment.
+          //
+          pos += 6; // Point to the first S.
+
+          size_type sec_end (pos + 2);
+          for (; sec_end < size; ++sec_end)
+          {
+            C c (s[sec_end]);
+
+            if (c == C ('Z') || c == C ('+') || c == C ('-'))
+              break;
+          }
+
+          // At least one digit should should follow the fraction point.
+          //
+          if ((sec_end - pos) == 3)
+            throw invalid_value<C> (bits::date_time<C> (), tmp);
+
+          ro_string<C> seconds_fragment (s + pos, sec_end - pos);
+          zc_istream<C> sis (seconds_fragment);
+
+          if (!(sis >> seconds_ && sis.exhausted () && seconds_ < 60.0))
+            throw invalid_value<C> (bits::date_time<C> (), tmp);
+
+          if (hours_ == 24 && (minutes_ != 0 || seconds_ != 0.0))
+            throw invalid_value<C> (bits::date_time<C> (), tmp);
+
+          // zone
+          //
+          if (sec_end < size)
+          {
+            if (!bits::parse_tz (s + sec_end, size - sec_end, zh_, zm_))
+              throw invalid_value<C> (bits::date_time<C> (), tmp);
+
+            z_ = true;
+          }
+          else
+            z_ = false;
+        }
+
+        template <typename C>
+        date_time date_time_pimpl<C>::
+        post_date_time ()
+        {
+          return z_
+            ? date_time (year_, month_, day_, hours_, minutes_, seconds_,
+                         zh_, zm_)
+            : date_time (year_, month_, day_, hours_, minutes_, seconds_);
+        }
+
+        // duration
+        //
+        template <typename C>
+        void duration_pimpl<C>::
+        _pre ()
+        {
+          str_.clear ();
+        }
+
+        template <typename C>
+        void duration_pimpl<C>::
+        _characters (const ro_string<C>& s)
+        {
+          if (str_.size () == 0)
+          {
+            ro_string<C> tmp (s.data (), s.size ());
+
+            if (trim_left (tmp) != 0)
+              str_ += tmp;
+          }
+          else
+            str_ += s;
+        }
+
+        namespace bits
+        {
+          template <typename C>
+          inline typename ro_string<C>::size_type
+          duration_delim (const C* s,
+                          typename ro_string<C>::size_type pos,
+                          typename ro_string<C>::size_type size)
+          {
+            const C* p (s + pos);
+            for (; p < (s + size); ++p)
+            {
+              if (*p == C ('Y') || *p == C ('D') || *p == C ('M') ||
+                  *p == C ('H') || *p == C ('M') || *p == C ('S') ||
+                  *p == C ('T'))
+                break;
+            }
+
+            return p - s;
+          }
+        }
+
+        template <typename C>
+        void duration_pimpl<C>::
+        _post ()
+        {
+          typedef typename ro_string<C>::size_type size_type;
+
+          ro_string<C> tmp (str_);
+          size_type size (trim_right (tmp));
+
+          negative_ = false;
+          years_ = 0;
+          months_ = 0;
+          days_ = 0;
+          hours_ = 0;
+          minutes_ = 0;
+          seconds_ = 0.0;
+
+          // duration := [-]P[nY][nM][nD][TnHnMn[.n+]S]
+          //
+          const C* s (tmp.data ());
+
+          if (size < 3 || (s[0] == C ('-') && size < 4))
+            throw invalid_value<C> (bits::duration<C> (), tmp);
+
+          size_type pos (0);
+
+          if (s[0] == C ('-'))
+          {
+            negative_ = true;
+            pos++;
+          }
+
+          if (s[pos++] != C ('P'))
+            throw invalid_value<C> (bits::duration<C> (), tmp);
+
+          size_type del (bits::duration_delim (s, pos, size));
+
+          // Duration should contain at least one component.
+          //
+          if (del == size)
+            throw invalid_value<C> (bits::duration<C> (), tmp);
+
+          if (s[del] == C ('Y'))
+          {
+            ro_string<C> fragment (s + pos, del - pos);
+            zc_istream<C> is (fragment);
+
+            if (!(is >> years_ && is.exhausted ()))
+              throw invalid_value<C> (bits::duration<C> (), tmp);
+
+            pos = del + 1;
+            del = bits::duration_delim (s, pos, size);
+          }
+
+          if (del != size && s[del] == C ('M'))
+          {
+            ro_string<C> fragment (s + pos, del - pos);
+            zc_istream<C> is (fragment);
+
+            if (!(is >> months_ && is.exhausted ()))
+              throw invalid_value<C> (bits::duration<C> (), tmp);
+
+            pos = del + 1;
+            del = bits::duration_delim (s, pos, size);
+          }
+
+          if (del != size && s[del] == C ('D'))
+          {
+            ro_string<C> fragment (s + pos, del - pos);
+            zc_istream<C> is (fragment);
+
+            if (!(is >> days_ && is.exhausted ()))
+              throw invalid_value<C> (bits::duration<C> (), tmp);
+
+            pos = del + 1;
+            del = bits::duration_delim (s, pos, size);
+          }
+
+          if (del != size && s[del] == C ('T'))
+          {
+            pos = del + 1;
+            del = bits::duration_delim (s, pos, size);
+
+            // At least one time component should be present.
+            //
+            if (del == size)
+              throw invalid_value<C> (bits::duration<C> (), tmp);
+
+            if (s[del] == C ('H'))
+            {
+              ro_string<C> fragment (s + pos, del - pos);
+              zc_istream<C> is (fragment);
+
+              if (!(is >> hours_ && is.exhausted ()))
+                throw invalid_value<C> (bits::duration<C> (), tmp);
+
+              pos = del + 1;
+              del = bits::duration_delim (s, pos, size);
+            }
+
+            if (del != size && s[del] == C ('M'))
+            {
+              ro_string<C> fragment (s + pos, del - pos);
+              zc_istream<C> is (fragment);
+
+              if (!(is >> minutes_ && is.exhausted ()))
+                throw invalid_value<C> (bits::duration<C> (), tmp);
+
+              pos = del + 1;
+              del = bits::duration_delim (s, pos, size);
+            }
+
+            if (del != size && s[del] == C ('S'))
+            {
+              ro_string<C> fragment (s + pos, del - pos);
+              zc_istream<C> is (fragment);
+
+              if (!(is >> seconds_ && is.exhausted () && seconds_ >= 0.0))
+                throw invalid_value<C> (bits::duration<C> (), tmp);
+
+              pos = del + 1;
+            }
+          }
+
+          // Something did not match or appeared in the wrong order.
+          //
+          if (pos != size)
+            throw invalid_value<C> (bits::duration<C> (), tmp);
+        }
+
+        template <typename C>
+        duration duration_pimpl<C>::
+        post_duration ()
+        {
+          return duration (
+            negative_, years_, months_, days_, hours_, minutes_, seconds_);
+        }
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/parser/validating/xml-schema-pskel.hxx src/base/include/xsd/cxx/parser/validating/xml-schema-pskel.hxx
new file mode 100644
index 0000000..67c8057
--- /dev/null
+++ src/base/include/xsd/cxx/parser/validating/xml-schema-pskel.hxx
@@ -0,0 +1,647 @@
+// file      : xsd/cxx/parser/validating/xml-schema-pskel.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_PARSER_VALIDATING_XML_SCHEMA_PSKEL_HXX
+#define XSD_CXX_PARSER_VALIDATING_XML_SCHEMA_PSKEL_HXX
+
+#include <string>
+#include <memory> // auto_ptr
+
+#include <xsd/cxx/parser/xml-schema.hxx>
+#include <xsd/cxx/parser/validating/parser.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      namespace validating
+      {
+        // anyType and anySimpleType. All events are routed to the
+        // _any_* callbacks.
+        //
+        template <typename C>
+        struct any_type_pskel: complex_content<C>
+        {
+          virtual bool
+          _start_element_impl (const ro_string<C>&,
+                               const ro_string<C>&,
+                               const ro_string<C>*);
+
+          virtual bool
+          _end_element_impl (const ro_string<C>&,
+                             const ro_string<C>&);
+
+          virtual bool
+          _attribute_impl_phase_two (const ro_string<C>&,
+                                     const ro_string<C>&,
+                                     const ro_string<C>&);
+
+          virtual bool
+          _characters_impl (const ro_string<C>&);
+
+          virtual void
+          post_any_type () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct any_simple_type_pskel: simple_content<C>
+        {
+          virtual bool
+          _characters_impl (const ro_string<C>&);
+
+          virtual void
+          post_any_simple_type () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+
+        // Boolean.
+        //
+        template <typename C>
+        struct boolean_pskel: simple_content<C>
+        {
+          virtual bool
+          post_boolean () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+
+        // 8-bit
+        //
+        template <typename C>
+        struct byte_pskel: simple_content<C>
+        {
+          virtual signed char
+          post_byte () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct unsigned_byte_pskel: simple_content<C>
+        {
+          virtual unsigned char
+          post_unsigned_byte () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+
+        // 16-bit
+        //
+        template <typename C>
+        struct short_pskel: simple_content<C>
+        {
+          virtual short
+          post_short () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct unsigned_short_pskel: simple_content<C>
+        {
+          virtual unsigned short
+          post_unsigned_short () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+
+        // 32-bit
+        //
+        template <typename C>
+        struct int_pskel: simple_content<C>
+        {
+          virtual int
+          post_int () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct unsigned_int_pskel: simple_content<C>
+        {
+          virtual unsigned int
+          post_unsigned_int () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+
+        // 64-bit
+        //
+        template <typename C>
+        struct long_pskel: simple_content<C>
+        {
+          virtual long long
+          post_long () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct unsigned_long_pskel: simple_content<C>
+        {
+          virtual unsigned long long
+          post_unsigned_long () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+
+        // Arbitrary-length integers.
+        //
+        template <typename C>
+        struct integer_pskel: simple_content<C>
+        {
+          virtual long long
+          post_integer () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct negative_integer_pskel: simple_content<C>
+        {
+          virtual long long
+          post_negative_integer () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct non_positive_integer_pskel: simple_content<C>
+        {
+          virtual long long
+          post_non_positive_integer () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct positive_integer_pskel: simple_content<C>
+        {
+          virtual unsigned long long
+          post_positive_integer () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct non_negative_integer_pskel: simple_content<C>
+        {
+          virtual unsigned long long
+          post_non_negative_integer () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+
+        // Floats.
+        //
+        template <typename C>
+        struct float_pskel: simple_content<C>
+        {
+          virtual float
+          post_float () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct double_pskel: simple_content<C>
+        {
+          virtual double
+          post_double () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct decimal_pskel: simple_content<C>
+        {
+          virtual double
+          post_decimal () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+
+        // Strings.
+        //
+        template <typename C>
+        struct string_pskel: simple_content<C>
+        {
+          virtual std::basic_string<C>
+          post_string () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct normalized_string_pskel: simple_content<C>
+        {
+          virtual std::basic_string<C>
+          post_normalized_string () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct token_pskel: simple_content<C>
+        {
+          virtual std::basic_string<C>
+          post_token () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct name_pskel: simple_content<C>
+        {
+          virtual std::basic_string<C>
+          post_name () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct nmtoken_pskel: simple_content<C>
+        {
+          virtual std::basic_string<C>
+          post_nmtoken () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct nmtokens_pskel: list_base<C>
+        {
+          virtual string_sequence<C>
+          post_nmtokens () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct ncname_pskel: simple_content<C>
+        {
+          virtual std::basic_string<C>
+          post_ncname () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct id_pskel: simple_content<C>
+        {
+          virtual std::basic_string<C>
+          post_id () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct idref_pskel: simple_content<C>
+        {
+          virtual std::basic_string<C>
+          post_idref () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct idrefs_pskel: list_base<C>
+        {
+          virtual string_sequence<C>
+          post_idrefs () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        // Language.
+        //
+        template <typename C>
+        struct language_pskel: simple_content<C>
+        {
+          virtual std::basic_string<C>
+          post_language () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        // URI.
+        //
+        template <typename C>
+        struct uri_pskel: simple_content<C>
+        {
+          virtual std::basic_string<C>
+          post_uri () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        // QName.
+        //
+        template <typename C>
+        struct qname_pskel: simple_content<C>
+        {
+          virtual qname<C>
+          post_qname () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        // Base64 and hex binaries.
+        //
+        template <typename C>
+        struct base64_binary_pskel: simple_content<C>
+        {
+          virtual std::auto_ptr<buffer>
+          post_base64_binary () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct hex_binary_pskel: simple_content<C>
+        {
+          virtual std::auto_ptr<buffer>
+          post_hex_binary () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        // Time and date types.
+        //
+        template <typename C>
+        struct gday_pskel: simple_content<C>
+        {
+          virtual gday
+          post_gday () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct gmonth_pskel: simple_content<C>
+        {
+          virtual gmonth
+          post_gmonth () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct gyear_pskel: simple_content<C>
+        {
+          virtual gyear
+          post_gyear () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct gmonth_day_pskel: simple_content<C>
+        {
+          virtual gmonth_day
+          post_gmonth_day () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct gyear_month_pskel: simple_content<C>
+        {
+          virtual gyear_month
+          post_gyear_month () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct date_pskel: simple_content<C>
+        {
+          virtual date
+          post_date () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct time_pskel: simple_content<C>
+        {
+          virtual time
+          post_time () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct date_time_pskel: simple_content<C>
+        {
+          virtual date_time
+          post_date_time () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+
+        template <typename C>
+        struct duration_pskel: simple_content<C>
+        {
+          virtual duration
+          post_duration () = 0;
+
+          static const C*
+          _static_type ();
+
+          virtual const C*
+          _dynamic_type () const;
+        };
+      }
+    }
+  }
+}
+
+#include <xsd/cxx/parser/validating/xml-schema-pskel.txx>
+
+#endif  // XSD_CXX_PARSER_VALIDATING_XML_SCHEMA_PSKEL_HXX
+
+#include <xsd/cxx/parser/validating/xml-schema-pskel.ixx>
diff --git src/base/include/xsd/cxx/parser/validating/xml-schema-pskel.ixx src/base/include/xsd/cxx/parser/validating/xml-schema-pskel.ixx
new file mode 100644
index 0000000..6958bea
--- /dev/null
+++ src/base/include/xsd/cxx/parser/validating/xml-schema-pskel.ixx
@@ -0,0 +1,1249 @@
+// file      : xsd/cxx/parser/validating/xml-schema-pskel.ixx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#if defined(XSD_CXX_PARSER_USE_CHAR) || !defined(XSD_CXX_PARSER_USE_WCHAR)
+
+#ifndef XSD_CXX_PARSER_VALIDATING_XML_SCHEMA_PSKEL_IXX_CHAR
+#define XSD_CXX_PARSER_VALIDATING_XML_SCHEMA_PSKEL_IXX_CHAR
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      namespace validating
+      {
+        template<>
+        inline const char* any_type_pskel<char>::
+        _static_type ()
+        {
+          return "anyType http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* any_type_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* any_simple_type_pskel<char>::
+        _static_type ()
+        {
+          return "anySimpleType http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* any_simple_type_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* boolean_pskel<char>::
+        _static_type ()
+        {
+          return "boolean http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* boolean_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* byte_pskel<char>::
+        _static_type ()
+        {
+          return "byte http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* byte_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* unsigned_byte_pskel<char>::
+        _static_type ()
+        {
+          return "unsignedByte http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* unsigned_byte_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* short_pskel<char>::
+        _static_type ()
+        {
+          return "short http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* short_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* unsigned_short_pskel<char>::
+        _static_type ()
+        {
+          return "unsignedShort http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* unsigned_short_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* int_pskel<char>::
+        _static_type ()
+        {
+          return "int http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* int_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* unsigned_int_pskel<char>::
+        _static_type ()
+        {
+          return "unsignedInt http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* unsigned_int_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* long_pskel<char>::
+        _static_type ()
+        {
+          return "long http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* long_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* unsigned_long_pskel<char>::
+        _static_type ()
+        {
+          return "unsignedLong http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* unsigned_long_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* integer_pskel<char>::
+        _static_type ()
+        {
+          return "integer http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* integer_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* negative_integer_pskel<char>::
+        _static_type ()
+        {
+          return "negativeInteger http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* negative_integer_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* non_positive_integer_pskel<char>::
+        _static_type ()
+        {
+          return "nonPositiveInteger http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* non_positive_integer_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* positive_integer_pskel<char>::
+        _static_type ()
+        {
+          return "positiveInteger http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* positive_integer_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* non_negative_integer_pskel<char>::
+        _static_type ()
+        {
+          return "nonNegativeInteger http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* non_negative_integer_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* float_pskel<char>::
+        _static_type ()
+        {
+          return "float http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* float_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* double_pskel<char>::
+        _static_type ()
+        {
+          return "double http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* double_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* decimal_pskel<char>::
+        _static_type ()
+        {
+          return "decimal http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* decimal_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* string_pskel<char>::
+        _static_type ()
+        {
+          return "string http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* string_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* normalized_string_pskel<char>::
+        _static_type ()
+        {
+          return "normalizedString http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* normalized_string_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* token_pskel<char>::
+        _static_type ()
+        {
+          return "token http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* token_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* name_pskel<char>::
+        _static_type ()
+        {
+          return "Name http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* name_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* nmtoken_pskel<char>::
+        _static_type ()
+        {
+          return "NMTOKEN http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* nmtoken_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* nmtokens_pskel<char>::
+        _static_type ()
+        {
+          return "NMTOKENS http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* nmtokens_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* ncname_pskel<char>::
+        _static_type ()
+        {
+          return "NCName http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* ncname_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* id_pskel<char>::
+        _static_type ()
+        {
+          return "ID http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* id_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* idref_pskel<char>::
+        _static_type ()
+        {
+          return "IDREF http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* idref_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* idrefs_pskel<char>::
+        _static_type ()
+        {
+          return "IDREFS http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* idrefs_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* language_pskel<char>::
+        _static_type ()
+        {
+          return "language http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* language_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* uri_pskel<char>::
+        _static_type ()
+        {
+          return "anyURI http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* uri_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* qname_pskel<char>::
+        _static_type ()
+        {
+          return "QName http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* qname_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* base64_binary_pskel<char>::
+        _static_type ()
+        {
+          return "base64Binary http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* base64_binary_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* hex_binary_pskel<char>::
+        _static_type ()
+        {
+          return "hexBinary http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* hex_binary_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* gday_pskel<char>::
+        _static_type ()
+        {
+          return "gDay http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* gday_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* gmonth_pskel<char>::
+        _static_type ()
+        {
+          return "gMonth http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* gmonth_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* gyear_pskel<char>::
+        _static_type ()
+        {
+          return "gYear http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* gyear_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* gmonth_day_pskel<char>::
+        _static_type ()
+        {
+          return "gMonthDay http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* gmonth_day_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* gyear_month_pskel<char>::
+        _static_type ()
+        {
+          return "gYearMonth http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* gyear_month_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* date_pskel<char>::
+        _static_type ()
+        {
+          return "date http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* date_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* time_pskel<char>::
+        _static_type ()
+        {
+          return "time http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* time_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* date_time_pskel<char>::
+        _static_type ()
+        {
+          return "dateTime http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* date_time_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const char* duration_pskel<char>::
+        _static_type ()
+        {
+          return "duration http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const char* duration_pskel<char>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+      }
+    }
+  }
+}
+
+#endif // XSD_CXX_PARSER_VALIDATING_XML_SCHEMA_PSKEL_IXX_CHAR
+#endif // XSD_CXX_PARSER_USE_CHAR
+
+
+#if defined(XSD_CXX_PARSER_USE_WCHAR) || !defined(XSD_CXX_PARSER_USE_CHAR)
+
+#ifndef XSD_CXX_PARSER_VALIDATING_XML_SCHEMA_PSKEL_IXX_WCHAR
+#define XSD_CXX_PARSER_VALIDATING_XML_SCHEMA_PSKEL_IXX_WCHAR
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      namespace validating
+      {
+        template<>
+        inline const wchar_t* any_type_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"anyType http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* any_type_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* any_simple_type_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"anySimpleType http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* any_simple_type_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* boolean_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"boolean http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* boolean_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* byte_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"byte http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* byte_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* unsigned_byte_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"unsignedByte http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* unsigned_byte_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* short_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"short http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* short_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* unsigned_short_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"unsignedShort http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* unsigned_short_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* int_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"int http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* int_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* unsigned_int_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"unsignedInt http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* unsigned_int_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* long_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"long http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* long_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* unsigned_long_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"unsignedLong http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* unsigned_long_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* integer_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"integer http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* integer_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* negative_integer_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"negativeInteger http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* negative_integer_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* non_positive_integer_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"nonPositiveInteger http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* non_positive_integer_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* positive_integer_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"positiveInteger http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* positive_integer_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* non_negative_integer_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"nonNegativeInteger http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* non_negative_integer_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* float_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"float http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* float_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* double_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"double http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* double_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* decimal_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"decimal http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* decimal_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* string_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"string http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* string_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* normalized_string_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"normalizedString http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* normalized_string_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* token_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"token http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* token_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* name_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"Name http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* name_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* nmtoken_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"NMTOKEN http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* nmtoken_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* nmtokens_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"NMTOKENS http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* nmtokens_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* ncname_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"NCName http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* ncname_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* id_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"ID http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* id_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* idref_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"IDREF http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* idref_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* idrefs_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"IDREFS http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* idrefs_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* language_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"language http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* language_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* uri_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"anyURI http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* uri_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* qname_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"QName http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* qname_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* base64_binary_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"base64Binary http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* base64_binary_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* hex_binary_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"hexBinary http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* hex_binary_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* gday_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"gDay http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* gday_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* gmonth_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"gMonth http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* gmonth_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* gyear_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"gYear http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* gyear_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* gmonth_day_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"gMonthDay http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* gmonth_day_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* gyear_month_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"gYearMonth http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* gyear_month_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* date_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"date http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* date_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* time_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"time http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* time_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* date_time_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"dateTime http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* date_time_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+
+        template<>
+        inline const wchar_t* duration_pskel<wchar_t>::
+        _static_type ()
+        {
+          return L"duration http://www.w3.org/2001/XMLSchema";
+        }
+
+        template<>
+        inline const wchar_t* duration_pskel<wchar_t>::
+        _dynamic_type () const
+        {
+          return _static_type ();
+        }
+      }
+    }
+  }
+}
+
+#endif // XSD_CXX_PARSER_VALIDATING_XML_SCHEMA_PSKEL_IXX_WCHAR
+#endif // XSD_CXX_PARSER_USE_WCHAR
diff --git src/base/include/xsd/cxx/parser/validating/xml-schema-pskel.txx src/base/include/xsd/cxx/parser/validating/xml-schema-pskel.txx
new file mode 100644
index 0000000..4ae50e3
--- /dev/null
+++ src/base/include/xsd/cxx/parser/validating/xml-schema-pskel.txx
@@ -0,0 +1,69 @@
+// file      : xsd/cxx/parser/validating/xml-schema-pskel.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      namespace validating
+      {
+        // any_type
+        //
+
+        template <typename C>
+        bool any_type_pskel<C>::
+        _start_element_impl (const ro_string<C>& ns,
+                             const ro_string<C>& name,
+                             const ro_string<C>* type)
+        {
+          this->_start_any_element (ns, name, type);
+          this->complex_content<C>::context_.top ().any_ = true;
+          return true;
+        }
+
+        template <typename C>
+        bool any_type_pskel<C>::
+        _end_element_impl (const ro_string<C>& ns, const ro_string<C>& name)
+        {
+          this->complex_content<C>::context_.top ().any_ = false;
+          this->_end_any_element (ns, name);
+          return true;
+        }
+
+
+        template <typename C>
+        bool any_type_pskel<C>::
+        _attribute_impl_phase_two (const ro_string<C>& ns,
+                                   const ro_string<C>& name,
+                                   const ro_string<C>& value)
+        {
+          this->_any_attribute (ns, name, value);
+          return true;
+        }
+
+        template <typename C>
+        bool any_type_pskel<C>::
+        _characters_impl (const ro_string<C>& s)
+        {
+          this->_any_characters (s);
+          return true;
+        }
+
+        // any_simple_type
+        //
+
+        template <typename C>
+        bool any_simple_type_pskel<C>::
+        _characters_impl (const ro_string<C>& s)
+        {
+          this->_any_characters (s);
+          return true;
+        }
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/parser/xerces/elements.hxx src/base/include/xsd/cxx/parser/xerces/elements.hxx
new file mode 100644
index 0000000..e0439f3
--- /dev/null
+++ src/base/include/xsd/cxx/parser/xerces/elements.hxx
@@ -0,0 +1,462 @@
+// file      : xsd/cxx/parser/xerces/elements.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_PARSER_XERCES_ELEMENTS_HXX
+#define XSD_CXX_PARSER_XERCES_ELEMENTS_HXX
+
+#include <memory>  // std::auto_ptr
+#include <string>
+#include <iosfwd>
+#include <vector>
+
+#include <xercesc/sax/Locator.hpp>
+#include <xercesc/sax/InputSource.hpp>
+#include <xercesc/sax2/SAX2XMLReader.hpp>
+#include <xercesc/sax2/DefaultHandler.hpp>
+
+#include <xsd/cxx/xml/elements.hxx>
+#include <xsd/cxx/xml/error-handler.hxx>
+
+#include <xsd/cxx/parser/exceptions.hxx>
+#include <xsd/cxx/parser/elements.hxx>
+#include <xsd/cxx/parser/document.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      namespace xerces
+      {
+        //
+        //
+        struct flags
+        {
+          // Use the following flags to modify the default behavior
+          // of the parsing functions.
+          //
+
+          // Do not try to validate instance documents.
+          //
+          static const unsigned long dont_validate = 0x00000001;
+
+          // Do not initialize the Xerces-C++ runtime.
+          //
+          static const unsigned long dont_initialize = 0x00000002;
+
+          // Disable handling of subsequent imports for the same namespace
+          // in Xerces-C++ 3.1.0 and later.
+          //
+          static const unsigned long no_multiple_imports = 0x00000004;
+
+        public:
+          flags (unsigned long x = 0)
+              : x_ (x)
+          {
+          }
+
+          operator unsigned long () const
+          {
+            return x_;
+          }
+
+        private:
+          unsigned long x_;
+        };
+
+
+        // Parsing properties. Refer to xsd/cxx/xml/elements.hxx for
+        // XML-related properties.
+        //
+        template <typename C>
+        class properties: public xml::properties<C>
+        {
+        };
+
+        //
+        //
+        template <typename C>
+        struct document: cxx::parser::document<C> // VC 7.1 likes it qualified
+        {
+        public:
+          document (parser_base<C>& root,
+                    const C* root_element_name,
+                    bool polymorphic = false);
+
+          document (parser_base<C>& root,
+                    const std::basic_string<C>& root_element_name,
+                    bool polymorphic = false);
+
+          document (parser_base<C>& root,
+                    const C* root_element_namespace,
+                    const C* root_element_name,
+                    bool polymorphic = false);
+
+          document (parser_base<C>& root,
+                    const std::basic_string<C>& root_element_namespace,
+                    const std::basic_string<C>& root_element_name,
+                    bool polymorphic = false);
+
+        protected:
+          explicit
+          document (bool polymorphic = false);
+
+        public:
+          // Parse URI or a local file. We have to overload it for const C*
+          // bacause xercesc::InputSource has an implicit constructor that
+          // takes const char*.
+          //
+          void
+          parse (const std::basic_string<C>& uri,
+                 flags = 0,
+                 const properties<C>& = properties<C> ());
+
+          void
+          parse (const C* uri,
+                 flags = 0,
+                 const properties<C>& = properties<C> ());
+
+
+          // Parse URI or a local file with a user-provided error_handler
+          // object.
+          //
+          void
+          parse (const std::basic_string<C>& uri,
+                 xml::error_handler<C>&,
+                 flags = 0,
+                 const properties<C>& = properties<C> ());
+
+          void
+          parse (const C* uri,
+                 xml::error_handler<C>&,
+                 flags = 0,
+                 const properties<C>& = properties<C> ());
+
+
+          // Parse URI or a local file with a user-provided ErrorHandler
+          // object. Note that you must initialize the Xerces-C++ runtime
+          // before calling these functions.
+          //
+          void
+          parse (const std::basic_string<C>& uri,
+                 xercesc::ErrorHandler&,
+                 flags = 0,
+                 const properties<C>& = properties<C> ());
+
+          void
+          parse (const C* uri,
+                 xercesc::ErrorHandler&,
+                 flags = 0,
+                 const properties<C>& = properties<C> ());
+
+
+          // Parse URI or a local file using a user-provided SAX2XMLReader
+          // object. Note that you must initialize the Xerces-C++ runtime
+          // before calling these functions.
+          //
+          void
+          parse (const std::basic_string<C>& uri,
+                 xercesc::SAX2XMLReader&,
+                 flags = 0,
+                 const properties<C>& = properties<C> ());
+
+          void
+          parse (const C* uri,
+                 xercesc::SAX2XMLReader&,
+                 flags = 0,
+                 const properties<C>& = properties<C> ());
+
+
+        public:
+          // System id is a "system" identifier of the resources (e.g.,
+          // URI or a full file path). Public id is a "public" identifier
+          // of the resource (e.g., an application-specific name or a
+          // relative file path). System id is used to resolve relative
+          // paths. In diagnostics messages system id is used if public
+          // id is not available. Otherwise public id is used.
+          //
+
+          // Parse std::istream.
+          //
+          void
+          parse (std::istream&,
+                 flags = 0,
+                 const properties<C>& = properties<C> ());
+
+
+          // Parse std::istream with a user-provided error_handler object.
+          //
+          void
+          parse (std::istream&,
+                 xml::error_handler<C>&,
+                 flags = 0,
+                 const properties<C>& = properties<C> ());
+
+
+          // Parse std::istream with a user-provided ErrorHandler object.
+          // Note that you must initialize the Xerces-C++ runtime before
+          // calling this function.
+          //
+          void
+          parse (std::istream&,
+                 xercesc::ErrorHandler&,
+                 flags = 0,
+                 const properties<C>& = properties<C> ());
+
+
+          // Parse std::istream using a user-provided SAX2XMLReader object.
+          // Note that you must initialize the Xerces-C++ runtime before
+          // calling this function.
+          //
+          void
+          parse (std::istream&,
+                 xercesc::SAX2XMLReader&,
+                 flags = 0,
+                 const properties<C>& = properties<C> ());
+
+
+        public:
+          // Parse std::istream with a system id.
+          //
+          void
+          parse (std::istream&,
+                 const std::basic_string<C>& system_id,
+                 flags = 0,
+                 const properties<C>& = properties<C> ());
+
+
+          // Parse std::istream with a system id and a user-provided
+          // error_handler object.
+          //
+          void
+          parse (std::istream&,
+                 const std::basic_string<C>& system_id,
+                 xml::error_handler<C>&,
+                 flags = 0,
+                 const properties<C>& = properties<C> ());
+
+
+          // Parse std::istream with a system id and a user-provided
+          // ErrorHandler object. Note that you must initialize the
+          // Xerces-C++ runtime before calling this function.
+          //
+          void
+          parse (std::istream&,
+                 const std::basic_string<C>& system_id,
+                 xercesc::ErrorHandler&,
+                 flags = 0,
+                 const properties<C>& = properties<C> ());
+
+
+          // Parse std::istream with a system id using a user-provided
+          // SAX2XMLReader object. Note that you must initialize the
+          // Xerces-C++ runtime before calling this function.
+          //
+          void
+          parse (std::istream&,
+                 const std::basic_string<C>& system_id,
+                 xercesc::SAX2XMLReader&,
+                 flags = 0,
+                 const properties<C>& = properties<C> ());
+
+
+
+        public:
+          // Parse std::istream with system and public ids.
+          //
+          void
+          parse (std::istream&,
+                 const std::basic_string<C>& system_id,
+                 const std::basic_string<C>& public_id,
+                 flags = 0,
+                 const properties<C>& = properties<C> ());
+
+
+          // Parse std::istream with system and public ids and a user-provided
+          // error_handler object.
+          //
+          void
+          parse (std::istream&,
+                 const std::basic_string<C>& system_id,
+                 const std::basic_string<C>& public_id,
+                 xml::error_handler<C>&,
+                 flags = 0,
+                 const properties<C>& = properties<C> ());
+
+
+          // Parse std::istream with system and public ids and a user-provided
+          // ErrorHandler object. Note that you must initialize the Xerces-C++
+          // runtime before calling this function.
+          //
+          void
+          parse (std::istream&,
+                 const std::basic_string<C>& system_id,
+                 const std::basic_string<C>& public_id,
+                 xercesc::ErrorHandler&,
+                 flags = 0,
+                 const properties<C>& = properties<C> ());
+
+
+          // Parse std::istream with system and public ids using a user-
+          // provided SAX2XMLReader object. Note that you must initialize
+          // the Xerces-C++ runtime before calling this function.
+          //
+          void
+          parse (std::istream&,
+                 const std::basic_string<C>& system_id,
+                 const std::basic_string<C>& public_id,
+                 xercesc::SAX2XMLReader&,
+                 flags = 0,
+                 const properties<C>& = properties<C> ());
+
+
+        public:
+          // Parse InputSource. Note that you must initialize the Xerces-C++
+          // runtime before calling this function.
+          //
+          void
+          parse (const xercesc::InputSource&,
+                 flags = 0,
+                 const properties<C>& = properties<C> ());
+
+
+          // Parse InputSource with a user-provided error_handler object.
+          // Note that you must initialize the Xerces-C++ runtime before
+          // calling this function.
+          //
+          void
+          parse (const xercesc::InputSource&,
+                 xml::error_handler<C>&,
+                 flags = 0,
+                 const properties<C>& = properties<C> ());
+
+
+          // Parse InputSource with a user-provided ErrorHandler object.
+          // Note that you must initialize the Xerces-C++ runtime before
+          // calling this function.
+          //
+          void
+          parse (const xercesc::InputSource&,
+                 xercesc::ErrorHandler&,
+                 flags = 0,
+                 const properties<C>& = properties<C> ());
+
+
+          // Parse InputSource using a user-provided SAX2XMLReader object.
+          // Note that you must initialize the Xerces-C++ runtime before
+          // calling this function.
+          //
+          void
+          parse (const xercesc::InputSource&,
+                 xercesc::SAX2XMLReader&,
+                 flags = 0,
+                 const properties<C>& = properties<C> ());
+
+        private:
+          void
+          parse (const std::basic_string<C>& uri,
+                 xercesc::ErrorHandler&,
+                 xercesc::SAX2XMLReader&,
+                 flags,
+                 const properties<C>&);
+
+          void
+          parse (const xercesc::InputSource&,
+                 xercesc::ErrorHandler&,
+                 xercesc::SAX2XMLReader&,
+                 flags,
+                 const properties<C>&);
+
+        private:
+          std::auto_ptr<xercesc::SAX2XMLReader>
+          create_sax_ (flags, const properties<C>&);
+
+        private:
+          bool polymorphic_;
+        };
+
+        //
+        //
+        template <typename C>
+        struct event_router: xercesc::DefaultHandler
+        {
+          event_router (cxx::parser::document<C>&, bool polymorphic);
+
+          // I know, some of those consts are stupid. But that's what
+          // Xerces folks put into their interfaces and VC 7.1 thinks
+          // there are different signatures if one strips this fluff off.
+          //
+          virtual void
+          setDocumentLocator (const xercesc::Locator* const);
+
+          virtual void
+          startElement (const XMLCh* const uri,
+                        const XMLCh* const lname,
+                        const XMLCh* const qname,
+                        const xercesc::Attributes& attributes);
+
+          virtual void
+          endElement (const XMLCh* const uri,
+                      const XMLCh* const lname,
+                      const XMLCh* const qname);
+
+#if _XERCES_VERSION >= 30000
+          virtual void
+          characters (const XMLCh* const s, const XMLSize_t length);
+#else
+          virtual void
+          characters (const XMLCh* const s, const unsigned int length);
+#endif
+
+          virtual void
+          startPrefixMapping (const XMLCh* const prefix,
+                              const XMLCh* const uri);
+
+          virtual void
+          endPrefixMapping (const XMLCh* const prefix);
+
+        private:
+          void
+          set_location (schema_exception<C>&);
+
+        private:
+          const xercesc::Locator* loc_;
+          cxx::parser::document<C>& consumer_;
+          bool polymorphic_;
+
+          // Last element name cache.
+          //
+          bool last_valid_;
+          std::basic_string<C> last_ns_;
+          std::basic_string<C> last_name_;
+
+          // Namespace-prefix mapping. Only maintained in the polymorphic
+          // case.
+          //
+          struct ns_decl
+          {
+            ns_decl (const std::basic_string<C>& p,
+                     const std::basic_string<C>& n)
+                : prefix (p), ns (n)
+            {
+            }
+
+            std::basic_string<C> prefix;
+            std::basic_string<C> ns;
+          };
+
+          typedef std::vector<ns_decl> ns_decls;
+
+          ns_decls ns_decls_;
+        };
+      }
+    }
+  }
+}
+
+#include <xsd/cxx/parser/xerces/elements.txx>
+
+#endif  // XSD_CXX_PARSER_XERCES_ELEMENTS_HXX
diff --git src/base/include/xsd/cxx/parser/xerces/elements.txx src/base/include/xsd/cxx/parser/xerces/elements.txx
new file mode 100644
index 0000000..2c1e2a1
--- /dev/null
+++ src/base/include/xsd/cxx/parser/xerces/elements.txx
@@ -0,0 +1,967 @@
+// file      : xsd/cxx/parser/xerces/elements.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#include <istream>
+#include <cstddef> // std::size_t
+#include <cassert>
+
+#include <xercesc/sax/SAXParseException.hpp>
+#include <xercesc/sax2/Attributes.hpp>
+#include <xercesc/sax2/XMLReaderFactory.hpp>
+#include <xercesc/validators/schema/SchemaSymbols.hpp>
+#include <xercesc/util/XMLUni.hpp>
+
+#include <xsd/cxx/xml/string.hxx>
+#include <xsd/cxx/xml/sax/std-input-source.hxx>
+#include <xsd/cxx/xml/sax/bits/error-handler-proxy.hxx>
+#include <xsd/cxx/xml/bits/literals.hxx> // xml::bits::{xml_prefix, etc}
+
+#include <xsd/cxx/parser/error-handler.hxx>
+#include <xsd/cxx/parser/schema-exceptions.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      namespace xerces
+      {
+
+        // document
+        //
+
+        template <typename C>
+        document<C>::
+        document (parser_base<C>& parser,
+                  const C* name,
+                  bool polymorphic)
+            : cxx::parser::document<C> (parser, std::basic_string<C> (), name),
+              polymorphic_ (polymorphic)
+        {
+        }
+
+        template <typename C>
+        document<C>::
+        document (parser_base<C>& parser,
+                  const std::basic_string<C>& name,
+                  bool polymorphic)
+            : cxx::parser::document<C> (parser, std::basic_string<C> (), name),
+              polymorphic_ (polymorphic)
+        {
+        }
+
+        template <typename C>
+        document<C>::
+        document (parser_base<C>& parser,
+                  const C* ns,
+                  const C* name,
+                  bool polymorphic)
+            : cxx::parser::document<C> (parser, ns, name),
+              polymorphic_ (polymorphic)
+        {
+        }
+
+        template <typename C>
+        document<C>::
+        document (parser_base<C>& parser,
+                  const std::basic_string<C>& ns,
+                  const std::basic_string<C>& name,
+                  bool polymorphic)
+            : cxx::parser::document<C> (parser, ns, name),
+              polymorphic_ (polymorphic)
+        {
+        }
+
+        template <typename C>
+        document<C>::
+        document (bool polymorphic)
+            : polymorphic_ (polymorphic)
+        {
+        }
+
+        // parse (uri)
+        //
+        template <typename C>
+        void document<C>::
+        parse (const std::basic_string<C>& uri,
+               flags f,
+               const properties<C>& p)
+        {
+          xml::auto_initializer init ((f & flags::dont_initialize) == 0);
+
+          error_handler<C> eh;
+          xml::sax::bits::error_handler_proxy<C> eh_proxy (eh);
+          std::auto_ptr<xercesc::SAX2XMLReader> sax (create_sax_ (f, p));
+
+          parse (uri, eh_proxy, *sax, f, p);
+
+          eh.throw_if_failed ();
+        }
+
+        template <typename C>
+        void document<C>::
+        parse (const C* uri,
+               flags f,
+               const properties<C>& p)
+        {
+          parse (std::basic_string<C> (uri), f, p);
+        }
+
+        // error_handler
+        //
+
+        template <typename C>
+        void document<C>::
+        parse (const std::basic_string<C>& uri,
+               xml::error_handler<C>& eh,
+               flags f,
+               const properties<C>& p)
+        {
+          xml::auto_initializer init ((f & flags::dont_initialize) == 0);
+
+          xml::sax::bits::error_handler_proxy<C> eh_proxy (eh);
+          std::auto_ptr<xercesc::SAX2XMLReader> sax (create_sax_ (f, p));
+
+          parse (uri, eh_proxy, *sax, f, p);
+
+          if (eh_proxy.failed ())
+            throw parsing<C> ();
+        }
+
+        template <typename C>
+        void document<C>::
+        parse (const C* uri,
+               xml::error_handler<C>& eh,
+               flags f,
+               const properties<C>& p)
+        {
+          parse (std::basic_string<C> (uri), eh, f, p);
+        }
+
+        // ErrorHandler
+        //
+
+        template <typename C>
+        void document<C>::
+        parse (const std::basic_string<C>& uri,
+               xercesc::ErrorHandler& eh,
+               flags f,
+               const properties<C>& p)
+        {
+          xml::sax::bits::error_handler_proxy<C> eh_proxy (eh);
+          std::auto_ptr<xercesc::SAX2XMLReader> sax (create_sax_ (f, p));
+
+          parse (uri, eh_proxy, *sax, f, p);
+
+          if (eh_proxy.failed ())
+            throw parsing<C> ();
+        }
+
+        template <typename C>
+        void document<C>::
+        parse (const C* uri,
+               xercesc::ErrorHandler& eh,
+               flags f,
+               const properties<C>& p)
+        {
+          parse (std::basic_string<C> (uri), eh, f, p);
+        }
+
+        // SAX2XMLReader
+        //
+
+        template <typename C>
+        void document<C>::
+        parse (const std::basic_string<C>& uri,
+               xercesc::SAX2XMLReader& sax,
+               flags f,
+               const properties<C>& p)
+        {
+          // If there is no error handler, then fall back on the default
+          // implementation.
+          //
+          xercesc::ErrorHandler* eh (sax.getErrorHandler ());
+
+          if (eh)
+          {
+            xml::sax::bits::error_handler_proxy<C> eh_proxy (*eh);
+
+            parse (uri, eh_proxy, sax, f, p);
+
+            if (eh_proxy.failed ())
+              throw parsing<C> ();
+          }
+          else
+          {
+            error_handler<C> fallback_eh;
+            xml::sax::bits::error_handler_proxy<C> eh_proxy (fallback_eh);
+
+            parse (uri, eh_proxy, sax, f, p);
+
+            fallback_eh.throw_if_failed ();
+          }
+        }
+
+        template <typename C>
+        void document<C>::
+        parse (const C* uri,
+               xercesc::SAX2XMLReader& sax,
+               flags f,
+               const properties<C>& p)
+        {
+          parse (std::basic_string<C> (uri), sax, f, p);
+        }
+
+        // parse (istream)
+        //
+
+        template <typename C>
+        void document<C>::
+        parse (std::istream& is,
+               flags f,
+               const properties<C>& p)
+        {
+          xml::auto_initializer init ((f & flags::dont_initialize) == 0);
+
+          xml::sax::std_input_source isrc (is);
+
+          parse (isrc, f, p);
+        }
+
+        template <typename C>
+        void document<C>::
+        parse (std::istream& is,
+               xml::error_handler<C>& eh,
+               flags f,
+               const properties<C>& p)
+        {
+          xml::auto_initializer init ((f & flags::dont_initialize) == 0);
+          xml::sax::std_input_source isrc (is);
+          parse (isrc, eh, f, p);
+        }
+
+        template <typename C>
+        void document<C>::
+        parse (std::istream& is,
+               xercesc::ErrorHandler& eh,
+               flags f,
+               const properties<C>& p)
+        {
+          xml::sax::std_input_source isrc (is);
+          parse (isrc, eh, f, p);
+        }
+
+        template <typename C>
+        void document<C>::
+        parse (std::istream& is,
+               xercesc::SAX2XMLReader& sax,
+               flags f,
+               const properties<C>& p)
+        {
+          xml::sax::std_input_source isrc (is);
+          parse (isrc, sax, f, p);
+        }
+
+
+        // parse (istream, system_id)
+        //
+
+
+        template <typename C>
+        void document<C>::
+        parse (std::istream& is,
+               const std::basic_string<C>& system_id,
+               flags f,
+               const properties<C>& p)
+        {
+          xml::auto_initializer init ((f & flags::dont_initialize) == 0);
+          xml::sax::std_input_source isrc (is, system_id);
+          parse (isrc, f, p);
+        }
+
+        template <typename C>
+        void document<C>::
+        parse (std::istream& is,
+               const std::basic_string<C>& system_id,
+               xml::error_handler<C>& eh,
+               flags f,
+               const properties<C>& p)
+        {
+          xml::auto_initializer init ((f & flags::dont_initialize) == 0);
+          xml::sax::std_input_source isrc (is, system_id);
+          parse (isrc, eh, f, p);
+        }
+
+        template <typename C>
+        void document<C>::
+        parse (std::istream& is,
+               const std::basic_string<C>& system_id,
+               xercesc::ErrorHandler& eh,
+               flags f,
+               const properties<C>& p)
+        {
+          xml::sax::std_input_source isrc (is, system_id);
+          parse (isrc, eh, f, p);
+        }
+
+        template <typename C>
+        void document<C>::
+        parse (std::istream& is,
+               const std::basic_string<C>& system_id,
+               xercesc::SAX2XMLReader& sax,
+               flags f,
+               const properties<C>& p)
+        {
+          xml::sax::std_input_source isrc (is, system_id);
+          parse (isrc, sax, f, p);
+        }
+
+
+        // parse (istream, system_id, public_id)
+        //
+
+        template <typename C>
+        void document<C>::
+        parse (std::istream& is,
+               const std::basic_string<C>& system_id,
+               const std::basic_string<C>& public_id,
+               flags f,
+               const properties<C>& p)
+        {
+          xml::auto_initializer init ((f & flags::dont_initialize) == 0);
+          xml::sax::std_input_source isrc (is, system_id, public_id);
+          parse (isrc, f, p);
+        }
+
+        template <typename C>
+        void document<C>::
+        parse (std::istream& is,
+               const std::basic_string<C>& system_id,
+               const std::basic_string<C>& public_id,
+               xml::error_handler<C>& eh,
+               flags f,
+               const properties<C>& p)
+        {
+          xml::auto_initializer init ((f & flags::dont_initialize) == 0);
+          xml::sax::std_input_source isrc (is, system_id, public_id);
+          parse (isrc, eh, f, p);
+        }
+
+        template <typename C>
+        void document<C>::
+        parse (std::istream& is,
+               const std::basic_string<C>& system_id,
+               const std::basic_string<C>& public_id,
+               xercesc::ErrorHandler& eh,
+               flags f,
+               const properties<C>& p)
+        {
+          xml::sax::std_input_source isrc (is, system_id, public_id);
+          parse (isrc, eh, f, p);
+        }
+
+        template <typename C>
+        void document<C>::
+        parse (std::istream& is,
+               const std::basic_string<C>& system_id,
+               const std::basic_string<C>& public_id,
+               xercesc::SAX2XMLReader& sax,
+               flags f,
+               const properties<C>& p)
+        {
+          xml::sax::std_input_source isrc (is, system_id, public_id);
+          parse (isrc, sax, f, p);
+        }
+
+
+        // parse (InputSource)
+        //
+
+
+        template <typename C>
+        void document<C>::
+        parse (const xercesc::InputSource& is,
+               flags f,
+               const properties<C>& p)
+        {
+          error_handler<C> eh;
+          xml::sax::bits::error_handler_proxy<C> eh_proxy (eh);
+          std::auto_ptr<xercesc::SAX2XMLReader> sax (create_sax_ (f, p));
+
+          parse (is, eh_proxy, *sax, f, p);
+
+          eh.throw_if_failed ();
+        }
+
+        template <typename C>
+        void document<C>::
+        parse (const xercesc::InputSource& is,
+               xml::error_handler<C>& eh,
+               flags f,
+               const properties<C>& p)
+        {
+          xml::sax::bits::error_handler_proxy<C> eh_proxy (eh);
+          std::auto_ptr<xercesc::SAX2XMLReader> sax (create_sax_ (f, p));
+
+          parse (is, eh_proxy, *sax, f, p);
+
+          if (eh_proxy.failed ())
+            throw parsing<C> ();
+        }
+
+        template <typename C>
+        void document<C>::
+        parse (const xercesc::InputSource& is,
+               xercesc::ErrorHandler& eh,
+               flags f,
+               const properties<C>& p)
+        {
+          xml::sax::bits::error_handler_proxy<C> eh_proxy (eh);
+          std::auto_ptr<xercesc::SAX2XMLReader> sax (create_sax_ (f, p));
+
+          parse (is, eh_proxy, *sax, f, p);
+
+          if (eh_proxy.failed ())
+            throw parsing<C> ();
+        }
+
+
+        template <typename C>
+        void document<C>::
+        parse (const xercesc::InputSource& is,
+               xercesc::SAX2XMLReader& sax,
+               flags f,
+               const properties<C>& p)
+        {
+          // If there is no error handler, then fall back on the default
+          // implementation.
+          //
+          xercesc::ErrorHandler* eh (sax.getErrorHandler ());
+
+          if (eh)
+          {
+            xml::sax::bits::error_handler_proxy<C> eh_proxy (*eh);
+
+            parse (is, eh_proxy, sax, f, p);
+
+            if (eh_proxy.failed ())
+              throw parsing<C> ();
+          }
+          else
+          {
+            error_handler<C> fallback_eh;
+            xml::sax::bits::error_handler_proxy<C> eh_proxy (fallback_eh);
+
+            parse (is, eh_proxy, sax, f, p);
+
+            fallback_eh.throw_if_failed ();
+          }
+        }
+
+        namespace Bits
+        {
+          struct ErrorHandlingController
+          {
+            ErrorHandlingController (xercesc::SAX2XMLReader& sax,
+                                     xercesc::ErrorHandler& eh)
+                : sax_ (sax), eh_ (sax_.getErrorHandler ())
+            {
+              sax_.setErrorHandler (&eh);
+            }
+
+            ~ErrorHandlingController ()
+            {
+              sax_.setErrorHandler (eh_);
+            }
+
+          private:
+            xercesc::SAX2XMLReader& sax_;
+            xercesc::ErrorHandler* eh_;
+          };
+
+          struct ContentHandlingController
+          {
+            ContentHandlingController (xercesc::SAX2XMLReader& sax,
+                                       xercesc::ContentHandler& ch)
+                : sax_ (sax), ch_ (sax_.getContentHandler ())
+            {
+              sax_.setContentHandler (&ch);
+            }
+
+            ~ContentHandlingController ()
+            {
+              sax_.setContentHandler (ch_);
+            }
+
+          private:
+            xercesc::SAX2XMLReader& sax_;
+            xercesc::ContentHandler* ch_;
+          };
+        };
+
+        template <typename C>
+        void document<C>::
+        parse (const std::basic_string<C>& uri,
+               xercesc::ErrorHandler& eh,
+               xercesc::SAX2XMLReader& sax,
+               flags,
+               const properties<C>&)
+        {
+          event_router<C> router (*this, polymorphic_);
+
+          Bits::ErrorHandlingController ehc (sax, eh);
+          Bits::ContentHandlingController chc (sax, router);
+
+          try
+          {
+            sax.parse (xml::string (uri).c_str ());
+          }
+          catch (const schema_exception<C>& e)
+          {
+            xml::string id (e.id ());
+
+            xercesc::SAXParseException se (
+              xml::string (e.message ()).c_str (),
+              id.c_str (),
+              id.c_str (),
+#if _XERCES_VERSION >= 30000
+              static_cast<XMLFileLoc> (e.line ()),
+              static_cast<XMLFileLoc> (e.column ())
+#else
+              static_cast<XMLSSize_t> (e.line ()),
+              static_cast<XMLSSize_t> (e.column ())
+#endif
+            );
+
+            eh.fatalError (se);
+          }
+        }
+
+        template <typename C>
+        void document<C>::
+        parse (const xercesc::InputSource& is,
+               xercesc::ErrorHandler& eh,
+               xercesc::SAX2XMLReader& sax,
+               flags,
+               const properties<C>&)
+        {
+          event_router<C> router (*this, polymorphic_);
+
+          Bits::ErrorHandlingController controller (sax, eh);
+          Bits::ContentHandlingController chc (sax, router);
+
+          try
+          {
+            sax.parse (is);
+          }
+          catch (const schema_exception<C>& e)
+          {
+            xml::string id (e.id ());
+
+            xercesc::SAXParseException se (
+              xml::string (e.message ()).c_str (),
+              id.c_str (),
+              id.c_str (),
+#if _XERCES_VERSION >= 30000
+              static_cast<XMLFileLoc> (e.line ()),
+              static_cast<XMLFileLoc> (e.column ())
+#else
+              static_cast<XMLSSize_t> (e.line ()),
+              static_cast<XMLSSize_t> (e.column ())
+#endif
+            );
+
+            eh.fatalError (se);
+          }
+        }
+
+
+        template <typename C>
+        std::auto_ptr<xercesc::SAX2XMLReader> document<C>::
+        create_sax_ (flags f, const properties<C>& p)
+        {
+          // HP aCC cannot handle using namespace xercesc;
+          //
+          using xercesc::SAX2XMLReader;
+          using xercesc::XMLReaderFactory;
+          using xercesc::XMLUni;
+
+          std::auto_ptr<SAX2XMLReader> sax (
+            XMLReaderFactory::createXMLReader ());
+
+          sax->setFeature (XMLUni::fgSAX2CoreNameSpaces, true);
+          sax->setFeature (XMLUni::fgSAX2CoreNameSpacePrefixes, true);
+          sax->setFeature (XMLUni::fgXercesValidationErrorAsFatal, true);
+
+          if (f & flags::dont_validate)
+          {
+            sax->setFeature (XMLUni::fgSAX2CoreValidation, false);
+            sax->setFeature (XMLUni::fgXercesSchema, false);
+            sax->setFeature (XMLUni::fgXercesSchemaFullChecking, false);
+          }
+          else
+          {
+            sax->setFeature (XMLUni::fgSAX2CoreValidation, true);
+            sax->setFeature (XMLUni::fgXercesSchema, true);
+
+            // Xerces-C++ 3.1.0 is the first version with working multi import
+            // support.
+            //
+#if _XERCES_VERSION >= 30100
+            if (!(f & flags::no_multiple_imports))
+              sax->setFeature (XMLUni::fgXercesHandleMultipleImports, true);
+#endif
+            // This feature checks the schema grammar for additional
+            // errors. We most likely do not need it when validating
+            // instances (assuming the schema is valid).
+            //
+            sax->setFeature (XMLUni::fgXercesSchemaFullChecking, false);
+          }
+
+          // Transfer properies if any.
+          //
+
+          if (!p.schema_location ().empty ())
+          {
+            xml::string sl (p.schema_location ());
+            const void* v (sl.c_str ());
+
+            sax->setProperty (
+              XMLUni::fgXercesSchemaExternalSchemaLocation,
+              const_cast<void*> (v));
+          }
+
+          if (!p.no_namespace_schema_location ().empty ())
+          {
+            xml::string sl (p.no_namespace_schema_location ());
+            const void* v (sl.c_str ());
+
+            sax->setProperty (
+              XMLUni::fgXercesSchemaExternalNoNameSpaceSchemaLocation,
+              const_cast<void*> (v));
+          }
+
+          return sax;
+        }
+
+        // event_router
+        //
+        template <typename C>
+        event_router<C>::
+        event_router (cxx::parser::document<C>& consumer, bool polymorphic)
+            : loc_ (0), consumer_ (consumer), polymorphic_ (polymorphic)
+        {
+        }
+
+        template <typename C>
+        void event_router<C>::
+        setDocumentLocator (const xercesc::Locator* const loc)
+        {
+          loc_ = loc;
+        }
+
+        template <typename C>
+        void event_router<C>::
+        startElement(const XMLCh* const uri,
+                     const XMLCh* const lname,
+                     const XMLCh* const /*qname*/,
+                     const xercesc::Attributes& attributes)
+        {
+          typedef std::basic_string<C> string;
+
+          {
+            last_valid_ = true;
+            last_ns_ = xml::transcode<C> (uri);
+            last_name_ = xml::transcode<C> (lname);
+
+            // Without this explicit construction IBM XL C++ complains
+            // about ro_string's copy ctor being private even though the
+            // temporary has been eliminated. Note that we cannot
+            // eliminate ns, name and value since ro_string does not make
+            // a copy.
+            //
+            ro_string<C> ro_ns (last_ns_);
+            ro_string<C> ro_name (last_name_);
+
+            if (!polymorphic_)
+            {
+              try
+              {
+                consumer_.start_element (ro_ns, ro_name, 0);
+              }
+              catch (schema_exception<C>& e)
+              {
+                set_location (e);
+                throw;
+              }
+            }
+            else
+            {
+              // Search for the xsi:type attribute.
+              //
+              int i (attributes.getIndex (
+                       xercesc::SchemaSymbols::fgURI_XSI,
+                       xercesc::SchemaSymbols::fgXSI_TYPE));
+
+              if (i == -1)
+              {
+                try
+                {
+                  consumer_.start_element (ro_ns, ro_name, 0);
+                }
+                catch (schema_exception<C>& e)
+                {
+                  set_location (e);
+                  throw;
+                }
+              }
+              else
+              {
+                try
+                {
+                  // @@ Probably need proper QName validation.
+                  //
+                  // Get the qualified type name and try to resolve it.
+                  //
+                  string qn (xml::transcode<C> (attributes.getValue (i)));
+
+                  ro_string<C> tp, tn;
+                  typename string::size_type pos (qn.find (C (':')));
+
+                  if (pos != string::npos)
+                  {
+                    tp.assign (qn.c_str (), pos);
+                    tn.assign (qn.c_str () + pos + 1);
+
+                    if (tp.empty ())
+                      throw dynamic_type<C> (qn);
+                  }
+                  else
+                    tn.assign (qn);
+
+                  if (tn.empty ())
+                    throw dynamic_type<C> (qn);
+
+                  // Search our namespace declaration stack. Sun CC 5.7
+                  // blows if we use const_reverse_iterator.
+                  //
+                  ro_string<C> tns;
+                  for (typename ns_decls::reverse_iterator
+                         it (ns_decls_.rbegin ()), e (ns_decls_.rend ());
+                       it != e; ++it)
+                  {
+                    if (it->prefix == tp)
+                    {
+                      tns.assign (it->ns);
+                      break;
+                    }
+                  }
+
+                  if (!tp.empty () && tns.empty ())
+                  {
+                    // The 'xml' prefix requires special handling.
+                    //
+                    if (tp == xml::bits::xml_prefix<C> ())
+                      tns.assign (xml::bits::xml_namespace<C> ());
+                    else
+                      throw dynamic_type<C> (qn);
+                  }
+
+                  // Construct the compound type id.
+                  //
+                  string id (tn.data (), tn.size ());
+
+                  if (!tns.empty ())
+                  {
+                    id += C (' ');
+                    id.append (tns.data (), tns.size ());
+                  }
+
+                  ro_string<C> ro_id (id);
+                  consumer_.start_element (ro_ns, ro_name, &ro_id);
+                }
+                catch (schema_exception<C>& e)
+                {
+                  set_location (e);
+                  throw;
+                }
+              }
+            }
+          }
+
+#if _XERCES_VERSION >= 30000
+          for (XMLSize_t i (0), end (attributes.getLength()); i < end; ++i)
+#else
+          for (unsigned int i (0), end (attributes.getLength()); i < end; ++i)
+#endif
+          {
+            string ns (xml::transcode<C> (attributes.getURI (i)));
+            string name (xml::transcode<C> (attributes.getLocalName (i)));
+            string value (xml::transcode<C> (attributes.getValue (i)));
+
+            // Without this explicit construction IBM XL C++ complains
+            // about ro_string's copy ctor being private even though the
+            // temporary has been eliminated. Note that we cannot
+            // eliminate ns, name and value since ro_string does not make
+            // a copy.
+            //
+            ro_string<C> ro_ns (ns);
+            ro_string<C> ro_name (name);
+            ro_string<C> ro_value (value);
+
+            try
+            {
+              consumer_.attribute (ro_ns, ro_name, ro_value);
+            }
+            catch (schema_exception<C>& e)
+            {
+              set_location (e);
+              throw;
+            }
+          }
+        }
+
+        template <typename C>
+        void event_router<C>::
+        endElement(const XMLCh* const uri,
+                   const XMLCh* const lname,
+                   const XMLCh* const /*qname*/)
+        {
+          typedef std::basic_string<C> string;
+
+          try
+          {
+            // Without this explicit construction IBM XL C++ complains
+            // about ro_string's copy ctor being private even though the
+            // temporary has been eliminated. Note that we cannot
+            // eliminate ns, name and value since ro_string does not make
+            // a copy.
+            //
+            if (last_valid_)
+            {
+              last_valid_ = false;
+              ro_string<C> ro_ns (last_ns_);
+              ro_string<C> ro_name (last_name_);
+
+              consumer_.end_element (ro_ns, ro_name);
+            }
+            else
+            {
+              string ns (xml::transcode<C> (uri));
+              string name (xml::transcode<C> (lname));
+
+              ro_string<C> ro_ns (ns);
+              ro_string<C> ro_name (name);
+
+              consumer_.end_element (ro_ns, ro_name);
+            }
+          }
+          catch (schema_exception<C>& e)
+          {
+            set_location (e);
+            throw;
+          }
+        }
+
+        template <typename C>
+        void event_router<C>::
+#if _XERCES_VERSION >= 30000
+        characters (const XMLCh* const s, const XMLSize_t n)
+#else
+        characters (const XMLCh* const s, const unsigned int n)
+#endif
+        {
+          typedef std::basic_string<C> string;
+
+          if (n != 0)
+          {
+            string str (xml::transcode<C> (s, n));
+
+            // Without this explicit construction IBM XL C++ complains
+            // about ro_string's copy ctor being private even though the
+            // temporary has been eliminated. Note that we cannot
+            // eliminate str since ro_string does not make a copy.
+            //
+            ro_string<C> ro_str (str);
+
+            try
+            {
+              consumer_.characters (ro_str);
+            }
+            catch (schema_exception<C>& e)
+            {
+              set_location (e);
+              throw;
+            }
+          }
+        }
+
+        template <typename C>
+        void event_router<C>::
+        startPrefixMapping (const XMLCh* const prefix,
+                            const XMLCh* const uri)
+        {
+          if (polymorphic_)
+          {
+            typedef std::basic_string<C> string;
+
+            string p (xml::transcode<C> (prefix));
+            string ns (xml::transcode<C> (uri));
+
+            ns_decls_.push_back (ns_decl (p, ns));
+          }
+        }
+
+        template <typename C>
+        void event_router<C>::
+        endPrefixMapping (const XMLCh* const prefix)
+        {
+          if (polymorphic_)
+          {
+            typedef std::basic_string<C> string;
+
+            string p (xml::transcode<C> (prefix));
+
+            // Here we assume the prefixes are removed in the reverse
+            // order of them being added. This appears to how every
+            // sensible implementation works.
+            //
+            assert (ns_decls_.back ().prefix == p);
+
+            ns_decls_.pop_back ();
+          }
+        }
+
+        template <typename C>
+        void event_router<C>::
+        set_location (schema_exception<C>& e)
+        {
+          if (loc_ != 0)
+          {
+            const XMLCh* id (loc_->getPublicId ());
+
+            if (id == 0)
+              id = loc_->getSystemId ();
+
+            if (id != 0)
+              e.id (xml::transcode<C> (id));
+
+#if _XERCES_VERSION >= 30000
+            e.line (static_cast<unsigned long> (loc_->getLineNumber ()));
+            e.column (static_cast<unsigned long> (loc_->getColumnNumber ()));
+#else
+            XMLSSize_t l (loc_->getLineNumber ());
+            XMLSSize_t c (loc_->getColumnNumber ());
+
+            e.line (l == -1 ? 0 : static_cast<unsigned long> (l));
+            e.column (c == -1 ? 0: static_cast<unsigned long> (c));
+#endif
+          }
+        }
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/parser/xml-schema.hxx src/base/include/xsd/cxx/parser/xml-schema.hxx
new file mode 100644
index 0000000..5d1f1c6
--- /dev/null
+++ src/base/include/xsd/cxx/parser/xml-schema.hxx
@@ -0,0 +1,572 @@
+// file      : xsd/cxx/parser/xml-schema.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_PARSER_XML_SCHEMA_HXX
+#define XSD_CXX_PARSER_XML_SCHEMA_HXX
+
+#include <string>
+#include <vector>
+#include <cstddef> // std::size_t
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      // String sequence. Used for the NMTOKENS and IDREFS types.
+      //
+      template <typename C>
+      class string_sequence: public std::vector<std::basic_string<C> >
+      {
+      public:
+        typedef std::basic_string<C> value_type;
+        typedef std::vector<value_type> base;
+        typedef typename base::size_type size_type;
+
+        string_sequence ();
+
+        explicit
+        string_sequence (size_type n, const value_type& x = value_type ());
+
+        template <typename I>
+        string_sequence (const I& begin, const I& end);
+      };
+
+      template <typename C>
+      bool
+      operator== (const string_sequence<C>&, const string_sequence<C>&);
+
+      template <typename C>
+      bool
+      operator!= (const string_sequence<C>&, const string_sequence<C>&);
+
+
+      // QName
+      //
+      template <typename C>
+      class qname
+      {
+      public:
+        explicit
+        qname (const std::basic_string<C>& name);
+
+        qname (const std::basic_string<C>& prefix,
+               const std::basic_string<C>& name);
+
+        void
+        swap (qname&);
+
+        const std::basic_string<C>&
+        prefix () const;
+
+        std::basic_string<C>&
+        prefix ();
+
+        void
+        prefix (const std::basic_string<C>&);
+
+        const std::basic_string<C>&
+        name () const;
+
+        std::basic_string<C>&
+        name ();
+
+        void
+        name (const std::basic_string<C>&);
+
+      private:
+        std::basic_string<C> prefix_;
+        std::basic_string<C> name_;
+      };
+
+      template <typename C>
+      bool
+      operator== (const qname<C>&, const qname<C>&);
+
+      template <typename C>
+      bool
+      operator!= (const qname<C>&, const qname<C>&);
+
+
+      // Binary buffer. Used for the base64Binary and hexBinary types.
+      //
+      class buffer
+      {
+      public:
+        typedef std::size_t size_t;
+
+        class bounds {}; // Out of bounds exception.
+
+      public:
+        ~buffer ();
+
+        explicit
+        buffer (size_t size = 0);
+        buffer (size_t size, size_t capacity);
+        buffer (const void* data, size_t size);
+        buffer (const void* data, size_t size, size_t capacity);
+
+        // If the assume_ownership argument is true, the buffer will
+        // assume the ownership of the data and will release the memory
+        // by calling operator delete ().
+        //
+        buffer (void* data,
+                size_t size,
+                size_t capacity,
+                bool assume_ownership);
+
+        buffer (const buffer&);
+
+      public:
+        buffer&
+        operator= (const buffer&);
+
+      public:
+        size_t
+        capacity () const;
+
+        // Returns true if the underlying buffer has moved.
+        //
+        bool
+        capacity (size_t);
+
+      public:
+        size_t
+        size () const;
+
+        // Returns true if the underlying buffer has moved.
+        //
+        bool
+        size (size_t);
+
+      public:
+        const char*
+        data () const;
+
+        char*
+        data ();
+
+        const char*
+        begin () const;
+
+        char*
+        begin ();
+
+        const char*
+        end () const;
+
+        char*
+        end ();
+
+      public:
+        void
+        swap (buffer&);
+
+      private:
+        bool
+        capacity (size_t capacity, bool copy);
+
+      private:
+        char* data_;
+        size_t size_;
+        size_t capacity_;
+      };
+
+      bool
+      operator== (const buffer&, const buffer&);
+
+      bool
+      operator!= (const buffer&, const buffer&);
+
+
+      // Time and date types.
+      //
+
+      class time_zone
+      {
+      public:
+        time_zone ();
+        time_zone (short hours, short minutes);
+
+        // Returns true if time zone is specified.
+        //
+        bool
+        zone_present () const;
+
+        // Resets the time zone to the 'not specified' state.
+        //
+        void
+        zone_reset ();
+
+        short
+        zone_hours () const;
+
+        void
+        zone_hours (short);
+
+        short
+        zone_minutes () const;
+
+        void
+        zone_minutes (short);
+
+      private:
+        bool present_;
+        short hours_;
+        short minutes_;
+      };
+
+      bool
+      operator== (const time_zone&, const time_zone&);
+
+      bool
+      operator!= (const time_zone&, const time_zone&);
+
+
+      class gday: public time_zone
+      {
+      public:
+        explicit
+        gday (unsigned short day);
+        gday (unsigned short day, short zone_hours, short zone_minutes);
+
+        unsigned short
+        day () const;
+
+        void
+        day (unsigned short);
+
+      private:
+        unsigned short day_;
+      };
+
+      bool
+      operator== (const gday&, const gday&);
+
+      bool
+      operator!= (const gday&, const gday&);
+
+
+      class gmonth: public time_zone
+      {
+      public:
+        explicit
+        gmonth (unsigned short month);
+        gmonth (unsigned short month, short zone_hours, short zone_minutes);
+
+        unsigned short
+        month () const;
+
+        void
+        month (unsigned short);
+
+      private:
+        unsigned short month_;
+      };
+
+      bool
+      operator== (const gmonth&, const gmonth&);
+
+      bool
+      operator!= (const gmonth&, const gmonth&);
+
+
+      class gyear: public time_zone
+      {
+      public:
+        explicit
+        gyear (int year);
+        gyear (int year, short zone_hours, short zone_minutes);
+
+        int
+        year () const;
+
+        void
+        year (int);
+
+      private:
+        int year_;
+      };
+
+      bool
+      operator== (const gyear&, const gyear&);
+
+      bool
+      operator!= (const gyear&, const gyear&);
+
+
+      class gmonth_day: public time_zone
+      {
+      public:
+        gmonth_day (unsigned short month, unsigned short day);
+        gmonth_day (unsigned short month, unsigned short day,
+                    short zone_hours, short zone_minutes);
+
+        unsigned short
+        month () const;
+
+        void
+        month (unsigned short);
+
+        unsigned short
+        day () const;
+
+        void
+        day (unsigned short);
+
+      private:
+        unsigned short month_;
+        unsigned short day_;
+      };
+
+      bool
+      operator== (const gmonth_day&, const gmonth_day&);
+
+      bool
+      operator!= (const gmonth_day&, const gmonth_day&);
+
+
+      class gyear_month: public time_zone
+      {
+      public:
+        gyear_month (int year, unsigned short month);
+        gyear_month (int year, unsigned short month,
+                     short zone_hours, short zone_minutes);
+
+        int
+        year () const;
+
+        void
+        year (int);
+
+        unsigned short
+        month () const;
+
+        void
+        month (unsigned short);
+
+      private:
+        int year_;
+        unsigned short month_;
+      };
+
+      bool
+      operator== (const gyear_month&, const gyear_month&);
+
+      bool
+      operator!= (const gyear_month&, const gyear_month&);
+
+
+      class date: public time_zone
+      {
+      public:
+        date (int year, unsigned short month, unsigned short day);
+        date (int year, unsigned short month, unsigned short day,
+              short zone_hours, short zone_minutes);
+
+        int
+        year () const;
+
+        void
+        year (int);
+
+        unsigned short
+        month () const;
+
+        void
+        month (unsigned short);
+
+        unsigned short
+        day () const;
+
+        void
+        day (unsigned short);
+
+      private:
+        int year_;
+        unsigned short month_;
+        unsigned short day_;
+      };
+
+      bool
+      operator== (const date&, const date&);
+
+      bool
+      operator!= (const date&, const date&);
+
+
+      class time: public time_zone
+      {
+      public:
+        time (unsigned short hours, unsigned short minutes, double seconds);
+        time (unsigned short hours, unsigned short minutes, double seconds,
+              short zone_hours, short zone_minutes);
+
+        unsigned short
+        hours () const;
+
+        void
+        hours (unsigned short);
+
+        unsigned short
+        minutes () const;
+
+        void
+        minutes (unsigned short);
+
+        double
+        seconds () const;
+
+        void
+        seconds (double);
+
+      private:
+        unsigned short hours_;
+        unsigned short minutes_;
+        double seconds_;
+      };
+
+      bool
+      operator== (const time&, const time&);
+
+      bool
+      operator!= (const time&, const time&);
+
+
+      class date_time: public time_zone
+      {
+      public:
+        date_time (int year, unsigned short month, unsigned short day,
+                   unsigned short hours, unsigned short minutes, double seconds);
+
+        date_time (int year, unsigned short month, unsigned short day,
+                   unsigned short hours, unsigned short minutes, double seconds,
+                   short zone_hours, short zone_minutes);
+
+        int
+        year () const;
+
+        void
+        year (int);
+
+        unsigned short
+        month () const;
+
+        void
+        month (unsigned short);
+
+        unsigned short
+        day () const;
+
+        void
+        day (unsigned short);
+
+        unsigned short
+        hours () const;
+
+        void
+        hours (unsigned short);
+
+        unsigned short
+        minutes () const;
+
+        void
+        minutes (unsigned short);
+
+        double
+        seconds () const;
+
+        void
+        seconds (double);
+
+      private:
+        int year_;
+        unsigned short month_;
+        unsigned short day_;
+        unsigned short hours_;
+        unsigned short minutes_;
+        double seconds_;
+      };
+
+      bool
+      operator== (const date_time&, const date_time&);
+
+      bool
+      operator!= (const date_time&, const date_time&);
+
+
+      class duration
+      {
+      public:
+        duration (bool negative,
+                  unsigned int years, unsigned int months, unsigned int days,
+                  unsigned int hours, unsigned int minutes, double seconds);
+
+        bool
+        negative () const;
+
+        void
+        negative (bool);
+
+        unsigned int
+        years () const;
+
+        void
+        years (unsigned int);
+
+        unsigned int
+        months () const;
+
+        void
+        months (unsigned int);
+
+        unsigned int
+        days () const;
+
+        void
+        days (unsigned int);
+
+        unsigned int
+        hours () const;
+
+        void
+        hours (unsigned int);
+
+        unsigned int
+        minutes () const;
+
+        void
+        minutes (unsigned int);
+
+        double
+        seconds () const;
+
+        void
+        seconds (double);
+
+      private:
+        bool negative_;
+        unsigned int years_;
+        unsigned int months_;
+        unsigned int days_;
+        unsigned int hours_;
+        unsigned int minutes_;
+        double seconds_;
+      };
+
+      bool
+      operator== (const duration&, const duration&);
+
+      bool
+      operator!= (const duration&, const duration&);
+    }
+  }
+}
+
+#include <xsd/cxx/parser/xml-schema.ixx>
+#include <xsd/cxx/parser/xml-schema.txx>
+
+#endif // XSD_CXX_PARSER_XML_SCHEMA_HXX
diff --git src/base/include/xsd/cxx/parser/xml-schema.ixx src/base/include/xsd/cxx/parser/xml-schema.ixx
new file mode 100644
index 0000000..891bc6f
--- /dev/null
+++ src/base/include/xsd/cxx/parser/xml-schema.ixx
@@ -0,0 +1,1022 @@
+// file      : xsd/cxx/parser/xml-schema.ixx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#include <new>     // operator new/delete
+#include <cstring> // std::memcpy, std::memcmp
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      // string_sequence
+      //
+      template <typename C>
+      string_sequence<C>::
+      string_sequence ()
+      {
+      }
+
+      template <typename C>
+      string_sequence<C>::
+      string_sequence (size_type n, const value_type& x)
+          : base (n, x)
+      {
+      }
+
+      template <typename C>
+      template <typename I>
+      string_sequence<C>::
+      string_sequence (const I& begin, const I& end)
+          : base (begin, end)
+      {
+      }
+
+      template <typename C>
+      inline bool
+      operator!= (const string_sequence<C>& a, const string_sequence<C>& b)
+      {
+        return !(a == b);
+      }
+
+      // qname
+      //
+      template <typename C>
+      inline qname<C>::
+      qname (const std::basic_string<C>& name)
+          : name_ (name)
+      {
+      }
+
+      template <typename C>
+      inline qname<C>::
+      qname (const std::basic_string<C>& prefix,
+             const std::basic_string<C>& name)
+          : prefix_ (prefix), name_ (name)
+      {
+      }
+
+      template <typename C>
+      void qname<C>::
+      swap (qname<C>& x)
+      {
+        prefix_.swap (x.prefix_);
+        name_.swap (x.name_);
+      }
+
+      template <typename C>
+      inline const std::basic_string<C>& qname<C>::
+      prefix () const
+      {
+        return prefix_;
+      }
+
+      template <typename C>
+      inline std::basic_string<C>& qname<C>::
+      prefix ()
+      {
+        return prefix_;
+      }
+
+      template <typename C>
+      inline void qname<C>::
+      prefix (const std::basic_string<C>& prefix)
+      {
+        prefix_ = prefix;
+      }
+
+      template <typename C>
+      inline const std::basic_string<C>& qname<C>::
+      name () const
+      {
+        return name_;
+      }
+
+      template <typename C>
+      inline std::basic_string<C>& qname<C>::
+      name ()
+      {
+        return name_;
+      }
+
+      template <typename C>
+      inline void qname<C>::
+      name (const std::basic_string<C>& name)
+      {
+        name_ = name;
+      }
+
+      template <typename C>
+      inline bool
+      operator== (const qname<C>& a, const qname<C>& b)
+      {
+        return a.prefix () == b.prefix () && a.name () == b.name ();
+      }
+
+      template <typename C>
+      inline bool
+      operator!= (const qname<C>& a, const qname<C>& b)
+      {
+        return !(a == b);
+      }
+
+      // buffer
+      //
+      inline buffer::
+      ~buffer ()
+      {
+        if (data_)
+	  operator delete (data_);
+      }
+
+      inline buffer::
+      buffer (size_t size)
+          : data_ (0), size_ (0), capacity_ (0)
+      {
+        capacity (size);
+        size_ = size;
+      }
+
+      inline buffer::
+      buffer (size_t size, size_t cap)
+          : data_ (0), size_ (0), capacity_ (0)
+      {
+        if (size > cap)
+          throw bounds ();
+
+        capacity (cap);
+        size_ = size;
+      }
+
+      inline buffer::
+      buffer (const void* data, size_t size)
+          : data_ (0), size_ (0), capacity_ (0)
+      {
+        capacity (size);
+        size_ = size;
+
+        if (size_)
+          std::memcpy (data_, data, size_);
+      }
+
+      inline buffer::
+      buffer (const void* data, size_t size, size_t cap)
+          : data_ (0), size_ (0), capacity_ (0)
+      {
+        if (size > cap)
+          throw bounds ();
+
+        capacity (cap);
+        size_ = size;
+
+        if (size_)
+          std::memcpy (data_, data, size_);
+      }
+
+      inline buffer::
+      buffer (void* data, size_t size, size_t cap, bool own)
+          : data_ (0), size_ (0), capacity_ (0)
+      {
+        if (size > cap)
+          throw bounds ();
+
+        if (own)
+        {
+          data_ = reinterpret_cast<char*> (data);
+          size_ = size;
+          capacity_ = cap;
+        }
+        else
+        {
+          capacity (cap);
+          size_ = size;
+
+          if (size_)
+            std::memcpy (data_, data, size_);
+        }
+      }
+
+      inline buffer::
+      buffer (const buffer& other)
+          : data_ (0), size_ (0), capacity_ (0)
+      {
+        capacity (other.capacity_);
+        size_ = other.size_;
+
+        if (size_)
+          std::memcpy (data_, other.data_, size_);
+      }
+
+      inline buffer& buffer::
+      operator= (const buffer& other)
+      {
+        if (this != &other)
+        {
+          capacity (other.capacity_, false);
+          size_ = other.size_;
+
+          if (size_)
+            std::memcpy (data_, other.data_, size_);
+        }
+
+        return *this;
+      }
+
+      inline size_t buffer::
+      capacity () const
+      {
+        return capacity_;
+      }
+
+      inline bool buffer::
+      capacity (size_t cap)
+      {
+        return capacity (cap, true);
+      }
+
+      inline size_t buffer::
+      size () const
+      {
+        return size_;
+      }
+
+      inline bool buffer::
+      size (size_t size)
+      {
+        bool r (false);
+
+        if (size > capacity_)
+          r = capacity (size);
+
+        size_ = size;
+
+        return r;
+      }
+
+      inline const char* buffer::
+      data () const
+      {
+        return data_;
+      }
+
+      inline char* buffer::
+      data ()
+      {
+        return data_;
+      }
+
+      inline const char* buffer::
+      begin () const
+      {
+        return data_;
+      }
+
+      inline char* buffer::
+      begin ()
+      {
+        return data_;
+      }
+
+      inline const char* buffer::
+      end () const
+      {
+        return data_ + size_;
+      }
+
+      inline char* buffer::
+      end ()
+      {
+        return data_ + size_;
+      }
+
+      inline void buffer::
+      swap (buffer& other)
+      {
+        char* tmp_data (data_);
+        size_t tmp_size (size_);
+        size_t tmp_capacity (capacity_);
+
+        data_ = other.data_;
+        size_ = other.size_;
+        capacity_ = other.capacity_;
+
+        other.data_ = tmp_data;
+        other.size_ = tmp_size;
+        other.capacity_ = tmp_capacity;
+      }
+
+      inline bool buffer::
+      capacity (size_t capacity, bool copy)
+      {
+        if (size_ > capacity)
+          throw bounds ();
+
+        if (capacity <= capacity_)
+        {
+          return false; // Do nothing if shrinking is requested.
+        }
+        else
+        {
+          char* data (reinterpret_cast<char*> (operator new (capacity)));
+
+          if (copy && size_ > 0)
+            std::memcpy (data, data_, size_);
+
+          if (data_)
+            operator delete (data_);
+
+          data_ = data;
+          capacity_ = capacity;
+
+          return true;
+        }
+      }
+
+      inline bool
+      operator== (const buffer& a, const buffer& b)
+      {
+        return a.size () == b.size () &&
+          std::memcmp (a.data (), b.data (), a.size ()) == 0;
+      }
+
+      inline bool
+      operator!= (const buffer& a, const buffer& b)
+      {
+        return !(a == b);
+      }
+
+      // time_zone
+      //
+      inline time_zone::
+      time_zone ()
+          : present_ (false)
+      {
+      }
+
+      inline time_zone::
+      time_zone (short h, short m)
+          : present_ (true), hours_ (h), minutes_ (m)
+      {
+      }
+
+      inline bool time_zone::
+      zone_present () const
+      {
+        return present_;
+      }
+
+      inline void time_zone::
+      zone_reset ()
+      {
+        present_ = false;
+      }
+
+      inline short time_zone::
+      zone_hours () const
+      {
+        return hours_;
+      }
+
+      inline void time_zone::
+      zone_hours (short h)
+      {
+        hours_ = h;
+        present_ = true;
+      }
+
+      inline short time_zone::
+      zone_minutes () const
+      {
+        return minutes_;
+      }
+
+      inline void time_zone::
+      zone_minutes (short m)
+      {
+        minutes_ = m;
+        present_ = true;
+      }
+
+      inline bool
+      operator== (const time_zone& x, const time_zone& y)
+      {
+        return x.zone_present ()
+          ? y.zone_present () &&
+          x.zone_hours () == y.zone_hours () &&
+          x.zone_minutes () == y.zone_minutes ()
+          : !y.zone_present ();
+      }
+
+      inline bool
+      operator!= (const time_zone& x, const time_zone& y)
+      {
+        return !(x == y);
+      }
+
+      // gday
+      //
+      inline gday::
+      gday (unsigned short day)
+          : day_ (day)
+      {
+      }
+
+      inline gday::
+      gday (unsigned short day, short zh, short zm)
+          : time_zone (zh, zm), day_ (day)
+      {
+      }
+
+      inline unsigned short gday::
+      day () const
+      {
+        return day_;
+      }
+
+      inline void gday::
+      day (unsigned short day)
+      {
+        day_ = day;
+      }
+
+      inline bool
+      operator== (const gday& a, const gday& b)
+      {
+        const time_zone& az = a;
+        const time_zone& bz = b;
+
+        return a.day () == b.day () && az == bz;
+      }
+
+      inline bool
+      operator!= (const gday& a, const gday& b)
+      {
+        return !(a == b);
+      }
+
+      // gmonth
+      //
+      inline gmonth::
+      gmonth (unsigned short month)
+          : month_ (month)
+      {
+      }
+
+      inline gmonth::
+      gmonth (unsigned short month, short zh, short zm)
+          : time_zone (zh, zm), month_ (month)
+      {
+      }
+
+      inline unsigned short gmonth::
+      month () const
+      {
+        return month_;
+      }
+
+      inline void gmonth::
+      month (unsigned short month)
+      {
+        month_ = month;
+      }
+
+      inline bool
+      operator== (const gmonth& a, const gmonth& b)
+      {
+        const time_zone& az = a;
+        const time_zone& bz = b;
+
+        return a.month () == b.month () && az == bz;
+      }
+
+      inline bool
+      operator!= (const gmonth& a, const gmonth& b)
+      {
+        return !(a == b);
+      }
+
+      // gyear
+      //
+      inline gyear::
+      gyear (int year)
+          : year_ (year)
+      {
+      }
+
+      inline gyear::
+      gyear (int year, short zh, short zm)
+          : time_zone (zh, zm), year_ (year)
+      {
+      }
+
+      inline int gyear::
+      year () const
+      {
+        return year_;
+      }
+
+      inline void gyear::
+      year (int year)
+      {
+        year_ = year;
+      }
+
+      inline bool
+      operator== (const gyear& a, const gyear& b)
+      {
+        const time_zone& az = a;
+        const time_zone& bz = b;
+
+        return a.year () == b.year () && az == bz;
+      }
+
+      inline bool
+      operator!= (const gyear& a, const gyear& b)
+      {
+        return !(a == b);
+      }
+
+      // gmonth_day
+      //
+      inline gmonth_day::
+      gmonth_day (unsigned short month, unsigned short day)
+          : month_ (month), day_ (day)
+      {
+      }
+
+      inline gmonth_day::
+      gmonth_day (unsigned short month,
+                  unsigned short day,
+                  short zh, short zm)
+          : time_zone (zh, zm), month_ (month), day_ (day)
+      {
+      }
+
+      inline unsigned short gmonth_day::
+      month () const
+      {
+        return month_;
+      }
+
+      inline void gmonth_day::
+      month (unsigned short month)
+      {
+        month_ = month;
+      }
+
+      inline unsigned short gmonth_day::
+      day () const
+      {
+        return day_;
+      }
+
+      inline void gmonth_day::
+      day (unsigned short day)
+      {
+        day_ = day;
+      }
+
+      inline bool
+      operator== (const gmonth_day& a, const gmonth_day& b)
+      {
+        const time_zone& az = a;
+        const time_zone& bz = b;
+
+        return a.month () == b.month () &&
+          a.day () == b.day () &&
+          az == bz;
+      }
+
+      inline bool
+      operator!= (const gmonth_day& a, const gmonth_day& b)
+      {
+        return !(a == b);
+      }
+
+      // gyear_month
+      //
+      inline gyear_month::
+      gyear_month (int year, unsigned short month)
+          : year_ (year), month_ (month)
+      {
+      }
+
+      inline gyear_month::
+      gyear_month (int year, unsigned short month,
+                   short zh, short zm)
+          : time_zone (zh, zm), year_ (year), month_ (month)
+      {
+      }
+
+      inline int gyear_month::
+      year () const
+      {
+        return year_;
+      }
+
+      inline void gyear_month::
+      year (int year)
+      {
+        year_ = year;
+      }
+
+      inline unsigned short gyear_month::
+      month () const
+      {
+        return month_;
+      }
+
+      inline void gyear_month::
+      month (unsigned short month)
+      {
+        month_ = month;
+      }
+
+      inline bool
+      operator== (const gyear_month& a, const gyear_month& b)
+      {
+        const time_zone& az = a;
+        const time_zone& bz = b;
+
+        return a.year () == b.year () &&
+          a.month () == b.month () &&
+          az == bz;
+      }
+
+      inline bool
+      operator!= (const gyear_month& a, const gyear_month& b)
+      {
+        return !(a == b);
+      }
+
+      // date
+      //
+      inline date::
+      date (int year, unsigned short month, unsigned short day)
+          : year_ (year), month_ (month), day_ (day)
+      {
+      }
+
+      inline date::
+      date (int year, unsigned short month, unsigned short day,
+            short zh, short zm)
+          : time_zone (zh, zm), year_ (year), month_ (month), day_ (day)
+      {
+      }
+
+      inline int date::
+      year () const
+      {
+        return year_;
+      }
+
+      inline void date::
+      year (int year)
+      {
+        year_ = year;
+      }
+
+      inline unsigned short date::
+      month () const
+      {
+        return month_;
+      }
+
+      inline void date::
+      month (unsigned short month)
+      {
+        month_ = month;
+      }
+
+      inline unsigned short date::
+      day () const
+      {
+        return day_;
+      }
+
+      inline void date::
+      day (unsigned short day)
+      {
+        day_ = day;
+      }
+
+      inline bool
+      operator== (const date& a, const date& b)
+      {
+        const time_zone& az = a;
+        const time_zone& bz = b;
+
+        return a.year () == b.year () &&
+          a.month () == b.month () &&
+          a.day () == b.day () &&
+          az == bz;
+      }
+
+      inline bool
+      operator!= (const date& a, const date& b)
+      {
+        return !(a == b);
+      }
+
+      // time
+      //
+      inline time::
+      time (unsigned short hours, unsigned short minutes, double seconds)
+          : hours_ (hours), minutes_ (minutes), seconds_ (seconds)
+      {
+      }
+
+      inline time::
+      time (unsigned short hours, unsigned short minutes, double seconds,
+            short zh, short zm)
+          : time_zone (zh, zm),
+            hours_ (hours), minutes_ (minutes), seconds_ (seconds)
+      {
+      }
+
+      inline unsigned short time::
+      hours () const
+      {
+        return hours_;
+      }
+
+      inline void time::
+      hours (unsigned short hours)
+      {
+        hours_ = hours;
+      }
+
+      inline unsigned short time::
+      minutes () const
+      {
+        return minutes_;
+      }
+
+      inline void time::
+      minutes (unsigned short minutes)
+      {
+        minutes_ = minutes;
+      }
+
+      inline double time::
+      seconds () const
+      {
+        return seconds_;
+      }
+
+      inline void time::
+      seconds (double seconds)
+      {
+        seconds_ = seconds;
+      }
+
+      inline bool
+      operator== (const time& a, const time& b)
+      {
+        const time_zone& az = a;
+        const time_zone& bz = b;
+
+        return a.hours () == b.hours () &&
+          a.minutes () == b.minutes () &&
+          a.seconds () == b.seconds () &&
+          az == bz;
+      }
+
+      inline bool
+      operator!= (const time& a, const time& b)
+      {
+        return !(a == b);
+      }
+
+      // date_time
+      //
+      inline date_time::
+      date_time (int year, unsigned short month, unsigned short day,
+                 unsigned short hours, unsigned short minutes, double seconds)
+          : year_ (year), month_ (month), day_ (day),
+            hours_ (hours), minutes_ (minutes), seconds_ (seconds)
+      {
+      }
+
+      inline date_time::
+      date_time (int year, unsigned short month, unsigned short day,
+                 unsigned short hours, unsigned short minutes, double seconds,
+                 short zh, short zm)
+          : time_zone (zh, zm),
+            year_ (year), month_ (month), day_ (day),
+            hours_ (hours), minutes_ (minutes), seconds_ (seconds)
+      {
+      }
+
+      inline int date_time::
+      year () const
+      {
+        return year_;
+      }
+
+      inline void date_time::
+      year (int year)
+      {
+        year_ = year;
+      }
+
+      inline unsigned short date_time::
+      month () const
+      {
+        return month_;
+      }
+
+      inline void date_time::
+      month (unsigned short month)
+      {
+        month_ = month;
+      }
+
+      inline unsigned short date_time::
+      day () const
+      {
+        return day_;
+      }
+
+      inline void date_time::
+      day (unsigned short day)
+      {
+        day_ = day;
+      }
+
+      inline unsigned short date_time::
+      hours () const
+      {
+        return hours_;
+      }
+
+      inline void date_time::
+      hours (unsigned short hours)
+      {
+        hours_ = hours;
+      }
+
+      inline unsigned short date_time::
+      minutes () const
+      {
+        return minutes_;
+      }
+
+      inline void date_time::
+      minutes (unsigned short minutes)
+      {
+        minutes_ = minutes;
+      }
+
+      inline double date_time::
+      seconds () const
+      {
+        return seconds_;
+      }
+
+      inline void date_time::
+      seconds (double seconds)
+      {
+        seconds_ = seconds;
+      }
+
+      inline bool
+      operator== (const date_time& a, const date_time& b)
+      {
+        const time_zone& az = a;
+        const time_zone& bz = b;
+
+        return a.year () == b.year () &&
+          a.month () == b.month () &&
+          a.day () == b.day () &&
+          a.hours () == b.hours () &&
+          a.minutes () == b.minutes () &&
+          a.seconds () == b.seconds () &&
+          az == bz;
+      }
+
+      inline bool
+      operator!= (const date_time& a, const date_time& b)
+      {
+        return !(a == b);
+      }
+
+      // duration
+      //
+      inline duration::
+      duration (bool negative,
+                unsigned int years, unsigned int months, unsigned int days,
+                unsigned int hours, unsigned int minutes, double seconds)
+          : negative_ (negative),
+            years_ (years), months_ (months), days_ (days),
+            hours_ (hours), minutes_ (minutes), seconds_ (seconds)
+      {
+      }
+
+      inline bool duration::
+      negative () const
+      {
+        return negative_;
+      }
+
+      inline void duration::
+      negative (bool negative)
+      {
+        negative_ = negative;
+      }
+
+      inline unsigned int duration::
+      years () const
+      {
+        return years_;
+      }
+
+      inline void duration::
+      years (unsigned int years)
+      {
+        years_ = years;
+      }
+
+      inline unsigned int duration::
+      months () const
+      {
+        return months_;
+      }
+
+      inline void duration::
+      months (unsigned int months)
+      {
+        months_ = months;
+      }
+
+      inline unsigned int duration::
+      days () const
+      {
+        return days_;
+      }
+
+      inline void duration::
+      days (unsigned int days)
+      {
+        days_ = days;
+      }
+
+      inline unsigned int duration::
+      hours () const
+      {
+        return hours_;
+      }
+
+      inline void duration::
+      hours (unsigned int hours)
+      {
+        hours_ = hours;
+      }
+
+      inline unsigned int duration::
+      minutes () const
+      {
+        return minutes_;
+      }
+
+      inline void duration::
+      minutes (unsigned int minutes)
+      {
+        minutes_ = minutes;
+      }
+
+      inline double duration::
+      seconds () const
+      {
+        return seconds_;
+      }
+
+      inline void duration::
+      seconds (double seconds)
+      {
+        seconds_ = seconds;
+      }
+
+      inline bool
+      operator== (const duration& a, const duration& b)
+      {
+        return a.negative () == b.negative () &&
+          a.years () == b.years () &&
+          a.months () == b.months () &&
+          a.days () == b.days () &&
+          a.hours () == b.hours () &&
+          a.minutes () == b.minutes () &&
+          a.seconds () == b.seconds ();
+      }
+
+      inline bool
+      operator!= (const duration& a, const duration& b)
+      {
+        return !(a == b);
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/parser/xml-schema.txx src/base/include/xsd/cxx/parser/xml-schema.txx
new file mode 100644
index 0000000..5f41a18
--- /dev/null
+++ src/base/include/xsd/cxx/parser/xml-schema.txx
@@ -0,0 +1,34 @@
+// file      : xsd/cxx/parser/xml-schema.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace parser
+    {
+      // string_sequence
+      //
+      template <typename C>
+      bool
+      operator== (const string_sequence<C>& a, const string_sequence<C>& b)
+      {
+        if (a.size () != b.size ())
+          return false;
+
+        for (typename string_sequence<C>::const_iterator
+               ai (a.begin ()), bi (b.begin ()), ae (a.end ());
+             ai != ae; ++ai, ++bi)
+        {
+          if (*ai != *bi)
+            return false;
+        }
+
+        return true;
+      }
+    }
+  }
+}
+
diff --git src/base/include/xsd/cxx/post.hxx src/base/include/xsd/cxx/post.hxx
new file mode 100644
index 0000000..b119bb4
--- /dev/null
+++ src/base/include/xsd/cxx/post.hxx
@@ -0,0 +1,13 @@
+// file      : xsd/cxx/post.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+
+#ifdef _MSC_VER
+#  if (_MSC_VER >= 1400)
+#    include <xsd/cxx/compilers/vc-8/post.hxx>
+#  elif (_MSC_VER >= 1300)
+#    include <xsd/cxx/compilers/vc-7/post.hxx>
+#  endif
+#endif
diff --git src/base/include/xsd/cxx/pre.hxx src/base/include/xsd/cxx/pre.hxx
new file mode 100644
index 0000000..845a854
--- /dev/null
+++ src/base/include/xsd/cxx/pre.hxx
@@ -0,0 +1,15 @@
+// file      : xsd/cxx/pre.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+
+#ifdef _MSC_VER
+#  if (_MSC_VER >= 1400)
+#    include <xsd/cxx/compilers/vc-8/pre.hxx>
+#  elif (_MSC_VER >= 1300)
+#    include <xsd/cxx/compilers/vc-7/pre.hxx>
+#  else
+#    error Microsoft Visual C++ 6 is not supported.
+#  endif
+#endif
diff --git src/base/include/xsd/cxx/ro-string.hxx src/base/include/xsd/cxx/ro-string.hxx
new file mode 100644
index 0000000..fd80cac
--- /dev/null
+++ src/base/include/xsd/cxx/ro-string.hxx
@@ -0,0 +1,430 @@
+// file      : xsd/cxx/ro-string.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_RO_STRING_HXX
+#define XSD_CXX_RO_STRING_HXX
+
+#include <string>
+#include <cstddef> // std::size_t
+#include <ostream>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    // Read-only string class template.
+    //
+    template <typename C>
+    class ro_string
+    {
+    public:
+      typedef std::char_traits<C> traits_type;
+      typedef std::size_t	    size_type;
+
+      static const size_type npos = ~(size_type (0));
+
+    public:
+      ro_string ()
+          : data_ (0), size_ (0)
+      {
+      }
+
+      ro_string (const C* s)
+          : data_ (s), size_ (traits_type::length (s))
+      {
+      }
+
+      ro_string (const C* s, size_type size)
+          : data_ (s), size_ (size)
+      {
+      }
+
+      ro_string (const std::basic_string<C>& s)
+          : data_ (s.data ()), size_ (s.size ())
+      {
+      }
+
+      operator std::basic_string<C> () const
+      {
+        return std::basic_string<C> (data (), size ());
+      }
+
+    private:
+      ro_string (const ro_string&);
+
+      ro_string&
+      operator= (const ro_string&);
+
+    public:
+      // The returned string is not necessarily terminated  with '\0'.
+      // If size() returns 0, the returned pointer may be 0.
+      //
+      const C*
+      data () const
+      {
+        return data_;
+      }
+
+      size_type
+      size () const
+      {
+        return size_;
+      }
+
+      size_type
+      length () const
+      {
+        return size ();
+      }
+
+    public:
+      bool
+      empty () const
+      {
+        return size () == 0;
+      }
+
+      const C&
+      operator[] (size_type pos) const
+      {
+        return data ()[pos];
+      }
+
+    public:
+      void
+      assign (const C* s)
+      {
+        data_ = s;
+        size_ = traits_type::length (s);
+      }
+
+      void
+      assign (const C* s, size_type size)
+      {
+        data_ = s;
+        size_ = size;
+      }
+
+      void
+      assign (const std::basic_string<C>& s)
+      {
+        data_ = s.c_str ();
+        size_ = s.size ();
+      }
+
+    public:
+      int
+      compare (const ro_string& str) const
+      {
+        return compare (str.data (), str.size ());
+      }
+
+      int
+      compare (const std::basic_string<C>& str) const
+      {
+        return compare (str.c_str (), str.size ());
+      }
+
+      int
+      compare (const C* str) const
+      {
+        return compare (str, traits_type::length (str));
+      }
+
+      int
+      compare (const C* str, size_type n) const
+      {
+        size_type s1 (size ());
+        size_type s (s1 < n ? s1 : n);
+
+        int r (s != 0 ? traits_type::compare (data (), str, s) : 0);
+
+        if (!r && s1 != n)
+          r = s1 < n ? -1 : 1;
+
+        return r;
+      }
+
+    public:
+      size_type
+      find (C c, size_type pos = 0) const;
+
+    private:
+      const C* data_;
+      size_type size_;
+    };
+
+    // operator==
+    //
+    template <typename C>
+    inline bool
+    operator== (const ro_string<C>& a, const ro_string<C>& b)
+    {
+      return a.compare (b) == 0;
+    }
+
+    template <typename C>
+    inline bool
+    operator== (const ro_string<C>& a, const std::basic_string<C>& b)
+    {
+      return a.compare (b) == 0;
+    }
+
+    template <typename C>
+    inline bool
+    operator== (const std::basic_string<C>& a, const ro_string<C>& b)
+    {
+      return b.compare (a) == 0;
+    }
+
+    template <typename C>
+    inline bool
+    operator== (const ro_string<C>& a, const C* b)
+    {
+      return a.compare (b) == 0;
+    }
+
+    template <typename C>
+    inline bool
+    operator== (const C* a, const ro_string<C>& b)
+    {
+      return b.compare (a) == 0;
+    }
+
+    // operator!=
+    //
+    template <typename C>
+    inline bool
+    operator!= (const ro_string<C>& a, const ro_string<C>& b)
+    {
+      return a.compare (b) != 0;
+    }
+
+    template <typename C>
+    inline bool
+    operator!= (const ro_string<C>& a, const std::basic_string<C>& b)
+    {
+      return a.compare (b) != 0;
+    }
+
+    template <typename C>
+    inline bool
+    operator!= (const std::basic_string<C>& a, const ro_string<C>& b)
+    {
+      return b.compare (a) != 0;
+    }
+
+    template <typename C>
+    inline bool
+    operator!= (const ro_string<C>& a, const C* b)
+    {
+      return a.compare (b) != 0;
+    }
+
+    template <typename C>
+    inline bool
+    operator!= (const C* a, const ro_string<C>& b)
+    {
+      return b.compare (a) != 0;
+    }
+
+    // operator<
+    //
+    template <typename C>
+    inline bool
+    operator< (const ro_string<C>& l, const ro_string<C>& r)
+    {
+      return l.compare (r) < 0;
+    }
+
+    template <typename C>
+    inline bool
+    operator< (const ro_string<C>& l, const std::basic_string<C>& r)
+    {
+      return l.compare (r) < 0;
+    }
+
+    template <typename C>
+    inline bool
+    operator< (const std::basic_string<C>& l, const ro_string<C>& r)
+    {
+      return r.compare (l) > 0;
+    }
+
+    template <typename C>
+    inline bool
+    operator< (const ro_string<C>& l, const C* r)
+    {
+      return l.compare (r) < 0;
+    }
+
+    template <typename C>
+    inline bool
+    operator< (const C* l, const ro_string<C>& r)
+    {
+      return r.compare (l) > 0;
+    }
+
+
+    // operator>
+    //
+    template <typename C>
+    inline bool
+    operator> (const ro_string<C>& l, const ro_string<C>& r)
+    {
+      return l.compare (r) > 0;
+    }
+
+    template <typename C>
+    inline bool
+    operator> (const ro_string<C>& l, const std::basic_string<C>& r)
+    {
+      return l.compare (r) > 0;
+    }
+
+    template <typename C>
+    inline bool
+    operator> (const std::basic_string<C>& l, const ro_string<C>& r)
+    {
+      return r.compare (l) < 0;
+    }
+
+    template <typename C>
+    inline bool
+    operator> (const ro_string<C>& l, const C* r)
+    {
+      return l.compare (r) > 0;
+    }
+
+    template <typename C>
+    inline bool
+    operator> (const C* l, const ro_string<C>& r)
+    {
+      return r.compare (l) < 0;
+    }
+
+    // operator<=
+    //
+    template <typename C>
+    inline bool
+    operator<= (const ro_string<C>& l, const ro_string<C>& r)
+    {
+      return l.compare (r) <= 0;
+    }
+
+    template <typename C>
+    inline bool
+    operator<= (const ro_string<C>& l, const std::basic_string<C>& r)
+    {
+      return l.compare (r) <= 0;
+    }
+
+    template <typename C>
+    inline bool
+    operator<= (const std::basic_string<C>& l, const ro_string<C>& r)
+    {
+      return r.compare (l) >= 0;
+    }
+
+    template <typename C>
+    inline bool
+    operator<= (const ro_string<C>& l, const C* r)
+    {
+      return l.compare (r) <= 0;
+    }
+
+    template <typename C>
+    inline bool
+    operator<= (const C* l, const ro_string<C>& r)
+    {
+      return r.compare (l) >= 0;
+    }
+
+
+    // operator>=
+    //
+    template <typename C>
+    inline bool
+    operator>= (const ro_string<C>& l, const ro_string<C>& r)
+    {
+      return l.compare (r) >= 0;
+    }
+
+    template <typename C>
+    inline bool
+    operator>= (const ro_string<C>& l, const std::basic_string<C>& r)
+    {
+      return l.compare (r) >= 0;
+    }
+
+    template <typename C>
+    inline bool
+    operator>= (const std::basic_string<C>& l, const ro_string<C>& r)
+    {
+      return r.compare (l) <= 0;
+    }
+
+    template <typename C>
+    inline bool
+    operator>= (const ro_string<C>& l, const C* r)
+    {
+      return l.compare (r) >= 0;
+    }
+
+    template <typename C>
+    inline bool
+    operator>= (const C* l, const ro_string<C>& r)
+    {
+      return r.compare (l) <= 0;
+    }
+
+    // operator<<
+    //
+    template<typename C>
+    std::basic_ostream<C>&
+    operator<< (std::basic_ostream<C>& os, const ro_string<C>& str)
+    {
+      if (str.size () != 0)
+        os.write (str.data (), static_cast<std::streamsize> (str.size ()));
+
+      return os;
+    }
+
+    // operator+=
+    //
+    template<typename C>
+    std::basic_string<C>&
+    operator+= (std::basic_string<C>& l, const ro_string<C>& r)
+    {
+      l.append (r.data (), r.size ());
+      return l;
+    }
+
+    // Trim leading and trailing XML whitespaces. Return the new
+    // string size.
+    //
+    template <typename C>
+    typename ro_string<C>::size_type
+    trim_left (ro_string<C>&);
+
+    template <typename C>
+    typename ro_string<C>::size_type
+    trim_right (ro_string<C>&);
+
+    template <typename C>
+    typename ro_string<C>::size_type
+    trim (ro_string<C>&);
+
+    // Trim leading and trailing XML whitespaces.
+    //
+    template<typename C>
+    std::basic_string<C>
+    trim (const std::basic_string<C>&);
+  }
+}
+
+#include <xsd/cxx/ro-string.txx>
+
+#endif  // XSD_CXX_RO_STRING_HXX
diff --git src/base/include/xsd/cxx/ro-string.txx src/base/include/xsd/cxx/ro-string.txx
new file mode 100644
index 0000000..58efef0
--- /dev/null
+++ src/base/include/xsd/cxx/ro-string.txx
@@ -0,0 +1,133 @@
+// file      : xsd/cxx/ro-string.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+namespace xsd
+{
+  namespace cxx
+  {
+    template <typename C>
+    typename ro_string<C>::size_type ro_string<C>::
+    find (C c, size_type pos) const
+    {
+      size_type r (npos);
+
+      if (pos < size_)
+      {
+        if (const C* p = traits_type::find(data_ + pos, size_ - pos, c))
+          r = p - data_;
+      }
+
+      return r;
+    }
+
+    template<typename C>
+    typename ro_string<C>::size_type
+    trim_left (ro_string<C>& s)
+    {
+      typename ro_string<C>::size_type size (s.size ());
+
+      if (size != 0)
+      {
+        const C* f (s.data ());
+        const C* l (f + size);
+        const C* of (f);
+
+        while (f < l &&
+               (*f == C (0x20) || *f == C (0x0A) ||
+                *f == C (0x0D) || *f == C (0x09)))
+          ++f;
+
+        if (f != of)
+        {
+          size = f <= l ? l - f : 0;
+          s.assign ((f <= l ? f : 0), size);
+        }
+      }
+
+      return size;
+    }
+
+    template<typename C>
+    typename ro_string<C>::size_type
+    trim_right (ro_string<C>& s)
+    {
+      typename ro_string<C>::size_type size (s.size ());
+
+      if (size != 0)
+      {
+        const C* f (s.data ());
+        const C* l (f + size - 1);
+        const C* ol (l);
+
+        while (l > f &&
+               (*l == C (0x20) || *l == C (0x0A) ||
+                *l == C (0x0D) || *l == C (0x09)))
+          --l;
+
+        if (l != ol)
+        {
+          size = f <= l ? l - f + 1 : 0;
+          s.assign ((f <= l ? f : 0), size);
+        }
+      }
+
+      return size;
+    }
+
+    template<typename C>
+    typename ro_string<C>::size_type
+    trim (ro_string<C>& s)
+    {
+      typename ro_string<C>::size_type size (s.size ());
+
+      if (size != 0)
+      {
+        const C* f (s.data ());
+        const C* l (f + size);
+
+        const C* of (f);
+
+        while (f < l &&
+               (*f == C (0x20) || *f == C (0x0A) ||
+                *f == C (0x0D) || *f == C (0x09)))
+          ++f;
+
+        --l;
+
+        const C* ol (l);
+
+        while (l > f &&
+               (*l == C (0x20) || *l == C (0x0A) ||
+                *l == C (0x0D) || *l == C (0x09)))
+          --l;
+
+        if (f != of || l != ol)
+        {
+          size = f <= l ? l - f + 1 : 0;
+          s.assign ((f <= l ? f : 0), size);
+        }
+      }
+
+      return size;
+    }
+
+    template<typename C>
+    std::basic_string<C>
+    trim (const std::basic_string<C>& s)
+    {
+      ro_string<C> tmp (s);
+      typename ro_string<C>::size_type size (tmp.size ());
+      trim (tmp);
+
+      // If we didn't change the string then return the original to help
+      // avoid copying for smart (ref counted) string implementations.
+      //
+      if (size == tmp.size ())
+        return s;
+      else
+        return tmp;
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/tree/ace-cdr-stream-common.hxx src/base/include/xsd/cxx/tree/ace-cdr-stream-common.hxx
new file mode 100644
index 0000000..7c3fc96
--- /dev/null
+++ src/base/include/xsd/cxx/tree/ace-cdr-stream-common.hxx
@@ -0,0 +1,26 @@
+// file      : xsd/cxx/tree/ace-cdr-stream-common.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_ACE_CDR_STREAM_COMMON_HXX
+#define XSD_CXX_TREE_ACE_CDR_STREAM_COMMON_HXX
+
+#include <xsd/cxx/exceptions.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      // Base exception for ACE CDR insertion/extraction exceptions.
+      //
+      struct ace_cdr_stream_operation: xsd::cxx::exception
+      {
+      };
+    }
+  }
+}
+
+#endif  // XSD_CXX_TREE_ACE_CDR_STREAM_COMMON_HXX
diff --git src/base/include/xsd/cxx/tree/ace-cdr-stream-extraction.hxx src/base/include/xsd/cxx/tree/ace-cdr-stream-extraction.hxx
new file mode 100644
index 0000000..53e1f6c
--- /dev/null
+++ src/base/include/xsd/cxx/tree/ace-cdr-stream-extraction.hxx
@@ -0,0 +1,334 @@
+// file      : xsd/cxx/tree/ace-cdr-stream-extraction.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_ACE_CDR_STREAM_EXTRACTION_HXX
+#define XSD_CXX_TREE_ACE_CDR_STREAM_EXTRACTION_HXX
+
+#include <cstddef> // std::size_t
+#include <string>
+
+#include <ace/ACE.h> // ACE::strdelete
+#include <ace/CDR_Stream.h>
+
+#include <xsd/cxx/auto-array.hxx>
+
+#include <xsd/cxx/tree/buffer.hxx>
+#include <xsd/cxx/tree/istream.hxx>
+#include <xsd/cxx/tree/ace-cdr-stream-common.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      struct ace_cdr_stream_extraction: ace_cdr_stream_operation
+      {
+        virtual const char*
+        what () const throw ()
+        {
+          return "ACE CDR stream extraction operation failed";
+        }
+      };
+
+
+      // as_size
+      //
+
+#ifdef XSD_CXX_TREE_USE_64_BIT_SIZE
+      template <typename T>
+      inline istream<ACE_InputCDR>&
+      operator>> (istream<ACE_InputCDR>& s,
+                  istream<ACE_InputCDR>::as_size<T>& x)
+      {
+        ACE_CDR::ULongLong r;
+
+        if (!s.impl ().read_ulonglong (r) ||
+            r > ~(T (0)))
+          throw ace_cdr_stream_extraction ();
+
+        x.x_ = static_cast<T> (r);
+
+        return s;
+      }
+#else
+      template <typename T>
+      inline istream<ACE_InputCDR>&
+      operator>> (istream<ACE_InputCDR>& s,
+                  istream<ACE_InputCDR>::as_size<T>& x)
+      {
+        ACE_CDR::ULong r;
+
+        if (!s.impl ().read_ulong (r))
+          throw ace_cdr_stream_extraction ();
+
+        x.x_ = static_cast<T> (r);
+
+        return s;
+      }
+#endif
+
+
+      // 8-bit
+      //
+      template <typename T>
+      inline istream<ACE_InputCDR>&
+      operator>> (istream<ACE_InputCDR>& s,
+                  istream<ACE_InputCDR>::as_int8<T>& x)
+      {
+        ACE_CDR::Octet r;
+
+        if (!s.impl ().read_octet (r))
+          throw ace_cdr_stream_extraction ();
+
+        x.x_ = static_cast<T> (r);
+
+        return s;
+      }
+
+      template <typename T>
+      inline istream<ACE_InputCDR>&
+      operator>> (istream<ACE_InputCDR>& s,
+                  istream<ACE_InputCDR>::as_uint8<T>& x)
+      {
+        ACE_CDR::Octet r;
+
+        if (!s.impl ().read_octet (r))
+          throw ace_cdr_stream_extraction ();
+
+        x.x_ = static_cast<T> (r);
+
+        return s;
+      }
+
+
+      // 16-bit
+      //
+      template <typename T>
+      inline istream<ACE_InputCDR>&
+      operator>> (istream<ACE_InputCDR>& s,
+                  istream<ACE_InputCDR>::as_int16<T>& x)
+      {
+        ACE_CDR::Short r;
+
+        if (!s.impl ().read_short (r))
+          throw ace_cdr_stream_extraction ();
+
+        x.x_ = static_cast<T> (r);
+
+        return s;
+      }
+
+      template <typename T>
+      inline istream<ACE_InputCDR>&
+      operator>> (istream<ACE_InputCDR>& s,
+                  istream<ACE_InputCDR>::as_uint16<T>& x)
+      {
+        ACE_CDR::UShort r;
+
+        if (!s.impl ().read_ushort (r))
+          throw ace_cdr_stream_extraction ();
+
+        x.x_ = static_cast<T> (r);
+
+        return s;
+      }
+
+
+      // 32-bit
+      //
+      template <typename T>
+      inline istream<ACE_InputCDR>&
+      operator>> (istream<ACE_InputCDR>& s,
+                  istream<ACE_InputCDR>::as_int32<T>& x)
+      {
+        ACE_CDR::Long r;
+
+        if (!s.impl ().read_long (r))
+          throw ace_cdr_stream_extraction ();
+
+        x.x_ = static_cast<T> (r);
+
+        return s;
+      }
+
+      template <typename T>
+      inline istream<ACE_InputCDR>&
+      operator>> (istream<ACE_InputCDR>& s,
+                  istream<ACE_InputCDR>::as_uint32<T>& x)
+      {
+        ACE_CDR::ULong r;
+
+        if (!s.impl ().read_ulong (r))
+          throw ace_cdr_stream_extraction ();
+
+        x.x_ = static_cast<T> (r);
+
+        return s;
+      }
+
+
+      // 64-bit
+      //
+      template <typename T>
+      inline istream<ACE_InputCDR>&
+      operator>> (istream<ACE_InputCDR>& s,
+                  istream<ACE_InputCDR>::as_int64<T>& x)
+      {
+        ACE_CDR::LongLong r;
+
+        if (!s.impl ().read_longlong (r))
+          throw ace_cdr_stream_extraction ();
+
+        x.x_ = static_cast<T> (r);
+
+        return s;
+      }
+
+      template <typename T>
+      inline istream<ACE_InputCDR>&
+      operator>> (istream<ACE_InputCDR>& s,
+                  istream<ACE_InputCDR>::as_uint64<T>& x)
+      {
+        ACE_CDR::ULongLong r;
+
+        if (!s.impl ().read_ulonglong (r))
+          throw ace_cdr_stream_extraction ();
+
+        x.x_ = static_cast<T> (r);
+
+        return s;
+      }
+
+
+      // Boolean
+      //
+      template <typename T>
+      inline istream<ACE_InputCDR>&
+      operator>> (istream<ACE_InputCDR>& s,
+                  istream<ACE_InputCDR>::as_bool<T>& x)
+      {
+        ACE_CDR::Boolean r;
+
+        if (!s.impl ().read_boolean (r))
+          throw ace_cdr_stream_extraction ();
+
+        x.x_ = static_cast<T> (r);
+
+        return s;
+      }
+
+
+      // Floating-point
+      //
+      template <typename T>
+      inline istream<ACE_InputCDR>&
+      operator>> (istream<ACE_InputCDR>& s,
+                  istream<ACE_InputCDR>::as_float32<T>& x)
+      {
+        ACE_CDR::Float r;
+
+        if (!s.impl ().read_float (r))
+          throw ace_cdr_stream_extraction ();
+
+        x.x_ = static_cast<T> (r);
+
+        return s;
+      }
+
+      template <typename T>
+      inline istream<ACE_InputCDR>&
+      operator>> (istream<ACE_InputCDR>& s,
+                  istream<ACE_InputCDR>::as_float64<T>& x)
+      {
+        ACE_CDR::Double r;
+
+        if (!s.impl ().read_double (r))
+          throw ace_cdr_stream_extraction ();
+
+        x.x_ = static_cast<T> (r);
+
+        return s;
+      }
+
+      // Extraction of std::basic_string.
+      //
+
+      namespace bits
+      {
+        template<typename C>
+        struct ace_str_deallocator
+        {
+          void
+          deallocate (C* s)
+          {
+            ACE::strdelete (s);
+          }
+        };
+      }
+
+      inline istream<ACE_InputCDR>&
+      operator>> (istream<ACE_InputCDR>& s, std::basic_string<char>& x)
+      {
+        typedef bits::ace_str_deallocator<char> deallocator;
+
+        deallocator d;
+        char* r;
+
+        if (!s.impl ().read_string (r))
+          throw ace_cdr_stream_extraction ();
+
+        auto_array<char, deallocator> ar (r, d);
+
+        x = r;
+
+        return s;
+      }
+
+#ifdef ACE_HAS_WCHAR
+      inline istream<ACE_InputCDR>&
+      operator>> (istream<ACE_InputCDR>& s, std::basic_string<wchar_t>& x)
+      {
+        typedef bits::ace_str_deallocator<wchar_t> deallocator;
+
+        deallocator d;
+        wchar_t* r;
+
+        if (!s.impl ().read_wstring (r))
+          throw ace_cdr_stream_extraction ();
+
+        auto_array<wchar_t, deallocator> ar (r, d);
+
+        x = r;
+
+        return s;
+      }
+#endif
+
+
+      // Extraction of a binary buffer.
+      //
+      template <typename C>
+      istream<ACE_InputCDR>&
+      operator>> (istream<ACE_InputCDR>& s, buffer<C>& x)
+      {
+        ACE_CDR::ULong size;
+
+        if (!s.impl ().read_ulong (size))
+          throw ace_cdr_stream_extraction ();
+
+        x.size (size);
+
+        if (!s.impl ().read_octet_array (
+              reinterpret_cast<ACE_CDR::Octet*> (x.data ()), size))
+          throw ace_cdr_stream_extraction ();
+
+        return s;
+      }
+    }
+  }
+}
+
+#endif  // XSD_CXX_TREE_ACE_CDR_STREAM_EXTRACTION_HXX
diff --git src/base/include/xsd/cxx/tree/ace-cdr-stream-insertion.hxx src/base/include/xsd/cxx/tree/ace-cdr-stream-insertion.hxx
new file mode 100644
index 0000000..0f723d0
--- /dev/null
+++ src/base/include/xsd/cxx/tree/ace-cdr-stream-insertion.hxx
@@ -0,0 +1,249 @@
+// file      : xsd/cxx/tree/ace-cdr-stream-insertion.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_ACE_CDR_STREAM_INSERTION_HXX
+#define XSD_CXX_TREE_ACE_CDR_STREAM_INSERTION_HXX
+
+#include <cstddef> // std::size_t
+#include <string>
+
+#include <ace/CDR_Stream.h>
+
+#include <xsd/cxx/tree/buffer.hxx>
+#include <xsd/cxx/tree/ostream.hxx>
+#include <xsd/cxx/tree/ace-cdr-stream-common.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      struct ace_cdr_stream_insertion: ace_cdr_stream_operation
+      {
+        virtual const char*
+        what () const throw ()
+        {
+          return "ACE CDR stream insertion operation failed";
+        }
+      };
+
+
+      // as_size
+      //
+
+#ifdef XSD_CXX_TREE_USE_64_BIT_SIZE
+      template <typename T>
+      inline ostream<ACE_OutputCDR>&
+      operator<< (ostream<ACE_OutputCDR>& s,
+                  ostream<ACE_OutputCDR>::as_size<T> x)
+      {
+        if (!s.impl ().write_ulonglong (
+              static_cast<ACE_CDR::ULongLong> (x.x_)))
+          throw ace_cdr_stream_insertion ();
+        return s;
+      }
+#else
+      template <typename T>
+      inline ostream<ACE_OutputCDR>&
+      operator<< (ostream<ACE_OutputCDR>& s,
+                  ostream<ACE_OutputCDR>::as_size<T> x)
+      {
+        if (x.x_ > ~(ACE_CDR::ULong (0)) ||
+            !s.impl ().write_ulong (static_cast<ACE_CDR::ULong> (x.x_)))
+          throw ace_cdr_stream_insertion ();
+
+        return s;
+      }
+#endif
+
+
+      // 8-bit
+      //
+      template <typename T>
+      inline ostream<ACE_OutputCDR>&
+      operator<< (ostream<ACE_OutputCDR>& s,
+                  ostream<ACE_OutputCDR>::as_int8<T> x)
+      {
+        ACE_CDR::Octet r (static_cast<ACE_CDR::Octet> (x.x_));
+
+        if (!s.impl ().write_octet (r))
+          throw ace_cdr_stream_insertion ();
+
+        return s;
+      }
+
+      template <typename T>
+      inline ostream<ACE_OutputCDR>&
+      operator<< (ostream<ACE_OutputCDR>& s,
+                  ostream<ACE_OutputCDR>::as_uint8<T> x)
+      {
+        ACE_CDR::Octet r (static_cast<ACE_CDR::Octet> (x.x_));
+
+        if (!s.impl ().write_octet (r))
+          throw ace_cdr_stream_insertion ();
+
+        return s;
+      }
+
+
+      // 16-bit
+      //
+      template <typename T>
+      inline ostream<ACE_OutputCDR>&
+      operator<< (ostream<ACE_OutputCDR>& s,
+                  ostream<ACE_OutputCDR>::as_int16<T> x)
+      {
+        if (!s.impl ().write_short (static_cast<ACE_CDR::Short> (x.x_)))
+          throw ace_cdr_stream_insertion ();
+        return s;
+      }
+
+      template <typename T>
+      inline ostream<ACE_OutputCDR>&
+      operator<< (ostream<ACE_OutputCDR>& s,
+                  ostream<ACE_OutputCDR>::as_uint16<T> x)
+      {
+        if (!s.impl ().write_ushort (static_cast<ACE_CDR::UShort> (x.x_)))
+          throw ace_cdr_stream_insertion ();
+        return s;
+      }
+
+
+      // 32-bit
+      //
+      template <typename T>
+      inline ostream<ACE_OutputCDR>&
+      operator<< (ostream<ACE_OutputCDR>& s,
+                  ostream<ACE_OutputCDR>::as_int32<T> x)
+      {
+        if (!s.impl ().write_long (static_cast<ACE_CDR::Long> (x.x_)))
+          throw ace_cdr_stream_insertion ();
+        return s;
+      }
+
+      template <typename T>
+      inline ostream<ACE_OutputCDR>&
+      operator<< (ostream<ACE_OutputCDR>& s,
+                  ostream<ACE_OutputCDR>::as_uint32<T> x)
+      {
+        if (!s.impl ().write_ulong (static_cast<ACE_CDR::ULong> (x.x_)))
+          throw ace_cdr_stream_insertion ();
+        return s;
+      }
+
+
+      // 64-bit
+      //
+      template <typename T>
+      inline ostream<ACE_OutputCDR>&
+      operator<< (ostream<ACE_OutputCDR>& s,
+                  ostream<ACE_OutputCDR>::as_int64<T> x)
+      {
+        if (!s.impl ().write_longlong (static_cast<ACE_CDR::LongLong> (x.x_)))
+          throw ace_cdr_stream_insertion ();
+        return s;
+      }
+
+      template <typename T>
+      inline ostream<ACE_OutputCDR>&
+      operator<< (ostream<ACE_OutputCDR>& s,
+                  ostream<ACE_OutputCDR>::as_uint64<T> x)
+      {
+        if (!s.impl ().write_ulonglong (
+              static_cast<ACE_CDR::ULongLong> (x.x_)))
+          throw ace_cdr_stream_insertion ();
+        return s;
+      }
+
+
+      // Boolean
+      //
+      template <typename T>
+      inline ostream<ACE_OutputCDR>&
+      operator<< (ostream<ACE_OutputCDR>& s,
+                  ostream<ACE_OutputCDR>::as_bool<T> x)
+      {
+        if (!s.impl ().write_boolean (static_cast<ACE_CDR::Boolean> (x.x_)))
+          throw ace_cdr_stream_insertion ();
+        return s;
+      }
+
+
+      // Floating-point
+      //
+      template <typename T>
+      inline ostream<ACE_OutputCDR>&
+      operator<< (ostream<ACE_OutputCDR>& s,
+                  ostream<ACE_OutputCDR>::as_float32<T> x)
+      {
+        if (!s.impl ().write_float (static_cast<ACE_CDR::Float> (x.x_)))
+          throw ace_cdr_stream_insertion ();
+        return s;
+      }
+
+      template <typename T>
+      inline ostream<ACE_OutputCDR>&
+      operator<< (ostream<ACE_OutputCDR>& s,
+                  ostream<ACE_OutputCDR>::as_float64<T> x)
+      {
+        if (!s.impl ().write_double (static_cast<ACE_CDR::Double> (x.x_)))
+          throw ace_cdr_stream_insertion ();
+        return s;
+      }
+
+      // Insertion of std::basic_string.
+      //
+
+      inline ostream<ACE_OutputCDR>&
+      operator<< (ostream<ACE_OutputCDR>& s, const std::basic_string<char>& x)
+      {
+        // ACE CDR strings are hard-wired with a 32 bit length.
+        //
+        if (x.length () > ~(ACE_CDR::ULong (0)) ||
+            !s.impl ().write_string (
+              static_cast<ACE_CDR::ULong> (x.length ()), x.c_str ()))
+          throw ace_cdr_stream_insertion ();
+        return s;
+      }
+
+#ifdef ACE_HAS_WCHAR
+      inline ostream<ACE_OutputCDR>&
+      operator<< (ostream<ACE_OutputCDR>& s,
+                  const std::basic_string<wchar_t>& x)
+      {
+        // ACE CDR strings are hard-wired with a 32 bit length.
+        //
+        if (x.length () > ~(ACE_CDR::ULong (0)) ||
+            !s.impl ().write_wstring (
+              static_cast<ACE_CDR::ULong> (x.length ()), x.c_str ()))
+          throw ace_cdr_stream_insertion ();
+        return s;
+      }
+#endif
+
+      // Insertion of a binary buffer.
+      //
+      template <typename C>
+      ostream<ACE_OutputCDR>&
+      operator<< (ostream<ACE_OutputCDR>& s, const buffer<C>& x)
+      {
+        std::size_t size (x.size ());
+
+        // It is not possible to write an array with a 64-bit size.
+        //
+        if (size > ~(ACE_CDR::ULong (0)) ||
+            !s.impl ().write_ulong (static_cast<ACE_CDR::ULong> (size)) ||
+            !s.impl ().write_octet_array (
+              reinterpret_cast<const ACE_CDR::Octet*> (x.data ()), size))
+          throw ace_cdr_stream_insertion ();
+
+        return s;
+      }
+    }
+  }
+}
+
+#endif  // XSD_CXX_TREE_ACE_CDR_STREAM_INSERTION_HXX
diff --git src/base/include/xsd/cxx/tree/bits/literals.hxx src/base/include/xsd/cxx/tree/bits/literals.hxx
new file mode 100644
index 0000000..49ac0ca
--- /dev/null
+++ src/base/include/xsd/cxx/tree/bits/literals.hxx
@@ -0,0 +1,261 @@
+// file      : xsd/cxx/tree/bits/literals.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_BITS_LITERALS_HXX
+#define XSD_CXX_TREE_BITS_LITERALS_HXX
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      namespace bits
+      {
+        // Boolean literals
+        //
+        template<typename C>
+        const C*
+        true_ ();
+
+        template<typename C>
+        const C*
+        one ();
+
+        // Float literals: INF -INF NaN.
+        //
+        template<typename C>
+        const C*
+        positive_inf ();
+
+        template<typename C>
+        const C*
+        negative_inf ();
+
+        template<typename C>
+        const C*
+        nan ();
+
+        // Optional "not present" literal.
+        //
+        template<typename C>
+        const C*
+        not_present ();
+
+        // XML Schema namespace
+        //
+        template <typename C>
+        const C*
+        xml_schema ();
+
+        // Built-in XML Schema type names.
+        //
+        template <typename C>
+        const C*
+        any_type ();
+
+        template <typename C>
+        const C*
+        any_simple_type ();
+
+        template <typename C>
+        const C*
+        string ();
+
+        template <typename C>
+        const C*
+        normalized_string ();
+
+        template <typename C>
+        const C*
+        token ();
+
+        template <typename C>
+        const C*
+        name ();
+
+        template <typename C>
+        const C*
+        nmtoken ();
+
+        template <typename C>
+        const C*
+        nmtokens ();
+
+        template <typename C>
+        const C*
+        ncname ();
+
+        template <typename C>
+        const C*
+        language ();
+
+        template <typename C>
+        const C*
+        id ();
+
+        template <typename C>
+        const C*
+        idref ();
+
+        template <typename C>
+        const C*
+        idrefs ();
+
+        template <typename C>
+        const C*
+        any_uri ();
+
+        template <typename C>
+        const C*
+        qname ();
+
+        template <typename C>
+        const C*
+        base64_binary ();
+
+        template <typename C>
+        const C*
+        hex_binary ();
+
+        template <typename C>
+        const C*
+        date ();
+
+        template <typename C>
+        const C*
+        date_time ();
+
+        template <typename C>
+        const C*
+        duration ();
+
+        template <typename C>
+        const C*
+        gday ();
+
+        template <typename C>
+        const C*
+        gmonth ();
+
+        template <typename C>
+        const C*
+        gmonth_day ();
+
+        template <typename C>
+        const C*
+        gyear ();
+
+        template <typename C>
+        const C*
+        gyear_month ();
+
+        template <typename C>
+        const C*
+        time ();
+
+        template <typename C>
+        const C*
+        entity ();
+
+        template <typename C>
+        const C*
+        entities ();
+
+        // gday ("---") and gmonth ("--") prefixes.
+        //
+        template <typename C>
+        const C*
+        gday_prefix ();
+
+        template <typename C>
+        const C*
+        gmonth_prefix ();
+
+        // Exception and diagnostics string literals.
+        //
+        template <typename C>
+        const C*
+        ex_error_error (); // " error: "
+
+        template <typename C>
+        const C*
+        ex_error_warning (); // " warning: "
+
+        template <typename C>
+        const C*
+        ex_parsing_msg (); // "instance document parsing failed"
+
+        template <typename C>
+        const C*
+        ex_eel_expected (); // "expected element '"
+
+        template <typename C>
+        const C*
+        ex_uel_expected (); // "expected element '"
+
+        template <typename C>
+        const C*
+        ex_uel_instead (); // "' instead of '"
+
+        template <typename C>
+        const C*
+        ex_uel_unexpected (); // "unexpected element '"
+
+        template <typename C>
+        const C*
+        ex_eat_expected (); // "expected attribute '"
+
+        template <typename C>
+        const C*
+        ex_uen_unexpected (); // "unexpected enumerator '"
+
+        template <typename C>
+        const C*
+        ex_etc_msg (); // "expected text content"
+
+        template <typename C>
+        const C*
+        ex_nti_no_type_info (); // "no type information available for type '"
+
+        template <typename C>
+        const C*
+        ex_nei_no_element_info (); // "no parsing or serialization information
+                                   // available for element '"
+        template <typename C>
+        const C*
+        ex_nd_type (); // "type '"
+
+        template <typename C>
+        const C*
+        ex_nd_not_derived (); // "' is not derived from '"
+
+        template <typename C>
+        const C*
+        ex_di_id (); // "ID '"
+
+        template <typename C>
+        const C*
+        ex_di_already_exist (); // "' already exist"
+
+        template <typename C>
+        const C*
+        ex_serialization_msg (); // "serialization failed"
+
+        template <typename C>
+        const C*
+        ex_npm_no_mapping (); // "no mapping provided for namespace prefix '"
+
+        template <typename C>
+        const C*
+        ex_bounds_msg (); // "buffer boundary rules have been violated"
+      }
+    }
+  }
+}
+
+#endif  // XSD_CXX_TREE_BITS_LITERALS_HXX
+
+#include <xsd/cxx/tree/bits/literals.ixx>
diff --git src/base/include/xsd/cxx/tree/bits/literals.ixx src/base/include/xsd/cxx/tree/bits/literals.ixx
new file mode 100644
index 0000000..260a9e7
--- /dev/null
+++ src/base/include/xsd/cxx/tree/bits/literals.ixx
@@ -0,0 +1,876 @@
+// file      : xsd/cxx/tree/bits/literals.ixx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_BITS_LITERALS_IXX
+#define XSD_CXX_TREE_BITS_LITERALS_IXX
+
+// The char versions of the following literals are required even
+// if we are using wchar_t as the character type.
+//
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      namespace bits
+      {
+        //
+        //
+        template<>
+        inline const char*
+        positive_inf<char> ()
+        {
+          return "INF";
+        }
+
+        template<>
+        inline const char*
+        negative_inf<char> ()
+        {
+          return "-INF";
+        }
+
+        template<>
+        inline const char*
+        nan<char> ()
+        {
+          return "NaN";
+        }
+      }
+    }
+  }
+}
+
+#endif // XSD_CXX_TREE_BITS_LITERALS_IXX
+
+
+#if defined(XSD_CXX_TREE_USE_CHAR) || !defined(XSD_CXX_TREE_USE_WCHAR)
+
+#ifndef XSD_CXX_TREE_BITS_LITERALS_IXX_CHAR
+#define XSD_CXX_TREE_BITS_LITERALS_IXX_CHAR
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      namespace bits
+      {
+        //
+        //
+        template<>
+        inline const char*
+        true_<char> ()
+        {
+          return "true";
+        }
+
+        template<>
+        inline const char*
+        one<char> ()
+        {
+          return "1";
+        }
+
+        //
+        //
+        template<>
+        inline const char*
+        not_present<char> ()
+        {
+          return "<not present>";
+        }
+
+        //
+        //
+        template <>
+        inline const char*
+        xml_schema<char> ()
+        {
+          return "http://www.w3.org/2001/XMLSchema";
+        }
+
+        //
+        //
+        template <>
+        inline const char*
+        any_type<char> ()
+        {
+          return "anyType";
+        }
+
+        template <>
+        inline const char*
+        any_simple_type<char> ()
+        {
+          return "anySimpleType";
+        }
+
+        template <>
+        inline const char*
+        string<char> ()
+        {
+          return "string";
+        }
+
+        template <>
+        inline const char*
+        normalized_string<char> ()
+        {
+          return "normalizedString";
+        }
+
+        template <>
+        inline const char*
+        token<char> ()
+        {
+          return "token";
+        }
+
+        template <>
+        inline const char*
+        name<char> ()
+        {
+          return "Name";
+        }
+
+        template <>
+        inline const char*
+        nmtoken<char> ()
+        {
+          return "NMTOKEN";
+        }
+
+        template <>
+        inline const char*
+        nmtokens<char> ()
+        {
+          return "NMTOKENS";
+        }
+
+        template <>
+        inline const char*
+        ncname<char> ()
+        {
+          return "NCName";
+        }
+
+        template <>
+        inline const char*
+        language<char> ()
+        {
+          return "language";
+        }
+
+
+        template <>
+        inline const char*
+        id<char> ()
+        {
+          return "ID";
+        }
+
+        template <>
+        inline const char*
+        idref<char> ()
+        {
+          return "IDREF";
+        }
+
+        template <>
+        inline const char*
+        idrefs<char> ()
+        {
+          return "IDREFS";
+        }
+
+        template <>
+        inline const char*
+        any_uri<char> ()
+        {
+          return "anyURI";
+        }
+
+        template <>
+        inline const char*
+        qname<char> ()
+        {
+          return "QName";
+        }
+
+        template <>
+        inline const char*
+        base64_binary<char> ()
+        {
+          return "base64Binary";
+        }
+
+        template <>
+        inline const char*
+        hex_binary<char> ()
+        {
+          return "hexBinary";
+        }
+
+        template <>
+        inline const char*
+        date<char> ()
+        {
+          return "date";
+        }
+
+        template <>
+        inline const char*
+        date_time<char> ()
+        {
+          return "dateTime";
+        }
+
+        template <>
+        inline const char*
+        duration<char> ()
+        {
+          return "duration";
+        }
+
+        template <>
+        inline const char*
+        gday<char> ()
+        {
+          return "gDay";
+        }
+
+        template <>
+        inline const char*
+        gmonth<char> ()
+        {
+          return "gMonth";
+        }
+
+        template <>
+        inline const char*
+        gmonth_day<char> ()
+        {
+          return "gMonthDay";
+        }
+
+        template <>
+        inline const char*
+        gyear<char> ()
+        {
+          return "gYear";
+        }
+
+        template <>
+        inline const char*
+        gyear_month<char> ()
+        {
+          return "gYearMonth";
+        }
+
+        template <>
+        inline const char*
+        time<char> ()
+        {
+          return "time";
+        }
+
+        template <>
+        inline const char*
+        entity<char> ()
+        {
+          return "ENTITY";
+        }
+
+        template <>
+        inline const char*
+        entities<char> ()
+        {
+          return "ENTITIES";
+        }
+
+        template <>
+        inline const char*
+        gday_prefix<char> ()
+        {
+          return "---";
+        }
+
+        template <>
+        inline const char*
+        gmonth_prefix<char> ()
+        {
+          return "--";
+        }
+
+        //
+        //
+        template <>
+        inline const char*
+        ex_error_error<char> ()
+        {
+          return " error: ";
+        }
+
+        template <>
+        inline const char*
+        ex_error_warning<char> ()
+        {
+          return " warning: ";
+        }
+
+        template <>
+        inline const char*
+        ex_parsing_msg<char> ()
+        {
+          return "instance document parsing failed";
+        }
+
+        template <>
+        inline const char*
+        ex_eel_expected<char> ()
+        {
+          return "expected element '";
+        }
+
+        template <>
+        inline const char*
+        ex_uel_expected<char> ()
+        {
+          return "expected element '";
+        }
+
+        template <>
+        inline const char*
+        ex_uel_instead<char> ()
+        {
+          return "' instead of '";
+        }
+
+        template <>
+        inline const char*
+        ex_uel_unexpected<char> ()
+        {
+          return "unexpected element '";
+        }
+
+        template <>
+        inline const char*
+        ex_eat_expected<char> ()
+        {
+          return "expected attribute '";
+        }
+
+        template <>
+        inline const char*
+        ex_uen_unexpected<char> ()
+        {
+          return "unexpected enumerator '";
+        }
+
+        template <>
+        inline const char*
+        ex_etc_msg<char> ()
+        {
+          return "expected text content";
+        }
+
+        template <>
+        inline const char*
+        ex_nti_no_type_info<char> ()
+        {
+          return "no type information available for type '";
+        }
+
+        template <>
+        inline const char*
+        ex_nei_no_element_info<char> ()
+        {
+          return "no parsing or serialization information available for "
+            "element '";
+        }
+        template <>
+        inline const char*
+        ex_nd_type<char> ()
+        {
+          return "type '";
+        }
+
+        template <>
+        inline const char*
+        ex_nd_not_derived<char> ()
+        {
+          return "' is not derived from '";
+        }
+
+        template <>
+        inline const char*
+        ex_di_id<char> ()
+        {
+          return "ID '";
+        }
+
+        template <>
+        inline const char*
+        ex_di_already_exist<char> ()
+        {
+          return "' already exist";
+        }
+
+        template <>
+        inline const char*
+        ex_serialization_msg<char> ()
+        {
+          return "serialization failed";
+        }
+
+        template <>
+        inline const char*
+        ex_npm_no_mapping<char> ()
+        {
+          return "no mapping provided for namespace prefix '";
+        }
+
+        template <>
+        inline const char*
+        ex_bounds_msg<char> ()
+        {
+          return "buffer boundary rules have been violated";
+        }
+      }
+    }
+  }
+}
+
+#endif // XSD_CXX_TREE_BITS_LITERALS_IXX_CHAR
+#endif // XSD_CXX_TREE_USE_CHAR
+
+
+#if defined(XSD_CXX_TREE_USE_WCHAR) || !defined(XSD_CXX_TREE_USE_CHAR)
+
+#ifndef XSD_CXX_TREE_BITS_LITERALS_IXX_WCHAR
+#define XSD_CXX_TREE_BITS_LITERALS_IXX_WCHAR
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      namespace bits
+      {
+        //
+        //
+        template<>
+        inline const wchar_t*
+        true_<wchar_t> ()
+        {
+          return L"true";
+        }
+
+        template<>
+        inline const wchar_t*
+        one<wchar_t> ()
+        {
+          return L"1";
+        }
+
+        //
+        //
+        template<>
+        inline const wchar_t*
+        positive_inf<wchar_t> ()
+        {
+          return L"INF";
+        }
+
+        template<>
+        inline const wchar_t*
+        negative_inf<wchar_t> ()
+        {
+          return L"-INF";
+        }
+
+        template<>
+        inline const wchar_t*
+        nan<wchar_t> ()
+        {
+          return L"NaN";
+        }
+
+        //
+        //
+        template<>
+        inline const wchar_t*
+        not_present<wchar_t> ()
+        {
+          return L"<not present>";
+        }
+
+        //
+        //
+        template <>
+        inline const wchar_t*
+        xml_schema<wchar_t> ()
+        {
+          return L"http://www.w3.org/2001/XMLSchema";
+        }
+
+        //
+        //
+        template <>
+        inline const wchar_t*
+        any_type<wchar_t> ()
+        {
+          return L"anyType";
+        }
+
+        template <>
+        inline const wchar_t*
+        any_simple_type<wchar_t> ()
+        {
+          return L"anySimpleType";
+        }
+
+        template <>
+        inline const wchar_t*
+        string<wchar_t> ()
+        {
+          return L"string";
+        }
+
+        template <>
+        inline const wchar_t*
+        normalized_string<wchar_t> ()
+        {
+          return L"normalizedString";
+        }
+
+        template <>
+        inline const wchar_t*
+        token<wchar_t> ()
+        {
+          return L"token";
+        }
+
+        template <>
+        inline const wchar_t*
+        name<wchar_t> ()
+        {
+          return L"Name";
+        }
+
+        template <>
+        inline const wchar_t*
+        nmtoken<wchar_t> ()
+        {
+          return L"NMTOKEN";
+        }
+
+        template <>
+        inline const wchar_t*
+        nmtokens<wchar_t> ()
+        {
+          return L"NMTOKENS";
+        }
+
+        template <>
+        inline const wchar_t*
+        ncname<wchar_t> ()
+        {
+          return L"NCName";
+        }
+
+        template <>
+        inline const wchar_t*
+        language<wchar_t> ()
+        {
+          return L"language";
+        }
+
+
+        template <>
+        inline const wchar_t*
+        id<wchar_t> ()
+        {
+          return L"ID";
+        }
+
+        template <>
+        inline const wchar_t*
+        idref<wchar_t> ()
+        {
+          return L"IDREF";
+        }
+
+        template <>
+        inline const wchar_t*
+        idrefs<wchar_t> ()
+        {
+          return L"IDREFS";
+        }
+
+        template <>
+        inline const wchar_t*
+        any_uri<wchar_t> ()
+        {
+          return L"anyURI";
+        }
+
+        template <>
+        inline const wchar_t*
+        qname<wchar_t> ()
+        {
+          return L"QName";
+        }
+
+        template <>
+        inline const wchar_t*
+        base64_binary<wchar_t> ()
+        {
+          return L"base64Binary";
+        }
+
+        template <>
+        inline const wchar_t*
+        hex_binary<wchar_t> ()
+        {
+          return L"hexBinary";
+        }
+
+        template <>
+        inline const wchar_t*
+        date<wchar_t> ()
+        {
+          return L"date";
+        }
+
+        template <>
+        inline const wchar_t*
+        date_time<wchar_t> ()
+        {
+          return L"dateTime";
+        }
+
+        template <>
+        inline const wchar_t*
+        duration<wchar_t> ()
+        {
+          return L"duration";
+        }
+
+        template <>
+        inline const wchar_t*
+        gday<wchar_t> ()
+        {
+          return L"gDay";
+        }
+
+        template <>
+        inline const wchar_t*
+        gmonth<wchar_t> ()
+        {
+          return L"gMonth";
+        }
+
+        template <>
+        inline const wchar_t*
+        gmonth_day<wchar_t> ()
+        {
+          return L"gMonthDay";
+        }
+
+        template <>
+        inline const wchar_t*
+        gyear<wchar_t> ()
+        {
+          return L"gYear";
+        }
+
+        template <>
+        inline const wchar_t*
+        gyear_month<wchar_t> ()
+        {
+          return L"gYearMonth";
+        }
+
+        template <>
+        inline const wchar_t*
+        time<wchar_t> ()
+        {
+          return L"time";
+        }
+
+        template <>
+        inline const wchar_t*
+        entity<wchar_t> ()
+        {
+          return L"ENTITY";
+        }
+
+        template <>
+        inline const wchar_t*
+        entities<wchar_t> ()
+        {
+          return L"ENTITIES";
+        }
+
+        template <>
+        inline const wchar_t*
+        gday_prefix<wchar_t> ()
+        {
+          return L"---";
+        }
+
+        template <>
+        inline const wchar_t*
+        gmonth_prefix<wchar_t> ()
+        {
+          return L"--";
+        }
+
+        //
+        //
+        template <>
+        inline const wchar_t*
+        ex_error_error<wchar_t> ()
+        {
+          return L" error: ";
+        }
+
+        template <>
+        inline const wchar_t*
+        ex_error_warning<wchar_t> ()
+        {
+          return L" warning: ";
+        }
+
+        template <>
+        inline const wchar_t*
+        ex_parsing_msg<wchar_t> ()
+        {
+          return L"instance document parsing failed";
+        }
+
+        template <>
+        inline const wchar_t*
+        ex_eel_expected<wchar_t> ()
+        {
+          return L"expected element '";
+        }
+
+        template <>
+        inline const wchar_t*
+        ex_uel_expected<wchar_t> ()
+        {
+          return L"expected element '";
+        }
+
+        template <>
+        inline const wchar_t*
+        ex_uel_instead<wchar_t> ()
+        {
+          return L"' instead of '";
+        }
+
+        template <>
+        inline const wchar_t*
+        ex_uel_unexpected<wchar_t> ()
+        {
+          return L"unexpected element '";
+        }
+
+        template <>
+        inline const wchar_t*
+        ex_eat_expected<wchar_t> ()
+        {
+          return L"expected attribute '";
+        }
+
+        template <>
+        inline const wchar_t*
+        ex_uen_unexpected<wchar_t> ()
+        {
+          return L"unexpected enumerator '";
+        }
+
+        template <>
+        inline const wchar_t*
+        ex_etc_msg<wchar_t> ()
+        {
+          return L"expected text content";
+        }
+
+        template <>
+        inline const wchar_t*
+        ex_nti_no_type_info<wchar_t> ()
+        {
+          return L"no type information available for type '";
+        }
+
+        template <>
+        inline const wchar_t*
+        ex_nei_no_element_info<wchar_t> ()
+        {
+          return L"no parsing or serialization information available for "
+            L"element '";
+        }
+        template <>
+        inline const wchar_t*
+        ex_nd_type<wchar_t> ()
+        {
+          return L"type '";
+        }
+
+        template <>
+        inline const wchar_t*
+        ex_nd_not_derived<wchar_t> ()
+        {
+          return L"' is not derived from '";
+        }
+
+        template <>
+        inline const wchar_t*
+        ex_di_id<wchar_t> ()
+        {
+          return L"ID '";
+        }
+
+        template <>
+        inline const wchar_t*
+        ex_di_already_exist<wchar_t> ()
+        {
+          return L"' already exist";
+        }
+
+        template <>
+        inline const wchar_t*
+        ex_serialization_msg<wchar_t> ()
+        {
+          return L"serialization failed";
+        }
+
+        template <>
+        inline const wchar_t*
+        ex_npm_no_mapping<wchar_t> ()
+        {
+          return L"no mapping provided for namespace prefix '";
+        }
+
+        template <>
+        inline const wchar_t*
+        ex_bounds_msg<wchar_t> ()
+        {
+          return L"buffer boundary rules have been violated";
+        }
+      }
+    }
+  }
+}
+
+#endif // XSD_CXX_TREE_BITS_LITERALS_IXX_WCHAR
+#endif // XSD_CXX_TREE_USE_WCHAR
diff --git src/base/include/xsd/cxx/tree/buffer.hxx src/base/include/xsd/cxx/tree/buffer.hxx
new file mode 100644
index 0000000..24da287
--- /dev/null
+++ src/base/include/xsd/cxx/tree/buffer.hxx
@@ -0,0 +1,337 @@
+// file      : xsd/cxx/tree/buffer.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+/**
+ * @file
+ *
+ * @brief Contains a simple binary buffer abstraction that is used to
+ * implement the base64Binary and hexBinary XML Schema built-in types.
+ *
+ * This is an internal header and is included by the generated code. You
+ * normally should not include it directly.
+ *
+ */
+
+#ifndef XSD_CXX_TREE_BUFFER_HXX
+#define XSD_CXX_TREE_BUFFER_HXX
+
+#include <new>     // operator new/delete
+#include <cstddef> // std::size_t
+#include <cstring> // std::memcpy, std::memcmp
+
+#include <xsd/cxx/tree/exceptions.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    /**
+     * @brief C++/Tree mapping runtime namespace.
+     *
+     * This is an internal namespace and normally should not be referenced
+     * directly. Instead you should use the aliases for types in this
+     * namespaces that are created in the generated code.
+     *
+     */
+    namespace tree
+    {
+      //@cond
+
+      class buffer_base
+      {
+      protected:
+        virtual
+        ~buffer_base ()
+        {
+          if (free_ && data_)
+            operator delete (data_);
+        }
+
+        buffer_base ()
+            : data_ (0), size_ (0), capacity_ (0), free_ (true)
+        {
+        }
+
+      protected:
+        char* data_;
+        size_t size_;
+        size_t capacity_;
+        bool free_;
+      };
+
+      //@endcond
+
+      /**
+       * @brief Simple binary %buffer abstraction
+       *
+       * The %buffer class manages a continuous binary %buffer. The base
+       * concepts are data (actual memory region), size (the portion of
+       * the %buffer that contains useful information), and capacity (the
+       * actual size of the underlying memory region). The bounds
+       * %exception is thrown from the constructors and modifier functions
+       * if the (size <= capacity) constraint is violated.
+       *
+       * Note that the template parameter is only used to instantiate
+       * %exception types. The underlying %buffer type is always @c char.
+       *
+       * @nosubgrouping
+       */
+      template<typename C>
+      class buffer: protected buffer_base
+      {
+      public:
+        /**
+         * @brief Size type
+         */
+        typedef std::size_t size_t;
+
+      public:
+        /**
+         * @name Constructors
+         */
+        //@{
+
+        /**
+         * @brief Allocate a %buffer of the specified size.
+         *
+         * The resulting %buffer has the same size and capacity.
+         *
+         * @param size A %buffer size in bytes.
+         */
+        explicit
+        buffer (size_t size = 0);
+
+        /**
+         * @brief Allocate a %buffer of the specified size and capacity.
+         *
+         * @param size A %buffer size in bytes.
+         * @param capacity A %buffer capacity in bytes.
+         * @throw bounds If @a size exceeds @a capacity
+         */
+        buffer (size_t size, size_t capacity);
+
+        /**
+         * @brief Allocate a %buffer of the specified size and copy
+         * the data.
+         *
+         * The resulting %buffer has the same size and capacity with
+         * @a size bytes copied from @a data.
+         *
+         * @param data A %buffer to copy the data from.
+         * @param size A %buffer size in bytes.
+         */
+        buffer (const void* data, size_t size);
+
+        /**
+         * @brief Allocate a %buffer of the specified size and capacity
+         * and copy the data.
+         *
+         * @a size bytes are copied from @a data to the resulting
+         * %buffer.
+         *
+         * @param data A %buffer to copy the data from.
+         * @param size A %buffer size in bytes.
+         * @param capacity A %buffer capacity in bytes.
+         * @throw bounds If @a size exceeds @a capacity
+         */
+        buffer (const void* data, size_t size, size_t capacity);
+
+        /**
+         * @brief Reuse an existing %buffer.
+         *
+         * If the @a assume_ownership argument is true, the %buffer will
+         * assume ownership of @a data and will release the memory
+         * by calling @c operator @c delete().
+         *
+         * @param data A %buffer to reuse.
+         * @param size A %buffer size in bytes.
+         * @param capacity A %buffer capacity in bytes.
+         * @param assume_ownership A boolean value indication whether to
+         * assume ownership.
+         * @throw bounds If @a size exceeds @a capacity
+         */
+        buffer (void* data,
+                size_t size,
+                size_t capacity,
+                bool assume_ownership);
+
+        /**
+         * @brief Copy constructor.
+         *
+         * The copy constructor performs a deep copy of the underlying
+         * memory %buffer.
+         *
+         * @param x An instance to make a copy of.
+         */
+        buffer (const buffer& x);
+
+        //@}
+
+      public:
+        /**
+         * @brief Copy assignment operator.
+         *
+         * The copy assignment operator changes the buffer's capacity
+         * to @c x.capacity() and copies @c x.size() bytes from @a x.
+         *
+         * @param x An instance to assign.
+         * @return A reference to the instance.
+         */
+        buffer&
+        operator= (const buffer& x);
+
+      public:
+        /**
+         * @brief Get buffer's capacity.
+         *
+         * @return A number of bytes that the %buffer can hold without
+         * reallocation.
+         */
+        size_t
+        capacity () const
+	{
+	  return capacity_;
+	}
+
+        /**
+         * @brief Set buffer's capacity.
+         *
+         * @param c The new capacity in bytes.
+         * @return True if the underlying %buffer has moved, false otherwise.
+         */
+        bool
+        capacity (size_t c)
+        {
+          return this->capacity (c, true);
+        }
+
+      public:
+        /**
+         * @brief Get buffer's size.
+         *
+         * @return A number of bytes that the %buffer holds.
+         */
+        size_t
+        size () const {return size_;}
+
+        /**
+         * @brief Set buffer's size.
+         *
+         * @param s The new size in bytes.
+         * @return True if the underlying %buffer has moved, false otherwise.
+         */
+        bool
+        size (size_t s)
+        {
+          bool r (false);
+
+          if (s > capacity_)
+            r = capacity (s);
+
+          size_ = s;
+
+          return r;
+        }
+
+      public:
+        /**
+         * @brief Get the underlying memory region.
+         *
+         * @return A constant pointer to the underlying memory region.
+         */
+        const char*
+        data () const {return data_;}
+
+        /**
+         * @brief Get the underlying memory region.
+         *
+         * @return A pointer to the underlying memory region.
+         */
+        char*
+        data () {return data_;}
+
+        /**
+         * @brief Get the beginning of the underlying memory region.
+         *
+         * @return A constant pointer to the first byte of the underlying
+         * memory region.
+         */
+        const char*
+        begin () const {return data_;}
+
+        /**
+         * @brief Get the beginning of the underlying memory region.
+         *
+         * @return A pointer to the first byte of the underlying memory
+         * region.
+         */
+        char*
+        begin () {return data_;}
+
+        /**
+         * @brief Get the end of the underlying memory region.
+         *
+         * @return A constant pointer to the one past last byte of the
+         * underlying memory region (that is @c %begin() @c + @c %size() ).
+         */
+        const char*
+        end () const {return data_ + size_;}
+
+        /**
+         * @brief Get the end of the underlying memory region.
+         *
+         * @return A pointer to the one past last byte of the underlying
+         * memory region (that is @c %begin() @c + @c %size() ).
+         */
+        char*
+        end () {return data_ + size_;}
+
+      public:
+        /**
+         * @brief Swap data with another %buffer.
+         *
+         * @param x A %buffer to swap with.
+         */
+        void
+        swap (buffer& x);
+
+      private:
+        bool
+        capacity (size_t capacity, bool copy);
+      };
+
+      /**
+       * @brief %buffer comparison operator.
+       *
+       * @return True if the buffers have the same sizes and the same
+       * data.
+       */
+      template <typename C>
+      inline bool
+      operator== (const buffer<C>& a, const buffer<C>& b)
+      {
+        return a.size () == b.size () &&
+          std::memcmp (a.data (), b.data (), a.size ()) == 0;
+      }
+
+      /**
+       * @brief %buffer comparison operator.
+       *
+       * @return True if the buffers have different sizes or different
+       * data.
+       */
+      template <typename C>
+      inline bool
+      operator!= (const buffer<C>& a, const buffer<C>& b)
+      {
+        return !(a == b);
+      }
+    }
+  }
+}
+
+#include <xsd/cxx/tree/buffer.txx>
+
+#endif  // XSD_CXX_TREE_BUFFER_HXX
diff --git src/base/include/xsd/cxx/tree/buffer.txx src/base/include/xsd/cxx/tree/buffer.txx
new file mode 100644
index 0000000..f88f140
--- /dev/null
+++ src/base/include/xsd/cxx/tree/buffer.txx
@@ -0,0 +1,147 @@
+// file      : xsd/cxx/tree/buffer.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      template <typename C>
+      buffer<C>::
+      buffer (size_t size)
+      {
+        capacity (size);
+        size_ = size;
+      }
+
+      template <typename C>
+      buffer<C>::
+      buffer (size_t size, size_t capacity)
+      {
+        if (size > capacity)
+          throw bounds<C> ();
+
+        this->capacity (capacity);
+        size_ = size;
+      }
+
+      template <typename C>
+      buffer<C>::
+      buffer (const void* data, size_t size)
+      {
+        capacity (size);
+        size_ = size;
+
+        if (size_)
+          std::memcpy (data_, data, size_);
+      }
+
+      template <typename C>
+      buffer<C>::
+      buffer (const void* data, size_t size, size_t capacity)
+      {
+        if (size > capacity)
+          throw bounds<C> ();
+
+        this->capacity (capacity);
+        size_ = size;
+
+        if (size_)
+          std::memcpy (data_, data, size_);
+      }
+
+      template <typename C>
+      buffer<C>::
+      buffer (void* data, size_t size, size_t capacity, bool own)
+      {
+        if (size > capacity)
+          throw bounds<C> ();
+
+        data_ = reinterpret_cast<char*> (data);
+        size_ = size;
+        capacity_ = capacity;
+        free_ = own;
+      }
+
+      template <typename C>
+      buffer<C>::
+      buffer (const buffer& other)
+          : buffer_base ()
+      {
+        capacity (other.capacity_);
+        size_ = other.size_;
+
+        if (size_)
+          std::memcpy (data_, other.data_, size_);
+      }
+
+      template <typename C>
+      buffer<C>& buffer<C>::
+      operator= (const buffer& other)
+      {
+        if (this != &other)
+        {
+          capacity (other.capacity_, false);
+          size_ = other.size_;
+
+          if (size_)
+            std::memcpy (data_, other.data_, size_);
+        }
+
+        return *this;
+      }
+
+      template <typename C>
+      void buffer<C>::
+      swap (buffer& other)
+      {
+        char* tmp_data (data_);
+        size_t tmp_size (size_);
+        size_t tmp_capacity (capacity_);
+        bool tmp_free (free_);
+
+        data_ = other.data_;
+        size_ = other.size_;
+        capacity_ = other.capacity_;
+        free_ = other.free_;
+
+        other.data_ = tmp_data;
+        other.size_ = tmp_size;
+        other.capacity_ = tmp_capacity;
+        other.free_ = tmp_free;
+      }
+
+      template <typename C>
+      bool buffer<C>::
+      capacity (size_t capacity, bool copy)
+      {
+        if (size_ > capacity)
+          throw bounds<C> ();
+
+        if (capacity <= capacity_)
+        {
+          return false; // Do nothing if shrinking is requested.
+        }
+        else
+        {
+          char* data (reinterpret_cast<char*> (operator new (capacity)));
+
+          if (copy && size_ > 0)
+            std::memcpy (data, data_, size_);
+
+          if (free_ && data_)
+            operator delete (data_);
+
+          data_ = data;
+          capacity_ = capacity;
+          free_ = true;
+
+          return true;
+        }
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/tree/comparison-map.hxx src/base/include/xsd/cxx/tree/comparison-map.hxx
new file mode 100644
index 0000000..b7794f4
--- /dev/null
+++ src/base/include/xsd/cxx/tree/comparison-map.hxx
@@ -0,0 +1,113 @@
+// file      : xsd/cxx/tree/comparison-map.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_COMPARISON_MAP_HXX
+#define XSD_CXX_TREE_COMPARISON_MAP_HXX
+
+#include <map>
+#include <cstddef>  // std::size_t
+#include <typeinfo>
+
+#include <xsd/cxx/tree/elements.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      template <typename C>
+      struct comparison_map
+      {
+        typedef std::type_info type_id;
+        typedef bool (*comparator) (const type&, const type&);
+
+        comparison_map ();
+
+        void
+        register_type (const type_id&, comparator, bool override = true);
+
+        void
+        unregister_type (const type_id&);
+
+        bool
+        compare (const type&, const type&);
+
+      public:
+        comparator
+        find (const type_id&) const;
+
+      private:
+        struct type_id_comparator
+        {
+          bool
+          operator() (const type_id* x, const type_id* y) const
+          {
+            // XL C++ on AIX has buggy type_info::before() in that
+            // it returns true for two different type_info objects
+            // that happened to be for the same type.
+            //
+#if defined(__xlC__) && defined(_AIX)
+            return *x != *y && x->before (*y);
+#else
+            return x->before (*y);
+#endif
+          }
+        };
+
+        typedef
+        std::map<const type_id*, comparator, type_id_comparator>
+        type_map;
+
+        type_map type_map_;
+      };
+
+      //
+      //
+      template<unsigned long id, typename C>
+      struct comparison_plate
+      {
+        static comparison_map<C>* map;
+        static std::size_t count;
+
+        comparison_plate ();
+        ~comparison_plate ();
+      };
+
+      template<unsigned long id, typename C>
+      comparison_map<C>* comparison_plate<id, C>::map = 0;
+
+      template<unsigned long id, typename C>
+      std::size_t comparison_plate<id, C>::count = 0;
+
+
+      //
+      //
+      template<unsigned long id, typename C>
+      inline comparison_map<C>&
+      comparison_map_instance ()
+      {
+        return *comparison_plate<id, C>::map;
+      }
+
+      //
+      //
+      template<typename T>
+      bool
+      comparator_impl (const type&, const type&);
+
+      template<unsigned long id, typename C, typename T>
+      struct comparison_initializer
+      {
+        comparison_initializer ();
+        ~comparison_initializer ();
+      };
+    }
+  }
+}
+
+#include <xsd/cxx/tree/comparison-map.txx>
+
+#endif // XSD_CXX_TREE_COMPARISON_MAP_HXX
diff --git src/base/include/xsd/cxx/tree/comparison-map.txx src/base/include/xsd/cxx/tree/comparison-map.txx
new file mode 100644
index 0000000..e638ed4
--- /dev/null
+++ src/base/include/xsd/cxx/tree/comparison-map.txx
@@ -0,0 +1,301 @@
+// file      : xsd/cxx/tree/comparison-map.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#include <xsd/cxx/tree/types.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      // comparison_map
+      //
+      template <typename C>
+      comparison_map<C>::
+      comparison_map ()
+      {
+        // anyType and anySimpleType.
+        //
+
+        //register_type (
+        //  typeid (type),
+        //  &comparator_impl<type>,
+        //  false);
+
+        typedef simple_type<type> simple_type;
+
+        //register_type (
+        //  typeid (simple_type),
+        //  &comparator_impl<simple_type>,
+        //  false);
+
+
+        // Strings
+        //
+        typedef string<C, simple_type> string;
+        register_type (
+          typeid (string),
+          &comparator_impl<string>,
+          false);
+
+        typedef normalized_string<C, string> normalized_string;
+        register_type (
+          typeid (normalized_string),
+          &comparator_impl<normalized_string>,
+          false);
+
+        typedef token<C, normalized_string> token;
+        register_type (
+          typeid (token),
+          &comparator_impl<token>,
+          false);
+
+        typedef name<C, token> name;
+        register_type (
+          typeid (name),
+          &comparator_impl<name>,
+          false);
+
+        typedef nmtoken<C, token> nmtoken;
+        register_type (
+          typeid (nmtoken),
+          &comparator_impl<nmtoken>,
+          false);
+
+        typedef nmtokens<C, simple_type, nmtoken> nmtokens;
+        register_type (
+          typeid (nmtokens),
+          &comparator_impl<nmtokens>,
+          false);
+
+        typedef ncname<C, name> ncname;
+        register_type (
+          typeid (ncname),
+          &comparator_impl<ncname>,
+          false);
+
+        typedef language<C, token> language;
+        register_type (
+          typeid (language),
+          &comparator_impl<language>,
+          false);
+
+
+        // ID/IDREF.
+        //
+        typedef id<C, ncname> id;
+        register_type (
+          typeid (id),
+          &comparator_impl<id>,
+          false);
+
+        typedef idref<C, ncname, type> idref;
+        register_type (
+          typeid (idref),
+          &comparator_impl<idref>,
+          false);
+
+        typedef idrefs<C, simple_type, idref> idrefs;
+        register_type (
+          typeid (idrefs),
+          &comparator_impl<idrefs>,
+          false);
+
+
+        // URI.
+        //
+        typedef uri<C, simple_type> uri;
+        register_type (
+          typeid (uri),
+          &comparator_impl<uri>,
+          false);
+
+
+        // Qualified name.
+        //
+        typedef qname<C, simple_type, uri, ncname> qname;
+        register_type (
+          typeid (qname),
+          &comparator_impl<qname>,
+          false);
+
+
+        // Binary.
+        //
+        typedef base64_binary<C, simple_type> base64_binary;
+        register_type (
+          typeid (base64_binary),
+          &comparator_impl<base64_binary>,
+          false);
+
+        typedef hex_binary<C, simple_type> hex_binary;
+        register_type (
+          typeid (hex_binary),
+          &comparator_impl<hex_binary>,
+          false);
+
+
+        // Date/time.
+        //
+        typedef gday<C, simple_type> gday;
+        register_type (
+          typeid (gday),
+          &comparator_impl<gday>,
+          false);
+
+        typedef gmonth<C, simple_type> gmonth;
+        register_type (
+          typeid (gmonth),
+          &comparator_impl<gmonth>,
+          false);
+
+        typedef gyear<C, simple_type> gyear;
+        register_type (
+          typeid (gyear),
+          &comparator_impl<gyear>,
+          false);
+
+        typedef gmonth_day<C, simple_type> gmonth_day;
+        register_type (
+          typeid (gmonth_day),
+          &comparator_impl<gmonth_day>,
+          false);
+
+        typedef gyear_month<C, simple_type> gyear_month;
+        register_type (
+          typeid (gyear_month),
+          &comparator_impl<gyear_month>,
+          false);
+
+        typedef date<C, simple_type> date;
+        register_type (
+          typeid (date),
+          &comparator_impl<date>,
+          false);
+
+        typedef time<C, simple_type> time;
+        register_type (
+          typeid (time),
+          &comparator_impl<time>,
+          false);
+
+        typedef date_time<C, simple_type> date_time;
+        register_type (
+          typeid (date_time),
+          &comparator_impl<date_time>,
+          false);
+
+        typedef duration<C, simple_type> duration;
+        register_type (
+          typeid (duration),
+          &comparator_impl<duration>,
+          false);
+
+
+        // Entity.
+        //
+        typedef entity<C, ncname> entity;
+        register_type (
+          typeid (entity),
+          &comparator_impl<entity>,
+          false);
+
+        typedef entities<C, simple_type, entity> entities;
+        register_type (
+          typeid (entities),
+          &comparator_impl<entities>,
+          false);
+      }
+
+      template <typename C>
+      void comparison_map<C>::
+      register_type (const type_id& tid, comparator c, bool override)
+      {
+        if (override || type_map_.find (&tid) == type_map_.end ())
+          type_map_[&tid] = c;
+      }
+
+      template <typename C>
+      void comparison_map<C>::
+      unregister_type (const type_id& tid)
+      {
+        type_map_.erase (&tid);
+      }
+
+      template <typename C>
+      bool comparison_map<C>::
+      compare (const type& x, const type& y)
+      {
+        const type_id& xi (typeid (x));
+
+        if (xi != typeid (y))
+          return false;
+
+        if (comparator c = find (xi))
+          return c (x, y);
+        else
+          throw no_type_info<C> (std::basic_string<C> (),
+                                 std::basic_string<C> ()); // @@ TODO
+      }
+
+      template <typename C>
+      typename comparison_map<C>::comparator
+      comparison_map<C>::
+      find (const type_id& tid) const
+      {
+        typename type_map::const_iterator i (type_map_.find (&tid));
+        return i == type_map_.end () ? 0 : i->second;
+      }
+
+
+      // comparison_plate
+      //
+      template<unsigned long id, typename C>
+      comparison_plate<id, C>::
+      comparison_plate ()
+      {
+        if (count == 0)
+          map = new comparison_map<C>;
+
+        ++count;
+      }
+
+      template<unsigned long id, typename C>
+      comparison_plate<id, C>::
+      ~comparison_plate ()
+      {
+        if (--count == 0)
+          delete map;
+      }
+
+      //
+      //
+      template<typename T>
+      bool
+      comparator_impl (const type& x, const type& y)
+      {
+        return static_cast<const T&> (x) == static_cast<const T&> (y);
+      }
+
+      // comparison_initializer
+      //
+      template<unsigned long id, typename C, typename T>
+      comparison_initializer<id, C, T>::
+      comparison_initializer ()
+      {
+        comparison_map_instance<id, C> ().register_type (
+          typeid (T), &comparator_impl<T>);
+      }
+
+      template<unsigned long id, typename C, typename T>
+      comparison_initializer<id, C, T>::
+      ~comparison_initializer ()
+      {
+        comparison_map_instance<id, C> ().unregister_type (typeid (T));
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/tree/containers-wildcard.hxx src/base/include/xsd/cxx/tree/containers-wildcard.hxx
new file mode 100644
index 0000000..5313507
--- /dev/null
+++ src/base/include/xsd/cxx/tree/containers-wildcard.hxx
@@ -0,0 +1,1335 @@
+// file      : xsd/cxx/tree/containers-wildcard.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_CONTAINERS_WILDCARD_HXX
+#define XSD_CXX_TREE_CONTAINERS_WILDCARD_HXX
+
+#include <set>
+#include <string>
+
+#include <xercesc/dom/DOMAttr.hpp>
+#include <xercesc/dom/DOMElement.hpp>
+#include <xercesc/dom/DOMDocument.hpp>
+#include <xercesc/util/XMLString.hpp>
+
+#include <xsd/cxx/xml/string.hxx>
+
+#include <xsd/cxx/tree/containers.hxx> // iterator_adapter
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      // one (for internal use only)
+      //
+      class element_one
+      {
+      public:
+        ~element_one ()
+        {
+          if (x_)
+            x_->release ();
+        }
+
+        explicit
+        element_one (xercesc::DOMDocument& doc)
+            : x_ (0), doc_ (doc)
+        {
+        }
+
+        element_one (const xercesc::DOMElement& x, xercesc::DOMDocument& doc)
+            : x_ (0), doc_ (doc)
+        {
+          set (x);
+        }
+
+        element_one (const element_one& x, xercesc::DOMDocument& doc)
+            : x_ (0), doc_ (doc)
+        {
+          if (x.present ())
+            set (x.get ());
+        }
+
+        element_one&
+        operator= (const element_one& x)
+        {
+          if (this == &x)
+            return *this;
+
+          if (x.present ())
+            set (x.get ());
+          else if (x_)
+          {
+            x_->release ();
+            x_ = 0;
+          }
+
+          return *this;
+        }
+
+      public:
+        const xercesc::DOMElement&
+        get () const
+        {
+          return *x_;
+        }
+
+        xercesc::DOMElement&
+        get ()
+        {
+          return *x_;
+        }
+
+        void
+        set (const xercesc::DOMElement& x)
+        {
+          using xercesc::DOMElement;
+
+          DOMElement* r (
+            static_cast<DOMElement*> (
+              doc_.importNode (const_cast<DOMElement*> (&x), true)));
+
+          if (x_)
+            x_->release ();
+
+          x_ = r;
+        }
+
+        void
+        set (xercesc::DOMElement* x)
+        {
+          assert (x->getOwnerDocument () == &doc_);
+
+          if (x_)
+            x_->release ();
+
+          x_ = x;
+        }
+
+        bool
+        present () const
+        {
+          return x_ != 0;
+        }
+
+      protected:
+        xercesc::DOMElement* x_;
+        xercesc::DOMDocument& doc_;
+      };
+
+
+      //
+      //
+      class element_optional
+      {
+      public:
+        ~element_optional ()
+        {
+          if (x_)
+            x_->release ();
+        }
+
+        explicit
+        element_optional (xercesc::DOMDocument& doc)
+            : x_ (0), doc_ (doc)
+        {
+        }
+
+        element_optional (const xercesc::DOMElement& x,
+                          xercesc::DOMDocument& doc)
+            : x_ (0), doc_ (doc)
+        {
+          set (x);
+        }
+
+        element_optional (xercesc::DOMElement* x, xercesc::DOMDocument& doc)
+            : x_ (0), doc_ (doc)
+        {
+          set (x);
+        }
+
+        element_optional (const element_optional& x,
+                          xercesc::DOMDocument& doc)
+            : x_ (0), doc_ (doc)
+        {
+          if (x)
+            set (*x);
+        }
+
+        element_optional&
+        operator= (const xercesc::DOMElement& x)
+        {
+          if (x_ == &x)
+            return *this;
+
+          set (x);
+
+          return *this;
+        }
+
+        element_optional&
+        operator= (const element_optional& x)
+        {
+          if (this == &x)
+            return *this;
+
+          if (x)
+            set (*x);
+          else
+            reset ();
+
+          return *this;
+        }
+
+        // Pointer-like interface.
+        //
+      public:
+        const xercesc::DOMElement*
+        operator-> () const
+        {
+          return x_;
+        }
+
+        xercesc::DOMElement*
+        operator-> ()
+        {
+          return x_;
+        }
+
+        const xercesc::DOMElement&
+        operator* () const
+        {
+          return *x_;
+        }
+
+        xercesc::DOMElement&
+        operator* ()
+        {
+          return *x_;
+        }
+
+        typedef void (element_optional::*bool_convertible) ();
+
+        operator bool_convertible () const
+        {
+          return x_ != 0 ? &element_optional::true_ : 0;
+        }
+
+        // Get/set interface.
+        //
+      public:
+        bool
+        present () const
+        {
+          return x_ != 0;
+        }
+
+        const xercesc::DOMElement&
+        get () const
+        {
+          return *x_;
+        }
+
+        xercesc::DOMElement&
+        get ()
+        {
+          return *x_;
+        }
+
+        void
+        set (const xercesc::DOMElement& x)
+        {
+          using xercesc::DOMElement;
+
+          DOMElement* r (
+            static_cast<DOMElement*> (
+              doc_.importNode (const_cast<DOMElement*> (&x), true)));
+
+          if (x_)
+            x_->release ();
+
+          x_ = r;
+        }
+
+        void
+        set (xercesc::DOMElement* x)
+        {
+          assert (x->getOwnerDocument () == &doc_);
+
+          if (x_)
+            x_->release ();
+
+          x_ = x;
+        }
+
+        void
+        reset ()
+        {
+          if (x_)
+            x_->release ();
+
+          x_ = 0;
+        }
+
+      private:
+        void
+        true_ ()
+        {
+        }
+
+      private:
+        xercesc::DOMElement* x_;
+        xercesc::DOMDocument& doc_;
+      };
+
+      // Comparison operators.
+      //
+
+      inline bool
+      operator== (const element_optional& a, const element_optional& b)
+      {
+        return !a || !b
+          ? a.present () == b.present ()
+          : a->isEqualNode (&b.get ());
+      }
+
+      inline bool
+      operator!= (const element_optional& a, const element_optional& b)
+      {
+        return !(a == b);
+      }
+
+
+      //
+      //
+      class element_sequence
+      {
+      protected:
+        // This is a dangerously destructive automatic pointer. We are going
+        // to use it in a controlled environment to save us a lot of coding.
+        //
+        struct ptr
+        {
+          ~ptr ()
+          {
+            if (x_)
+              x_->release ();
+          }
+
+          explicit
+          ptr (xercesc::DOMElement* x = 0)
+              : x_ (x)
+          {
+          }
+
+          ptr (const ptr& y)
+              : x_ (y.x_)
+          {
+            // Yes, hostile takeover.
+            //
+            y.x_ = 0;
+          }
+
+          ptr&
+          operator= (const ptr& y)
+          {
+            if (this != &y)
+            {
+              // Yes, hostile takeover.
+              //
+              if (x_)
+                x_->release ();
+
+              x_ = y.x_;
+              y.x_ = 0;
+            }
+
+            return *this;
+          }
+
+        public:
+          xercesc::DOMElement&
+          operator* () const
+          {
+            return *x_;
+          }
+
+          xercesc::DOMElement*
+          get () const
+          {
+            return x_;
+          }
+
+        private:
+          mutable xercesc::DOMElement* x_;
+        };
+
+        typedef std::vector<ptr> base_sequence;
+        typedef base_sequence::iterator base_iterator;
+        typedef base_sequence::const_iterator base_const_iterator;
+
+      public:
+        typedef xercesc::DOMElement        value_type;
+        typedef xercesc::DOMElement*       pointer;
+        typedef const xercesc::DOMElement* const_pointer;
+        typedef xercesc::DOMElement&       reference;
+        typedef const xercesc::DOMElement& const_reference;
+
+        typedef
+        iterator_adapter<base_sequence::iterator, xercesc::DOMElement>
+        iterator;
+
+        typedef
+        iterator_adapter<base_sequence::const_iterator,
+                         const xercesc::DOMElement>
+        const_iterator;
+
+        typedef
+        iterator_adapter<base_sequence::reverse_iterator, xercesc::DOMElement>
+        reverse_iterator;
+
+        typedef
+        iterator_adapter<base_sequence::const_reverse_iterator,
+                         const xercesc::DOMElement>
+        const_reverse_iterator;
+
+        typedef base_sequence::size_type       size_type;
+        typedef base_sequence::difference_type difference_type;
+        typedef base_sequence::allocator_type  allocator_type;
+
+      public:
+        explicit
+        element_sequence (xercesc::DOMDocument& doc)
+            : doc_ (doc)
+        {
+        }
+
+        // DOMElement cannot be default-constructed.
+        //
+        // explicit
+        // element_sequence (size_type n);
+
+        element_sequence (size_type n,
+                          const xercesc::DOMElement& x,
+                          xercesc::DOMDocument& doc)
+            : doc_ (doc)
+        {
+          assign (n, x);
+        }
+
+        template <typename I>
+        element_sequence (const I& begin, const I& end,
+                          xercesc::DOMDocument& doc)
+            : doc_ (doc)
+        {
+          assign (begin, end);
+        }
+
+        element_sequence (const element_sequence& v,
+                          xercesc::DOMDocument& doc)
+            : doc_ (doc)
+        {
+          v_.reserve (v.v_.size ());
+
+          for (base_const_iterator i (v.v_.begin ()), e (v.v_.end ());
+               i != e; ++i)
+          {
+            ptr p (static_cast<xercesc::DOMElement*> (
+                     doc_.importNode (i->get (), true)));
+
+            v_.push_back (p);
+          }
+        }
+
+        element_sequence&
+        operator= (const element_sequence& v)
+        {
+          if (this == &v)
+            return *this;
+
+          v_.assign (v.v_.size (), ptr ());
+
+          base_iterator di (v_.begin ()), de (v_.end ());
+          base_const_iterator si (v.v_.begin ()), se (v.v_.end ());
+
+          for (; si != se && di != de; ++si, ++di)
+          {
+            ptr p (static_cast<xercesc::DOMElement*> (
+                     doc_.importNode (si->get (), true)));
+            *di = p;
+          }
+
+          return *this;
+        }
+
+      public:
+        void
+        assign (size_type n, const xercesc::DOMElement& x)
+        {
+          v_.assign (n, ptr ());
+
+          for (base_iterator i (v_.begin ()), e (v_.end ()); i != e; ++i)
+          {
+            ptr p (static_cast<xercesc::DOMElement*> (
+                     doc_.importNode (
+                       const_cast<xercesc::DOMElement*> (&x), true)));
+            *i = p;
+          }
+        }
+
+        template <typename I>
+        void
+        assign (const I& begin, const I& end)
+        {
+          // This is not the fastest way to do it.
+          //
+          v_.clear ();
+
+          for (I i (begin); i != end; ++i)
+          {
+            ptr p (static_cast<xercesc::DOMElement*> (
+                     doc_.importNode (
+                       const_cast<xercesc::DOMElement*> (&(*i)), true)));
+            v_.push_back (p);
+          }
+        }
+
+      public:
+        // This version of resize can only be used to shrink the
+        // sequence because DOMElement cannot be default-constructed.
+        //
+        void
+        resize (size_type n)
+        {
+          assert (n <= v_.size ());
+          v_.resize (n, ptr ());
+        }
+
+        void
+        resize (size_type n, const xercesc::DOMElement& x)
+        {
+          size_type old (v_.size ());
+          v_.resize (n, ptr ());
+
+          if (old < n)
+          {
+            for (base_iterator i (v_.begin () + old), e (v_.end ());
+                 i != e; ++i)
+            {
+              ptr p (static_cast<xercesc::DOMElement*> (
+                       doc_.importNode (
+                         const_cast<xercesc::DOMElement*> (&x), true)));
+              *i = p;
+            }
+          }
+        }
+
+      public:
+        size_type
+        size () const
+        {
+          return v_.size ();
+        }
+
+        size_type
+        max_size () const
+        {
+          return v_.max_size ();
+        }
+
+        size_type
+        capacity () const
+        {
+          return v_.capacity ();
+        }
+
+        bool
+        empty () const
+        {
+          return v_.empty ();
+        }
+
+        void
+        reserve (size_type n)
+        {
+          v_.reserve (n);
+        }
+
+        void
+        clear ()
+        {
+          v_.clear ();
+        }
+
+      public:
+        const_iterator
+        begin () const
+        {
+          return const_iterator (v_.begin ());
+        }
+
+        const_iterator
+        end () const
+        {
+          return const_iterator (v_.end ());
+        }
+
+        iterator
+        begin ()
+        {
+          return iterator (v_.begin ());
+        }
+
+        iterator
+        end ()
+        {
+          return iterator (v_.end ());
+        }
+
+        // reverse
+        //
+
+        const_reverse_iterator
+        rbegin () const
+        {
+          return const_reverse_iterator (v_.rbegin ());
+        }
+
+        const_reverse_iterator
+        rend () const
+        {
+          return const_reverse_iterator (v_.rend ());
+        }
+
+        reverse_iterator
+        rbegin ()
+        {
+          return reverse_iterator (v_.rbegin ());
+        }
+
+        reverse_iterator
+        rend ()
+        {
+          return reverse_iterator (v_.rend ());
+        }
+
+      public:
+        xercesc::DOMElement&
+        operator[] (size_type n)
+        {
+          return *(v_[n]);
+        }
+
+        const xercesc::DOMElement&
+        operator[] (size_type n) const
+        {
+          return *(v_[n]);
+        }
+
+        xercesc::DOMElement&
+        at (size_type n)
+        {
+          return *(v_.at (n));
+        }
+
+        const xercesc::DOMElement&
+        at (size_type n) const
+        {
+          return *(v_.at (n));
+        }
+
+        xercesc::DOMElement&
+        front ()
+        {
+          return *(v_.front ());
+        }
+
+        const xercesc::DOMElement&
+        front () const
+        {
+          return *(v_.front ());
+        }
+
+        xercesc::DOMElement&
+        back ()
+        {
+          return *(v_.back ());
+        }
+
+        const xercesc::DOMElement&
+        back () const
+        {
+          return *(v_.back ());
+        }
+
+      public:
+        // Makes a deep copy.
+        //
+        void
+        push_back (const xercesc::DOMElement& x)
+        {
+          ptr p (static_cast<xercesc::DOMElement*> (
+                   doc_.importNode (
+                     const_cast<xercesc::DOMElement*> (&x), true)));
+
+          v_.push_back (p);
+        }
+
+        // Assumes ownership.
+        //
+        void
+        push_back (xercesc::DOMElement* x)
+        {
+          assert (x->getOwnerDocument () == &doc_);
+          v_.push_back (ptr (x));
+        }
+
+        void
+        pop_back ()
+        {
+          v_.pop_back ();
+        }
+
+        // Makes a deep copy.
+        //
+        iterator
+        insert (iterator position, const xercesc::DOMElement& x)
+        {
+          ptr p (static_cast<xercesc::DOMElement*> (
+                   doc_.importNode (
+                     const_cast<xercesc::DOMElement*> (&x), true)));
+
+          return iterator (v_.insert (position.base (), p));
+        }
+
+        // Assumes ownership.
+        //
+        iterator
+        insert (iterator position, xercesc::DOMElement* x)
+        {
+          assert (x->getOwnerDocument () == &doc_);
+          return iterator (v_.insert (position.base (), ptr (x)));
+        }
+
+        void
+        insert (iterator position, size_type n, const xercesc::DOMElement& x)
+        {
+          difference_type d (v_.end () - position.base ());
+          v_.insert (position.base (), n, ptr ());
+
+          for (base_iterator i (v_.end () - d); n != 0; --n)
+          {
+            ptr r (static_cast<xercesc::DOMElement*> (
+                     doc_.importNode (
+                       const_cast<xercesc::DOMElement*> (&x), true)));
+            *(--i) = r;
+          }
+        }
+
+        template <typename I>
+        void
+        insert (iterator position, const I& begin, const I& end)
+        {
+          // This is not the fastest way to do it.
+          //
+          if (begin != end)
+          {
+            base_iterator p (position.base ());
+
+            for (I i (end);;)
+            {
+              --i;
+              ptr r (static_cast<xercesc::DOMElement*> (
+                       doc_.importNode (i->get (), true)));
+
+              p = v_.insert (p, r);
+
+              if (i == begin)
+                break;
+            }
+          }
+        }
+
+        iterator
+        erase (iterator position)
+        {
+          return iterator (v_.erase (position.base ()));
+        }
+
+        iterator
+        erase (iterator begin, iterator end)
+        {
+          return iterator (v_.erase (begin.base (), end.base ()));
+        }
+
+      public:
+        // Note that the DOMDocument object of the two sequences being
+	// swapped should be the same.
+        //
+        void
+        swap (element_sequence& x)
+        {
+          assert (&doc_ == &x.doc_);
+          v_.swap (x.v_);
+        }
+
+      private:
+        base_sequence v_;
+        xercesc::DOMDocument& doc_;
+      };
+
+      // Comparison operators.
+      //
+
+      inline bool
+      operator== (const element_sequence& a, const element_sequence& b)
+      {
+        if (a.size () != b.size ())
+          return false;
+
+        element_sequence::const_iterator
+          ai (a.begin ()), ae (a.end ()), bi (b.begin ());
+
+        for (; ai != ae; ++ai, ++bi)
+          if (!ai->isEqualNode (&(*bi)))
+            return false;
+
+        return true;
+      }
+
+      inline bool
+      operator!= (const element_sequence& a, const element_sequence& b)
+      {
+        return !(a == b);
+      }
+
+
+      // Attribute set.
+      //
+
+      class attribute_set_common
+      {
+      protected:
+        // Set entry. It can either act as a dangerously destructive
+        // automatic pointer for DOMAttr or as an entry containing the
+        // name we are searching for.
+        //
+        struct entry
+        {
+          ~entry ()
+          {
+            if (a_)
+              a_->release ();
+          }
+
+          explicit
+          entry (xercesc::DOMAttr* a)
+              : a_ (a), ns_ (0), name_ (0)
+          {
+            ns_ = a->getNamespaceURI ();
+            name_ = ns_ == 0 ? a->getName () : a->getLocalName ();
+          }
+
+          // Note: uses shallow copy.
+          //
+          explicit
+          entry (const XMLCh* ns, const XMLCh* name)
+              : a_ (0), ns_ (ns), name_ (name)
+          {
+          }
+
+          entry (const entry& y)
+              : a_ (y.a_), ns_ (y.ns_), name_ (y.name_)
+          {
+            // Yes, hostile takeover.
+            //
+            y.a_ = 0;
+            y.ns_ = 0;
+            y.name_ = 0;
+          }
+
+          entry&
+          operator= (const entry& y)
+          {
+            if (this != &y)
+            {
+              // Yes, hostile takeover.
+              //
+              if (a_)
+                a_->release ();
+
+              a_ = y.a_;
+              ns_ = y.ns_;
+              name_ = y.name_;
+
+              y.a_ = 0;
+              y.ns_ = 0;
+              y.name_ = 0;
+            }
+
+            return *this;
+          }
+
+        public:
+          xercesc::DOMAttr&
+          operator* () const
+          {
+            return *a_;
+          }
+
+          xercesc::DOMAttr*
+          get () const
+          {
+            return a_;
+          }
+
+          const XMLCh*
+          ns () const
+          {
+            return ns_;
+          }
+
+          const XMLCh*
+          name () const
+          {
+            return name_;
+          }
+
+          void
+          release ()
+          {
+            a_ = 0;
+          }
+
+        private:
+          mutable xercesc::DOMAttr* a_;
+          mutable const XMLCh* ns_;
+          mutable const XMLCh* name_;
+        };
+
+        struct entry_cmp
+        {
+          bool
+          operator() (const entry& a, const entry& b) const
+          {
+            using xercesc::XMLString;
+
+            const XMLCh* ans (a.ns ());
+            const XMLCh* bns (b.ns ());
+
+            const XMLCh* an (a.name ());
+            const XMLCh* bn (b.name ());
+
+            if (ans == 0)
+              return bns != 0
+                ? true
+                : (XMLString::compareString (an, bn) < 0);
+
+            if (ans != 0 && bns == 0)
+              return false;
+
+            int r (XMLString::compareString (ans, bns));
+
+            return r < 0
+              ? true
+              : (r > 0 ? false : XMLString::compareString (an, bn));
+          }
+        };
+
+        typedef std::set<entry, entry_cmp> base_set;
+        typedef base_set::iterator base_iterator;
+        typedef base_set::const_iterator base_const_iterator;
+      };
+
+      template <typename C>
+      class attribute_set: public attribute_set_common
+      {
+      public:
+        typedef xercesc::DOMAttr        key_type;
+        typedef xercesc::DOMAttr        value_type;
+        typedef xercesc::DOMAttr*       pointer;
+        typedef const xercesc::DOMAttr* const_pointer;
+        typedef xercesc::DOMAttr&       reference;
+        typedef const xercesc::DOMAttr& const_reference;
+
+        typedef
+        iterator_adapter<base_set::iterator, xercesc::DOMAttr>
+        iterator;
+
+        typedef
+        iterator_adapter<base_set::const_iterator, const xercesc::DOMAttr>
+        const_iterator;
+
+        typedef
+        iterator_adapter<base_set::reverse_iterator, xercesc::DOMAttr>
+        reverse_iterator;
+
+        typedef
+        iterator_adapter<base_set::const_reverse_iterator,
+                         const xercesc::DOMAttr>
+        const_reverse_iterator;
+
+        typedef base_set::size_type       size_type;
+        typedef base_set::difference_type difference_type;
+        typedef base_set::allocator_type  allocator_type;
+
+      public:
+        attribute_set (xercesc::DOMDocument& doc)
+            : doc_ (doc)
+        {
+        }
+
+        template <typename I>
+        attribute_set (const I& begin,
+                       const I& end,
+                       xercesc::DOMDocument& doc)
+            : doc_ (doc)
+        {
+          insert (begin, end);
+        }
+
+        attribute_set (const attribute_set& s, xercesc::DOMDocument& doc)
+            : doc_ (doc)
+        {
+          // Can be done faster with the "hinted" insert.
+          //
+          insert (s.begin (), s.end ());
+        }
+
+        attribute_set&
+        operator= (const attribute_set& s)
+        {
+          if (this == &s)
+            return *this;
+
+          // Can be done faster with the "hinted" insert.
+          //
+          clear ();
+          insert (s.begin (), s.end ());
+
+          return *this;
+        }
+
+      public:
+        const_iterator
+        begin () const
+        {
+          return const_iterator (s_.begin ());
+        }
+
+        const_iterator
+        end () const
+        {
+          return const_iterator (s_.end ());
+        }
+
+        iterator
+        begin ()
+        {
+          return iterator (s_.begin ());
+        }
+
+        iterator
+        end ()
+        {
+          return iterator (s_.end ());
+        }
+
+        // reverse
+        //
+
+        const_reverse_iterator
+        rbegin () const
+        {
+          return const_reverse_iterator (s_.rbegin ());
+        }
+
+        const_reverse_iterator
+        rend () const
+        {
+          return const_reverse_iterator (s_.rend ());
+        }
+
+        reverse_iterator
+        rbegin ()
+        {
+          return reverse_iterator (s_.rbegin ());
+        }
+
+        reverse_iterator
+        rend ()
+        {
+          return reverse_iterator (s_.rend ());
+        }
+
+      public:
+        size_type
+        size () const
+        {
+          return s_.size ();
+        }
+
+        size_type
+        max_size () const
+        {
+          return s_.max_size ();
+        }
+
+        bool
+        empty () const
+        {
+          return s_.empty ();
+        }
+
+        void
+        clear ()
+        {
+          s_.clear ();
+        }
+
+      public:
+        // Makes a deep copy.
+        //
+        std::pair<iterator, bool>
+        insert (const xercesc::DOMAttr& a)
+        {
+          entry e (static_cast<xercesc::DOMAttr*> (
+                     doc_.importNode (
+                       const_cast<xercesc::DOMAttr*> (&a), true)));
+
+          std::pair<base_iterator, bool> r (s_.insert (e));
+
+          return std::pair<iterator, bool> (iterator (r.first), r.second);
+        }
+
+        // Assumes ownership.
+        //
+        std::pair<iterator, bool>
+        insert (xercesc::DOMAttr* a)
+        {
+          assert (a->getOwnerDocument () == &doc_);
+          entry e (a);
+          std::pair<base_iterator, bool> r (s_.insert (e));
+
+          if (!r.second)
+            e.release (); // Detach the attribute of insert failed.
+
+          return std::pair<iterator, bool> (iterator (r.first), r.second);
+        }
+
+        // Makes a deep copy.
+        //
+        iterator
+        insert (iterator position, const xercesc::DOMAttr& a)
+        {
+          entry e (static_cast<xercesc::DOMAttr*> (
+                     doc_.importNode (
+                       const_cast<xercesc::DOMAttr*> (&a), true)));
+
+          return iterator (s_.insert (position.base (), e));
+        }
+
+        // Assumes ownership.
+        //
+        iterator
+        insert (iterator position, xercesc::DOMAttr* a)
+        {
+          assert (a->getOwnerDocument () == &doc_);
+          entry e (a);
+          base_iterator r (s_.insert (position.base (), e));
+
+          if (r->get () != a)
+            e.release (); // Detach the attribute of insert failed.
+
+          return iterator (r);
+        }
+
+        template <typename I>
+        void
+        insert (const I& begin, const I& end)
+        {
+          for (I i (begin); i != end; ++i)
+          {
+            entry e (static_cast<xercesc::DOMAttr*> (
+                       doc_.importNode (
+                         const_cast<xercesc::DOMAttr*> (&(*i)), true)));
+
+            s_.insert (e);
+          }
+        }
+
+      public:
+        void
+        erase (iterator position)
+        {
+          s_.erase (position.base ());
+        }
+
+        size_type
+        erase (const std::basic_string<C>& name)
+        {
+          return s_.erase (entry (0, xml::string (name).c_str ()));
+        }
+
+        size_type
+        erase (const std::basic_string<C>& namespace_,
+               const std::basic_string<C>& name)
+        {
+          return s_.erase (entry (xml::string (namespace_).c_str (),
+                                  xml::string (name).c_str ()));
+        }
+
+        size_type
+        erase (const XMLCh* name)
+        {
+          return s_.erase (entry (0, name));
+        }
+
+        size_type
+        erase (const XMLCh* namespace_, const XMLCh* name)
+        {
+          return s_.erase (entry (namespace_, name));
+        }
+
+        void
+        erase (iterator begin, iterator end)
+        {
+          s_.erase (begin.base (), end.base ());
+        }
+
+      public:
+        size_type
+        count (const std::basic_string<C>& name) const
+        {
+          return s_.count (entry (0, xml::string (name).c_str ()));
+        }
+
+        size_type
+        count (const std::basic_string<C>& namespace_,
+               const std::basic_string<C>& name) const
+        {
+          return s_.count (entry (xml::string (namespace_).c_str (),
+                                  xml::string (name).c_str ()));
+        }
+
+        size_type
+        count (const XMLCh* name) const
+        {
+          return s_.count (entry (0, name));
+        }
+
+        size_type
+        count (const XMLCh* namespace_, const XMLCh* name) const
+        {
+          return s_.count (entry (namespace_, name));
+        }
+
+        // find
+        //
+
+        iterator
+        find (const std::basic_string<C>& name)
+        {
+          return iterator (s_.find (entry (0, xml::string (name).c_str ())));
+        }
+
+        iterator
+        find (const std::basic_string<C>& namespace_,
+              const std::basic_string<C>& name)
+        {
+          return iterator (
+            s_.find (entry (xml::string (namespace_).c_str (),
+                            xml::string (name).c_str ())));
+        }
+
+        iterator
+        find (const XMLCh* name)
+        {
+          return iterator (s_.find (entry (0, name)));
+        }
+
+        iterator
+        find (const XMLCh* namespace_, const XMLCh* name)
+        {
+          return iterator (s_.find (entry (namespace_, name)));
+        }
+
+        const_iterator
+        find (const std::basic_string<C>& name) const
+        {
+          return const_iterator (
+            s_.find (entry (0, xml::string (name).c_str ())));
+        }
+
+        const_iterator
+        find (const std::basic_string<C>& namespace_,
+               const std::basic_string<C>& name) const
+        {
+          return const_iterator (
+            s_.find (entry (xml::string (namespace_).c_str (),
+                            xml::string (name).c_str ())));
+        }
+
+        const_iterator
+        find (const XMLCh* name) const
+        {
+          return const_iterator (s_.find (entry (0, name)));
+        }
+
+        const_iterator
+        find (const XMLCh* namespace_, const XMLCh* name) const
+        {
+          return const_iterator (s_.find (entry (namespace_, name)));
+        }
+
+      public:
+        // Note that the DOMDocument object of the two sets being
+	// swapped should be the same.
+        //
+        void
+        swap (attribute_set& x)
+        {
+          assert (&doc_ == &x.doc_);
+          s_.swap (x.s_);
+        }
+
+      private:
+        base_set s_;
+        xercesc::DOMDocument& doc_;
+      };
+
+      // Comparison operators.
+      //
+
+      template <typename C>
+      inline bool
+      operator== (const attribute_set<C>& a, const attribute_set<C>& b)
+      {
+        if (a.size () != b.size ())
+          return false;
+
+        typename attribute_set<C>::const_iterator
+          ai (a.begin ()), ae (a.end ()), bi (b.begin ());
+
+        for (; ai != ae; ++ai, ++bi)
+          if (!ai->isEqualNode (&(*bi)))
+            return false;
+
+        return true;
+      }
+
+      template <typename C>
+      inline bool
+      operator!= (const attribute_set<C>& a, const attribute_set<C>& b)
+      {
+        return !(a == b);
+      }
+    }
+  }
+}
+
+#endif  // XSD_CXX_TREE_CONTAINERS_WILDCARD_HXX
diff --git src/base/include/xsd/cxx/tree/containers.hxx src/base/include/xsd/cxx/tree/containers.hxx
new file mode 100644
index 0000000..ba76eae
--- /dev/null
+++ src/base/include/xsd/cxx/tree/containers.hxx
@@ -0,0 +1,1458 @@
+// file      : xsd/cxx/tree/containers.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_CONTAINERS_HXX
+#define XSD_CXX_TREE_CONTAINERS_HXX
+
+#include <cstddef>   // std::ptrdiff_t
+#include <string>
+#include <vector>
+#include <memory>    // std::auto_ptr
+#include <iterator>  // std::iterator_traits
+#include <algorithm> // std::equal, std::lexicographical_compare
+#include <iosfwd>
+
+#include <xsd/cxx/tree/elements.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      // Test whether T is a fundamental C++ type.
+      //
+
+      template <typename T>
+      struct fundamental_p
+      {
+        static const bool r = false;
+      };
+
+      // byte
+      //
+      template <>
+      struct fundamental_p<signed char>
+      {
+        static const bool r = true;
+      };
+
+      template <>
+      struct fundamental_p<unsigned char>
+      {
+        static const bool r = true;
+      };
+
+      // short
+      //
+      template <>
+      struct fundamental_p<short>
+      {
+        static const bool r = true;
+      };
+
+      template <>
+      struct fundamental_p<unsigned short>
+      {
+        static const bool r = true;
+      };
+
+      // int
+      //
+      template <>
+      struct fundamental_p<int>
+      {
+        static const bool r = true;
+      };
+
+      template <>
+      struct fundamental_p<unsigned int>
+      {
+        static const bool r = true;
+      };
+
+      // long
+      //
+      template <>
+      struct fundamental_p<long>
+      {
+        static const bool r = true;
+      };
+
+      template <>
+      struct fundamental_p<unsigned long>
+      {
+        static const bool r = true;
+      };
+
+      template <>
+      struct fundamental_p<long long>
+      {
+        static const bool r = true;
+      };
+
+      template <>
+      struct fundamental_p<unsigned long long>
+      {
+        static const bool r = true;
+      };
+
+      // bool
+      //
+      template <>
+      struct fundamental_p<bool>
+      {
+        static const bool r = true;
+      };
+
+      // float
+      //
+      template <>
+      struct fundamental_p<float>
+      {
+        static const bool r = true;
+      };
+
+      template <>
+      struct fundamental_p<double>
+      {
+        static const bool r = true;
+      };
+
+      // one (for internal use only)
+      //
+      template <typename T, bool fund = fundamental_p<T>::r>
+      class one;
+
+      template <typename T>
+      class one<T, false>
+      {
+      public:
+        ~one ();
+
+        one (flags, container*);
+
+        one (const T&, flags, container*);
+
+        one (std::auto_ptr<T>, flags, container*);
+
+        one (const one&, flags, container*);
+
+        one&
+        operator= (const one&);
+
+      public:
+        const T&
+        get () const
+        {
+          return *x_;
+        }
+
+        T&
+        get ()
+        {
+          return *x_;
+        }
+
+        void
+        set (const T&);
+
+        void
+        set (std::auto_ptr<T>);
+
+        bool
+        present () const
+        {
+          return x_ != 0;
+        }
+
+        std::auto_ptr<T>
+        detach ()
+        {
+          T* x (x_);
+          x->_container (0);
+          x_ = 0;
+          return std::auto_ptr<T> (x);
+        }
+
+      protected:
+        T* x_;
+        flags flags_;
+        container* container_;
+      };
+
+
+      template <typename T>
+      class one<T, true>
+      {
+      public:
+        one (flags, container*)
+            : present_ (false)
+        {
+        }
+
+        one (const T& x, flags, container*)
+            : x_ (x), present_ (true)
+        {
+        }
+
+        one (const one& x, flags, container*)
+            : x_ (x.x_), present_ (x.present_)
+        {
+        }
+
+        one&
+        operator= (const one& x)
+        {
+          if (this == &x)
+            return *this;
+
+          x_ = x.x_;
+          present_ = x.present_;
+
+          return *this;
+        }
+
+      public:
+        const T&
+        get () const
+        {
+          return x_;
+        }
+
+        T&
+        get ()
+        {
+          return x_;
+        }
+
+        void
+        set (const T& x)
+        {
+          x_ = x;
+          present_ = true;
+        }
+
+        bool
+        present () const
+        {
+          return present_;
+        }
+
+      protected:
+        T x_;
+        bool present_;
+      };
+
+
+      // Note that I cannot get rid of fund because of HP aCC3.
+      //
+      template <typename T, bool fund = fundamental_p<T>::r>
+      class optional;
+
+      template <typename T>
+      class optional<T, false>
+      {
+      public:
+        ~optional ();
+
+        explicit
+        optional (flags = 0, container* = 0);
+
+        explicit
+        optional (const T&, flags = 0, container* = 0);
+
+        explicit
+        optional (std::auto_ptr<T>, flags = 0, container* = 0);
+
+        optional (const optional&, flags = 0, container* = 0);
+
+        optional&
+        operator= (const T&);
+
+        optional&
+        operator= (const optional&);
+
+        // Pointer-like interface.
+        //
+      public:
+        const T*
+        operator-> () const
+        {
+          return x_;
+        }
+
+        T*
+        operator-> ()
+        {
+          return x_;
+        }
+
+        const T&
+        operator* () const
+        {
+          return *x_;
+        }
+
+        T&
+        operator* ()
+        {
+          return *x_;
+        }
+
+        typedef optional self_; // Simplifier for Sun C++ 5.7.
+        typedef void (self_::*bool_convertible) ();
+
+        operator bool_convertible () const
+        {
+          return x_ != 0 ? &self_::true_ : 0;
+        }
+
+        // Get/set interface.
+        //
+      public:
+        bool
+        present () const
+        {
+          return x_ != 0;
+        }
+
+        const T&
+        get () const
+        {
+          return *x_;
+        }
+
+        T&
+        get ()
+        {
+          return *x_;
+        }
+
+        void
+        set (const T&);
+
+        void
+        set (std::auto_ptr<T>);
+
+        void
+        reset ();
+
+        std::auto_ptr<T>
+        detach ()
+        {
+          T* x (x_);
+          x->_container (0);
+          x_ = 0;
+          return std::auto_ptr<T> (x);
+        }
+
+      private:
+        void
+        true_ ();
+
+      private:
+        T* x_;
+        flags flags_;
+        container* container_;
+      };
+
+
+      //
+      //
+      template <typename T>
+      class optional<T, true>
+      {
+      public:
+        explicit
+        optional (flags  = 0, container* = 0)
+            : present_ (false)
+        {
+        }
+
+        explicit
+        optional (const T&, flags = 0, container* = 0);
+
+        optional (const optional&, flags = 0, container* = 0);
+
+        optional&
+        operator= (const T&);
+
+        optional&
+        operator= (const optional&);
+
+        // Pointer-like interface.
+        //
+      public:
+        const T*
+        operator-> () const
+        {
+          return &x_;
+        }
+
+        T*
+        operator-> ()
+        {
+          return &x_;
+        }
+
+        const T&
+        operator* () const
+        {
+          return get ();
+        }
+
+        T&
+        operator* ()
+        {
+          return get ();
+        }
+
+        typedef optional self_; // Simplifier for Sun C++ 5.7.
+        typedef void (self_::*bool_convertible) ();
+
+        operator bool_convertible () const
+        {
+          return present () ? &self_::true_ : 0;
+        }
+
+        // Get/set interface.
+        //
+      public:
+        bool
+        present () const
+        {
+          return present_;
+        }
+
+        const T&
+        get () const
+        {
+          return x_;
+        }
+
+        T&
+        get ()
+        {
+          return x_;
+        }
+
+        void
+        set (const T& y)
+        {
+          x_ = y;
+          present_ = true;
+        }
+
+        void
+        reset ()
+        {
+          present_ = false;
+        }
+
+      private:
+        void
+        true_ ();
+
+      private:
+        bool present_;
+        T x_;
+      };
+
+      // Comparison operators.
+      //
+
+      template <typename T, bool fund>
+      inline bool
+      operator== (const optional<T, fund>& a, const optional<T, fund>& b)
+      {
+        return !a || !b ? a.present () == b.present () : *a == *b;
+      }
+
+      template <typename T, bool fund>
+      inline bool
+      operator!= (const optional<T, fund>& a, const optional<T, fund>& b)
+      {
+        return !(a == b);
+      }
+
+      template <typename T, bool fund>
+      inline bool
+      operator< (const optional<T, fund>& a, const optional<T, fund>& b)
+      {
+        return a && (!b || *a < *b);
+      }
+
+      template <typename T, bool fund>
+      inline bool
+      operator> (const optional<T, fund>& a, const optional<T, fund>& b)
+      {
+        return b < a;
+      }
+
+      template <typename T, bool fund>
+      inline bool
+      operator<= (const optional<T, fund>& a, const optional<T, fund>& b)
+      {
+        return !(a > b);
+      }
+
+      template <typename T, bool fund>
+      inline bool
+      operator>= (const optional<T, fund>& a, const optional<T, fund>& b)
+      {
+        return !(a < b);
+      }
+
+      // Provide an ostream insertion opretaor to prevent confusion from
+      // the implicit bool conversion.
+      //
+      template <typename C, typename T, bool fund>
+      std::basic_ostream<C>&
+      operator<< (std::basic_ostream<C>&, const optional<T, fund>&);
+
+
+      // Sequence.
+      //
+
+      // Note that I cannot get rid of 'fund' because HP aCC3 likes it
+      // this way.
+      //
+      template <typename T, bool fund = fundamental_p<T>::r>
+      class sequence;
+
+
+      // Sun CC's <iterator> does not have iterator_traits. To overcome
+      // this, we will wrap std::iterator_traits into our own and also
+      // specialize it for pointer types. Since Sun CC uses pointer
+      // for vector::iterator, it will use the specialization and won't
+      // notice the std::iterator_traits.
+      //
+#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC
+      template <typename I>
+      struct iterator_traits
+      {
+        typedef
+        typename std::iterator_traits<I>::iterator_category
+        iterator_category;
+
+        typedef
+        typename std::iterator_traits<I>::value_type
+        value_type;
+
+        typedef
+        typename std::iterator_traits<I>::difference_type
+        difference_type;
+      };
+#else
+      // The Pointer specialization does not work for reverse and
+      // set iterators. But these iterators are user-dfined types
+      // and have suitable typedefs that we can use.
+      //
+      template <typename I>
+      struct iterator_traits
+      {
+        typedef typename I::iterator_category iterator_category;
+        typedef typename I::value_type value_type;
+        typedef typename I::difference_type difference_type;
+      };
+
+      template <typename T>
+      struct iterator_traits<T*>
+      {
+        typedef std::random_access_iterator_tag iterator_category;
+        typedef T value_type;
+        typedef std::ptrdiff_t difference_type;
+      };
+#endif
+
+      // Iterator adapter for complex types. It expects I to point to
+      // a smart pointer-like object that has operator*() that returns
+      // a refernce to a type static_cast'able to T and get() that
+      // returns a pointer to a type static_cast'able to T.
+      //
+
+      template <typename I, typename T>
+      struct iterator_adapter
+      {
+        typedef T value_type;
+        typedef value_type& reference;
+        typedef value_type* pointer;
+
+        typedef
+        typename iterator_traits<I>::iterator_category
+        iterator_category;
+
+        typedef
+        typename iterator_traits<I>::difference_type
+        difference_type;
+
+
+      public:
+        iterator_adapter ()
+            : i_ () // i_ can be of a pointer type.
+        {
+        }
+
+        // Allow iterator to const_iterator conversion.
+        //
+        template <typename J, typename T2>
+        iterator_adapter (const iterator_adapter<J, T2>& j)
+            : i_ (j.base ())
+        {
+        }
+
+        explicit
+        iterator_adapter (const I& i)
+            : i_ (i)
+        {
+        }
+
+      public:
+        // Forward iterator requirements.
+        //
+        reference
+        operator* () const
+        {
+          return static_cast<reference> (**i_);
+        }
+
+        pointer
+        operator-> () const
+        {
+          return static_cast<pointer> (i_->get ());
+        }
+
+        iterator_adapter&
+        operator++ ()
+        {
+          ++i_;
+          return *this;
+        }
+
+        iterator_adapter
+        operator++ (int)
+        {
+          iterator_adapter r (*this);
+          ++i_;
+          return r;
+        }
+
+        // Bidirectional iterator requirements.
+        //
+        iterator_adapter&
+        operator-- ()
+        {
+          --i_;
+          return *this;
+        }
+
+        iterator_adapter
+        operator-- (int)
+        {
+          iterator_adapter r (*this);
+          --i_;
+          return r;
+        }
+
+        // Random access iterator requirements.
+        //
+        reference
+        operator[] (difference_type n) const
+        {
+          return static_cast<reference> (*(i_[n]));
+        }
+
+        iterator_adapter&
+        operator+= (difference_type n)
+        {
+          i_ += n;
+          return *this;
+        }
+
+        iterator_adapter
+        operator+ (difference_type n) const
+        {
+          return iterator_adapter (i_ + n);
+        }
+
+        iterator_adapter&
+        operator-= (difference_type n)
+        {
+          i_ -= n;
+          return *this;
+        }
+
+        iterator_adapter
+        operator- (difference_type n) const
+        {
+          return iterator_adapter (i_ - n);
+        }
+
+      public:
+        const I&
+        base () const
+        {
+          return i_;
+        }
+
+      private:
+        I i_;
+      };
+
+      // Note: We use different types for left- and right-hand-side
+      // arguments to allow comparison between iterator and const_iterator.
+      //
+
+      // Forward iterator requirements.
+      //
+      template <typename I, typename J, typename T1, typename T2>
+      inline bool
+      operator== (const iterator_adapter<I, T1>& i,
+                  const iterator_adapter<J, T2>& j)
+      {
+        return i.base () == j.base ();
+      }
+
+      template <typename I, typename J, typename T1, typename T2>
+      inline bool
+      operator!= (const iterator_adapter<I, T1>& i,
+                  const iterator_adapter<J, T2>& j)
+      {
+        return i.base () != j.base ();
+      }
+
+      // Random access iterator requirements
+      //
+      template <typename I, typename J, typename T1, typename T2>
+      inline bool
+      operator< (const iterator_adapter<I, T1>& i,
+                 const iterator_adapter<J, T2>& j)
+      {
+        return i.base () < j.base ();
+      }
+
+      template <typename I, typename J, typename T1, typename T2>
+      inline bool
+      operator> (const iterator_adapter<I, T1>& i,
+                 const iterator_adapter<J, T2>& j)
+      {
+        return i.base () > j.base ();
+      }
+
+      template <typename I, typename J, typename T1, typename T2>
+      inline bool
+      operator<= (const iterator_adapter<I, T1>& i,
+                  const iterator_adapter<J, T2>& j)
+      {
+        return i.base () <= j.base ();
+      }
+
+      template <typename I, typename J, typename T1, typename T2>
+      inline bool
+      operator>= (const iterator_adapter<I, T1>& i,
+                  const iterator_adapter<J, T2>& j)
+      {
+        return i.base () >= j.base ();
+      }
+
+      template <typename I, typename J, typename T1, typename T2>
+      inline typename iterator_adapter<I, T1>::difference_type
+      operator- (const iterator_adapter<I, T1>& i,
+                 const iterator_adapter<J, T2>& j)
+      {
+        return i.base () - j.base ();
+      }
+
+      template <typename I, typename T>
+      inline iterator_adapter<I, T>
+      operator+ (typename iterator_adapter<I, T>::difference_type n,
+                 const iterator_adapter<I, T>& i)
+      {
+        return iterator_adapter<I, T> (i.base () + n);
+      }
+
+      //
+      //
+      class sequence_common
+      {
+      protected:
+        // This is a dangerously destructive automatic pointer. We are going
+        // to use it in a controlled environment to save us a lot of coding.
+        //
+        struct ptr
+        {
+          ~ptr ()
+          {
+            delete x_;
+          }
+
+          explicit
+          ptr (type* x = 0)
+              : x_ (x)
+          {
+          }
+
+          ptr (const ptr& y)
+              : x_ (y.x_)
+          {
+            // Yes, hostile takeover.
+            //
+            y.x_ = 0;
+          }
+
+          ptr&
+          operator= (const ptr& y)
+          {
+            if (this != &y)
+            {
+              // Yes, hostile takeover.
+              //
+              delete x_;
+              x_ = y.x_;
+              y.x_ = 0;
+            }
+
+            return *this;
+          }
+
+        public:
+          type&
+          operator* () const
+          {
+            return *x_;
+          }
+
+          type*
+          operator-> () const
+          {
+            return x_;
+          }
+
+          type*
+          get () const
+          {
+            return x_;
+          }
+
+          type*
+          release ()
+          {
+            type* x (x_);
+            x_ = 0;
+            return x;
+          }
+
+        private:
+          mutable type* x_;
+        };
+
+      protected:
+        typedef std::vector<ptr> base_sequence;
+        typedef base_sequence::iterator base_iterator;
+        typedef base_sequence::const_iterator base_const_iterator;
+
+        typedef base_sequence::size_type       size_type;
+        typedef base_sequence::difference_type difference_type;
+        typedef base_sequence::allocator_type  allocator_type;
+
+      protected:
+        sequence_common (flags f, container* c)
+            : flags_ (f), container_ (c)
+        {
+        }
+
+        sequence_common (size_type n, const type& x, container* c)
+            : flags_ (0), container_ (c)
+        {
+          assign (n, x);
+        }
+
+        template <typename I>
+        sequence_common (const I& begin, const I& end, container* c)
+            : flags_ (0), container_ (c)
+        {
+          assign (begin, end);
+        }
+
+        sequence_common (const sequence_common& v, flags f, container* c)
+            : flags_ (f), container_ (c)
+        {
+          v_.reserve (v.v_.size ());
+
+          for (base_const_iterator i (v.v_.begin ()), e (v.v_.end ());
+               i != e; ++i)
+          {
+            ptr p ((**i)._clone (flags_, container_));
+            v_.push_back (p);
+          }
+        }
+
+      public:
+        sequence_common&
+        operator= (const sequence_common& v)
+        {
+          if (this == &v)
+            return *this;
+
+          v_.assign (v.v_.size (), ptr ());
+
+          base_iterator di (v_.begin ()), de (v_.end ());
+          base_const_iterator si (v.v_.begin ()), se (v.v_.end ());
+
+          for (; si != se && di != de; ++si, ++di)
+          {
+            // We have no ptr_ref.
+            //
+            ptr p ((**si)._clone (flags_, container_));
+            *di = p;
+          }
+
+          return *this;
+        }
+
+      public:
+        size_type
+        size () const
+        {
+          return v_.size ();
+        }
+
+        size_type
+        max_size () const
+        {
+          return v_.max_size ();
+        }
+
+        size_type
+        capacity () const
+        {
+          return v_.capacity ();
+        }
+
+        bool
+        empty () const
+        {
+          return v_.empty ();
+        }
+
+        void
+        reserve (size_type n)
+        {
+          v_.reserve (n);
+        }
+
+        void
+        clear ()
+        {
+          v_.clear ();
+        }
+
+      protected:
+        void
+        assign (size_type n, const type& x)
+        {
+          v_.assign (n, ptr ());
+
+          for (base_iterator i (v_.begin ()), e (v_.end ()); i != e; ++i)
+          {
+            ptr p (x._clone (flags_, container_));
+            *i = p;
+          }
+        }
+
+        template <typename I>
+        void
+        assign (const I& begin, const I& end)
+        {
+          // This is not the fastest way to do it. Also I's type may not
+          // have _clone.
+          //
+          v_.clear ();
+
+          for (I i (begin); i != end; ++i)
+          {
+            ptr p (i->_clone (flags_, container_));
+            v_.push_back (p);
+          }
+        }
+
+        void
+        resize (size_type n, const type& x)
+        {
+          size_type old (v_.size ());
+          v_.resize (n, ptr ());
+
+          if (old < n)
+          {
+            for (base_iterator i (v_.begin () + old), e (v_.end ());
+                 i != e; ++i)
+            {
+              ptr p (x._clone (flags_, container_));
+              *i = p;
+            }
+          }
+        }
+
+        void
+        insert (base_iterator p, size_type n, const type& x)
+        {
+          difference_type d (v_.end () - p);
+          v_.insert (p, n, ptr ());
+
+          for (base_iterator i (v_.end () - d); n != 0; --n)
+          {
+            ptr r (x._clone (flags_, container_));
+            *(--i) = r;
+          }
+        }
+
+        template <typename I>
+        void
+        insert (base_iterator p, const I& begin, const I& end)
+        {
+          // This is not the fastest way to do it. Also I's type may not
+          // have _clone.
+          //
+          if (begin != end)
+          {
+            for (I i (end);;)
+            {
+              --i;
+              ptr r (i->_clone (flags_, container_));
+              p = v_.insert (p, r);
+
+              if (i == begin)
+                break;
+            }
+          }
+        }
+
+      protected:
+        flags flags_;
+        container* container_;
+        base_sequence v_;
+      };
+
+      //
+      //
+      template <typename T>
+      class sequence<T, false>: public sequence_common
+      {
+      protected:
+        // For IBM XL C++ 8.0.
+        //
+        typedef sequence_common::ptr ptr;
+
+      public:
+        typedef T        value_type;
+        typedef T*       pointer;
+        typedef const T* const_pointer;
+        typedef T&       reference;
+        typedef const T& const_reference;
+
+        typedef
+        iterator_adapter<base_sequence::iterator, T>
+        iterator;
+
+        typedef
+        iterator_adapter<base_sequence::const_iterator, const T>
+        const_iterator;
+
+        typedef
+        iterator_adapter<base_sequence::reverse_iterator, T>
+        reverse_iterator;
+
+        typedef
+        iterator_adapter<base_sequence::const_reverse_iterator, const T>
+        const_reverse_iterator;
+
+        typedef sequence_common::size_type       size_type;
+        typedef sequence_common::difference_type difference_type;
+        typedef sequence_common::allocator_type  allocator_type;
+
+      public:
+        explicit
+        sequence (flags f = 0, container* c = 0)
+            : sequence_common (f, c)
+        {
+        }
+
+        // The first version causes trouble on IBM XL C++ 7.0 when
+        // a type does not have the default c-tor. While the second
+        // breaks VC++ 8.0 when using dllexport (it appears to
+        // instantiate everything instead of only what's used).
+        //
+#ifdef _MSC_VER
+        explicit
+        sequence (size_type n, const T& x = T (), container* c = 0)
+            : sequence_common (n, x, c)
+        {
+        }
+#else
+        explicit
+        sequence (size_type n, container* c = 0)
+            : sequence_common (n, T (), c)
+        {
+        }
+
+        sequence (size_type n, const T& x, container* c = 0)
+            : sequence_common (n, x, c)
+        {
+        }
+#endif
+
+        template <typename I>
+        sequence (const I& begin, const I& end, container* c = 0)
+            : sequence_common (begin, end, c)
+        {
+        }
+
+        sequence (const sequence& v, flags f = 0, container* c = 0)
+            : sequence_common (v, f, c)
+        {
+        }
+
+      public:
+        void
+        assign (size_type n, const T& x)
+        {
+          sequence_common::assign (n, x);
+        }
+
+        template <typename I>
+        void
+        assign (const I& begin, const I& end)
+        {
+          sequence_common::assign (begin, end);
+        }
+
+      public:
+        // The first version causes trouble on IBM XL C++ 7.0 when
+        // a type does not have the default c-tor. While the second
+        // breaks VC++ 8.0 when using dllexport (it appears to
+        // instantiate everything instead of only what's used).
+        //
+#ifdef _MSC_VER
+        void
+        resize (size_type n, const T& x = T ())
+        {
+          sequence_common::resize (n, x);
+        }
+#else
+        void
+        resize (size_type n)
+        {
+          sequence_common::resize (n, T ());
+        }
+
+        void
+        resize (size_type n, const T& x)
+        {
+          sequence_common::resize (n, x);
+        }
+#endif
+
+      public:
+        const_iterator
+        begin () const
+        {
+          return const_iterator (v_.begin ());
+        }
+
+        const_iterator
+        end () const
+        {
+          return const_iterator (v_.end ());
+        }
+
+        iterator
+        begin ()
+        {
+          return iterator (v_.begin ());
+        }
+
+        iterator
+        end ()
+        {
+          return iterator (v_.end ());
+        }
+
+        // reverse
+        //
+
+        const_reverse_iterator
+        rbegin () const
+        {
+          return const_reverse_iterator (v_.rbegin ());
+        }
+
+        const_reverse_iterator
+        rend () const
+        {
+          return const_reverse_iterator (v_.rend ());
+        }
+
+        reverse_iterator
+        rbegin ()
+        {
+          return reverse_iterator (v_.rbegin ());
+        }
+
+        reverse_iterator
+        rend ()
+        {
+          return reverse_iterator (v_.rend ());
+        }
+
+      public:
+        T&
+        operator[] (size_type n)
+        {
+          return static_cast<T&> (*(v_[n]));
+        }
+
+        const T&
+        operator[] (size_type n) const
+        {
+          return static_cast<const T&> (*(v_[n]));
+        }
+
+        T&
+        at (size_type n)
+        {
+          return static_cast<T&> (*(v_.at (n)));
+        }
+
+        const T&
+        at (size_type n) const
+        {
+          return static_cast<const T&> (*(v_.at (n)));
+        }
+
+        T&
+        front ()
+        {
+          return static_cast<T&> (*(v_.front ()));
+        }
+
+        const T&
+        front () const
+        {
+          return static_cast<const T&> (*(v_.front ()));
+        }
+
+        T&
+        back ()
+        {
+          return static_cast<T&> (*(v_.back ()));
+        }
+
+        const T&
+        back () const
+        {
+          return static_cast<const T&> (*(v_.back ()));
+        }
+
+      public:
+        void
+        push_back (const T& x)
+        {
+          v_.push_back (ptr (x._clone (flags_, container_)));
+        }
+
+        void
+        push_back (std::auto_ptr<T> x)
+        {
+          if (x->_container () != container_)
+            x->_container (container_);
+
+          v_.push_back (ptr (x.release ()));
+        }
+
+        void
+        pop_back ()
+        {
+          v_.pop_back ();
+        }
+
+        std::auto_ptr<T>
+        detach_back (bool pop = true)
+        {
+          ptr& p (v_.back ());
+          p->_container (0);
+          T* x (static_cast<T*> (p.release ()));
+
+          if (pop)
+            v_.pop_back ();
+
+          return std::auto_ptr<T> (x);
+        }
+
+        iterator
+        insert (iterator position, const T& x)
+        {
+          return iterator (
+            v_.insert (
+              position.base (), ptr (x._clone (flags_, container_))));
+        }
+
+        iterator
+        insert (iterator position, std::auto_ptr<T> x)
+        {
+          if (x->_container () != container_)
+            x->_container (container_);
+
+          return iterator (v_.insert (position.base (), ptr (x.release ())));
+        }
+
+        void
+        insert (iterator position, size_type n, const T& x)
+        {
+          sequence_common::insert (position.base (), n, x);
+        }
+
+        template <typename I>
+        void
+        insert (iterator position, const I& begin, const I& end)
+        {
+          sequence_common::insert (position.base (), begin, end);
+        }
+
+        iterator
+        erase (iterator position)
+        {
+          return iterator (v_.erase (position.base ()));
+        }
+
+        iterator
+        erase (iterator begin, iterator end)
+        {
+          return iterator (v_.erase (begin.base (), end.base ()));
+        }
+
+        iterator
+        detach (iterator position, std::auto_ptr<T>& r, bool erase = true)
+        {
+          ptr& p (*position.base ());
+          p->_container (0);
+          std::auto_ptr<T> tmp (static_cast<T*> (p.release ()));
+          r = tmp;
+
+          if (erase)
+            return iterator (v_.erase (position.base ()));
+          else
+            return ++position;
+        }
+
+        // Note that the container object of the two sequences being
+	// swapped should be the same.
+        //
+        void
+        swap (sequence& x)
+        {
+          assert (container_ == x.container_);
+          v_.swap (x.v_);
+        }
+      };
+
+
+      // Specialization for fundamental types.
+      //
+      template <typename T>
+      class sequence<T, true>: public std::vector<T>
+      {
+        typedef std::vector<T> base_sequence;
+
+      public:
+        explicit
+        sequence (flags = 0, container* = 0)
+        {
+        }
+
+        explicit
+        sequence (typename base_sequence::size_type n,
+                  const T& x = T (),
+                  container* = 0)
+            : base_sequence (n, x)
+        {
+        }
+
+        template <typename I>
+        sequence (const I& begin, const I& end, container* = 0)
+            : base_sequence (begin, end)
+        {
+        }
+
+        sequence (const sequence& s, flags = 0, container* = 0)
+            : base_sequence (s)
+        {
+        }
+      };
+
+
+      // Comparison operators.
+      //
+
+      template <typename T, bool fund>
+      inline bool
+      operator== (const sequence<T, fund>& a, const sequence<T, fund>& b)
+      {
+        return (a.size () == b.size ()
+                && std::equal (a.begin (), a.end (), b.begin ()));
+      }
+
+      template <typename T, bool fund>
+      inline bool
+      operator!= (const sequence<T, fund>& a, const sequence<T, fund>& b)
+      {
+        return !(a == b);
+      }
+
+      template <typename T, bool fund>
+      inline bool
+      operator< (const sequence<T, fund>& a, const sequence<T, fund>& b)
+      {
+        return std::lexicographical_compare (a.begin (), a.end (),
+                                             b.begin (), b.end ());
+      }
+
+      template <typename T, bool fund>
+      inline bool
+      operator> (const sequence<T, fund>& a, const sequence<T, fund>& b)
+      {
+        return b < a;
+      }
+
+      template <typename T, bool fund>
+      inline bool
+      operator<= (const sequence<T, fund>& a, const sequence<T, fund>& b)
+      {
+        return !(a > b);
+      }
+
+      template <typename T, bool fund>
+      inline bool
+      operator>= (const sequence<T, fund>& a, const sequence<T, fund>& b)
+      {
+        return !(a < b);
+      }
+
+      // Note that the container object of the two sequences being
+      // swapped should be the same.
+      //
+      template <typename T, bool fund>
+      inline void
+      swap (sequence<T, fund>& x, sequence<T, fund>& y)
+      {
+        x.swap (y);
+      }
+    }
+  }
+}
+
+#include <xsd/cxx/tree/containers.txx>
+
+#endif  // XSD_CXX_TREE_CONTAINERS_HXX
diff --git src/base/include/xsd/cxx/tree/containers.txx src/base/include/xsd/cxx/tree/containers.txx
new file mode 100644
index 0000000..fdc0bfd
--- /dev/null
+++ src/base/include/xsd/cxx/tree/containers.txx
@@ -0,0 +1,284 @@
+// file      : xsd/cxx/tree/containers.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#include <ostream>
+#include <xsd/cxx/tree/bits/literals.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      // one
+      //
+      template<typename T>
+      one<T, false>::
+      ~one ()
+      {
+        delete x_;
+      }
+
+      template<typename T>
+      one<T, false>::
+      one (flags f, container* c)
+          : x_ (0), flags_ (f), container_ (c)
+      {
+      }
+
+      template<typename T>
+      one<T, false>::
+      one (const T& x, flags f, container* c)
+          : x_ (0), flags_ (f), container_ (c)
+      {
+        set (x);
+      }
+
+      template<typename T>
+      one<T, false>::
+      one (std::auto_ptr<T> x, flags f, container* c)
+          : x_ (0), flags_ (f), container_ (c)
+      {
+        set (x);
+      }
+
+      template<typename T>
+      one<T, false>::
+      one (const one<T, false>& x, flags f, container* c)
+          : x_ (0), flags_ (f), container_ (c)
+      {
+        if (x.present ())
+          set (x.get ());
+      }
+
+      template<typename T>
+      one<T, false>& one<T, false>::
+      operator= (const one<T, false>& x)
+      {
+        if (this == &x)
+          return *this;
+
+        if (x.present ())
+          set (x.get ());
+        else
+        {
+          delete x_;
+          x_ = 0;
+        }
+
+        return *this;
+      }
+
+      template<typename T>
+      void one<T, false>::
+      set (const T& x)
+      {
+        // We always do a fresh copy because T may not be x's
+        // dynamic type.
+        //
+        T* r (x._clone (flags_, container_));
+
+        delete x_;
+        x_ = r;
+      }
+
+      template<typename T>
+      void one<T, false>::
+      set (std::auto_ptr<T> x)
+      {
+        T* r (0);
+
+        if (x.get () != 0)
+        {
+          if (x->_container () != container_)
+            x->_container (container_);
+
+          r = x.release ();
+        }
+
+        delete x_;
+        x_ = r;
+      }
+
+      // optional
+      //
+      template <typename T>
+      optional<T, false>::
+      ~optional ()
+      {
+        delete x_;
+      }
+
+      template <typename T>
+      optional<T, false>::
+      optional (flags f, container* c)
+          : x_ (0), flags_ (f), container_ (c)
+      {
+      }
+
+      template <typename T>
+      optional<T, false>::
+      optional (const T& x, flags f, container* c)
+          : x_ (0), flags_ (f), container_ (c)
+      {
+        set (x);
+      }
+
+      template <typename T>
+      optional<T, false>::
+      optional (std::auto_ptr<T> x, flags f, container* c)
+          : x_ (0), flags_ (f), container_ (c)
+      {
+        set (x);
+      }
+
+      template <typename T>
+      optional<T, false>::
+      optional (const optional<T, false>& x, flags f, container* c)
+          : x_ (0), flags_ (f), container_ (c)
+      {
+        if (x)
+          set (*x);
+      }
+
+      template <typename T>
+      optional<T, false>& optional<T, false>::
+      operator= (const T& x)
+      {
+        if (x_ == &x)
+          return *this;
+
+        set (x);
+
+        return *this;
+      }
+
+      template <typename T>
+      optional<T, false>& optional<T, false>::
+      operator= (const optional<T, false>& x)
+      {
+        if (this == &x)
+          return *this;
+
+        if (x)
+          set (*x);
+        else
+          reset ();
+
+        return *this;
+      }
+
+      template <typename T>
+      void optional<T, false>::
+      set (const T& x)
+      {
+        // We always do a fresh copy because T may not be x's
+        // dynamic type.
+        //
+        T* r (x._clone (flags_, container_));
+
+        delete x_;
+        x_ = r;
+      }
+
+      template <typename T>
+      void optional<T, false>::
+      set (std::auto_ptr<T> x)
+      {
+        T* r (0);
+
+        if (x.get () != 0)
+        {
+          if (x->_container () != container_)
+            x->_container (container_);
+
+          r = x.release ();
+        }
+
+        delete x_;
+        x_ = r;
+      }
+
+      template <typename T>
+      void optional<T, false>::
+      reset ()
+      {
+        delete x_;
+        x_ = 0;
+      }
+
+      template <typename T>
+      void optional<T, false>::
+      true_ ()
+      {
+      }
+
+
+      // optional
+      //
+      template <typename T>
+      optional<T, true>::
+      optional (const T& y, flags, container*)
+          : present_ (false)
+      {
+        set (y);
+      }
+
+      template <typename T>
+      optional<T, true>::
+      optional (const optional<T, true>& y, flags, container*)
+          : present_ (false)
+      {
+        if (y)
+          set (*y);
+      }
+
+      template <typename T>
+      optional<T, true>& optional<T, true>::
+      operator= (const T& y)
+      {
+        if (&x_ == &y)
+          return *this;
+
+        set (y);
+
+        return *this;
+      }
+
+      template <typename T>
+      optional<T, true>& optional<T, true>::
+      operator= (const optional<T, true>& y)
+      {
+        if (this == &y)
+          return *this;
+
+        if (y)
+          set (*y);
+        else
+          reset ();
+
+        return *this;
+      }
+
+      template <typename T>
+      void optional<T, true>::
+      true_ ()
+      {
+      }
+
+      template <typename C, typename T, bool fund>
+      std::basic_ostream<C>&
+      operator<< (std::basic_ostream<C>& os, const optional<T, fund>& x)
+      {
+        if (x)
+          os << *x;
+        else
+          os << bits::not_present<C> ();
+
+        return os;
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/tree/date-time-extraction.txx src/base/include/xsd/cxx/tree/date-time-extraction.txx
new file mode 100644
index 0000000..317b80f
--- /dev/null
+++ src/base/include/xsd/cxx/tree/date-time-extraction.txx
@@ -0,0 +1,157 @@
+// file      : xsd/cxx/tree/date-time-extraction.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      // time_zone
+      //
+      template <typename S>
+      inline void time_zone::
+      zone_extract (istream<S>& s)
+      {
+        s >> hours_ >> minutes_;
+        present_ = true;
+      }
+
+      // gday
+      //
+      template <typename C, typename B>
+      template <typename S>
+      gday<C, B>::
+      gday (istream<S>& s, flags f, container* c)
+          : B (s, f, c)
+      {
+        bool zp;
+        s >> day_ >> zp;
+
+        if (zp)
+          zone_extract (s);
+      }
+
+      // gmonth
+      //
+      template <typename C, typename B>
+      template <typename S>
+      gmonth<C, B>::
+      gmonth (istream<S>& s, flags f, container* c)
+          : B (s, f, c)
+      {
+        bool zp;
+        s >> month_ >> zp;
+
+        if (zp)
+          zone_extract (s);
+      }
+
+      // gyear
+      //
+      template <typename C, typename B>
+      template <typename S>
+      gyear<C, B>::
+      gyear (istream<S>& s, flags f, container* c)
+          : B (s, f, c)
+      {
+        bool zp;
+        s >> year_ >> zp;
+
+        if (zp)
+          zone_extract (s);
+      }
+
+      // gmonth_day
+      //
+      template <typename C, typename B>
+      template <typename S>
+      gmonth_day<C, B>::
+      gmonth_day (istream<S>& s, flags f, container* c)
+          : B (s, f, c)
+      {
+        bool zp;
+        s >> month_ >> day_ >> zp;
+
+        if (zp)
+          zone_extract (s);
+      }
+
+      // gyear_month
+      //
+      template <typename C, typename B>
+      template <typename S>
+      gyear_month<C, B>::
+      gyear_month (istream<S>& s, flags f, container* c)
+          : B (s, f, c)
+      {
+        bool zp;
+        s >> year_ >> month_ >> zp;
+
+        if (zp)
+          zone_extract (s);
+      }
+
+      // date
+      //
+      template <typename C, typename B>
+      template <typename S>
+      date<C, B>::
+      date (istream<S>& s, flags f, container* c)
+          : B (s, f, c)
+      {
+        bool zp;
+        s >> year_ >> month_ >> day_ >> zp;
+
+        if (zp)
+          zone_extract (s);
+      }
+
+      // time
+      //
+      template <typename C, typename B>
+      template <typename S>
+      time<C, B>::
+      time (istream<S>& s, flags f, container* c)
+          : B (s, f, c)
+      {
+        bool zp;
+        s >> hours_ >> minutes_ >> seconds_ >> zp;
+
+        if (zp)
+          zone_extract (s);
+      }
+
+      // date_time
+      //
+      template <typename C, typename B>
+      template <typename S>
+      date_time<C, B>::
+      date_time (istream<S>& s, flags f, container* c)
+          : B (s, f, c)
+      {
+        bool zp;
+        s >> year_ >> month_ >> day_
+          >> hours_ >> minutes_ >> seconds_ >> zp;
+
+        if (zp)
+          zone_extract (s);
+      }
+
+      // duration
+      //
+      template <typename C, typename B>
+      template <typename S>
+      duration<C, B>::
+      duration (istream<S>& s, flags f, container* c)
+          : B (s, f, c)
+      {
+        s >> negative_
+          >> years_ >> months_ >> days_
+          >> hours_ >> minutes_ >> seconds_;
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/tree/date-time-insertion.txx src/base/include/xsd/cxx/tree/date-time-insertion.txx
new file mode 100644
index 0000000..db24ae1
--- /dev/null
+++ src/base/include/xsd/cxx/tree/date-time-insertion.txx
@@ -0,0 +1,188 @@
+// file      : xsd/cxx/tree/date-time-insertion.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      // time_zone
+      //
+      template <typename S>
+      inline ostream<S>&
+      operator<< (ostream<S>& s, const time_zone& z)
+      {
+        return s << z.zone_hours () << z.zone_minutes ();
+      }
+
+      // gday
+      //
+      template <typename S, typename C, typename B>
+      ostream<S>&
+      operator<< (ostream<S>& s, const gday<C, B>& x)
+      {
+        bool zp (x.zone_present ());
+
+        s << x.day () << zp;
+
+        if (zp)
+        {
+          const time_zone& z (x);
+          s << z;
+        }
+
+        return s;
+      }
+
+      // gmonth
+      //
+      template <typename S, typename C, typename B>
+      ostream<S>&
+      operator<< (ostream<S>& s, const gmonth<C, B>& x)
+      {
+        bool zp (x.zone_present ());
+
+        s << x.month () << zp;
+
+        if (zp)
+        {
+          const time_zone& z (x);
+          s << z;
+        }
+
+        return s;
+      }
+
+      // gyear
+      //
+      template <typename S, typename C, typename B>
+      ostream<S>&
+      operator<< (ostream<S>& s, const gyear<C, B>& x)
+      {
+        bool zp (x.zone_present ());
+
+        s << x.year () << zp;
+
+        if (zp)
+        {
+          const time_zone& z (x);
+          s << z;
+        }
+
+        return s;
+      }
+
+      // gmonth_day
+      //
+      template <typename S, typename C, typename B>
+      ostream<S>&
+      operator<< (ostream<S>& s, const gmonth_day<C, B>& x)
+      {
+        bool zp (x.zone_present ());
+
+        s << x.month () << x.day () << zp;
+
+        if (zp)
+        {
+          const time_zone& z (x);
+          s << z;
+        }
+
+        return s;
+      }
+
+      // gyear_month
+      //
+      template <typename S, typename C, typename B>
+      ostream<S>&
+      operator<< (ostream<S>& s, const gyear_month<C, B>& x)
+      {
+        bool zp (x.zone_present ());
+
+        s << x.year () << x.month () << zp;
+
+        if (zp)
+        {
+          const time_zone& z (x);
+          s << z;
+        }
+
+        return s;
+      }
+
+      // date
+      //
+      template <typename S, typename C, typename B>
+      ostream<S>&
+      operator<< (ostream<S>& s, const date<C, B>& x)
+      {
+        bool zp (x.zone_present ());
+
+        s << x.year () << x.month () << x.day () << zp;
+
+        if (zp)
+        {
+          const time_zone& z (x);
+          s << z;
+        }
+
+        return s;
+      }
+
+      // time
+      //
+      template <typename S, typename C, typename B>
+      ostream<S>&
+      operator<< (ostream<S>& s, const time<C, B>& x)
+      {
+        bool zp (x.zone_present ());
+
+        s << x.hours () << x.minutes () << x.seconds () << zp;
+
+        if (zp)
+        {
+          const time_zone& z (x);
+          s << z;
+        }
+
+        return s;
+      }
+
+      // date_time
+      //
+      template <typename S, typename C, typename B>
+      ostream<S>&
+      operator<< (ostream<S>& s, const date_time<C, B>& x)
+      {
+        bool zp (x.zone_present ());
+
+        s << x.year () << x.month () << x.day ()
+          << x.hours () << x.minutes () << x.seconds () << zp;
+
+        if (zp)
+        {
+          const time_zone& z (x);
+          s << z;
+        }
+
+        return s;
+      }
+
+      // duration
+      //
+      template <typename S, typename C, typename B>
+      ostream<S>&
+      operator<< (ostream<S>& s, const duration<C, B>& x)
+      {
+        s << x.negative ()
+          << x.years () << x.months () << x.days ()
+          << x.hours () << x.minutes () << x.seconds ();
+
+        return s;
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/tree/date-time-ostream.txx src/base/include/xsd/cxx/tree/date-time-ostream.txx
new file mode 100644
index 0000000..90073f4
--- /dev/null
+++ src/base/include/xsd/cxx/tree/date-time-ostream.txx
@@ -0,0 +1,324 @@
+// file      : xsd/cxx/tree/date-time-ostream.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#include <ostream>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      // time_zone
+      //
+      template <typename C>
+      std::basic_ostream<C>&
+      operator<< (std::basic_ostream<C>& os, const time_zone& z)
+      {
+        short h = z.zone_hours ();
+        short m = z.zone_minutes ();
+
+        if (h == 0 && m == 0)
+        {
+          os << C ('Z');
+        }
+        else
+        {
+          if (h < 0 || m < 0)
+          {
+            h = -h;
+            m = -m;
+            os << C ('-');
+          }
+          else
+            os << C ('+');
+
+          C f (os.fill (C ('0')));
+
+          os.width (2);
+          os << h << C (':');
+          os.width (2);
+          os << m;
+
+          os.fill (f);
+        }
+
+        return os;
+      }
+
+      // gday
+      //
+      template <typename C, typename B>
+      std::basic_ostream<C>&
+      operator<< (std::basic_ostream<C>& os, const gday<C, B>& x)
+      {
+        C f (os.fill (C ('0')));
+        os.width (2);
+        os << x.day ();
+        os.fill (f);
+
+        if (x.zone_present ())
+        {
+          const time_zone& z (x);
+          os << z;
+        }
+
+        return os;
+      }
+
+      // gmonth
+      //
+      template <typename C, typename B>
+      std::basic_ostream<C>&
+      operator<< (std::basic_ostream<C>& os, const gmonth<C, B>& x)
+      {
+        C f (os.fill (C ('0')));
+        os.width (2);
+        os << x.month ();
+        os.fill (f);
+
+        if (x.zone_present ())
+        {
+          const time_zone& z (x);
+          os << z;
+        }
+
+        return os;
+      }
+
+      // gyear
+      //
+      template <typename C, typename B>
+      std::basic_ostream<C>&
+      operator<< (std::basic_ostream<C>& os, const gyear<C, B>& x)
+      {
+        C f (os.fill (C ('0')));
+        os.width (4);
+        os << x.year ();
+        os.fill (f);
+
+        if (x.zone_present ())
+        {
+          const time_zone& z (x);
+          os << z;
+        }
+
+        return os;
+      }
+
+      // gmonth_day
+      //
+      template <typename C, typename B>
+      std::basic_ostream<C>&
+      operator<< (std::basic_ostream<C>& os, const gmonth_day<C, B>& x)
+      {
+        C f (os.fill (C ('0')));
+
+        os.width (2);
+        os << x.month () << C ('-');
+
+        os.width (2);
+        os << x.day ();
+
+        os.fill (f);
+
+        if (x.zone_present ())
+        {
+          const time_zone& z (x);
+          os << z;
+        }
+
+        return os;
+      }
+
+
+      // gyear_month
+      //
+      template <typename C, typename B>
+      std::basic_ostream<C>&
+      operator<< (std::basic_ostream<C>& os, const gyear_month<C, B>& x)
+      {
+        C f (os.fill (C ('0')));
+
+        os.width (4);
+        os << x.year () << C ('-');
+
+        os.width (2);
+        os << x.month ();
+
+        os.fill (f);
+
+        if (x.zone_present ())
+        {
+          const time_zone& z (x);
+          os << z;
+        }
+
+        return os;
+      }
+
+      // date
+      //
+      template <typename C, typename B>
+      std::basic_ostream<C>&
+      operator<< (std::basic_ostream<C>& os, const date<C, B>& x)
+      {
+        C f (os.fill (C ('0')));
+
+        os.width (4);
+        os << x.year () << C ('-');
+
+        os.width (2);
+        os << x.month () << C ('-');
+
+        os.width (2);
+        os << x.day ();
+
+        os.fill (f);
+
+        if (x.zone_present ())
+        {
+          const time_zone& z (x);
+          os << z;
+        }
+
+        return os;
+      }
+
+      // time
+      //
+      template <typename C, typename B>
+      std::basic_ostream<C>&
+      operator<< (std::basic_ostream<C>& os, const time<C, B>& x)
+      {
+        C f (os.fill (C ('0')));
+
+        os.width (2);
+        os << x.hours () << C (':');
+
+        os.width (2);
+        os << x.minutes () << C (':');
+
+        os.width (9);
+        std::ios_base::fmtflags ff (
+          os.setf (std::ios::fixed, std::ios::floatfield));
+        os << x.seconds ();
+        os.setf (ff, std::ios::floatfield);
+
+        os.fill (f);
+
+        if (x.zone_present ())
+        {
+          const time_zone& z (x);
+          os << z;
+        }
+
+        return os;
+      }
+
+      // date_time
+      //
+      template <typename C, typename B>
+      std::basic_ostream<C>&
+      operator<< (std::basic_ostream<C>& os, const date_time<C, B>& x)
+      {
+        C f (os.fill (C ('0')));
+
+        os.width (4);
+        os << x.year () << C ('-');
+
+        os.width (2);
+        os << x.month () << C ('-');
+
+        os.width (2);
+        os << x.day () << C ('T');
+
+        os.width (2);
+        os << x.hours () << C (':');
+
+        os.width (2);
+        os << x.minutes () << C (':');
+
+        os.width (9);
+        std::ios_base::fmtflags ff (
+          os.setf (std::ios::fixed, std::ios::floatfield));
+        os << x.seconds ();
+        os.setf (ff, std::ios::floatfield);
+
+        os.fill (f);
+
+        if (x.zone_present ())
+        {
+          const time_zone& z (x);
+          os << z;
+        }
+
+        return os;
+      }
+
+      // duration
+      //
+      template <typename C, typename B>
+      std::basic_ostream<C>&
+      operator<< (std::basic_ostream<C>& os, const duration<C, B>& x)
+      {
+        if (x.negative ())
+          os << C ('-');
+
+        os << C ('P');
+
+        // In case it is 0-duration, use the years field to handle
+        // this case.
+        //
+        if (x.years () != 0 ||
+            (x.months () == 0 &&
+             x.days () == 0 &&
+             x.hours () == 0 &&
+             x.minutes () == 0 &&
+             x.seconds () == 0.0))
+        {
+          os << x.years () << C ('Y');
+        }
+
+        if (x.months () != 0)
+        {
+          os << x.months () << C ('M');
+        }
+
+        if (x.days () != 0)
+        {
+          os << x.days () << C ('D');
+        }
+
+        // Figure out if we need the 'T' delimiter.
+        //
+        if (x.hours () != 0 ||
+            x.minutes () != 0 ||
+            x.seconds () != 0.0)
+          os << C ('T');
+
+        if (x.hours () != 0)
+        {
+          os << x.hours () << C ('H');
+        }
+
+        if (x.minutes () != 0)
+        {
+          os << x.minutes () << C ('M');
+        }
+
+        if (x.seconds () > 0.0)
+        {
+          std::ios_base::fmtflags ff (
+            os.setf (std::ios::fixed, std::ios::floatfield));
+          os << x.seconds () << C ('S');
+          os.setf (ff, std::ios::floatfield);
+        }
+
+        return os;
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/tree/date-time.hxx src/base/include/xsd/cxx/tree/date-time.hxx
new file mode 100644
index 0000000..abde516
--- /dev/null
+++ src/base/include/xsd/cxx/tree/date-time.hxx
@@ -0,0 +1,1951 @@
+// file      : xsd/cxx/tree/date-time.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+/**
+ * @file
+ *
+ * @brief Contains C++ class definitions for the XML Schema date/time types.
+ *
+ * This is an internal header and is included by the generated code. You
+ * normally should not include it directly.
+ *
+ */
+
+#ifndef XSD_CXX_TREE_DATE_TIME_HXX
+#define XSD_CXX_TREE_DATE_TIME_HXX
+
+#include <string>
+#include <cstddef> // std::size_t
+
+#include <xercesc/dom/DOMAttr.hpp>
+#include <xercesc/dom/DOMElement.hpp>
+
+#include <xsd/cxx/tree/elements.hxx>
+#include <xsd/cxx/tree/istream-fwd.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    /**
+     * @brief C++/Tree mapping runtime namespace.
+     *
+     * This is an internal namespace and normally should not be referenced
+     * directly. Instead you should use the aliases for types in this
+     * namespaces that are created in the generated code.
+     *
+     */
+    namespace tree
+    {
+      /**
+       * @brief Time zone representation
+       *
+       * The %time_zone class represents an optional %time zone and
+       * is used as a base class for date/time types.
+       *
+       * The %time zone can negative in which case both the hours and
+       * minutes components should be negative.
+       *
+       * @nosubgrouping
+       */
+      class time_zone
+      {
+      public:
+        /**
+         * @name Constructors
+         */
+        //@{
+
+        /**
+         * @brief Default constructor.
+         *
+         * This constructor initializes the instance to the 'not specified'
+         * state.
+         */
+        time_zone ();
+
+        /**
+         * @brief Initialize an instance with the hours and minutes
+         * components.
+         *
+         * @param hours The %time zone hours component.
+         * @param minutes The %time zone minutes component.
+         */
+        time_zone (short hours, short minutes);
+
+        //@}
+
+        /**
+         * @brief Determine if %time zone is specified.
+         *
+         * @return True if %time zone is specified, false otherwise.
+         */
+        bool
+        zone_present () const;
+
+        /**
+         * @brief Reset the %time zone to the 'not specified' state.
+         *
+         */
+        void
+        zone_reset ();
+
+        /**
+         * @brief Get the hours component of the %time zone.
+         *
+         * @return The hours component of the %time zone.
+         */
+        short
+        zone_hours () const;
+
+        /**
+         * @brief Set the hours component of the %time zone.
+         *
+         * @param h The new hours component.
+         */
+        void
+        zone_hours (short h);
+
+
+        /**
+         * @brief Get the minutes component of the %time zone.
+         *
+         * @return The minutes component of the %time zone.
+         */
+        short
+        zone_minutes () const;
+
+        /**
+         * @brief Set the minutes component of the %time zone.
+         *
+         * @param m The new minutes component.
+         */
+        void
+        zone_minutes (short m);
+
+      protected:
+        //@cond
+
+        template <typename C>
+        void
+        zone_parse (const C*, std::size_t);
+
+        template <typename S>
+        void
+        zone_extract (istream<S>&);
+
+        //@endcond
+
+      private:
+        bool present_;
+        short hours_;
+        short minutes_;
+      };
+
+      /**
+       * @brief %time_zone comparison operator.
+       *
+       * @return True if both %time zones are either not specified or
+       * have equal hours and minutes components, false otherwise.
+       */
+      bool
+      operator== (const time_zone&, const time_zone&);
+
+      /**
+       * @brief %time_zone comparison operator.
+       *
+       * @return False if both %time zones are either not specified or
+       * have equal hours and minutes components, true otherwise.
+       */
+      bool
+      operator!= (const time_zone&, const time_zone&);
+
+
+      /**
+       * @brief Class corresponding to the XML Schema gDay built-in type.
+       *
+       * The %gday class represents a day of the month with an optional
+       * %time zone.
+       *
+       * @nosubgrouping
+       */
+      template <typename C, typename B>
+      class gday: public B, public time_zone
+      {
+      public:
+        /**
+         * @name Constructors
+         */
+        //@{
+
+        /**
+         * @brief Initialize an instance with the day component.
+         *
+         * When this constructor is used, the %time zone is left
+         * unspecified.
+         *
+         * @param day The day component.
+         */
+        explicit
+        gday (unsigned short day);
+
+        /**
+         * @brief Initialize an instance with the day component and %time
+         * zone.
+         *
+         * @param day The day component.
+         * @param zone_hours The %time zone hours component.
+         * @param zone_minutes The %time zone minutes component.
+         */
+        gday (unsigned short day, short zone_hours, short zone_minutes);
+
+        /**
+         * @brief Copy constructor.
+         *
+         * @param x An instance to make a copy of.
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         *
+         * For polymorphic object models use the _clone function instead.
+         */
+        gday (const gday& x, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Copy the instance polymorphically.
+         *
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         * @return A pointer to the dynamically allocated copy.
+         *
+         * This function ensures that the dynamic type of the instance
+         * is used for copying and should be used for polymorphic object
+         * models instead of the copy constructor.
+         */
+        virtual gday*
+        _clone (flags f = 0, container* c = 0) const;
+
+        /**
+         * @brief Create an instance from a data representation
+         * stream.
+         *
+         * @param s A stream to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        template <typename S>
+        gday (istream<S>& s, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM element.
+         *
+         * @param e A DOM element to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        gday (const xercesc::DOMElement& e, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM Attribute.
+         *
+         * @param a A DOM attribute to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        gday (const xercesc::DOMAttr& a, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a %string fragment.
+         *
+         * @param s A %string fragment to extract the data from.
+         * @param e A pointer to DOM element containing the %string fragment.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        gday (const std::basic_string<C>& s,
+              const xercesc::DOMElement* e,
+              flags f = 0,
+              container* c = 0);
+        //@}
+
+      public:
+        /**
+         * @brief Get the day component.
+         *
+         * @return The day component.
+         */
+        unsigned short
+        day () const;
+
+        /**
+         * @brief Set the day component.
+         *
+         * @param d The new day component.
+         */
+        void
+        day (unsigned short d);
+
+      protected:
+        //@cond
+
+        gday ();
+
+        void
+        parse (const std::basic_string<C>&);
+
+        //@endcond
+
+      private:
+        unsigned short day_;
+      };
+
+      /**
+       * @brief %gday comparison operator.
+       *
+       * @return True if the day components and %time zones are equal, false
+       * otherwise.
+       */
+      template <typename C, typename B>
+      bool
+      operator== (const gday<C, B>&, const gday<C, B>&);
+
+      /**
+       * @brief %gday comparison operator.
+       *
+       * @return False if the day components and %time zones are equal, true
+       * otherwise.
+       */
+      template <typename C, typename B>
+      bool
+      operator!= (const gday<C, B>&, const gday<C, B>&);
+
+      /**
+       * @brief Class corresponding to the XML Schema gMonth built-in type.
+       *
+       * The %gmonth class represents a month of the year with an optional
+       * %time zone.
+       *
+       * @nosubgrouping
+       */
+      template <typename C, typename B>
+      class gmonth: public B, public time_zone
+      {
+      public:
+        /**
+         * @name Constructors
+         */
+        //@{
+
+        /**
+         * @brief Initialize an instance with the month component.
+         *
+         * When this constructor is used, the %time zone is left
+         * unspecified.
+         *
+         * @param month The month component.
+         */
+        explicit
+        gmonth (unsigned short month);
+
+        /**
+         * @brief Initialize an instance with the month component and %time
+         * zone.
+         *
+         * @param month The month component.
+         * @param zone_hours The %time zone hours component.
+         * @param zone_minutes The %time zone minutes component.
+         */
+        gmonth (unsigned short month, short zone_hours, short zone_minutes);
+
+        /**
+         * @brief Copy constructor.
+         *
+         * @param x An instance to make a copy of.
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         *
+         * For polymorphic object models use the _clone function instead.
+         */
+        gmonth (const gmonth& x, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Copy the instance polymorphically.
+         *
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         * @return A pointer to the dynamically allocated copy.
+         *
+         * This function ensures that the dynamic type of the instance
+         * is used for copying and should be used for polymorphic object
+         * models instead of the copy constructor.
+         */
+        virtual gmonth*
+        _clone (flags f = 0, container* c = 0) const;
+
+        /**
+         * @brief Create an instance from a data representation
+         * stream.
+         *
+         * @param s A stream to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        template <typename S>
+        gmonth (istream<S>& s, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM element.
+         *
+         * @param e A DOM element to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        gmonth (const xercesc::DOMElement& e, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM Attribute.
+         *
+         * @param a A DOM attribute to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        gmonth (const xercesc::DOMAttr& a, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a %string fragment.
+         *
+         * @param s A %string fragment to extract the data from.
+         * @param e A pointer to DOM element containing the %string fragment.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        gmonth (const std::basic_string<C>& s,
+                const xercesc::DOMElement* e,
+                flags f = 0,
+                container* c = 0);
+        //@}
+
+      public:
+        /**
+         * @brief Get the month component.
+         *
+         * @return The month component.
+         */
+        unsigned short
+        month () const;
+
+        /**
+         * @brief Set the month component.
+         *
+         * @param m The new month component.
+         */
+        void
+        month (unsigned short m);
+
+      protected:
+        //@cond
+
+        gmonth ();
+
+        void
+        parse (const std::basic_string<C>&);
+
+        //@endcond
+
+      private:
+        unsigned short month_;
+      };
+
+      /**
+       * @brief %gmonth comparison operator.
+       *
+       * @return True if the month components and %time zones are equal, false
+       * otherwise.
+       */
+      template <typename C, typename B>
+      bool
+      operator== (const gmonth<C, B>&, const gmonth<C, B>&);
+
+      /**
+       * @brief %gmonth comparison operator.
+       *
+       * @return False if the month components and %time zones are equal, true
+       * otherwise.
+       */
+      template <typename C, typename B>
+      bool
+      operator!= (const gmonth<C, B>&, const gmonth<C, B>&);
+
+
+      /**
+       * @brief Class corresponding to the XML Schema gYear built-in type.
+       *
+       * The %gyear class represents a year with an optional %time zone.
+       *
+       * @nosubgrouping
+       */
+      template <typename C, typename B>
+      class gyear: public B, public time_zone
+      {
+      public:
+        /**
+         * @name Constructors
+         */
+        //@{
+
+        /**
+         * @brief Initialize an instance with the year component.
+         *
+         * When this constructor is used, the %time zone is left
+         * unspecified.
+         *
+         * @param year The year component.
+         */
+        explicit
+        gyear (int year);
+
+        /**
+         * @brief Initialize an instance with the year component and %time
+         * zone.
+         *
+         * @param year The year component.
+         * @param zone_hours The %time zone hours component.
+         * @param zone_minutes The %time zone minutes component.
+         */
+        gyear (int year, short zone_hours, short zone_minutes);
+
+        /**
+         * @brief Copy constructor.
+         *
+         * @param x An instance to make a copy of.
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         *
+         * For polymorphic object models use the _clone function instead.
+         */
+        gyear (const gyear& x, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Copy the instance polymorphically.
+         *
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         * @return A pointer to the dynamically allocated copy.
+         *
+         * This function ensures that the dynamic type of the instance
+         * is used for copying and should be used for polymorphic object
+         * models instead of the copy constructor.
+         */
+        virtual gyear*
+        _clone (flags f = 0, container* c = 0) const;
+
+        /**
+         * @brief Create an instance from a data representation
+         * stream.
+         *
+         * @param s A stream to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        template <typename S>
+        gyear (istream<S>& s, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM element.
+         *
+         * @param e A DOM element to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        gyear (const xercesc::DOMElement& e, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM Attribute.
+         *
+         * @param a A DOM attribute to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        gyear (const xercesc::DOMAttr& a, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a %string fragment.
+         *
+         * @param s A %string fragment to extract the data from.
+         * @param e A pointer to DOM element containing the %string fragment.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        gyear (const std::basic_string<C>& s,
+               const xercesc::DOMElement* e,
+               flags f = 0,
+               container* c = 0);
+        //@}
+
+      public:
+        /**
+         * @brief Get the year component.
+         *
+         * @return The year component.
+         */
+        int
+        year () const;
+
+        /**
+         * @brief Set the year component.
+         *
+         * @param y The new year component.
+         */
+        void
+        year (int y);
+
+      protected:
+        //@cond
+
+        gyear ();
+
+        void
+        parse (const std::basic_string<C>&);
+
+        //@endcond
+
+      private:
+        int year_;
+      };
+
+      /**
+       * @brief %gyear comparison operator.
+       *
+       * @return True if the year components and %time zones are equal, false
+       * otherwise.
+       */
+      template <typename C, typename B>
+      bool
+      operator== (const gyear<C, B>&, const gyear<C, B>&);
+
+      /**
+       * @brief %gyear comparison operator.
+       *
+       * @return False if the year components and %time zones are equal, true
+       * otherwise.
+       */
+      template <typename C, typename B>
+      bool
+      operator!= (const gyear<C, B>&, const gyear<C, B>&);
+
+
+      /**
+       * @brief Class corresponding to the XML Schema gMonthDay built-in type.
+       *
+       * The %gmonth_day class represents day and month of the year with an
+       * optional %time zone.
+       *
+       * @nosubgrouping
+       */
+      template <typename C, typename B>
+      class gmonth_day: public B, public time_zone
+      {
+      public:
+        /**
+         * @name Constructors
+         */
+        //@{
+
+        /**
+         * @brief Initialize an instance with the month and day components.
+         *
+         * When this constructor is used, the %time zone is left
+         * unspecified.
+         *
+         * @param month The month component.
+         * @param day The day component.
+         */
+        gmonth_day (unsigned short month, unsigned short day);
+
+        /**
+         * @brief Initialize an instance with the month and day components
+         * as well as %time zone.
+         *
+         * @param month The month component.
+         * @param day The day component.
+         * @param zone_hours The %time zone hours component.
+         * @param zone_minutes The %time zone minutes component.
+         */
+        gmonth_day (unsigned short month, unsigned short day,
+                    short zone_hours, short zone_minutes);
+
+        /**
+         * @brief Copy constructor.
+         *
+         * @param x An instance to make a copy of.
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         *
+         * For polymorphic object models use the _clone function instead.
+         */
+        gmonth_day (const gmonth_day& x, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Copy the instance polymorphically.
+         *
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         * @return A pointer to the dynamically allocated copy.
+         *
+         * This function ensures that the dynamic type of the instance
+         * is used for copying and should be used for polymorphic object
+         * models instead of the copy constructor.
+         */
+        virtual gmonth_day*
+        _clone (flags f = 0, container* c = 0) const;
+
+        /**
+         * @brief Create an instance from a data representation
+         * stream.
+         *
+         * @param s A stream to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        template <typename S>
+        gmonth_day (istream<S>& s, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM element.
+         *
+         * @param e A DOM element to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        gmonth_day (const xercesc::DOMElement& e,
+                    flags f = 0,
+                    container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM Attribute.
+         *
+         * @param a A DOM attribute to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        gmonth_day (const xercesc::DOMAttr& a, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a %string fragment.
+         *
+         * @param s A %string fragment to extract the data from.
+         * @param e A pointer to DOM element containing the %string fragment.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        gmonth_day (const std::basic_string<C>& s,
+                    const xercesc::DOMElement* e,
+                    flags f = 0,
+                    container* c = 0);
+        //@}
+
+      public:
+        /**
+         * @brief Get the month component.
+         *
+         * @return The month component.
+         */
+        unsigned short
+        month () const;
+
+        /**
+         * @brief Set the month component.
+         *
+         * @param m The new month component.
+         */
+        void
+        month (unsigned short m);
+
+        /**
+         * @brief Get the day component.
+         *
+         * @return The day component.
+         */
+        unsigned short
+        day () const;
+
+        /**
+         * @brief Set the day component.
+         *
+         * @param d The new day component.
+         */
+        void
+        day (unsigned short d);
+
+      protected:
+        //@cond
+
+        gmonth_day ();
+
+        void
+        parse (const std::basic_string<C>&);
+
+        //@endcond
+
+      private:
+        unsigned short month_;
+        unsigned short day_;
+      };
+
+      /**
+       * @brief %gmonth_day comparison operator.
+       *
+       * @return True if the month and day components as well as %time zones
+       * are equal, false otherwise.
+       */
+      template <typename C, typename B>
+      bool
+      operator== (const gmonth_day<C, B>&, const gmonth_day<C, B>&);
+
+      /**
+       * @brief %gmonth_day comparison operator.
+       *
+       * @return False if the month and day components as well as %time zones
+       * are equal, true otherwise.
+       */
+      template <typename C, typename B>
+      bool
+      operator!= (const gmonth_day<C, B>&, const gmonth_day<C, B>&);
+
+
+      /**
+       * @brief Class corresponding to the XML Schema gYearMonth built-in
+       * type.
+       *
+       * The %gyear_month class represents year and month with an optional
+       * %time zone.
+       *
+       * @nosubgrouping
+       */
+      template <typename C, typename B>
+      class gyear_month: public B, public time_zone
+      {
+      public:
+        /**
+         * @name Constructors
+         */
+        //@{
+
+        /**
+         * @brief Initialize an instance with the year and month components.
+         *
+         * When this constructor is used, the %time zone is left
+         * unspecified.
+         *
+         * @param year The year component.
+         * @param month The month component.
+         */
+        gyear_month (int year, unsigned short month);
+
+        /**
+         * @brief Initialize an instance with the year and month components
+         * as well as %time zone.
+         *
+         * @param year The year component.
+         * @param month The month component.
+         * @param zone_hours The %time zone hours component.
+         * @param zone_minutes The %time zone minutes component.
+         */
+        gyear_month (int year, unsigned short month,
+                     short zone_hours, short zone_minutes);
+
+        /**
+         * @brief Copy constructor.
+         *
+         * @param x An instance to make a copy of.
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         *
+         * For polymorphic object models use the _clone function instead.
+         */
+        gyear_month (const gyear_month& x, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Copy the instance polymorphically.
+         *
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         * @return A pointer to the dynamically allocated copy.
+         *
+         * This function ensures that the dynamic type of the instance
+         * is used for copying and should be used for polymorphic object
+         * models instead of the copy constructor.
+         */
+        virtual gyear_month*
+        _clone (flags f = 0, container* c = 0) const;
+
+        /**
+         * @brief Create an instance from a data representation
+         * stream.
+         *
+         * @param s A stream to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        template <typename S>
+        gyear_month (istream<S>& s, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM element.
+         *
+         * @param e A DOM element to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        gyear_month (const xercesc::DOMElement& e,
+                     flags f = 0,
+                     container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM Attribute.
+         *
+         * @param a A DOM attribute to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        gyear_month (const xercesc::DOMAttr& a,
+                     flags f = 0,
+                     container* c = 0);
+
+        /**
+         * @brief Create an instance from a %string fragment.
+         *
+         * @param s A %string fragment to extract the data from.
+         * @param e A pointer to DOM element containing the %string fragment.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        gyear_month (const std::basic_string<C>& s,
+                     const xercesc::DOMElement* e,
+                     flags f = 0,
+                     container* c = 0);
+        //@}
+
+      public:
+        /**
+         * @brief Get the year component.
+         *
+         * @return The year component.
+         */
+        int
+        year () const;
+
+        /**
+         * @brief Set the year component.
+         *
+         * @param y The new year component.
+         */
+        void
+        year (int y);
+
+        /**
+         * @brief Get the month component.
+         *
+         * @return The month component.
+         */
+        unsigned short
+        month () const;
+
+        /**
+         * @brief Set the month component.
+         *
+         * @param m The new month component.
+         */
+        void
+        month (unsigned short m);
+
+      protected:
+        //@cond
+
+        gyear_month ();
+
+        void
+        parse (const std::basic_string<C>&);
+
+        //@endcond
+
+      private:
+        int year_;
+        unsigned short month_;
+      };
+
+      /**
+       * @brief %gyear_month comparison operator.
+       *
+       * @return True if the year and month components as well as %time zones
+       * are equal, false otherwise.
+       */
+      template <typename C, typename B>
+      bool
+      operator== (const gyear_month<C, B>&, const gyear_month<C, B>&);
+
+      /**
+       * @brief %gyear_month comparison operator.
+       *
+       * @return False if the year and month components as well as %time zones
+       * are equal, true otherwise.
+       */
+      template <typename C, typename B>
+      bool
+      operator!= (const gyear_month<C, B>&, const gyear_month<C, B>&);
+
+
+      /**
+       * @brief Class corresponding to the XML Schema %date built-in type.
+       *
+       * The %date class represents day, month, and year with an optional
+       * %time zone.
+       *
+       * @nosubgrouping
+       */
+      template <typename C, typename B>
+      class date: public B, public time_zone
+      {
+      public:
+        /**
+         * @name Constructors
+         */
+        //@{
+
+        /**
+         * @brief Initialize an instance with the year, month, and day
+         * components.
+         *
+         * When this constructor is used, the %time zone is left
+         * unspecified.
+         *
+         * @param year The year component.
+         * @param month The month component.
+         * @param day The day component.
+         */
+        date (int year, unsigned short month, unsigned short day);
+
+        /**
+         * @brief Initialize an instance with the year, month, and day
+         * components as well as %time zone.
+         *
+         * @param year The year component.
+         * @param month The month component.
+         * @param day The day component.
+         * @param zone_hours The %time zone hours component.
+         * @param zone_minutes The %time zone minutes component.
+         */
+        date (int year, unsigned short month, unsigned short day,
+              short zone_hours, short zone_minutes);
+
+        /**
+         * @brief Copy constructor.
+         *
+         * @param x An instance to make a copy of.
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         *
+         * For polymorphic object models use the _clone function instead.
+         */
+        date (const date& x, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Copy the instance polymorphically.
+         *
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         * @return A pointer to the dynamically allocated copy.
+         *
+         * This function ensures that the dynamic type of the instance
+         * is used for copying and should be used for polymorphic object
+         * models instead of the copy constructor.
+         */
+        virtual date*
+        _clone (flags f = 0, container* c = 0) const;
+
+        /**
+         * @brief Create an instance from a data representation
+         * stream.
+         *
+         * @param s A stream to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        template <typename S>
+        date (istream<S>& s, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM element.
+         *
+         * @param e A DOM element to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        date (const xercesc::DOMElement& e, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM Attribute.
+         *
+         * @param a A DOM attribute to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        date (const xercesc::DOMAttr& a, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a %string fragment.
+         *
+         * @param s A %string fragment to extract the data from.
+         * @param e A pointer to DOM element containing the %string fragment.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        date (const std::basic_string<C>& s,
+              const xercesc::DOMElement* e,
+              flags f = 0,
+              container* c = 0);
+        //@}
+
+      public:
+        /**
+         * @brief Get the year component.
+         *
+         * @return The year component.
+         */
+        int
+        year () const;
+
+        /**
+         * @brief Set the year component.
+         *
+         * @param y The new year component.
+         */
+        void
+        year (int y);
+
+        /**
+         * @brief Get the month component.
+         *
+         * @return The month component.
+         */
+        unsigned short
+        month () const;
+
+        /**
+         * @brief Set the month component.
+         *
+         * @param m The new month component.
+         */
+        void
+        month (unsigned short m);
+
+        /**
+         * @brief Get the day component.
+         *
+         * @return The day component.
+         */
+        unsigned short
+        day () const;
+
+        /**
+         * @brief Set the day component.
+         *
+         * @param d The new day component.
+         */
+        void
+        day (unsigned short d);
+
+      protected:
+        //@cond
+
+        date ();
+
+        void
+        parse (const std::basic_string<C>&);
+
+        //@endcond
+
+      private:
+        int year_;
+        unsigned short month_;
+        unsigned short day_;
+      };
+
+      /**
+       * @brief %date comparison operator.
+       *
+       * @return True if the year, month, and day components as well as %time
+       * zones are equal, false otherwise.
+       */
+      template <typename C, typename B>
+      bool
+      operator== (const date<C, B>&, const date<C, B>&);
+
+      /**
+       * @brief %date comparison operator.
+       *
+       * @return False if the year, month, and day components as well as %time
+       * zones are equal, true otherwise.
+       */
+      template <typename C, typename B>
+      bool
+      operator!= (const date<C, B>&, const date<C, B>&);
+
+
+      /**
+       * @brief Class corresponding to the XML Schema %time built-in type.
+       *
+       * The %time class represents hours, minutes, and seconds with an
+       * optional %time zone.
+       *
+       * @nosubgrouping
+       */
+      template <typename C, typename B>
+      class time: public B, public time_zone
+      {
+      public:
+        /**
+         * @name Constructors
+         */
+        //@{
+
+        /**
+         * @brief Initialize an instance with the hours, minutes, and
+         * seconds components.
+         *
+         * When this constructor is used, the %time zone is left
+         * unspecified.
+         *
+         * @param hours The hours component.
+         * @param minutes The minutes component.
+         * @param seconds The seconds component.
+         */
+        time (unsigned short hours, unsigned short minutes, double seconds);
+
+        /**
+         * @brief Initialize an instance with the hours, minutes, and
+         * seconds components as well as %time zone.
+         *
+         * @param hours The hours component.
+         * @param minutes The minutes component.
+         * @param seconds The seconds component.
+         * @param zone_hours The %time zone hours component.
+         * @param zone_minutes The %time zone minutes component.
+         */
+        time (unsigned short hours, unsigned short minutes, double seconds,
+              short zone_hours, short zone_minutes);
+
+        /**
+         * @brief Copy constructor.
+         *
+         * @param x An instance to make a copy of.
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         *
+         * For polymorphic object models use the _clone function instead.
+         */
+        time (const time& x, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Copy the instance polymorphically.
+         *
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         * @return A pointer to the dynamically allocated copy.
+         *
+         * This function ensures that the dynamic type of the instance
+         * is used for copying and should be used for polymorphic object
+         * models instead of the copy constructor.
+         */
+        virtual time*
+        _clone (flags f = 0, container* c = 0) const;
+
+        /**
+         * @brief Create an instance from a data representation
+         * stream.
+         *
+         * @param s A stream to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        template <typename S>
+        time (istream<S>& s, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM element.
+         *
+         * @param e A DOM element to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        time (const xercesc::DOMElement& e, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM Attribute.
+         *
+         * @param a A DOM attribute to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        time (const xercesc::DOMAttr& a, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a %string fragment.
+         *
+         * @param s A %string fragment to extract the data from.
+         * @param e A pointer to DOM element containing the %string fragment.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        time (const std::basic_string<C>& s,
+              const xercesc::DOMElement* e,
+              flags f = 0,
+              container* c = 0);
+        //@}
+
+      public:
+        /**
+         * @brief Get the hours component.
+         *
+         * @return The hours component.
+         */
+        unsigned short
+        hours () const;
+
+        /**
+         * @brief Set the hours component.
+         *
+         * @param h The new hours component.
+         */
+        void
+        hours (unsigned short h);
+
+        /**
+         * @brief Get the minutes component.
+         *
+         * @return The minutes component.
+         */
+        unsigned short
+        minutes () const;
+
+        /**
+         * @brief Set the minutes component.
+         *
+         * @param m The new minutes component.
+         */
+        void
+        minutes (unsigned short m);
+
+        /**
+         * @brief Get the seconds component.
+         *
+         * @return The seconds component.
+         */
+        double
+        seconds () const;
+
+        /**
+         * @brief Set the seconds component.
+         *
+         * @param s The new seconds component.
+         */
+        void
+        seconds (double s);
+
+      protected:
+        //@cond
+
+        time ();
+
+        void
+        parse (const std::basic_string<C>&);
+
+        //@endcond
+
+      private:
+        unsigned short hours_;
+        unsigned short minutes_;
+        double seconds_;
+      };
+
+      /**
+       * @brief %time comparison operator.
+       *
+       * @return True if the hours, seconds, and minutes components as well
+       * as %time zones are equal, false otherwise.
+       */
+      template <typename C, typename B>
+      bool
+      operator== (const time<C, B>&, const time<C, B>&);
+
+      /**
+       * @brief %time comparison operator.
+       *
+       * @return False if the hours, seconds, and minutes components as well
+       * as %time zones are equal, true otherwise.
+       */
+      template <typename C, typename B>
+      bool
+      operator!= (const time<C, B>&, const time<C, B>&);
+
+
+      /**
+       * @brief Class corresponding to the XML Schema dateTime built-in type.
+       *
+       * The %date_time class represents year, month, day, hours, minutes,
+       * and seconds with an optional %time zone.
+       *
+       * @nosubgrouping
+       */
+      template <typename C, typename B>
+      class date_time: public B, public time_zone
+      {
+      public:
+        /**
+         * @name Constructors
+         */
+        //@{
+
+        /**
+         * @brief Initialize an instance with the year, month, day, hours,
+         * minutes, and seconds components.
+         *
+         * When this constructor is used, the %time zone is left
+         * unspecified.
+         *
+         * @param year The year component.
+         * @param month The month component.
+         * @param day The day component.
+         * @param hours The hours component.
+         * @param minutes The minutes component.
+         * @param seconds The seconds component.
+         */
+        date_time (int year, unsigned short month, unsigned short day,
+                   unsigned short hours, unsigned short minutes,
+                   double seconds);
+
+        /**
+         * @brief Initialize an instance with the year, month, day, hours,
+         * minutes, and seconds components as well as %time zone.
+         *
+         * @param year The year component.
+         * @param month The month component.
+         * @param day The day component.
+         * @param hours The hours component.
+         * @param minutes The minutes component.
+         * @param seconds The seconds component.
+         * @param zone_hours The %time zone hours component.
+         * @param zone_minutes The %time zone minutes component.
+         */
+        date_time (int year, unsigned short month, unsigned short day,
+                   unsigned short hours, unsigned short minutes,
+                   double seconds, short zone_hours, short zone_minutes);
+
+        /**
+         * @brief Copy constructor.
+         *
+         * @param x An instance to make a copy of.
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         *
+         * For polymorphic object models use the _clone function instead.
+         */
+        date_time (const date_time& x, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Copy the instance polymorphically.
+         *
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         * @return A pointer to the dynamically allocated copy.
+         *
+         * This function ensures that the dynamic type of the instance
+         * is used for copying and should be used for polymorphic object
+         * models instead of the copy constructor.
+         */
+        virtual date_time*
+        _clone (flags f = 0, container* c = 0) const;
+
+        /**
+         * @brief Create an instance from a data representation
+         * stream.
+         *
+         * @param s A stream to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        template <typename S>
+        date_time (istream<S>& s, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM element.
+         *
+         * @param e A DOM element to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        date_time (const xercesc::DOMElement& e,
+                   flags f = 0,
+                   container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM Attribute.
+         *
+         * @param a A DOM attribute to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        date_time (const xercesc::DOMAttr& a, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a %string fragment.
+         *
+         * @param s A %string fragment to extract the data from.
+         * @param e A pointer to DOM element containing the %string fragment.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        date_time (const std::basic_string<C>& s,
+                   const xercesc::DOMElement* e,
+                   flags f = 0,
+                   container* c = 0);
+        //@}
+
+      public:
+        /**
+         * @brief Get the year component.
+         *
+         * @return The year component.
+         */
+        int
+        year () const;
+
+        /**
+         * @brief Set the year component.
+         *
+         * @param y The new year component.
+         */
+        void
+        year (int y);
+
+        /**
+         * @brief Get the month component.
+         *
+         * @return The month component.
+         */
+        unsigned short
+        month () const;
+
+        /**
+         * @brief Set the month component.
+         *
+         * @param m The new month component.
+         */
+        void
+        month (unsigned short m);
+
+        /**
+         * @brief Get the day component.
+         *
+         * @return The day component.
+         */
+        unsigned short
+        day () const;
+
+        /**
+         * @brief Set the day component.
+         *
+         * @param d The new day component.
+         */
+        void
+        day (unsigned short d);
+
+        /**
+         * @brief Get the hours component.
+         *
+         * @return The hours component.
+         */
+        unsigned short
+        hours () const;
+
+        /**
+         * @brief Set the hours component.
+         *
+         * @param h The new hours component.
+         */
+        void
+        hours (unsigned short h);
+
+        /**
+         * @brief Get the minutes component.
+         *
+         * @return The minutes component.
+         */
+        unsigned short
+        minutes () const;
+
+        /**
+         * @brief Set the minutes component.
+         *
+         * @param m The new minutes component.
+         */
+        void
+        minutes (unsigned short m);
+
+        /**
+         * @brief Get the seconds component.
+         *
+         * @return The seconds component.
+         */
+        double
+        seconds () const;
+
+        /**
+         * @brief Set the seconds component.
+         *
+         * @param s The new seconds component.
+         */
+        void
+        seconds (double s);
+
+      protected:
+        //@cond
+
+        date_time ();
+
+        void
+        parse (const std::basic_string<C>&);
+
+        //@endcond
+
+      private:
+        int year_;
+        unsigned short month_;
+        unsigned short day_;
+        unsigned short hours_;
+        unsigned short minutes_;
+        double seconds_;
+      };
+
+      /**
+       * @brief %date_time comparison operator.
+       *
+       * @return True if the year, month, day, hours, seconds, and minutes
+       * components as well as %time zones are equal, false otherwise.
+       */
+      template <typename C, typename B>
+      bool
+      operator== (const date_time<C, B>&, const date_time<C, B>&);
+
+      /**
+       * @brief %date_time comparison operator.
+       *
+       * @return False if the year, month, day, hours, seconds, and minutes
+       * components as well as %time zones are equal, true otherwise.
+       */
+      template <typename C, typename B>
+      bool
+      operator!= (const date_time<C, B>&, const date_time<C, B>&);
+
+
+      /**
+       * @brief Class corresponding to the XML Schema %duration built-in type.
+       *
+       * The %duration class represents a potentially negative %duration in
+       * the form of years, months, days, hours, minutes, and seconds.
+       *
+       * @nosubgrouping
+       */
+      template <typename C, typename B>
+      class duration: public B
+      {
+      public:
+        /**
+         * @name Constructors
+         */
+        //@{
+        /**
+         * @brief Initialize a potentially negative instance with the years,
+         * months, days, hours, minutes, and seconds components.
+         *
+         * @param negative A boolean value indicating whether the %duration
+         * is negative (true) or positive (false).
+         * @param years The years component.
+         * @param months The months component.
+         * @param days The days component.
+         * @param hours The hours component.
+         * @param minutes The minutes component.
+         * @param seconds The seconds component.
+         */
+        duration (bool negative,
+                  unsigned int years, unsigned int months, unsigned int days,
+                  unsigned int hours, unsigned int minutes, double seconds);
+
+        /**
+         * @brief Copy constructor.
+         *
+         * @param x An instance to make a copy of.
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         *
+         * For polymorphic object models use the _clone function instead.
+         */
+        duration (const duration& x, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Copy the instance polymorphically.
+         *
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         * @return A pointer to the dynamically allocated copy.
+         *
+         * This function ensures that the dynamic type of the instance
+         * is used for copying and should be used for polymorphic object
+         * models instead of the copy constructor.
+         */
+        virtual duration*
+        _clone (flags f = 0, container* c = 0) const;
+
+        /**
+         * @brief Create an instance from a data representation
+         * stream.
+         *
+         * @param s A stream to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        template <typename S>
+        duration (istream<S>& s, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM element.
+         *
+         * @param e A DOM element to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        duration (const xercesc::DOMElement& e,
+                  flags f = 0,
+                  container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM Attribute.
+         *
+         * @param a A DOM attribute to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        duration (const xercesc::DOMAttr& a, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a %string fragment.
+         *
+         * @param s A %string fragment to extract the data from.
+         * @param e A pointer to DOM element containing the %string fragment.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        duration (const std::basic_string<C>& s,
+                  const xercesc::DOMElement* e,
+                  flags f = 0,
+                  container* c = 0);
+        //@}
+
+      public:
+        /**
+         * @brief Determine if %duration is negative.
+         *
+         * @return True if %duration is negative, false otherwise.
+         */
+        bool
+        negative () const;
+
+        /**
+         * @brief Change %duration sign.
+         *
+         * @param n A boolean value indicating whether %duration is
+         * negative (true) or positive (false).
+         */
+        void
+        negative (bool n);
+
+        /**
+         * @brief Get the years component.
+         *
+         * @return The years component.
+         */
+        unsigned int
+        years () const;
+
+        /**
+         * @brief Set the years component.
+         *
+         * @param y The new years component.
+         */
+        void
+        years (unsigned int y);
+
+        /**
+         * @brief Get the months component.
+         *
+         * @return The months component.
+         */
+        unsigned int
+        months () const;
+
+        /**
+         * @brief Set the months component.
+         *
+         * @param m The new months component.
+         */
+        void
+        months (unsigned int m);
+
+        /**
+         * @brief Get the days component.
+         *
+         * @return The days component.
+         */
+        unsigned int
+        days () const;
+
+        /**
+         * @brief Set the days component.
+         *
+         * @param d The new days component.
+         */
+        void
+        days (unsigned int d);
+
+        /**
+         * @brief Get the hours component.
+         *
+         * @return The hours component.
+         */
+        unsigned int
+        hours () const;
+
+        /**
+         * @brief Set the hours component.
+         *
+         * @param h The new hours component.
+         */
+        void
+        hours (unsigned int h);
+
+        /**
+         * @brief Get the minutes component.
+         *
+         * @return The minutes component.
+         */
+        unsigned int
+        minutes () const;
+
+        /**
+         * @brief Set the minutes component.
+         *
+         * @param m The new minutes component.
+         */
+        void
+        minutes (unsigned int m);
+
+        /**
+         * @brief Get the seconds component.
+         *
+         * @return The seconds component.
+         */
+        double
+        seconds () const;
+
+        /**
+         * @brief Set the seconds component.
+         *
+         * @param s The new seconds component.
+         */
+        void
+        seconds (double s);
+
+      protected:
+        //@cond
+
+        duration ();
+
+        void
+        parse (const std::basic_string<C>&);
+
+        //@endcond
+
+      private:
+        bool negative_;
+        unsigned int years_;
+        unsigned int months_;
+        unsigned int days_;
+        unsigned int hours_;
+        unsigned int minutes_;
+        double seconds_;
+      };
+
+      /**
+       * @brief %duration comparison operator.
+       *
+       * @return True if the sings as well as years, months, days, hours,
+       * seconds, and minutes components are equal, false otherwise.
+       */
+      template <typename C, typename B>
+      bool
+      operator== (const duration<C, B>&, const duration<C, B>&);
+
+      /**
+       * @brief %duration comparison operator.
+       *
+       * @return False if the sings as well as years, months, days, hours,
+       * seconds, and minutes components are equal, true otherwise.
+       */
+      template <typename C, typename B>
+      bool
+      operator!= (const duration<C, B>&, const duration<C, B>&);
+    }
+  }
+}
+
+#include <xsd/cxx/tree/date-time.ixx>
+#include <xsd/cxx/tree/date-time.txx>
+
+#endif  // XSD_CXX_TREE_DATE_TIME_HXX
diff --git src/base/include/xsd/cxx/tree/date-time.ixx src/base/include/xsd/cxx/tree/date-time.ixx
new file mode 100644
index 0000000..5bc7200
--- /dev/null
+++ src/base/include/xsd/cxx/tree/date-time.ixx
@@ -0,0 +1,893 @@
+// file      : xsd/cxx/tree/date-time.ixx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      // time_zone
+      //
+      inline time_zone::
+      time_zone ()
+          : present_ (false)
+      {
+      }
+
+      inline time_zone::
+      time_zone (short h, short m)
+          : present_ (true), hours_ (h), minutes_ (m)
+      {
+      }
+
+      inline bool time_zone::
+      zone_present () const
+      {
+        return present_;
+      }
+
+      inline void time_zone::
+      zone_reset ()
+      {
+        present_ = false;
+      }
+
+      inline short time_zone::
+      zone_hours () const
+      {
+        return hours_;
+      }
+
+      inline void time_zone::
+      zone_hours (short h)
+      {
+        hours_ = h;
+        present_ = true;
+      }
+
+      inline short time_zone::
+      zone_minutes () const
+      {
+        return minutes_;
+      }
+
+      inline void time_zone::
+      zone_minutes (short m)
+      {
+        minutes_ = m;
+        present_ = true;
+      }
+
+      inline bool
+      operator== (const time_zone& x, const time_zone& y)
+      {
+        return x.zone_present ()
+          ? y.zone_present () &&
+          x.zone_hours () == y.zone_hours () &&
+          x.zone_minutes () == y.zone_minutes ()
+          : !y.zone_present ();
+      }
+
+      inline bool
+      operator!= (const time_zone& x, const time_zone& y)
+      {
+        return !(x == y);
+      }
+
+      // gday
+      //
+      template <typename C, typename B>
+      inline gday<C, B>::
+      gday ()
+      {
+      }
+
+      template <typename C, typename B>
+      inline gday<C, B>::
+      gday (unsigned short day)
+          : day_ (day)
+      {
+      }
+
+      template <typename C, typename B>
+      inline gday<C, B>::
+      gday (unsigned short day, short zone_h, short zone_m)
+          : time_zone (zone_h, zone_m), day_ (day)
+      {
+      }
+
+      template <typename C, typename B>
+      inline gday<C, B>::
+      gday (const gday& x, flags f, container* c)
+          : B (x, f, c), time_zone (x), day_ (x.day_)
+      {
+      }
+
+      template <typename C, typename B>
+      inline unsigned short gday<C, B>::
+      day () const
+      {
+        return day_;
+      }
+
+      template <typename C, typename B>
+      inline void gday<C, B>::
+      day (unsigned short day)
+      {
+        day_ = day;
+      }
+
+      template <typename C, typename B>
+      inline bool
+      operator== (const gday<C, B>& x, const gday<C, B>& y)
+      {
+        const time_zone& xz = x;
+        const time_zone& yz = y;
+
+        return x.day () == y.day () && xz == yz;
+      }
+
+      template <typename C, typename B>
+      inline bool
+      operator!= (const gday<C, B>& x, const gday<C, B>& y)
+      {
+        return !(x == y);
+      }
+
+      // gmonth
+      //
+      template <typename C, typename B>
+      inline gmonth<C, B>::
+      gmonth ()
+      {
+      }
+
+      template <typename C, typename B>
+      inline gmonth<C, B>::
+      gmonth (unsigned short month)
+          : month_ (month)
+      {
+      }
+
+      template <typename C, typename B>
+      inline gmonth<C, B>::
+      gmonth (unsigned short month, short zone_h, short zone_m)
+          : time_zone (zone_h, zone_m), month_ (month)
+      {
+      }
+
+      template <typename C, typename B>
+      inline gmonth<C, B>::
+      gmonth (const gmonth& x, flags f, container* c)
+          : B (x, f, c), time_zone (x), month_ (x.month_)
+      {
+      }
+
+      template <typename C, typename B>
+      inline unsigned short gmonth<C, B>::
+      month () const
+      {
+        return month_;
+      }
+
+      template <typename C, typename B>
+      inline void gmonth<C, B>::
+      month (unsigned short month)
+      {
+        month_ = month;
+      }
+
+      template <typename C, typename B>
+      inline bool
+      operator== (const gmonth<C, B>& x, const gmonth<C, B>& y)
+      {
+        const time_zone& xz = x;
+        const time_zone& yz = y;
+
+        return x.month () == y.month () && xz == yz;
+      }
+
+      template <typename C, typename B>
+      inline bool
+      operator!= (const gmonth<C, B>& x, const gmonth<C, B>& y)
+      {
+        return !(x == y);
+      }
+
+      // gyear
+      //
+      template <typename C, typename B>
+      inline gyear<C, B>::
+      gyear ()
+      {
+      }
+
+      template <typename C, typename B>
+      inline gyear<C, B>::
+      gyear (int year)
+          : year_ (year)
+      {
+      }
+
+      template <typename C, typename B>
+      inline gyear<C, B>::
+      gyear (int year, short zone_h, short zone_m)
+          : time_zone (zone_h, zone_m), year_ (year)
+      {
+      }
+
+      template <typename C, typename B>
+      inline gyear<C, B>::
+      gyear (const gyear& x, flags f, container* c)
+          : B (x, f, c), time_zone (x), year_ (x.year_)
+      {
+      }
+
+      template <typename C, typename B>
+      inline int gyear<C, B>::
+      year () const
+      {
+        return year_;
+      }
+
+      template <typename C, typename B>
+      inline void gyear<C, B>::
+      year (int year)
+      {
+        year_ = year;
+      }
+
+      template <typename C, typename B>
+      inline bool
+      operator== (const gyear<C, B>& x, const gyear<C, B>& y)
+      {
+        const time_zone& xz = x;
+        const time_zone& yz = y;
+
+        return x.year () == y.year () && xz == yz;
+      }
+
+      template <typename C, typename B>
+      inline bool
+      operator!= (const gyear<C, B>& x, const gyear<C, B>& y)
+      {
+        return !(x == y);
+      }
+
+      // gmonth_day
+      //
+      template <typename C, typename B>
+      inline gmonth_day<C, B>::
+      gmonth_day ()
+      {
+      }
+
+      template <typename C, typename B>
+      inline gmonth_day<C, B>::
+      gmonth_day (unsigned short month, unsigned short day)
+          : month_ (month), day_ (day)
+      {
+      }
+
+      template <typename C, typename B>
+      inline gmonth_day<C, B>::
+      gmonth_day (unsigned short month, unsigned short day,
+                  short zone_h, short zone_m)
+          : time_zone (zone_h, zone_m), month_ (month), day_ (day)
+      {
+      }
+
+      template <typename C, typename B>
+      inline gmonth_day<C, B>::
+      gmonth_day (const gmonth_day& x, flags f, container* c)
+          : B (x, f, c), time_zone (x), month_ (x.month_), day_ (x.day_)
+      {
+      }
+
+      template <typename C, typename B>
+      inline unsigned short gmonth_day<C, B>::
+      month () const
+      {
+        return month_;
+      }
+
+      template <typename C, typename B>
+      inline void gmonth_day<C, B>::
+      month (unsigned short month)
+      {
+        month_ = month;
+      }
+
+      template <typename C, typename B>
+      inline unsigned short gmonth_day<C, B>::
+      day () const
+      {
+        return day_;
+      }
+
+      template <typename C, typename B>
+      inline void gmonth_day<C, B>::
+      day (unsigned short day)
+      {
+        day_ = day;
+      }
+
+      template <typename C, typename B>
+      inline bool
+      operator== (const gmonth_day<C, B>& x, const gmonth_day<C, B>& y)
+      {
+        const time_zone& xz = x;
+        const time_zone& yz = y;
+
+        return x.month () == y.month () &&
+          x.day () == y.day () &&
+          xz == yz;
+      }
+
+      template <typename C, typename B>
+      inline bool
+      operator!= (const gmonth_day<C, B>& x, const gmonth_day<C, B>& y)
+      {
+        return !(x == y);
+      }
+
+      // gyear_month
+      //
+      template <typename C, typename B>
+      inline gyear_month<C, B>::
+      gyear_month ()
+      {
+      }
+
+      template <typename C, typename B>
+      inline gyear_month<C, B>::
+      gyear_month (int year, unsigned short month)
+          : year_ (year), month_ (month)
+      {
+      }
+
+      template <typename C, typename B>
+      inline gyear_month<C, B>::
+      gyear_month (int year, unsigned short month,
+                   short zone_h, short zone_m)
+          : time_zone (zone_h, zone_m), year_ (year), month_ (month)
+      {
+      }
+
+      template <typename C, typename B>
+      inline gyear_month<C, B>::
+      gyear_month (const gyear_month& x, flags f, container* c)
+          : B (x, f, c), time_zone (x), year_ (x.year_), month_ (x.month_)
+      {
+      }
+
+      template <typename C, typename B>
+      inline int gyear_month<C, B>::
+      year () const
+      {
+        return year_;
+      }
+
+      template <typename C, typename B>
+      inline void gyear_month<C, B>::
+      year (int year)
+      {
+        year_ = year;
+      }
+
+      template <typename C, typename B>
+      inline unsigned short gyear_month<C, B>::
+      month () const
+      {
+        return month_;
+      }
+
+      template <typename C, typename B>
+      inline void gyear_month<C, B>::
+      month (unsigned short month)
+      {
+        month_ = month;
+      }
+
+      template <typename C, typename B>
+      inline bool
+      operator== (const gyear_month<C, B>& x, const gyear_month<C, B>& y)
+      {
+        const time_zone& xz = x;
+        const time_zone& yz = y;
+
+        return x.year () == y.year () &&
+          x.month () == y.month () &&
+          xz == yz;
+      }
+
+      template <typename C, typename B>
+      inline bool
+      operator!= (const gyear_month<C, B>& x, const gyear_month<C, B>& y)
+      {
+        return !(x == y);
+      }
+
+      // date
+      //
+      template <typename C, typename B>
+      inline date<C, B>::
+      date ()
+      {
+      }
+
+      template <typename C, typename B>
+      inline date<C, B>::
+      date (int year, unsigned short month, unsigned short day)
+          : year_ (year), month_ (month), day_ (day)
+      {
+      }
+
+      template <typename C, typename B>
+      inline date<C, B>::
+      date (int year, unsigned short month, unsigned short day,
+            short zone_h, short zone_m)
+          : time_zone (zone_h, zone_m),
+            year_ (year), month_ (month), day_ (day)
+      {
+      }
+
+      template <typename C, typename B>
+      inline date<C, B>::
+      date (const date& x, flags f, container* c)
+          : B (x, f, c), time_zone (x),
+            year_ (x.year_), month_ (x.month_), day_ (x.day_)
+      {
+      }
+
+      template <typename C, typename B>
+      inline int date<C, B>::
+      year () const
+      {
+        return year_;
+      }
+
+      template <typename C, typename B>
+      inline void date<C, B>::
+      year (int year)
+      {
+        year_ = year;
+      }
+
+      template <typename C, typename B>
+      inline unsigned short date<C, B>::
+      month () const
+      {
+        return month_;
+      }
+
+      template <typename C, typename B>
+      inline void date<C, B>::
+      month (unsigned short month)
+      {
+        month_ = month;
+      }
+
+      template <typename C, typename B>
+      inline unsigned short date<C, B>::
+      day () const
+      {
+        return day_;
+      }
+
+      template <typename C, typename B>
+      inline void date<C, B>::
+      day (unsigned short day)
+      {
+        day_ = day;
+      }
+
+      template <typename C, typename B>
+      inline bool
+      operator== (const date<C, B>& x, const date<C, B>& y)
+      {
+        const time_zone& xz = x;
+        const time_zone& yz = y;
+
+        return x.year () == y.year () &&
+          x.month () == y.month () &&
+          x.day () == y.day () &&
+          xz == yz;
+      }
+
+      template <typename C, typename B>
+      inline bool
+      operator!= (const date<C, B>& x, const date<C, B>& y)
+      {
+        return !(x == y);
+      }
+
+      // time
+      //
+      template <typename C, typename B>
+      inline time<C, B>::
+      time ()
+      {
+      }
+
+      template <typename C, typename B>
+      inline time<C, B>::
+      time (unsigned short hours, unsigned short minutes, double seconds)
+          : hours_ (hours), minutes_ (minutes), seconds_ (seconds)
+      {
+      }
+
+      template <typename C, typename B>
+      inline time<C, B>::
+      time (unsigned short hours, unsigned short minutes, double seconds,
+            short zone_h, short zone_m)
+          : time_zone (zone_h, zone_m),
+            hours_ (hours), minutes_ (minutes), seconds_ (seconds)
+      {
+      }
+
+      template <typename C, typename B>
+      inline time<C, B>::
+      time (const time& x, flags f, container* c)
+          : B (x, f, c), time_zone (x),
+            hours_ (x.hours_), minutes_ (x.minutes_), seconds_ (x.seconds_)
+      {
+      }
+
+      template <typename C, typename B>
+      inline unsigned short time<C, B>::
+      hours () const
+      {
+        return hours_;
+      }
+
+      template <typename C, typename B>
+      inline void time<C, B>::
+      hours (unsigned short hours)
+      {
+        hours_ = hours;
+      }
+
+      template <typename C, typename B>
+      inline unsigned short time<C, B>::
+      minutes () const
+      {
+        return minutes_;
+      }
+
+      template <typename C, typename B>
+      inline void time<C, B>::
+      minutes (unsigned short minutes)
+      {
+        minutes_ = minutes;
+      }
+
+      template <typename C, typename B>
+      inline double time<C, B>::
+      seconds () const
+      {
+        return seconds_;
+      }
+
+      template <typename C, typename B>
+      inline void time<C, B>::
+      seconds (double seconds)
+      {
+        seconds_ = seconds;
+      }
+
+      template <typename C, typename B>
+      inline bool
+      operator== (const time<C, B>& x, const time<C, B>& y)
+      {
+        const time_zone& xz = x;
+        const time_zone& yz = y;
+
+        return x.hours () == y.hours () &&
+          x.minutes () == y.minutes () &&
+          x.seconds () == y.seconds () &&
+          xz == yz;
+      }
+
+      template <typename C, typename B>
+      inline bool
+      operator!= (const time<C, B>& x, const time<C, B>& y)
+      {
+        return !(x == y);
+      }
+
+      // date_time
+      //
+      template <typename C, typename B>
+      inline date_time<C, B>::
+      date_time ()
+      {
+      }
+
+      template <typename C, typename B>
+      inline date_time<C, B>::
+      date_time (int year, unsigned short month, unsigned short day,
+                 unsigned short hours, unsigned short minutes, double seconds)
+          : year_ (year), month_ (month), day_ (day),
+            hours_ (hours), minutes_ (minutes), seconds_ (seconds)
+      {
+      }
+
+      template <typename C, typename B>
+      inline date_time<C, B>::
+      date_time (int year, unsigned short month, unsigned short day,
+                 unsigned short hours, unsigned short minutes, double seconds,
+                 short zone_h, short zone_m)
+          : time_zone (zone_h, zone_m),
+            year_ (year), month_ (month), day_ (day),
+            hours_ (hours), minutes_ (minutes), seconds_ (seconds)
+      {
+      }
+
+      template <typename C, typename B>
+      inline date_time<C, B>::
+      date_time (const date_time& x, flags f, container* c)
+          : B (x, f, c), time_zone (x),
+            year_ (x.year_), month_ (x.month_), day_ (x.day_),
+            hours_ (x.hours_), minutes_ (x.minutes_), seconds_ (x.seconds_)
+      {
+      }
+
+      template <typename C, typename B>
+      inline int date_time<C, B>::
+      year () const
+      {
+        return year_;
+      }
+
+      template <typename C, typename B>
+      inline void date_time<C, B>::
+      year (int year)
+      {
+        year_ = year;
+      }
+
+      template <typename C, typename B>
+      inline unsigned short date_time<C, B>::
+      month () const
+      {
+        return month_;
+      }
+
+      template <typename C, typename B>
+      inline void date_time<C, B>::
+      month (unsigned short month)
+      {
+        month_ = month;
+      }
+
+      template <typename C, typename B>
+      inline unsigned short date_time<C, B>::
+      day () const
+      {
+        return day_;
+      }
+
+      template <typename C, typename B>
+      inline void date_time<C, B>::
+      day (unsigned short day)
+      {
+        day_ = day;
+      }
+
+      template <typename C, typename B>
+      inline unsigned short date_time<C, B>::
+      hours () const
+      {
+        return hours_;
+      }
+
+      template <typename C, typename B>
+      inline void date_time<C, B>::
+      hours (unsigned short hours)
+      {
+        hours_ = hours;
+      }
+
+      template <typename C, typename B>
+      inline unsigned short date_time<C, B>::
+      minutes () const
+      {
+        return minutes_;
+      }
+
+      template <typename C, typename B>
+      inline void date_time<C, B>::
+      minutes (unsigned short minutes)
+      {
+        minutes_ = minutes;
+      }
+
+      template <typename C, typename B>
+      inline double date_time<C, B>::
+      seconds () const
+      {
+        return seconds_;
+      }
+
+      template <typename C, typename B>
+      inline void date_time<C, B>::
+      seconds (double seconds)
+      {
+        seconds_ = seconds;
+      }
+
+      template <typename C, typename B>
+      inline bool
+      operator== (const date_time<C, B>& x, const date_time<C, B>& y)
+      {
+        const time_zone& xz = x;
+        const time_zone& yz = y;
+
+        return x.year () == y.year () &&
+          x.month () == y.month () &&
+          x.day () == y.day () &&
+          x.hours () == y.hours () &&
+          x.minutes () == y.minutes () &&
+          x.seconds () == y.seconds () &&
+          xz == yz;
+      }
+
+      template <typename C, typename B>
+      inline bool
+      operator!= (const date_time<C, B>& x, const date_time<C, B>& y)
+      {
+        return !(x == y);
+      }
+
+      // duration
+      //
+      template <typename C, typename B>
+      inline duration<C, B>::
+      duration ()
+      {
+      }
+
+      template <typename C, typename B>
+      inline duration<C, B>::
+      duration (bool negative,
+                unsigned int years, unsigned int months, unsigned int days,
+                unsigned int hours, unsigned int minutes, double seconds)
+          : negative_ (negative),
+            years_ (years), months_ (months), days_ (days),
+            hours_ (hours), minutes_ (minutes), seconds_ (seconds)
+      {
+      }
+
+      template <typename C, typename B>
+      inline duration<C, B>::
+      duration (const duration& x, flags f, container* c)
+          : B (x, f, c), negative_ (x.negative_),
+            years_ (x.years_), months_ (x.months_), days_ (x.days_),
+            hours_ (x.hours_), minutes_ (x.minutes_), seconds_ (x.seconds_)
+      {
+      }
+
+      template <typename C, typename B>
+      inline bool duration<C, B>::
+      negative () const
+      {
+        return negative_;
+      }
+
+      template <typename C, typename B>
+      inline void duration<C, B>::
+      negative (bool negative)
+      {
+        negative_ = negative;
+      }
+
+      template <typename C, typename B>
+      inline unsigned int duration<C, B>::
+      years () const
+      {
+        return years_;
+      }
+
+      template <typename C, typename B>
+      inline void duration<C, B>::
+      years (unsigned int years)
+      {
+        years_ = years;
+      }
+
+      template <typename C, typename B>
+      inline unsigned int duration<C, B>::
+      months () const
+      {
+        return months_;
+      }
+
+      template <typename C, typename B>
+      inline void duration<C, B>::
+      months (unsigned int months)
+      {
+        months_ = months;
+      }
+
+      template <typename C, typename B>
+      inline unsigned int duration<C, B>::
+      days () const
+      {
+        return days_;
+      }
+
+      template <typename C, typename B>
+      inline void duration<C, B>::
+      days (unsigned int days)
+      {
+        days_ = days;
+      }
+
+      template <typename C, typename B>
+      inline unsigned int duration<C, B>::
+      hours () const
+      {
+        return hours_;
+      }
+
+      template <typename C, typename B>
+      inline void duration<C, B>::
+      hours (unsigned int hours)
+      {
+        hours_ = hours;
+      }
+
+      template <typename C, typename B>
+      inline unsigned int duration<C, B>::
+      minutes () const
+      {
+        return minutes_;
+      }
+
+      template <typename C, typename B>
+      inline void duration<C, B>::
+      minutes (unsigned int minutes)
+      {
+        minutes_ = minutes;
+      }
+
+      template <typename C, typename B>
+      inline double duration<C, B>::
+      seconds () const
+      {
+        return seconds_;
+      }
+
+      template <typename C, typename B>
+      inline void duration<C, B>::
+      seconds (double seconds)
+      {
+        seconds_ = seconds;
+      }
+
+      template <typename C, typename B>
+      inline bool
+      operator== (const duration<C, B>& x, const duration<C, B>& y)
+      {
+        return x.negative () == y.negative () &&
+          x.years () == y.years () &&
+          x.months () == y.months () &&
+          x.days () == y.days () &&
+          x.hours () == y.hours () &&
+          x.minutes () == y.minutes () &&
+          x.seconds () == y.seconds ();
+      }
+
+      template <typename C, typename B>
+      inline bool
+      operator!= (const duration<C, B>& x, const duration<C, B>& y)
+      {
+        return !(x == y);
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/tree/date-time.txx src/base/include/xsd/cxx/tree/date-time.txx
new file mode 100644
index 0000000..34c6c84
--- /dev/null
+++ src/base/include/xsd/cxx/tree/date-time.txx
@@ -0,0 +1,94 @@
+// file      : xsd/cxx/tree/date-time.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      // gday
+      //
+      template <typename C, typename B>
+      gday<C, B>* gday<C, B>::
+      _clone (flags f, container* c) const
+      {
+        return new gday (*this, f, c);
+      }
+
+      // gmonth
+      //
+      template <typename C, typename B>
+      gmonth<C, B>* gmonth<C, B>::
+      _clone (flags f, container* c) const
+      {
+        return new gmonth (*this, f, c);
+      }
+
+      // gyear
+      //
+      template <typename C, typename B>
+      gyear<C, B>* gyear<C, B>::
+      _clone (flags f, container* c) const
+      {
+        return new gyear (*this, f, c);
+      }
+
+      // gmonth_day
+      //
+      template <typename C, typename B>
+      gmonth_day<C, B>* gmonth_day<C, B>::
+      _clone (flags f, container* c) const
+      {
+        return new gmonth_day (*this, f, c);
+      }
+
+      // gyear_month
+      //
+      template <typename C, typename B>
+      gyear_month<C, B>* gyear_month<C, B>::
+      _clone (flags f, container* c) const
+      {
+        return new gyear_month (*this, f, c);
+      }
+
+      // date
+      //
+      template <typename C, typename B>
+      date<C, B>* date<C, B>::
+      _clone (flags f, container* c) const
+      {
+        return new date (*this, f, c);
+      }
+
+      // time
+      //
+      template <typename C, typename B>
+      time<C, B>* time<C, B>::
+      _clone (flags f, container* c) const
+      {
+        return new time (*this, f, c);
+      }
+
+      // date_time
+      //
+      template <typename C, typename B>
+      date_time<C, B>* date_time<C, B>::
+      _clone (flags f, container* c) const
+      {
+        return new date_time (*this, f, c);
+      }
+
+      // duration
+      //
+      template <typename C, typename B>
+      duration<C, B>* duration<C, B>::
+      _clone (flags f, container* c) const
+      {
+        return new duration (*this, f, c);
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/tree/element-map.hxx src/base/include/xsd/cxx/tree/element-map.hxx
new file mode 100644
index 0000000..2f12b0b
--- /dev/null
+++ src/base/include/xsd/cxx/tree/element-map.hxx
@@ -0,0 +1,146 @@
+// file      : xsd/cxx/tree/element-map.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_ELEMENT_MAP_HXX
+#define XSD_CXX_TREE_ELEMENT_MAP_HXX
+
+#include <map>
+#include <memory>   // std::auto_ptr
+#include <cstddef>  // std::size_t
+#include <string>
+
+#include <xsd/cxx/xml/qualified-name.hxx>
+#include <xsd/cxx/tree/elements.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      /**
+       * @brief Root element map.
+       *
+       * This class allows uniform parsing/serialization of multiple
+       * root elements via the element_type base class.
+       *
+       * @nosubgrouping
+       */
+      template <typename C, typename T>
+      class element_map
+      {
+      public:
+        /**
+         * @brief Common base class for all element types.
+         */
+        typedef tree::element_type<C, T> element_type;
+
+        /**
+         * @brief Parse a DOM element.
+         *
+         * @param e A DOM element to parse.
+         * @param f Flags to create the new element object with.
+         * @return An automatic pointer to the new element object.
+         */
+        static std::auto_ptr<element_type>
+        parse (const xercesc::DOMElement& e, flags f = 0);
+
+        /**
+         * @brief Serialize an element object to a DOM element.
+         *
+         * @param e A DOM element to serialize to.
+         * @param x An element object to serialize.
+         */
+        static void
+        serialize (xercesc::DOMElement& e, const element_type& x);
+
+      public:
+        //@cond
+
+        typedef xml::qualified_name<C> qualified_name;
+
+        typedef std::auto_ptr<element_type>
+        (*parser) (const xercesc::DOMElement&, flags f);
+
+        typedef void
+        (*serializer) (xercesc::DOMElement&, const element_type&);
+
+        static void
+        register_parser (const qualified_name&, parser);
+
+        static void
+        register_serializer (const qualified_name&, serializer);
+
+      public:
+        struct map_entry
+        {
+          map_entry () : parser_ (0), serializer_ (0) {}
+
+          parser parser_;
+          serializer serializer_;
+        };
+
+        typedef
+        std::map<qualified_name, map_entry>
+        map;
+
+        static map* map_;
+        static std::size_t count_;
+
+      private:
+        element_map ();
+
+        //@endcond
+      };
+
+      //@cond
+
+      template <typename C, typename T>
+      typename element_map<C, T>::map* element_map<C, T>::map_ = 0;
+
+      template <typename C, typename T>
+      std::size_t element_map<C, T>::count_ = 0;
+
+      template <typename C, typename T>
+      struct element_map_init
+      {
+        element_map_init ();
+        ~element_map_init ();
+      };
+
+      //
+      //
+      template<typename T, typename C, typename B>
+      std::auto_ptr<element_type<C, B> >
+      parser_impl (const xercesc::DOMElement&, flags);
+
+      template<typename T, typename C, typename B>
+      struct parser_init
+      {
+        parser_init (const std::basic_string<C>& name,
+                     const std::basic_string<C>& ns);
+      };
+
+      //
+      //
+      template<typename T, typename C, typename B>
+      void
+      serializer_impl (xercesc::DOMElement&, const element_type<C, B>&);
+
+      template<typename T, typename C, typename B>
+      struct serializer_init
+      {
+        serializer_init (const std::basic_string<C>& name,
+                         const std::basic_string<C>& ns);
+      };
+
+      //@endcond
+    }
+  }
+}
+
+#include <xsd/cxx/tree/element-map.txx>
+
+#endif // XSD_CXX_TREE_ELEMENT_MAP_HXX
diff --git src/base/include/xsd/cxx/tree/element-map.txx src/base/include/xsd/cxx/tree/element-map.txx
new file mode 100644
index 0000000..0ff5d2a
--- /dev/null
+++ src/base/include/xsd/cxx/tree/element-map.txx
@@ -0,0 +1,71 @@
+// file      : xsd/cxx/tree/element-map.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      // element_map
+      //
+      template <typename C, typename T>
+      void element_map<C, T>::
+      register_parser (const qualified_name& n, parser p)
+      {
+        (*map_)[n].parser_ = p;
+      }
+
+      template <typename C, typename T>
+      void element_map<C, T>::
+      register_serializer (const qualified_name& n, serializer s)
+      {
+        (*map_)[n].serializer_ = s;
+      }
+
+      // element_map_init
+      //
+      template <typename C, typename T>
+      element_map_init<C, T>::
+      element_map_init ()
+      {
+        if (element_map<C, T>::count_ == 0)
+          element_map<C, T>::map_ = new typename element_map<C, T>::map;
+
+        ++element_map<C, T>::count_;
+      }
+
+      template <typename C, typename T>
+      element_map_init<C, T>::
+      ~element_map_init ()
+      {
+        if (--element_map<C, T>::count_ == 0)
+          delete element_map<C, T>::map_;
+      }
+
+      // parser_init
+      //
+      template<typename T, typename C, typename B>
+      parser_init<T, C, B>::
+      parser_init (const std::basic_string<C>& name,
+                   const std::basic_string<C>& ns)
+      {
+        element_map<C, B>::register_parser (
+          xml::qualified_name<C> (name, ns), &parser_impl<T, C, B>);
+      }
+
+      // serializer_init
+      //
+      template<typename T, typename C, typename B>
+      serializer_init<T, C, B>::
+      serializer_init (const std::basic_string<C>& name,
+                   const std::basic_string<C>& ns)
+      {
+        element_map<C, B>::register_serializer (
+          xml::qualified_name<C> (name, ns), &serializer_impl<T, C, B>);
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/tree/elements.hxx src/base/include/xsd/cxx/tree/elements.hxx
new file mode 100644
index 0000000..403fdb3
--- /dev/null
+++ src/base/include/xsd/cxx/tree/elements.hxx
@@ -0,0 +1,1490 @@
+// file      : xsd/cxx/tree/elements.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+/**
+ * @file
+ *
+ * @brief Contains C++ class definitions for XML Schema anyType and
+ * anySimpleType types as well as supporting code.
+ *
+ * This is an internal header and is included by the generated code. You
+ * normally should not include it directly.
+ *
+ */
+
+#ifndef XSD_CXX_TREE_ELEMENTS_HXX
+#define XSD_CXX_TREE_ELEMENTS_HXX
+
+#include <map>
+#include <string>
+#include <memory>  // std::auto_ptr
+#include <istream>
+#include <sstream>
+#include <cassert>
+
+#include <xercesc/dom/DOMNode.hpp>
+#include <xercesc/dom/DOMAttr.hpp>
+#include <xercesc/dom/DOMElement.hpp>
+#include <xercesc/dom/DOMDocument.hpp>
+#include <xercesc/dom/DOMNamedNodeMap.hpp>
+
+#include <xsd/cxx/xml/elements.hxx> // xml::properties
+#include <xsd/cxx/xml/dom/auto-ptr.hxx> // dom::auto_ptr
+
+#include <xsd/cxx/tree/facet.hxx>
+#include <xsd/cxx/tree/exceptions.hxx>
+#include <xsd/cxx/tree/istream-fwd.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    /**
+     * @brief C++/Tree mapping runtime namespace.
+     *
+     * This is an internal namespace and normally should not be referenced
+     * directly. Instead you should use the aliases for types in this
+     * namespaces that are created in the generated code.
+     *
+     */
+    namespace tree
+    {
+      /**
+       * @brief Parsing and %serialization %flags.
+       *
+       * Flags are used to modify the default behavior of %parsing and
+       * %serialization functions as well as %parsing constructors.
+       *
+       * @nosubgrouping
+       */
+      class flags
+      {
+      public:
+        /**
+         * @name Flag constants
+         */
+        //@{
+
+        /**
+         * @brief Keep DOM association in the resulting tree.
+         */
+        static const unsigned long keep_dom = 0x00000100UL;
+
+        /**
+         * @brief Assume ownership of the DOM document.
+         *
+         * This flag only makes sense together with the @c keep_dom
+         * flag in the call to the %parsing function with the
+         * @c dom::auto_ptr<DOMDocument> argument.
+         *
+         */
+        static const unsigned long own_dom = 0x00000200UL;
+
+        /**
+         * @brief Turn off XML Schema validation in the underlying XML
+         * parser.
+         */
+        static const unsigned long dont_validate = 0x00000400UL;
+
+        /**
+         * @brief Do not initialize the Xerces-C++ runtime.
+         */
+        static const unsigned long dont_initialize = 0x00000001UL;
+
+        /**
+         * @brief Do not write XML declaration during %serialization.
+         */
+        static const unsigned long no_xml_declaration = 0x00010000UL;
+
+        /**
+         * @brief Do not add extra spaces or new lines that make the
+         * resulting XML easier to read.
+         */
+        static const unsigned long dont_pretty_print = 0x00020000UL;
+
+        //@cond
+
+        // The following flags are for internal use.
+        //
+        static const unsigned long base = 0x01000000UL;
+
+        //@endcond
+
+        // Notes on flag blocks:
+        //
+        // 0x000000FF - common (applicable to both parsing and serialization)
+        // 0x0000FF00 - parsing (values aligned with XML parsing)
+        // 0x00FF0000 - serialization (values aligned with XML serialization)
+        // 0xFF000000 - internal
+
+        //@}
+
+      public:
+        /**
+         * @brief Initialize an instance with an integer value.
+         *
+         * @param x A %flags value as an integer.
+         */
+        flags (unsigned long x = 0)
+            : x_ (x)
+        {
+        }
+
+        /**
+         * @brief Convert an instance to an integer value.
+         *
+         * @return An integer %flags value.
+         */
+        operator unsigned long () const
+        {
+          return x_;
+        }
+
+        /**
+         * @brief Combine two %flags.
+         *
+         * @return A %flags object that is a combination of the arguments.
+         */
+        friend flags
+        operator| (const flags& a, const flags& b)
+        {
+          return flags (a.x_ | b.x_);
+        }
+
+        /**
+         * @brief Combine two %flags.
+         *
+         * @return A %flags object that is a combination of the arguments.
+         */
+        friend flags
+        operator| (const flags& a, unsigned long b)
+        {
+          return flags (a.x_ | b);
+        }
+
+        /**
+         * @brief Combine two %flags.
+         *
+         * @return A %flags object that is a combination of the arguments.
+         */
+        friend flags
+        operator| (unsigned long a, const flags& b)
+        {
+          return flags (a | b.x_);
+        }
+
+      private:
+        unsigned long x_;
+      };
+
+
+      // Parsing properties. Refer to xsd/cxx/xml/elements.hxx for XML-
+      // related properties.
+      //
+      template <typename C>
+      class properties: public xml::properties<C>
+      {
+      };
+
+      //@cond
+
+      // DOM user data keys.
+      //
+      template <int dummy>
+      struct user_data_keys_template
+      {
+        // Back pointers to tree nodes.
+        //
+        static const XMLCh node[21];
+      };
+
+      typedef user_data_keys_template<0> user_data_keys;
+
+      // HP aCC3 complains about unresolved symbols without an explicit
+      // instantiation.
+      //
+#if defined(__HP_aCC) && __HP_aCC <= 39999
+      template struct user_data_keys_template<0>;
+#endif
+      //
+      //
+      struct identity
+      {
+        virtual
+        ~identity ()
+        {
+        }
+
+        identity ()
+        {
+        }
+
+        virtual bool
+        before (const identity&) const = 0;
+
+        virtual void
+        throw_duplicate_id () const = 0;
+
+      private:
+        identity (const identity&);
+
+        identity&
+        operator= (const identity&);
+      };
+
+      //@endcond
+
+
+      // anyType. VC++ has a name injection bug that makes it impossible
+      // to have a member with the same name as a base type. To address
+      // that we will have to choose some unique name for the definition
+      // and typedef it to 'type'.
+      //
+      class _type;
+
+      /**
+       * @brief Class corresponding to the XML Schema anyType built-in type.
+       *
+       */
+      typedef _type type;
+
+      /**
+       * @brief Container type.
+       *
+       */
+      typedef _type container;
+
+      /**
+       * @brief Class corresponding to the XML Schema anyType built-in type.
+       *
+       * This class is a base for every generated and built-in type in the
+       * C++/Tree mapping.
+       *
+       * @nosubgrouping
+       */
+      class _type
+      {
+      public:
+        virtual
+        ~_type ()
+        {
+          // Everything should have been unregistered by now.
+          //
+          assert (map_.get () == 0 || map_->size () == 0);
+        }
+
+      public:
+        /**
+         * @name Constructors
+         */
+        //@{
+
+        /**
+         * @brief Default constructor.
+         */
+        _type ()
+            : container_ (0)
+        {
+        }
+
+      public:
+        /**
+         * @brief Copy constructor.
+         *
+         * @param x An instance to make a copy of.
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         *
+         * For polymorphic object models use the @c _clone function instead.
+         */
+        _type (const type& x, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Copy the instance polymorphically.
+         *
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         * @return A pointer to the dynamically allocated copy.
+         *
+         * This function ensures that the dynamic type of the instance
+         * is used for copying and should be used for polymorphic object
+         * models instead of the copy constructor.
+         */
+        virtual type*
+        _clone (flags f = 0, container* c = 0) const
+        {
+          return new type (*this, f, c);
+        }
+
+      public:
+        /**
+         * @brief Create an instance from a data representation
+         * stream.
+         *
+         * @param s A stream to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        template <typename S>
+        _type (istream<S>& s, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM element.
+         *
+         * @param e A DOM element to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        _type (const xercesc::DOMElement& e, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM Attribute.
+         *
+         * @param a A DOM attribute to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        _type (const xercesc::DOMAttr& a, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a %string fragment.
+         *
+         * @param s A %string fragment to extract the data from.
+         * @param e A pointer to DOM element containing the %string fragment.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        template <typename C>
+        _type (const std::basic_string<C>& s,
+               const xercesc::DOMElement* e,
+               flags f = 0,
+               container* c = 0);
+        //@}
+
+      public:
+        /**
+         * @brief Copy assignment operator.
+         *
+         * @param x An instance to assign.
+         * @return A reference to the instance.
+         */
+        type&
+        operator= (const type& x)
+        {
+          while (&x == 0) /* unused */;
+          return *this;
+        }
+
+        // Container API.
+        //
+      public:
+        /**
+         * @brief Get a constant pointer to container, an object model
+         * node that contains this instance.
+         *
+         * @return A constant pointer to container, or 0 if this instance
+         * is not contained.
+         */
+        const container*
+        _container () const
+        {
+          return container_;
+        }
+
+        /**
+         * @brief Get a pointer to container, an object model node that
+         * contains this instance.
+         *
+         * @return A pointer to container, or 0 if this instance is not
+         * contained.
+         */
+        container*
+        _container ()
+        {
+          return container_;
+        }
+
+        /**
+         * @brief Set this instance's new container, an object model node
+         * that contains this instance.
+         *
+         * @param c A pointer to container.
+         */
+        virtual void
+        _container (container* c)
+        {
+          container* dr (0);
+
+          if (c != 0)
+          {
+            dr = c->_root ();
+
+            if (dr == 0)
+              dr = c;
+          }
+
+          std::auto_ptr<map>& m (dr ? dr->map_ : map_);
+
+          if (container_ == 0)
+          {
+            if (c != 0 && map_.get () != 0)
+            {
+              // Transfer our IDs to the new root.
+              //
+              if (m.get () != 0)
+              {
+                m->insert (map_->begin (), map_->end ());
+                std::auto_ptr<map> tmp (0);
+                map_ = tmp;
+              }
+              else
+                m = map_;
+            }
+          }
+          else
+          {
+            container* sr (_root ());
+
+            if (sr->map_.get () != 0)
+            {
+              // Transfer IDs that belong to this subtree.
+              //
+              for (map::iterator i (sr->map_->begin ()), e (sr->map_->end ());
+                   i != e;)
+              {
+                type* x (i->second);
+                for (; x != this && x != sr; x = x->_container ()) ;
+
+                if (x != sr)
+                {
+                  // Part of our subtree.
+                  //
+                  if (m.get () == 0)
+                  {
+                    std::auto_ptr<map> tmp (new map);
+                    m = tmp;
+                  }
+
+                  m->insert (*i);
+                  sr->map_->erase (i++);
+                }
+                else
+                  ++i;
+              }
+            }
+          }
+
+          container_ = c;
+        }
+
+        /**
+         * @brief Get a constant pointer to object model's root node.
+         *
+         * @return A constant pointer to root node, or 0 if this instance
+         * is not contained.
+         */
+        const container*
+        _root () const
+        {
+          const container* r (container_);
+
+          for (const container* c (r); c != 0; c = c->container_)
+            r = c;
+
+          return r;
+        }
+
+        /**
+         * @brief Get a pointer to object model's root node.
+         *
+         * @return A pointer to root node, or 0 if this instance is not
+         * contained.
+         */
+        container*
+        _root ()
+        {
+          container* r (container_);
+
+          for (container* c (r); c != 0; c = c->container_)
+            r = c;
+
+          return r;
+        }
+
+        // DOM association.
+        //
+      public:
+        /**
+         * @brief Get a constant pointer to a DOM node associated with
+         * this object model node.
+         *
+         * @return A constant pointer to DOM node, or 0 if none associated.
+         */
+        const xercesc::DOMNode*
+        _node () const
+        {
+          return dom_info_.get () ? dom_info_->node() : 0;
+        }
+
+        /**
+         * @brief Get a pointer to a DOM node associated with this object
+         * model node.
+         *
+         * @return A pointer to DOM node, or 0 if none associated.
+         */
+        xercesc::DOMNode*
+        _node ()
+        {
+          return dom_info_.get () ? dom_info_->node () : 0;
+        }
+
+        /**
+         * @brief Exception indicating that a DOM node cannot be associated
+         * with an object model node.
+         */
+        class bad_dom_node_type: public std::exception //@@ Inherit exception.
+        {
+        public:
+          /**
+           * @brief Get %exception description.
+           *
+           * @return A C %string describing the %exception.
+           */
+          virtual const char*
+          what () const throw ()
+          {
+            return "DOM node is not an attribute node or element node";
+          }
+        };
+
+        /**
+         * @brief Manually set a DOM node associated with this object
+         * model node.
+         *
+         * The DOM node should be a child of the parent's DOM node. If
+         * this object model node is a root of the tree, then it will
+         * assume the ownership of the whole DOM document to which this
+         * DOM node belongs.
+         *
+         * @param n A pointer to DOM node (should be either an element or
+         * an attribute).
+         */
+        void
+        _node (xercesc::DOMNode* n)
+        {
+          switch (n->getNodeType ())
+          {
+          case xercesc::DOMNode::ELEMENT_NODE:
+            {
+              if (container_ != 0)
+              {
+                // @@ Should be a throw.
+                //
+                assert (_root ()->_node () != 0);
+                assert (_root ()->_node ()->getOwnerDocument () ==
+                        n->getOwnerDocument ());
+              }
+
+              std::auto_ptr<dom_info> r (
+                dom_info_factory::create (
+                  *static_cast<xercesc::DOMElement*> (n),
+                  *this,
+                  container_ == 0));
+
+              dom_info_ = r;
+              break;
+            }
+          case xercesc::DOMNode::ATTRIBUTE_NODE:
+            {
+              //@@ Should be a throw.
+              //
+              assert (container_ != 0);
+              assert (_root ()->_node () != 0);
+              assert (_root ()->_node ()->getOwnerDocument () ==
+                      n->getOwnerDocument ());
+
+              std::auto_ptr<dom_info> r (
+                dom_info_factory::create (
+                  *static_cast<xercesc::DOMAttr*> (n),
+                  *this));
+
+              dom_info_ = r;
+              break;
+            }
+          default:
+            {
+              throw bad_dom_node_type ();
+            }
+          }
+        }
+
+      public:
+        //@cond
+
+        void
+        _register_id (const identity& id, type* t)
+        {
+          // We should be the root.
+          //
+          assert (container_ == 0);
+
+          if (map_.get () == 0)
+          {
+            std::auto_ptr<map> tmp (new map);
+            map_ = tmp;
+          }
+
+          if (!map_->insert (
+                std::pair<const identity*, type*> (&id, t)).second)
+          {
+            id.throw_duplicate_id ();
+          }
+        }
+
+        //@@ Does not inherit from exception.
+        //
+        struct not_registered: std::exception
+        {
+          virtual const char*
+          what () const throw ()
+          {
+            return "attempt to unregister non-existent id";
+          }
+        };
+
+        void
+        _unregister_id (const identity& id)
+        {
+          // We should be the root.
+          //
+          assert (container_ == 0);
+
+          if (map_.get () == 0 || map_->erase (&id) == 0)
+            throw not_registered ();
+        }
+
+        type*
+        _lookup_id (const identity& id) const
+        {
+          if (map_.get ())
+          {
+            map::const_iterator it (map_->find (&id));
+
+            if (it != map_->end ())
+              return it->second;
+          }
+
+          return 0;
+        }
+
+        //@endcond
+
+      private:
+        //@cond
+
+        struct dom_info
+        {
+          virtual
+          ~dom_info ()
+          {
+          }
+
+          dom_info ()
+          {
+          }
+
+          virtual std::auto_ptr<dom_info>
+          clone (type& tree_node, container*) const = 0;
+
+          virtual xercesc::DOMNode*
+          node () = 0;
+
+        private:
+          dom_info (const dom_info&);
+
+          dom_info&
+          operator= (const dom_info&);
+        };
+
+
+        struct dom_element_info: public dom_info
+        {
+          dom_element_info (xercesc::DOMElement& e, type& n, bool root)
+              : doc_ (0), e_ (e)
+          {
+            e_.setUserData (user_data_keys::node, &n, 0);
+
+            if (root)
+            {
+              // The caller should have associated a dom::auto_ptr object
+              // that owns this document with the document node using the
+              // xml_schema::dom::tree_node_key key.
+              //
+              xml::dom::auto_ptr<xercesc::DOMDocument>* pd (
+                reinterpret_cast<xml::dom::auto_ptr<xercesc::DOMDocument>*> (
+                  e.getOwnerDocument ()->getUserData (user_data_keys::node)));
+
+              assert (pd != 0);
+              assert (pd->get () == e.getOwnerDocument ());
+
+              doc_ = *pd; // Transfer ownership.
+            }
+          }
+
+          virtual std::auto_ptr<dom_info>
+          clone (type& tree_node, container* c) const
+          {
+            using std::auto_ptr;
+
+            // Check if we are a document root.
+            //
+            if (c == 0)
+            {
+              // We preserver DOM associations only in complete
+              // copies from root.
+              //
+              if (doc_.get () == 0)
+                return auto_ptr<dom_info> (0);
+
+              return auto_ptr<dom_info> (
+                new dom_element_info (*doc_, tree_node));
+            }
+
+            // Check if our container does not have DOM association (e.g.,
+            // because it wasn't a complete copy of the tree).
+            //
+            using xercesc::DOMNode;
+
+            DOMNode* cn (c->_node ());
+
+            if (cn == 0)
+              return auto_ptr<dom_info> (0);
+
+
+            // Now we are going to find the corresponding element in
+            // the new tree.
+            //
+            {
+              using xercesc::DOMElement;
+
+              DOMNode& pn (*e_.getParentNode ());
+              assert (pn.getNodeType () == DOMNode::ELEMENT_NODE);
+
+              DOMNode* sn (pn.getFirstChild ()); // Source.
+              DOMNode* dn (cn->getFirstChild ()); // Destination.
+
+              // We should have at least one child.
+              //
+              assert (sn != 0);
+
+              // Move in parallel until we get to the needed node.
+              //
+              for (; sn != 0 && !e_.isSameNode (sn);)
+              {
+                sn = sn->getNextSibling ();
+                dn = dn->getNextSibling ();
+              }
+
+              // e_ should be on the list.
+              //
+              assert (sn != 0);
+
+              assert (dn->getNodeType () == DOMNode::ELEMENT_NODE);
+
+              return auto_ptr<dom_info> (
+                new dom_element_info (static_cast<DOMElement&> (*dn),
+                                      tree_node,
+                                      false));
+            }
+          }
+
+          virtual xercesc::DOMNode*
+          node ()
+          {
+            return &e_;
+          }
+
+        private:
+          dom_element_info (const xercesc::DOMDocument& d, type& n)
+              : doc_ (static_cast<xercesc::DOMDocument*> (
+                        d.cloneNode (true))),
+                e_ (*doc_->getDocumentElement ())
+          {
+            e_.setUserData (user_data_keys::node, &n, 0);
+          }
+
+        private:
+          xml::dom::auto_ptr<xercesc::DOMDocument> doc_;
+          xercesc::DOMElement& e_;
+        };
+
+
+        struct dom_attribute_info: public dom_info
+        {
+          dom_attribute_info (xercesc::DOMAttr& a, type& n)
+              : a_ (a)
+          {
+            a_.setUserData (user_data_keys::node, &n, 0);
+          }
+
+          virtual std::auto_ptr<dom_info>
+          clone (type& tree_node, container* c) const
+          {
+            using std::auto_ptr;
+
+            // Check if we are a document root.
+            //
+            if (c == 0)
+            {
+              // We preserver DOM associations only in complete
+              // copies from root.
+              //
+              return auto_ptr<dom_info> (0);
+            }
+
+            // Check if our container does not have DOM association (e.g.,
+            // because it wasn't a complete copy of the tree).
+            //
+            using xercesc::DOMNode;
+
+            DOMNode* cn (c->_node ());
+
+            if (cn == 0)
+              return auto_ptr<dom_info> (0);
+
+            // We are going to find the corresponding attribute in
+            // the new tree.
+            //
+            using xercesc::DOMAttr;
+            using xercesc::DOMElement;
+            using xercesc::DOMNamedNodeMap;
+
+            DOMElement& p (*a_.getOwnerElement ());
+            DOMNamedNodeMap& nl (*p.getAttributes ());
+
+            XMLSize_t size (nl.getLength ()), i (0);
+
+            // We should have at least one child.
+            //
+            assert (size != 0);
+
+            for ( ;i < size && !a_.isSameNode (nl.item (i)); ++i)/*noop*/;
+
+            // a_ should be in the list.
+            //
+            assert (i < size);
+
+            DOMNode& n (*cn->getAttributes ()->item (i));
+            assert (n.getNodeType () == DOMNode::ATTRIBUTE_NODE);
+
+            return auto_ptr<dom_info> (
+              new dom_attribute_info (static_cast<DOMAttr&> (n), tree_node));
+          }
+
+          virtual xercesc::DOMNode*
+          node ()
+          {
+            return &a_;
+          }
+
+        private:
+          xercesc::DOMAttr& a_;
+        };
+
+        // For Sun C++ 5.6.
+        //
+        struct dom_info_factory;
+        friend struct _type::dom_info_factory;
+
+        struct dom_info_factory
+        {
+          static std::auto_ptr<dom_info>
+          create (const xercesc::DOMElement& e, type& n, bool root)
+          {
+            return std::auto_ptr<dom_info> (
+              new dom_element_info (
+                const_cast<xercesc::DOMElement&> (e), n, root));
+          }
+
+          static std::auto_ptr<dom_info>
+          create (const xercesc::DOMAttr& a, type& n)
+          {
+            return std::auto_ptr<dom_info> (
+              new dom_attribute_info (
+                const_cast<xercesc::DOMAttr&> (a), n));
+          }
+        };
+
+        //@endcond
+
+        std::auto_ptr<dom_info> dom_info_;
+
+
+        // ID/IDREF map.
+        //
+      private:
+
+        //@cond
+
+        struct identity_comparator
+        {
+          bool operator () (const identity* x, const identity* y) const
+          {
+            return x->before (*y);
+          }
+        };
+
+        //@endcond
+
+        typedef
+        std::map<const identity*, type*, identity_comparator>
+        map;
+
+        std::auto_ptr<map> map_;
+
+      private:
+        container* container_;
+      };
+
+      inline _type::
+      _type (const type& x, flags, container* c)
+          : container_ (c)
+      {
+        if (x.dom_info_.get ())
+        {
+          std::auto_ptr<dom_info> r (x.dom_info_->clone (*this, c));
+          dom_info_ = r;
+        }
+      }
+
+
+      /**
+       * @brief Class corresponding to the XML Schema anySimpleType built-in
+       * type.
+       *
+       * @nosubgrouping
+       */
+      template <typename B>
+      class simple_type: public B
+      {
+      public:
+        /**
+         * @name Constructors
+         */
+        //@{
+
+        /**
+         * @brief Default constructor.
+         */
+        simple_type ();
+
+        /**
+         * @brief Create an instance from a string.
+         *
+         * @param s A string to initialize the instance with.
+         */
+        template <typename C>
+        simple_type (const C* s);
+
+      public:
+        /**
+         * @brief Copy constructor.
+         *
+         * @param x An instance to make a copy of.
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         *
+         * For polymorphic object models use the @c _clone function instead.
+         */
+        simple_type (const simple_type& x, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Copy the instance polymorphically.
+         *
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         * @return A pointer to the dynamically allocated copy.
+         *
+         * This function ensures that the dynamic type of the instance
+         * is used for copying and should be used for polymorphic object
+         * models instead of the copy constructor.
+         */
+        virtual simple_type*
+        _clone (flags f = 0, container* c = 0) const;
+
+      public:
+        /**
+         * @brief Create an instance from a data representation
+         * stream.
+         *
+         * @param s A stream to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        template <typename S>
+        simple_type (istream<S>& s, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM element.
+         *
+         * @param e A DOM element to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        simple_type (const xercesc::DOMElement& e,
+                     flags f = 0,
+                     container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM Attribute.
+         *
+         * @param a A DOM attribute to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        simple_type (const xercesc::DOMAttr& a,
+                     flags f = 0,
+                     container* c = 0);
+
+        /**
+         * @brief Create an instance from a %string fragment.
+         *
+         * @param s A %string fragment to extract the data from.
+         * @param e A pointer to DOM element containing the %string fragment.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        template <typename C>
+        simple_type (const std::basic_string<C>& s,
+                     const xercesc::DOMElement* e,
+                     flags f = 0,
+                     container* c = 0);
+        //@}
+      };
+
+
+      /**
+       * @brief Base class for element types.
+       *
+       * This class is a base for every generated element type.
+       *
+       * @nosubgrouping
+       */
+      template <typename C, typename T>
+      class element_type
+      {
+      public:
+        virtual
+        ~element_type ()
+        {
+        }
+
+        /**
+         * @brief Copy the instance polymorphically.
+         *
+         * @param f Flags to create the copy with.
+         * @return A pointer to the dynamically allocated copy.
+         *
+         * This function ensures that the dynamic type of the instance
+         * is used for copying and should be used for polymorphic object
+         * models instead of the copy constructor.
+         */
+        virtual element_type*
+        _clone (flags f = 0) const = 0;
+
+        /**
+         * @brief Return the element name.
+         *
+         * @return A read-only string reference containing the element
+         * name.
+         */
+        virtual const std::basic_string<C>&
+        _name () const = 0;
+
+        /**
+         * @brief Return the element namespace.
+         *
+         * @return A read-only string reference containing the element
+         * namespace. Empty string is returned if the element is
+         * unqualified.
+         */
+        virtual const std::basic_string<C>&
+        _namespace () const = 0;
+
+        /**
+         * @brief Return the element value.
+         *
+         * @return A pointer to the element value or 0 if the element
+         * is of a fundamental type.
+         */
+        virtual T*
+        _value () = 0;
+
+        /**
+         * @brief Return the element value.
+         *
+         * @return A read-only pointer to the element value or 0 if the
+         * element is of a fundamental type.
+         */
+        virtual const T*
+        _value () const = 0;
+      };
+
+
+      //@cond
+
+      // Extra schema type id to disambiguate certain cases where
+      // different XML Schema types (e.g., double and decimal) are
+      // mapped to the same fundamental C++ type (e.g., double).
+      //
+      struct schema_type
+      {
+        enum value
+        {
+          other,
+          double_,
+          decimal
+        };
+      };
+
+      //@endcond
+
+
+      //@cond
+      template <typename T,
+                typename C,
+                schema_type::value ST = schema_type::other>
+      struct traits
+      {
+        typedef T type;
+
+        static std::auto_ptr<T>
+        create (const xercesc::DOMElement& e, flags f, container* c)
+        {
+          return std::auto_ptr<T> (new T (e, f, c));
+        }
+
+        static std::auto_ptr<T>
+        create (const xercesc::DOMAttr& a, flags f, container* c)
+        {
+          return std::auto_ptr<T> (new T (a, f, c));
+        }
+
+        static std::auto_ptr<T>
+        create (const std::basic_string<C>& s,
+                const xercesc::DOMElement* e,
+                flags f,
+                container* c)
+        {
+          return std::auto_ptr<T> (new T (s, e, f, c));
+        }
+      };
+
+      //@endcond
+
+
+      /**
+       * @brief Class template that emulates inheritance from a
+       * fundamental C++ type.
+       *
+       * @nosubgrouping
+       */
+      template <typename T,
+                typename C,
+                typename B,
+                schema_type::value ST = schema_type::other>
+      class fundamental_base: public B
+      {
+      public:
+        /**
+         * @name Constructors
+         */
+        //@{
+
+        /**
+         * @brief Default constructor.
+         */
+        fundamental_base ()
+            : facet_table_ (0), x_ ()
+        {
+        }
+
+        /**
+         * @brief Initialize an instance with an underlying type value.
+         *
+         * @param x An underlying type value.
+         */
+        fundamental_base (T x)
+            : facet_table_ (0), x_ (x)
+        {
+        }
+
+      public:
+        /**
+         * @brief Copy constructor.
+         *
+         * @param x An instance to make a copy of.
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         *
+         * For polymorphic object models use the @c _clone function instead.
+         */
+        fundamental_base (const fundamental_base& x,
+                          flags f = 0,
+                          container* c = 0)
+            : B (x, f, c), facet_table_ (0), x_ (x.x_)
+        {
+        }
+
+        /**
+         * @brief Copy the instance polymorphically.
+         *
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         * @return A pointer to the dynamically allocated copy.
+         *
+         * This function ensures that the dynamic type of the instance
+         * is used for copying and should be used for polymorphic object
+         * models instead of the copy constructor.
+         */
+        virtual fundamental_base*
+        _clone (flags f = 0, container* c = 0) const;
+
+      public:
+        /**
+         * @brief Create an instance from a data representation
+         * stream.
+         *
+         * @param s A stream to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        template <typename S>
+        fundamental_base (istream<S>& s, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM element.
+         *
+         * @param e A DOM element to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        fundamental_base (const xercesc::DOMElement& e,
+                          flags f = 0,
+                          container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM Attribute.
+         *
+         * @param a A DOM attribute to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        fundamental_base (const xercesc::DOMAttr& a,
+                          flags f = 0,
+                          container* c = 0);
+
+        /**
+         * @brief Create an instance from a %string fragment.
+         *
+         * @param s A %string fragment to extract the data from.
+         * @param e A pointer to DOM element containing the %string fragment.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        fundamental_base (const std::basic_string<C>& s,
+                          const xercesc::DOMElement* e,
+                          flags f = 0,
+                          container* c = 0);
+        //@}
+
+      public:
+        /**
+         * @brief Assign an underlying type value to the instance.
+         *
+         * @param x An underlying type value.
+         * @return A reference to the instance.
+         */
+        fundamental_base&
+        operator= (const T& x)
+        {
+          if (&x_ != &x)
+            x_ = x;
+
+          return *this;
+        }
+
+      public:
+        /**
+         * @brief Implicitly convert the instance to constant reference to
+         * the underlying type.
+         *
+         * @return A constant reference to the underlying type.
+         */
+        operator const T& () const
+        {
+          return x_;
+        }
+
+        /**
+         * @brief Implicitly convert the instance to reference to the
+         * underlying type.
+         *
+         * @return A reference to the underlying type.
+         */
+        operator T& ()
+        {
+          return x_;
+        }
+
+        // The following extra conversion operators causes problems on
+        // some compilers (notably VC 7.1 and 9.0) and are disabled by
+        // default.
+        //
+#ifdef XSD_TREE_EXTRA_FUND_CONV
+        /**
+         * @brief Implicitly convert the instance to another type (const
+         * version).
+         *
+         * @return A value converted to the target type.
+         */
+        template <typename T2>
+        operator T2 () const
+        {
+          return x_;
+        }
+
+        /**
+         * @brief Implicitly convert the instance to another type.
+         *
+         * @return A value converted to the target type.
+         */
+        template <typename T2>
+        operator T2 ()
+        {
+          return x_;
+        }
+#endif // XSD_TREE_EXTRA_FUND_CONV
+
+      public:
+        /**
+         * @brief Get the facet table associated with this type.
+         *
+         * @return A pointer to read-only facet table or 0.
+         */
+        const facet*
+        _facet_table () const
+        {
+          return facet_table_;
+        }
+
+      protected:
+        /**
+         * @brief Set the facet table associated with this type.
+         *
+         * @param ft A pointer to read-only facet table.
+         */
+        void
+        _facet_table (const facet* ft)
+        {
+          facet_table_ = ft;
+        }
+
+      private:
+        const facet* facet_table_;
+        T x_;
+      };
+
+      // While thse operators are not normally necessary, they
+      // help resolve ambiguities between implicit conversion and
+      // construction.
+      //
+
+      /**
+       * @brief %fundamental_base comparison operator.
+       *
+       * @return True if the underlying values are equal, false otherwise.
+       */
+      template <typename T, typename C, typename B, schema_type::value ST>
+      inline bool
+      operator== (const fundamental_base<T, C, B, ST>& x,
+                  const fundamental_base<T, C, B, ST>& y)
+      {
+        T x_ (x);
+        T y_ (y);
+        return x_ == y_;
+      }
+
+      /**
+       * @brief %fundamental_base comparison operator.
+       *
+       * @return True if the underlying values are not equal, false otherwise.
+       */
+      template <typename T, typename C, typename B, schema_type::value ST>
+      inline bool
+      operator!= (const fundamental_base<T, C, B, ST>& x,
+                  const fundamental_base<T, C, B, ST>& y)
+      {
+        T x_ (x);
+        T y_ (y);
+        return x_ != y_;
+      }
+
+
+      //@cond
+
+      // Comparator for enum tables.
+      //
+      template <typename C>
+      struct enum_comparator
+      {
+        enum_comparator (const C* const* table)
+            : table_ (table)
+        {
+        }
+
+        bool
+        operator() (std::size_t i, const std::basic_string<C>& s) const
+        {
+          return table_[i] < s;
+        }
+
+        bool
+        operator() (const std::basic_string<C>& s, std::size_t i) const
+        {
+          return s < table_[i];
+        }
+
+        bool
+        operator() (std::size_t i, std::size_t j) const
+        {
+          return std::basic_string<C> (table_[i]) < table_[j];
+        }
+
+      private:
+        const C* const* table_;
+      };
+
+      //@endcond
+    }
+  }
+}
+
+#include <xsd/cxx/tree/elements.ixx>
+#include <xsd/cxx/tree/elements.txx>
+
+#endif  // XSD_CXX_TREE_ELEMENTS_HXX
diff --git src/base/include/xsd/cxx/tree/elements.ixx src/base/include/xsd/cxx/tree/elements.ixx
new file mode 100644
index 0000000..e4dd60a
--- /dev/null
+++ src/base/include/xsd/cxx/tree/elements.ixx
@@ -0,0 +1,29 @@
+// file      : xsd/cxx/tree/elements.ixx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      // simple_type
+      //
+
+      template <typename B>
+      inline simple_type<B>::
+      simple_type ()
+      {
+      }
+
+      template <typename B>
+      template <typename C>
+      inline simple_type<B>::
+      simple_type (const C*)
+      {
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/tree/elements.txx src/base/include/xsd/cxx/tree/elements.txx
new file mode 100644
index 0000000..084cb56
--- /dev/null
+++ src/base/include/xsd/cxx/tree/elements.txx
@@ -0,0 +1,57 @@
+// file      : xsd/cxx/tree/elements.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#include <xercesc/util/XMLUniDefs.hpp>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      // user_data_keys_template
+      //
+      template <int dummy>
+      const XMLCh user_data_keys_template<dummy>::node[21] =
+      {xercesc::chLatin_x, xercesc::chLatin_s, xercesc::chLatin_d, // xsd
+       xercesc::chColon, xercesc::chColon,                         // ::
+       xercesc::chLatin_c, xercesc::chLatin_x, xercesc::chLatin_x, // cxx
+       xercesc::chColon, xercesc::chColon,                         // ::
+       xercesc::chLatin_t, xercesc::chLatin_r, xercesc::chLatin_e, // tre
+       xercesc::chLatin_e, xercesc::chColon, xercesc::chColon,     // e::
+       xercesc::chLatin_n, xercesc::chLatin_o, xercesc::chLatin_d, // nod
+       xercesc::chLatin_e, xercesc::chNull                         // e\0
+      };
+
+
+      // simple_type
+      //
+      template <typename B>
+      simple_type<B>::
+      simple_type (const simple_type& other,
+                   flags f,
+                   container* c)
+          : B (other, f, c)
+      {
+      }
+
+      template <typename B>
+      simple_type<B>* simple_type<B>::
+      _clone (flags f, container* c) const
+      {
+        return new simple_type (*this, f, c);
+      }
+
+      // fundamental_base
+      //
+      template <typename T, typename C, typename B, schema_type::value ST>
+      fundamental_base<T, C, B, ST>* fundamental_base<T, C, B, ST>::
+      _clone (flags f, container* c) const
+      {
+        return new fundamental_base (*this, f, c);
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/tree/error-handler.hxx src/base/include/xsd/cxx/tree/error-handler.hxx
new file mode 100644
index 0000000..6e4426b
--- /dev/null
+++ src/base/include/xsd/cxx/tree/error-handler.hxx
@@ -0,0 +1,62 @@
+// file      : xsd/cxx/tree/error-handler.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_ERROR_HANDLER_HXX
+#define XSD_CXX_TREE_ERROR_HANDLER_HXX
+
+#include <xsd/cxx/xml/error-handler.hxx>
+
+#include <xsd/cxx/tree/exceptions.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      template <typename C>
+      class error_handler: public xml::error_handler<C>
+      {
+      public:
+        typedef typename xml::error_handler<C>::severity severity;
+
+        error_handler ()
+            : failed_ (false)
+        {
+        }
+
+        virtual bool
+        handle (const std::basic_string<C>& id,
+                unsigned long line,
+                unsigned long column,
+                severity,
+                const std::basic_string<C>& message);
+
+        template <typename E>
+        void
+        throw_if_failed () const
+        {
+          if (failed_)
+            throw E (diagnostics_);
+        }
+
+        void
+        reset ()
+        {
+          failed_ = false;
+          diagnostics_.clear ();
+        }
+
+      private:
+        bool failed_;
+        diagnostics<C> diagnostics_;
+      };
+    }
+  }
+}
+
+#include <xsd/cxx/tree/error-handler.txx>
+
+#endif  // XSD_CXX_TREE_ERROR_HANDLER_HXX
diff --git src/base/include/xsd/cxx/tree/error-handler.txx src/base/include/xsd/cxx/tree/error-handler.txx
new file mode 100644
index 0000000..c19d354
--- /dev/null
+++ src/base/include/xsd/cxx/tree/error-handler.txx
@@ -0,0 +1,32 @@
+// file      : xsd/cxx/tree/error-handler.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      template <typename C>
+      bool error_handler<C>::
+      handle (const std::basic_string<C>& id,
+              unsigned long line,
+              unsigned long column,
+              severity s,
+              const std::basic_string<C>& message)
+      {
+        diagnostics_.push_back (
+          error<C> (s == severity::warning
+                    ? tree::severity::warning
+                    : tree::severity::error, id, line, column, message));
+
+        if (!failed_ && s != severity::warning)
+          failed_ = true;
+
+        return true;
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/tree/exceptions.hxx src/base/include/xsd/cxx/tree/exceptions.hxx
new file mode 100644
index 0000000..f6ddb15
--- /dev/null
+++ src/base/include/xsd/cxx/tree/exceptions.hxx
@@ -0,0 +1,1034 @@
+// file      : xsd/cxx/tree/exceptions.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+/**
+ * @file
+ *
+ * @brief Contains exception definitions for the C++/Tree mapping.
+ *
+ * This is an internal header and is included by the generated code.
+ * You normally should not include it directly.
+ *
+ */
+
+#ifndef XSD_CXX_TREE_EXCEPTIONS_HXX
+#define XSD_CXX_TREE_EXCEPTIONS_HXX
+
+#include <string>
+#include <vector>
+#include <ostream>
+
+#include <xsd/cxx/exceptions.hxx> // xsd::cxx::exception
+
+namespace xsd
+{
+  namespace cxx
+  {
+    /**
+     * @brief C++/Tree mapping runtime namespace.
+     *
+     * This is an internal namespace and normally should not be referenced
+     * directly. Instead you should use the aliases for types in this
+     * namespaces that are created in the generated code.
+     *
+     */
+    namespace tree
+    {
+      /**
+       * @brief Root of the C++/Tree %exception hierarchy.
+       *
+       * You can catch this %exception in order to handle all C++/Tree
+       * errors.
+       *
+       * @nosubgrouping
+       */
+      template <typename C>
+      class exception: public xsd::cxx::exception
+      {
+      public:
+        /**
+         * @brief Stream insertion operator for %exception.
+         */
+        friend
+        std::basic_ostream<C>&
+        operator<< (std::basic_ostream<C>& os, const exception& e)
+        {
+          e.print (os);
+          return os;
+        }
+
+      protected:
+        //@cond
+
+        virtual void
+        print (std::basic_ostream<C>&) const = 0;
+
+        //@endcond
+      };
+
+
+      /**
+       * @brief Error %severity.
+       *
+       * @nosubgrouping
+       */
+      class severity
+      {
+      public:
+        /**
+         * @brief Underlying enum type.
+         */
+        enum value
+        {
+          /**
+           * @brief Indicates the warning condition.
+           */
+          warning,
+
+          /**
+           * @brief Indicates the %error condition.
+           */
+          error
+        };
+
+        /**
+         * @brief Initialize an instance with the underlying enum value.
+         *
+         * @param v An underlying enum value.
+         */
+        severity (value v) : v_ (v) {}
+
+        /**
+         * @brief Implicitly convert the instance to the underlying enum
+         * value.
+         *
+         * @return The underlying enum value.
+         */
+        operator value () const { return v_; }
+
+      private:
+        value v_;
+      };
+
+      /**
+       * @brief Error condition.
+       *
+       * @nosubgrouping
+       */
+      template <typename C>
+      class error
+      {
+      public:
+        /**
+         * @brief Initialize an instance with %error description.
+         *
+         * @param s An %error %severity.
+         * @param res_id A resource %id where the %error occurred.
+         * @param line A line number where the %error occurred.
+         * @param column A column number where the %error occurred.
+         * @param message A message describing the %error.
+         */
+        error (tree::severity s,
+               const std::basic_string<C>& res_id,
+               unsigned long line,
+               unsigned long column,
+               const std::basic_string<C>& message);
+
+        /**
+         * @brief Get %error %severity.
+         *
+         * @return The %severity of this %error.
+         */
+        tree::severity
+        severity () const
+        {
+          return severity_;
+        }
+
+        /**
+         * @brief Get resource %id.
+         *
+         * @return The %id of the resource where this %error occurred.
+         */
+        const std::basic_string<C>&
+        id () const
+        {
+          return id_;
+        }
+
+        /**
+         * @brief Get %error line.
+         *
+         * @return The line number where this %error occurred.
+         */
+        unsigned long
+        line () const
+        {
+          return line_;
+        }
+
+        /**
+         * @brief Get %error column.
+         *
+         * @return The column number where this %error occurred.
+         */
+        unsigned long
+        column () const
+        {
+          return column_;
+        }
+
+        /**
+         * @brief Get %error message.
+         *
+         * @return The message for this %error.
+         */
+        const std::basic_string<C>&
+        message () const
+        {
+          return message_;
+        }
+
+        //@cond
+
+        // Default c-tor that shouldn't be. Needed when we completely
+        // instantiate std::vector in diagnostics below.
+        //
+        error ();
+
+        //@endcond
+
+
+      private:
+        tree::severity severity_;
+        std::basic_string<C> id_;
+        unsigned long line_;
+        unsigned long column_;
+        std::basic_string<C> message_;
+      };
+
+      // See exceptions.ixx for operator<< (error).
+
+
+      /**
+       * @brief List of %error conditions.
+       *
+       * @nosubgrouping
+       */
+      template <typename C>
+      class diagnostics: public std::vector<error<C> >
+      {
+      };
+
+      // See exceptions.ixx for operator<< (diagnostics).
+
+      /**
+       * @brief Exception indicating a %parsing failure.
+       *
+       * @nosubgrouping
+       */
+      template <typename C>
+      class parsing: public exception<C>
+      {
+      public:
+        virtual
+        ~parsing () throw ();
+
+        /**
+         * @brief Default constructor.
+         */
+        parsing ();
+
+        /**
+         * @brief Initialize an instance with a %list of %error conditions.
+         *
+         * @param d A %list of %error conditions.
+         */
+        parsing (const tree::diagnostics<C>& d);
+
+      public:
+        /**
+         * @brief Get the %list of %error conditions.
+         *
+         * @return The %list of %error conditions.
+         */
+        const tree::diagnostics<C>&
+        diagnostics () const
+        {
+          return diagnostics_;
+        }
+
+        /**
+         * @brief Get %exception description.
+         *
+         * @return A C %string describing the %exception.
+         */
+        virtual const char*
+        what () const throw ();
+
+      protected:
+        //@cond
+
+        virtual void
+        print (std::basic_ostream<C>&) const;
+
+        //@endcond
+
+      private:
+        tree::diagnostics<C> diagnostics_;
+      };
+
+
+      /**
+       * @brief Exception indicating that an expected element was not
+       * encountered.
+       *
+       * @nosubgrouping
+       */
+      template <typename C>
+      class expected_element: public exception<C>
+      {
+      public:
+        virtual
+        ~expected_element () throw ();
+
+        /**
+         * @brief Initialize an instance with the expected element
+         * description.
+         *
+         * @param name A name of the expected element.
+         * @param ns A namespace of the expected element.
+         */
+        expected_element (const std::basic_string<C>& name,
+                          const std::basic_string<C>& ns);
+
+
+      public:
+        /**
+         * @brief Get the name of the expected element.
+         *
+         * @return The name of the expected element.
+         */
+        const std::basic_string<C>&
+        name () const
+        {
+          return name_;
+        }
+
+        /**
+         * @brief Get the namespace of the expected element.
+         *
+         * @return The namespace of the expected element.
+         */
+        const std::basic_string<C>&
+        namespace_ () const
+        {
+          return namespace__;
+        }
+
+        /**
+         * @brief Get %exception description.
+         *
+         * @return A C %string describing the %exception.
+         */
+        virtual const char*
+        what () const throw ();
+
+      protected:
+        //@cond
+
+        virtual void
+        print (std::basic_ostream<C>&) const;
+
+        //@endcond
+
+      private:
+        std::basic_string<C> name_;
+        std::basic_string<C> namespace__;
+      };
+
+
+      /**
+       * @brief Exception indicating that an unexpected element was
+       * encountered.
+       *
+       * @nosubgrouping
+       */
+      template <typename C>
+      class unexpected_element: public exception<C>
+      {
+      public:
+        virtual
+        ~unexpected_element () throw ();
+
+        /**
+         * @brief Initialize an instance with the encountered and expected
+         * element descriptions.
+         *
+         * @param encountered_name A name of the encountered element.
+         * @param encountered_ns A namespace of the encountered element.
+         * @param expected_name A name of the expected element.
+         * @param expected_ns A namespace of the expected element.
+         */
+        unexpected_element (const std::basic_string<C>& encountered_name,
+                            const std::basic_string<C>& encountered_ns,
+                            const std::basic_string<C>& expected_name,
+                            const std::basic_string<C>& expected_ns);
+
+      public:
+        /**
+         * @brief Get the name of the encountered element.
+         *
+         * @return The name of the encountered element.
+         */
+        const std::basic_string<C>&
+        encountered_name () const
+        {
+          return encountered_name_;
+        }
+
+        /**
+         * @brief Get the namespace of the encountered element.
+         *
+         * @return The namespace of the encountered element.
+         */
+        const std::basic_string<C>&
+        encountered_namespace () const
+        {
+          return encountered_namespace_;
+        }
+
+        /**
+         * @brief Get the name of the expected element.
+         *
+         * @return The name of the expected element.
+         */
+        const std::basic_string<C>&
+        expected_name () const
+        {
+          return expected_name_;
+        }
+
+        /**
+         * @brief Get the namespace of the expected element.
+         *
+         * @return The namespace of the expected element.
+         */
+        const std::basic_string<C>&
+        expected_namespace () const
+        {
+          return expected_namespace_;
+        }
+
+        /**
+         * @brief Get %exception description.
+         *
+         * @return A C %string describing the %exception.
+         */
+        virtual const char*
+        what () const throw ();
+
+      protected:
+        //@cond
+
+        virtual void
+        print (std::basic_ostream<C>&) const;
+
+        //@endcond
+
+      private:
+        std::basic_string<C> encountered_name_;
+        std::basic_string<C> encountered_namespace_;
+        std::basic_string<C> expected_name_;
+        std::basic_string<C> expected_namespace_;
+      };
+
+
+      /**
+       * @brief Exception indicating that an expected attribute was not
+       * encountered.
+       *
+       * @nosubgrouping
+       */
+      template <typename C>
+      class expected_attribute: public exception<C>
+      {
+      public:
+        virtual
+        ~expected_attribute () throw ();
+
+        /**
+         * @brief Initialize an instance with the expected attribute
+         * description.
+         *
+         * @param name A name of the expected attribute.
+         * @param ns A namespace of the expected attribute.
+         */
+        expected_attribute (const std::basic_string<C>& name,
+                            const std::basic_string<C>& ns);
+
+      public:
+        /**
+         * @brief Get the name of the expected attribute.
+         *
+         * @return The name of the expected attribute.
+         */
+        const std::basic_string<C>&
+        name () const
+        {
+          return name_;
+        }
+
+        /**
+         * @brief Get the namespace of the expected attribute.
+         *
+         * @return The namespace of the expected attribute.
+         */
+        const std::basic_string<C>&
+        namespace_ () const
+        {
+          return namespace__;
+        }
+
+        /**
+         * @brief Get %exception description.
+         *
+         * @return A C %string describing the %exception.
+         */
+        virtual const char*
+        what () const throw ();
+
+      protected:
+        //@cond
+
+        virtual void
+        print (std::basic_ostream<C>&) const;
+
+        //@endcond
+
+      private:
+        std::basic_string<C> name_;
+        std::basic_string<C> namespace__;
+      };
+
+
+      /**
+       * @brief Exception indicating that an unexpected enumerator was
+       * encountered.
+       *
+       * @nosubgrouping
+       */
+      template <typename C>
+      class unexpected_enumerator: public exception<C>
+      {
+      public:
+        virtual
+        ~unexpected_enumerator () throw ();
+
+        /**
+         * @brief Initialize an instance with the encountered enumerator.
+         *
+         * @param e A value of the encountered enumerator.
+         */
+        unexpected_enumerator (const std::basic_string<C>& e);
+
+      public:
+        /**
+         * @brief Get the value of the encountered enumerator.
+         *
+         * @return The value of the encountered enumerator.
+         */
+        const std::basic_string<C>&
+        enumerator () const
+        {
+          return enumerator_;
+        }
+
+        /**
+         * @brief Get %exception description.
+         *
+         * @return A C %string describing the %exception.
+         */
+        virtual const char*
+        what () const throw ();
+
+      protected:
+        //@cond
+
+        virtual void
+        print (std::basic_ostream<C>&) const;
+
+        //@endcond
+
+      private:
+        std::basic_string<C> enumerator_;
+      };
+
+
+      /**
+       * @brief Exception indicating that the text content was expected
+       * for an element.
+       *
+       * @nosubgrouping
+       */
+      template <typename C>
+      class expected_text_content: public exception<C>
+      {
+      public:
+        /**
+         * @brief Get %exception description.
+         *
+         * @return A C %string describing the %exception.
+         */
+        virtual const char*
+        what () const throw ();
+
+      protected:
+        //@cond
+
+        virtual void
+        print (std::basic_ostream<C>&) const;
+
+        //@endcond
+      };
+
+
+      /**
+       * @brief Exception indicating that the type information is not
+       * available for a type.
+       *
+       * @nosubgrouping
+       */
+      template <typename C>
+      class no_type_info: public exception<C>
+      {
+      public:
+        virtual
+        ~no_type_info () throw ();
+
+        /**
+         * @brief Initialize an instance with the type description.
+         *
+         * @param type_name A name of the type.
+         * @param type_ns A namespace of the type.
+         */
+        no_type_info (const std::basic_string<C>& type_name,
+                      const std::basic_string<C>& type_ns);
+
+      public:
+        /**
+         * @brief Get the type name.
+         *
+         * @return The type name.
+         */
+        const std::basic_string<C>&
+        type_name () const
+        {
+          return type_name_;
+        }
+
+        /**
+         * @brief Get the type namespace.
+         *
+         * @return The type namespace.
+         */
+        const std::basic_string<C>&
+        type_namespace () const
+        {
+          return type_namespace_;
+        }
+
+        /**
+         * @brief Get %exception description.
+         *
+         * @return A C %string describing the %exception.
+         */
+        virtual const char*
+        what () const throw ();
+
+      protected:
+        //@cond
+
+        virtual void
+        print (std::basic_ostream<C>&) const;
+
+        //@endcond
+
+      private:
+        std::basic_string<C> type_name_;
+        std::basic_string<C> type_namespace_;
+      };
+
+      /**
+       * @brief Exception indicating that %parsing or %serialization
+       * information is not available for an element.
+       *
+       * @nosubgrouping
+       */
+      template <typename C>
+      class no_element_info: public exception<C>
+      {
+      public:
+        virtual
+        ~no_element_info () throw ();
+
+        /**
+         * @brief Initialize an instance with the element description.
+         *
+         * @param element_name An element name.
+         * @param element_ns An element namespace.
+         */
+        no_element_info (const std::basic_string<C>& element_name,
+                         const std::basic_string<C>& element_ns);
+
+      public:
+        /**
+         * @brief Get the element name.
+         *
+         * @return The element name.
+         */
+        const std::basic_string<C>&
+        element_name () const
+        {
+          return element_name_;
+        }
+
+        /**
+         * @brief Get the element namespace.
+         *
+         * @return The element namespace.
+         */
+        const std::basic_string<C>&
+        element_namespace () const
+        {
+          return element_namespace_;
+        }
+
+        /**
+         * @brief Get %exception description.
+         *
+         * @return A C %string describing the %exception.
+         */
+        virtual const char*
+        what () const throw ();
+
+      protected:
+        //@cond
+
+        virtual void
+        print (std::basic_ostream<C>&) const;
+
+        //@endcond
+
+      private:
+        std::basic_string<C> element_name_;
+        std::basic_string<C> element_namespace_;
+      };
+
+      /**
+       * @brief Exception indicating that the types are not related by
+       * inheritance.
+       *
+       * @nosubgrouping
+       */
+      template <typename C>
+      class not_derived: public exception<C>
+      {
+      public:
+        virtual
+        ~not_derived () throw ();
+
+        //@cond
+
+        // @@ tmp
+        //
+        not_derived ()
+        {
+        }
+
+        //@endcond
+
+        /**
+         * @brief Initialize an instance with the type descriptions.
+         *
+         * @param base_type_name A name of the base type.
+         * @param base_type_ns A namespace of the base type.
+         * @param derived_type_name A name of the derived type.
+         * @param derived_type_ns A namespace of the derived type.
+         */
+        not_derived (const std::basic_string<C>& base_type_name,
+                     const std::basic_string<C>& base_type_ns,
+                     const std::basic_string<C>& derived_type_name,
+                     const std::basic_string<C>& derived_type_ns);
+
+      public:
+        /**
+         * @brief Get the base type name.
+         *
+         * @return The base type name.
+         */
+        const std::basic_string<C>&
+        base_type_name () const
+        {
+          return base_type_name_;
+        }
+
+        /**
+         * @brief Get the base type namespace.
+         *
+         * @return The base type namespace.
+         */
+        const std::basic_string<C>&
+        base_type_namespace () const
+        {
+          return base_type_namespace_;
+        }
+
+        /**
+         * @brief Get the derived type name.
+         *
+         * @return The derived type name.
+         */
+        const std::basic_string<C>&
+        derived_type_name () const
+        {
+          return derived_type_name_;
+        }
+
+        /**
+         * @brief Get the derived type namespace.
+         *
+         * @return The derived type namespace.
+         */
+        const std::basic_string<C>&
+        derived_type_namespace () const
+        {
+          return derived_type_namespace_;
+        }
+
+        /**
+         * @brief Get %exception description.
+         *
+         * @return A C %string describing the %exception.
+         */
+        virtual const char*
+        what () const throw ();
+
+      protected:
+        //@cond
+
+        virtual void
+        print (std::basic_ostream<C>&) const;
+
+        //@endcond
+
+      private:
+        std::basic_string<C> base_type_name_;
+        std::basic_string<C> base_type_namespace_;
+        std::basic_string<C> derived_type_name_;
+        std::basic_string<C> derived_type_namespace_;
+      };
+
+
+      /**
+       * @brief Exception indicating that a duplicate ID value was
+       * encountered in the object model.
+       *
+       * @nosubgrouping
+       */
+      template <typename C>
+      class duplicate_id: public exception<C>
+      {
+      public:
+        virtual
+        ~duplicate_id () throw ();
+
+        /**
+         * @brief Initialize an instance with the offending ID value.
+         *
+         * @param id An offending ID value.
+         */
+        duplicate_id (const std::basic_string<C>& id);
+
+      public:
+        /**
+         * @brief Get the offending ID value.
+         *
+         * @return The offending ID value.
+         */
+        const std::basic_string<C>&
+        id () const
+        {
+          return id_;
+        }
+
+        /**
+         * @brief Get %exception description.
+         *
+         * @return A C %string describing the %exception.
+         */
+        virtual const char*
+        what () const throw ();
+
+      protected:
+        //@cond
+
+        virtual void
+        print (std::basic_ostream<C>&) const;
+
+        //@endcond
+
+      private:
+        std::basic_string<C> id_;
+      };
+
+
+      /**
+       * @brief Exception indicating a %serialization failure.
+       *
+       * @nosubgrouping
+       */
+      template <typename C>
+      class serialization: public exception<C>
+      {
+      public:
+        virtual
+        ~serialization () throw ();
+
+        /**
+         * @brief Default constructor.
+         */
+        serialization ();
+
+        /**
+         * @brief Initialize an instance with a %list of %error conditions.
+         *
+         * @param d A %list of %error conditions.
+         */
+        serialization (const tree::diagnostics<C>& d);
+
+      public:
+        /**
+         * @brief Get the %list of %error conditions.
+         *
+         * @return The %list of %error conditions.
+         */
+        const tree::diagnostics<C>&
+        diagnostics () const
+        {
+          return diagnostics_;
+        }
+
+        /**
+         * @brief Get %exception description.
+         *
+         * @return A C %string describing the %exception.
+         */
+        virtual const char*
+        what () const throw ();
+
+      protected:
+        //@cond
+
+        virtual void
+        print (std::basic_ostream<C>&) const;
+
+        //@endcond
+
+      private:
+        tree::diagnostics<C> diagnostics_;
+      };
+
+
+      /**
+       * @brief Exception indicating that a prefix-namespace mapping was
+       * not provided.
+       *
+       * @nosubgrouping
+       */
+      template <typename C>
+      class no_prefix_mapping: public exception<C>
+      {
+      public:
+        virtual
+        ~no_prefix_mapping () throw ();
+
+        /**
+         * @brief Initialize an instance with the prefix for which the
+         * prefix-namespace mapping was not provided.
+         *
+         * @param prefix A prefix.
+         */
+        no_prefix_mapping (const std::basic_string<C>& prefix);
+
+      public:
+        /**
+         * @brief Get the prefix for which the prefix-namespace mapping was
+         * not provided.
+         *
+         * @return The prefix.
+         */
+        const std::basic_string<C>&
+        prefix () const
+        {
+          return prefix_;
+        }
+
+        /**
+         * @brief Get %exception description.
+         *
+         * @return A C %string describing the %exception.
+         */
+        virtual const char*
+        what () const throw ();
+
+      protected:
+        //@cond
+
+        virtual void
+        print (std::basic_ostream<C>&) const;
+
+        //@endcond
+
+      private:
+        std::basic_string<C> prefix_;
+      };
+
+
+      /**
+       * @brief Exception indicating that the size argument exceeds
+       * the capacity argument.
+       *
+       * See the buffer class for details.
+       *
+       * @nosubgrouping
+       */
+      template <typename C>
+      class bounds: public exception<C>
+      {
+      public:
+        /**
+         * @brief Get %exception description.
+         *
+         * @return A C %string describing the %exception.
+         */
+        virtual const char*
+        what () const throw ();
+
+      protected:
+        //@cond
+
+        virtual void
+        print (std::basic_ostream<C>&) const;
+
+        //@endcond
+      };
+    }
+  }
+}
+
+#include <xsd/cxx/tree/exceptions.txx>
+
+#endif  // XSD_CXX_TREE_EXCEPTIONS_HXX
diff --git src/base/include/xsd/cxx/tree/exceptions.txx src/base/include/xsd/cxx/tree/exceptions.txx
new file mode 100644
index 0000000..8262fce
--- /dev/null
+++ src/base/include/xsd/cxx/tree/exceptions.txx
@@ -0,0 +1,510 @@
+// file      : xsd/cxx/tree/exceptions.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#include <xsd/cxx/tree/bits/literals.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      // error
+      //
+      template <typename C>
+      error<C>::
+      error (tree::severity s,
+             const std::basic_string<C>& id,
+             unsigned long line,
+             unsigned long column,
+             const std::basic_string<C>& message)
+          : severity_ (s),
+            id_ (id),
+            line_ (line),
+            column_ (column),
+            message_ (message)
+      {
+      }
+
+      template <typename C>
+      error<C>::
+      error ()
+          : severity_ (tree::severity::error), line_ (0), column_ (0)
+      {
+      }
+
+      template <typename C>
+      std::basic_ostream<C>&
+      operator<< (std::basic_ostream<C>& os, const error<C>& e)
+      {
+        return os << e.id () << C (':') << e.line () << C (':') << e.column ()
+                  << (e.severity () == severity::error
+                      ? bits::ex_error_error<C> ()
+                      : bits::ex_error_warning<C> ()) << e.message ();
+      }
+
+      // diagnostics
+      //
+      template <typename C>
+      std::basic_ostream<C>&
+      operator<< (std::basic_ostream<C>& os, const diagnostics<C>& d)
+      {
+        for (typename diagnostics<C>::const_iterator b (d.begin ()), i (b);
+             i != d.end ();
+             ++i)
+        {
+          if (i != b)
+            os << C ('\n');
+
+          os << *i;
+        }
+
+        return os;
+      }
+
+      // parsing
+      //
+      template <typename C>
+      parsing<C>::
+      ~parsing () throw ()
+      {
+      }
+
+      template <typename C>
+      parsing<C>::
+      parsing ()
+      {
+      }
+
+      template <typename C>
+      parsing<C>::
+      parsing (const tree::diagnostics<C>& diagnostics)
+          : diagnostics_ (diagnostics)
+      {
+      }
+
+      template <typename C>
+      const char* parsing<C>::
+      what () const throw ()
+      {
+        return "instance document parsing failed";
+      }
+
+      template <typename C>
+      void parsing<C>::
+      print (std::basic_ostream<C>& os) const
+      {
+        if (diagnostics_.empty ())
+          os << bits::ex_parsing_msg<C> ();
+        else
+          os << diagnostics_;
+      }
+
+      // expected_element
+      //
+      template <typename C>
+      expected_element<C>::
+      ~expected_element () throw ()
+      {
+      }
+
+      template <typename C>
+      expected_element<C>::
+      expected_element (const std::basic_string<C>& name,
+                        const std::basic_string<C>& namespace_)
+          : name_ (name), namespace__ (namespace_)
+      {
+      }
+
+      template <typename C>
+      const char* expected_element<C>::
+      what () const throw ()
+      {
+        return "expected element not encountered";
+      }
+
+      template <typename C>
+      void expected_element<C>::
+      print (std::basic_ostream<C>& os) const
+      {
+        os << bits::ex_eel_expected<C> ();
+
+        if (!namespace_ ().empty ())
+          os << namespace_ () << C ('#');
+
+        os << name () << C ('\'');
+      }
+
+      // unexpected_element
+      //
+      template <typename C>
+      unexpected_element<C>::
+      ~unexpected_element () throw ()
+      {
+      }
+
+      template <typename C>
+      unexpected_element<C>::
+      unexpected_element (const std::basic_string<C>& encountered_name,
+                          const std::basic_string<C>& encountered_namespace,
+                          const std::basic_string<C>& expected_name,
+                          const std::basic_string<C>& expected_namespace)
+          : encountered_name_ (encountered_name),
+            encountered_namespace_ (encountered_namespace),
+            expected_name_ (expected_name),
+            expected_namespace_ (expected_namespace)
+      {
+      }
+
+      template <typename C>
+      const char* unexpected_element<C>::
+      what () const throw ()
+      {
+        return "unexpected element encountered";
+      }
+
+      template <typename C>
+      void unexpected_element<C>::
+      print (std::basic_ostream<C>& os) const
+      {
+        if (!expected_name ().empty ())
+        {
+          os << bits::ex_uel_expected<C> ();
+
+          if (!expected_namespace ().empty ())
+            os << expected_namespace () << C ('#');
+
+          os << expected_name () << bits::ex_uel_instead<C> ();
+
+          if (!encountered_namespace ().empty ())
+            os << encountered_namespace () << C ('#');
+
+          os << encountered_name () << C ('\'');
+        }
+        else
+        {
+          os << bits::ex_uel_unexpected<C> ();
+
+          if (!encountered_namespace ().empty ())
+            os << encountered_namespace () << C ('#');
+
+          os << encountered_name () << C ('\'');
+        }
+      }
+
+      // expected_attribute
+      //
+      template <typename C>
+      expected_attribute<C>::
+      ~expected_attribute () throw ()
+      {
+      }
+
+      template <typename C>
+      expected_attribute<C>::
+      expected_attribute (const std::basic_string<C>& name,
+                          const std::basic_string<C>& namespace_)
+          : name_ (name), namespace__ (namespace_)
+      {
+      }
+
+      template <typename C>
+      const char* expected_attribute<C>::
+      what () const throw ()
+      {
+        return "expected attribute not encountered";
+      }
+
+      template <typename C>
+      void expected_attribute<C>::
+      print (std::basic_ostream<C>& os) const
+      {
+        os << bits::ex_eat_expected<C> ();
+
+        if (!namespace_ ().empty ())
+          os << namespace_ () << C ('#');
+
+        os << name () << C ('\'');
+      }
+
+      // unexpected_enumerator
+      //
+      template <typename C>
+      unexpected_enumerator<C>::
+      ~unexpected_enumerator () throw ()
+      {
+      }
+
+      template <typename C>
+      unexpected_enumerator<C>::
+      unexpected_enumerator (const std::basic_string<C>& enumerator)
+          : enumerator_ (enumerator)
+      {
+      }
+
+      template <typename C>
+      const char* unexpected_enumerator<C>::
+      what () const throw ()
+      {
+        return "unexpected enumerator encountered";
+      }
+
+      template <typename C>
+      void unexpected_enumerator<C>::
+      print (std::basic_ostream<C>& os) const
+      {
+        os << bits::ex_uen_unexpected<C> () << enumerator () << C ('\'');
+      }
+
+      // expected_text_content
+      //
+      template <typename C>
+      const char* expected_text_content<C>::
+      what () const throw ()
+      {
+        return "expected text content";
+      }
+
+      template <typename C>
+      void expected_text_content<C>::
+      print (std::basic_ostream<C>& os) const
+      {
+        os << bits::ex_etc_msg<C> ();
+      }
+
+      // no_type_info
+      //
+      template <typename C>
+      no_type_info<C>::
+      ~no_type_info () throw ()
+      {
+      }
+
+      template <typename C>
+      no_type_info<C>::
+      no_type_info (const std::basic_string<C>& type_name,
+                    const std::basic_string<C>& type_namespace)
+          : type_name_ (type_name),
+            type_namespace_ (type_namespace)
+      {
+      }
+
+      template <typename C>
+      const char* no_type_info<C>::
+      what () const throw ()
+      {
+        return "no type information available for a type";
+      }
+
+      template <typename C>
+      void no_type_info<C>::
+      print (std::basic_ostream<C>& os) const
+      {
+        os << bits::ex_nti_no_type_info<C> ();
+
+        if (!type_namespace ().empty ())
+          os << type_namespace () << C ('#');
+
+        os << type_name () << C ('\'');
+      }
+
+      // no_element_info
+      //
+      template <typename C>
+      no_element_info<C>::
+      ~no_element_info () throw ()
+      {
+      }
+
+      template <typename C>
+      no_element_info<C>::
+      no_element_info (const std::basic_string<C>& element_name,
+                       const std::basic_string<C>& element_namespace)
+          : element_name_ (element_name),
+            element_namespace_ (element_namespace)
+      {
+      }
+
+      template <typename C>
+      const char* no_element_info<C>::
+      what () const throw ()
+      {
+        return "no parsing or serialization information available for "
+          "an element";
+      }
+
+      template <typename C>
+      void no_element_info<C>::
+      print (std::basic_ostream<C>& os) const
+      {
+        os << bits::ex_nei_no_element_info<C> ();
+
+        if (!element_namespace ().empty ())
+          os << element_namespace () << C ('#');
+
+        os << element_name () << C ('\'');
+      }
+
+      // not_derived
+      //
+      template <typename C>
+      not_derived<C>::
+      ~not_derived () throw ()
+      {
+      }
+
+      template <typename C>
+      not_derived<C>::
+      not_derived (const std::basic_string<C>& base_type_name,
+                   const std::basic_string<C>& base_type_namespace,
+                   const std::basic_string<C>& derived_type_name,
+                   const std::basic_string<C>& derived_type_namespace)
+          : base_type_name_ (base_type_name),
+            base_type_namespace_ (base_type_namespace),
+            derived_type_name_ (derived_type_name),
+            derived_type_namespace_ (derived_type_namespace)
+      {
+      }
+
+      template <typename C>
+      const char* not_derived<C>::
+      what () const throw ()
+      {
+        return "type is not derived";
+      }
+
+      template <typename C>
+      void not_derived<C>::
+      print (std::basic_ostream<C>& os) const
+      {
+        os << bits::ex_nd_type<C> ();
+
+        if (!derived_type_namespace ().empty ())
+          os << derived_type_namespace () << C ('#');
+
+        os << derived_type_name () << bits::ex_nd_not_derived<C> ();
+
+        if (!base_type_namespace ().empty ())
+          os << base_type_namespace () << C ('#');
+
+        os << base_type_name () << C ('\'');
+      }
+
+      // duplicate_id
+      //
+      template <typename C>
+      duplicate_id<C>::
+      ~duplicate_id () throw ()
+      {
+      }
+
+      template <typename C>
+      duplicate_id<C>::
+      duplicate_id (const std::basic_string<C>& id)
+          : id_ (id)
+      {
+      }
+
+      template <typename C>
+      const char* duplicate_id<C>::
+      what () const throw ()
+      {
+        return "ID already exist";
+      }
+
+      template <typename C>
+      void duplicate_id<C>::
+      print (std::basic_ostream<C>& os) const
+      {
+        os << bits::ex_di_id<C> () << id () << bits::ex_di_already_exist<C> ();
+      }
+
+      // serialization
+      //
+      template <typename C>
+      serialization<C>::
+      ~serialization () throw ()
+      {
+      }
+
+      template <typename C>
+      serialization<C>::
+      serialization ()
+      {
+      }
+
+      template <typename C>
+      serialization<C>::
+      serialization (const tree::diagnostics<C>& diagnostics)
+          : diagnostics_ (diagnostics)
+      {
+      }
+
+      template <typename C>
+      const char* serialization<C>::
+      what () const throw ()
+      {
+        return "serialization failed";
+      }
+
+      template <typename C>
+      void serialization<C>::
+      print (std::basic_ostream<C>& os) const
+      {
+        if (diagnostics_.empty ())
+          os << bits::ex_serialization_msg<C> ();
+        else
+          os << diagnostics_;
+      }
+
+
+      // no_prefix_mapping
+      //
+      template <typename C>
+      no_prefix_mapping<C>::
+      ~no_prefix_mapping () throw ()
+      {
+      }
+
+      template <typename C>
+      no_prefix_mapping<C>::
+      no_prefix_mapping (const std::basic_string<C>& prefix)
+          : prefix_ (prefix)
+      {
+      }
+
+      template <typename C>
+      const char* no_prefix_mapping<C>::
+      what () const throw ()
+      {
+        return "no mapping provided for a namespace prefix";
+      }
+
+      template <typename C>
+      void no_prefix_mapping<C>::
+      print (std::basic_ostream<C>& os) const
+      {
+        os << bits::ex_npm_no_mapping<C> () << prefix () << C ('\'');
+      }
+
+
+      // bounds
+      //
+      template <typename C>
+      const char* bounds<C>::
+      what () const throw ()
+      {
+        return "buffer boundary rules have been violated";
+      }
+
+      template <typename C>
+      void bounds<C>::
+      print (std::basic_ostream<C>& os) const
+      {
+        os << bits::ex_bounds_msg<C> ();
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/tree/facet.hxx src/base/include/xsd/cxx/tree/facet.hxx
new file mode 100644
index 0000000..c4fbcbe
--- /dev/null
+++ src/base/include/xsd/cxx/tree/facet.hxx
@@ -0,0 +1,43 @@
+// file      : xsd/cxx/tree/facet.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_FACET_HXX
+#define XSD_CXX_TREE_FACET_HXX
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      // We need to keep this type POD in order to be able to create a
+      // static array.
+      //
+      struct facet
+      {
+        enum id_type
+        {
+          none,
+          total_digits,
+          fraction_digits
+        };
+
+        id_type id;
+        unsigned long value;
+
+        static const facet*
+        find (const facet* facets, facet::id_type id)
+        {
+          while (facets->id != id && facets->id != none)
+            ++facets;
+
+          return facets->id != none ? facets : 0;
+        }
+      };
+    }
+  }
+}
+
+#endif  // XSD_CXX_TREE_FACET_HXX
diff --git src/base/include/xsd/cxx/tree/istream-fwd.hxx src/base/include/xsd/cxx/tree/istream-fwd.hxx
new file mode 100644
index 0000000..a523952
--- /dev/null
+++ src/base/include/xsd/cxx/tree/istream-fwd.hxx
@@ -0,0 +1,21 @@
+// file      : xsd/cxx/tree/istream-fwd.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_ISTREAM_FWD_HXX
+#define XSD_CXX_TREE_ISTREAM_FWD_HXX
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      template<typename S>
+      class istream;
+    }
+  }
+}
+
+#endif  // XSD_CXX_TREE_ISTREAM_FWD_HXX
diff --git src/base/include/xsd/cxx/tree/istream.hxx src/base/include/xsd/cxx/tree/istream.hxx
new file mode 100644
index 0000000..2f8f8cb
--- /dev/null
+++ src/base/include/xsd/cxx/tree/istream.hxx
@@ -0,0 +1,258 @@
+// file      : xsd/cxx/tree/istream.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_ISTREAM_HXX
+#define XSD_CXX_TREE_ISTREAM_HXX
+
+#include <cstddef> // std::size_t
+
+#include <xsd/cxx/tree/istream-fwd.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      class istream_common
+      {
+      public:
+        template <typename T>
+        struct as_size
+        {
+          explicit as_size (T& x) : x_ (x) {}
+          T& x_;
+        };
+
+
+        // 8-bit
+        //
+        template <typename T>
+        struct as_int8
+        {
+          explicit as_int8 (T& x) : x_ (x) {}
+          T& x_;
+        };
+
+        template <typename T>
+        struct as_uint8
+        {
+          explicit as_uint8 (T& x) : x_ (x) {}
+          T& x_;
+        };
+
+
+        // 16-bit
+        //
+        template <typename T>
+        struct as_int16
+        {
+          explicit as_int16 (T& x) : x_ (x) {}
+          T& x_;
+        };
+
+        template <typename T>
+        struct as_uint16
+        {
+          explicit as_uint16 (T& x) : x_ (x) {}
+          T& x_;
+        };
+
+
+        // 32-bit
+        //
+        template <typename T>
+        struct as_int32
+        {
+          explicit as_int32 (T& x) : x_ (x) {}
+          T& x_;
+        };
+
+        template <typename T>
+        struct as_uint32
+        {
+          explicit as_uint32 (T& x) : x_ (x) {}
+          T& x_;
+        };
+
+
+        // 64-bit
+        //
+        template <typename T>
+        struct as_int64
+        {
+          explicit as_int64 (T& x) : x_ (x) {}
+          T& x_;
+        };
+
+        template <typename T>
+        struct as_uint64
+        {
+          explicit as_uint64 (T& x) : x_ (x) {}
+          T& x_;
+        };
+
+
+        // Boolean
+        //
+        template <typename T>
+        struct as_bool
+        {
+          explicit as_bool (T& x) : x_ (x) {}
+          T& x_;
+        };
+
+
+        // Floating-point
+        //
+        template <typename T>
+        struct as_float32
+        {
+          explicit as_float32 (T& x) : x_ (x) {}
+          T& x_;
+        };
+
+        template <typename T>
+        struct as_float64
+        {
+          explicit as_float64 (T& x) : x_ (x) {}
+          T& x_;
+        };
+      };
+
+      template<typename S>
+      class istream: public istream_common
+      {
+      public:
+        explicit
+        istream (S& s)
+            : s_ (s)
+        {
+        }
+
+        S&
+        impl ()
+        {
+          return s_;
+        }
+
+      private:
+        istream (const istream&);
+        istream&
+        operator= (const istream&);
+
+      private:
+        S& s_;
+      };
+
+
+      // 8-bit
+      //
+      template <typename S>
+      inline istream<S>&
+      operator>> (istream<S>& s, signed char& x)
+      {
+        istream_common::as_int8<signed char> as_int8 (x);
+        return s >> as_int8;
+      }
+
+      template <typename S>
+      inline istream<S>&
+      operator>> (istream<S>& s, unsigned char& x)
+      {
+        istream_common::as_uint8<unsigned char> as_uint8 (x);
+        return s >> as_uint8;
+      }
+
+
+      // 16-bit
+      //
+      template <typename S>
+      inline istream<S>&
+      operator>> (istream<S>& s, short& x)
+      {
+        istream_common::as_int16<short> as_int16 (x);
+        return s >> as_int16;
+      }
+
+      template <typename S>
+      inline istream<S>&
+      operator>> (istream<S>& s, unsigned short& x)
+      {
+        istream_common::as_uint16<unsigned short> as_uint16 (x);
+        return s >> as_uint16;
+      }
+
+
+      // 32-bit
+      //
+      template <typename S>
+      inline istream<S>&
+      operator>> (istream<S>& s, int& x)
+      {
+        istream_common::as_int32<int> as_int32 (x);
+        return s >> as_int32;
+      }
+
+      template <typename S>
+      inline istream<S>&
+      operator>> (istream<S>& s, unsigned int& x)
+      {
+        istream_common::as_uint32<unsigned int> as_uint32 (x);
+        return s >> as_uint32;
+      }
+
+
+      // 64-bit
+      //
+      template <typename S>
+      inline istream<S>&
+      operator>> (istream<S>& s, long long& x)
+      {
+        istream_common::as_int64<long long> as_int64 (x);
+        return s >> as_int64;
+      }
+
+      template <typename S>
+      inline istream<S>&
+      operator>> (istream<S>& s, unsigned long long& x)
+      {
+        istream_common::as_uint64<unsigned long long> as_uint64 (x);
+        return s >> as_uint64;
+      }
+
+      // Boolean
+      //
+      template <typename S>
+      inline istream<S>&
+      operator>> (istream<S>& s, bool& x)
+      {
+        istream_common::as_bool<bool> as_bool (x);
+        return s >> as_bool;
+      }
+
+
+      // Floating-point
+      //
+      template <typename S>
+      inline istream<S>&
+      operator>> (istream<S>& s, float& x)
+      {
+        istream_common::as_float32<float> as_float32 (x);
+        return s >> as_float32;
+      }
+
+      template <typename S>
+      inline istream<S>&
+      operator>> (istream<S>& s, double& x)
+      {
+        istream_common::as_float64<double> as_float64 (x);
+        return s >> as_float64;
+      }
+    }
+  }
+}
+
+#endif  // XSD_CXX_TREE_ISTREAM_HXX
diff --git src/base/include/xsd/cxx/tree/list.hxx src/base/include/xsd/cxx/tree/list.hxx
new file mode 100644
index 0000000..30636e9
--- /dev/null
+++ src/base/include/xsd/cxx/tree/list.hxx
@@ -0,0 +1,134 @@
+// file      : xsd/cxx/tree/list.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_LIST_HXX
+#define XSD_CXX_TREE_LIST_HXX
+
+#include <string>
+
+#include <xercesc/dom/DOMAttr.hpp>
+#include <xercesc/dom/DOMElement.hpp>
+
+#include <xsd/cxx/tree/elements.hxx> // tree::istream
+#include <xsd/cxx/tree/istream-fwd.hxx> // tree::istream
+#include <xsd/cxx/tree/containers.hxx>  // fundamental_p, sequence
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      // Class template for xsd:list mapping. Based on the sequence
+      // template. Note that I cannot get rid of 'fund' because HP
+      // aCC3 likes it this way.
+      //
+      template <typename T,
+                typename C,
+                schema_type::value ST = schema_type::other,
+                bool fund = fundamental_p<T>::r>
+      class list;
+
+
+      //
+      //
+      template <typename T, typename C, schema_type::value ST>
+      class list<T, C, ST, false>: public sequence<T>
+      {
+      public:
+        explicit
+        list (flags f = 0, container* c = 0)
+            : sequence<T> (f, c)
+        {
+        }
+
+        list (typename sequence<T>::size_type n,
+              const T& x,
+              container* c = 0)
+            : sequence<T> (n, x, c)
+        {
+        }
+
+        template<typename I>
+        list (const I& b, const I& e, container* c = 0)
+            : sequence<T> (b, e, c)
+        {
+        }
+
+        template <typename S>
+        list (istream<S>&, flags = 0, container* c = 0);
+
+        list (const list<T, C, ST, false>& v, flags f = 0, container* c = 0)
+            : sequence<T> (v, f, c)
+        {
+        }
+
+      public:
+        list (const xercesc::DOMElement&, flags = 0, container* c = 0);
+
+        list (const xercesc::DOMAttr&, flags = 0, container* c = 0);
+
+        list (const std::basic_string<C>&,
+              const xercesc::DOMElement*,
+              flags = 0,
+              container* c = 0);
+
+      private:
+        void
+        init (const std::basic_string<C>&, const xercesc::DOMElement*);
+      };
+
+
+      //
+      //
+      template <typename T, typename C, schema_type::value ST>
+      class list<T, C, ST, true>: public sequence<T>
+      {
+      public:
+        explicit
+        list (flags f = 0, container* c = 0)
+            : sequence<T> (f, c)
+        {
+        }
+
+        explicit
+        list (typename sequence<T>::size_type n, const T& x, container* c = 0)
+            : sequence<T> (n, x, c)
+        {
+        }
+
+        template<typename I>
+        list (const I& b, const I& e, container* c = 0)
+            : sequence<T> (b, e, c)
+        {
+        }
+
+        template <typename S>
+        list (istream<S>&, flags = 0, container* c = 0);
+
+        list (const list<T, C, ST, true>& s, flags f = 0, container* c = 0)
+            : sequence<T> (s, f, c)
+        {
+        }
+
+      public:
+        list (const xercesc::DOMElement&, flags = 0, container* c = 0);
+
+        list (const xercesc::DOMAttr&, flags = 0, container* c = 0);
+
+        list (const std::basic_string<C>&,
+              const xercesc::DOMElement*,
+              flags = 0,
+              container* c = 0);
+
+      private:
+        void
+        init (const std::basic_string<C>&, const xercesc::DOMElement*);
+      };
+    }
+  }
+}
+
+#endif // XSD_CXX_TREE_LIST_HXX
diff --git src/base/include/xsd/cxx/tree/ostream.hxx src/base/include/xsd/cxx/tree/ostream.hxx
new file mode 100644
index 0000000..cf2d9ee
--- /dev/null
+++ src/base/include/xsd/cxx/tree/ostream.hxx
@@ -0,0 +1,245 @@
+// file      : xsd/cxx/tree/ostream.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_OSTREAM_HXX
+#define XSD_CXX_TREE_OSTREAM_HXX
+
+#include <cstddef> // std::size_t
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      class ostream_common
+      {
+      public:
+        template <typename T>
+        struct as_size
+        {
+          explicit as_size (T x) : x_ (x) {}
+          T x_;
+        };
+
+
+        // 8-bit
+        //
+        template <typename T>
+        struct as_int8
+        {
+          explicit as_int8 (T x) : x_ (x) {}
+          T x_;
+        };
+
+        template <typename T>
+        struct as_uint8
+        {
+          explicit as_uint8 (T x) : x_ (x) {}
+          T x_;
+        };
+
+
+        // 16-bit
+        //
+        template <typename T>
+        struct as_int16
+        {
+          explicit as_int16 (T x) : x_ (x) {}
+          T x_;
+        };
+
+        template <typename T>
+        struct as_uint16
+        {
+          explicit as_uint16 (T x) : x_ (x) {}
+          T x_;
+        };
+
+
+        // 32-bit
+        //
+        template <typename T>
+        struct as_int32
+        {
+          explicit as_int32 (T x) : x_ (x) {}
+          T x_;
+        };
+
+        template <typename T>
+        struct as_uint32
+        {
+          explicit as_uint32 (T x) : x_ (x) {}
+          T x_;
+        };
+
+
+        // 64-bit
+        //
+        template <typename T>
+        struct as_int64
+        {
+          explicit as_int64 (T x) : x_ (x) {}
+          T x_;
+        };
+
+        template <typename T>
+        struct as_uint64
+        {
+          explicit as_uint64 (T x) : x_ (x) {}
+          T x_;
+        };
+
+
+        // Boolean
+        //
+        template <typename T>
+        struct as_bool
+        {
+          explicit as_bool (T x) : x_ (x) {}
+          T x_;
+        };
+
+
+        // Floating-point
+        //
+        template <typename T>
+        struct as_float32
+        {
+          explicit as_float32 (T x) : x_ (x) {}
+          T x_;
+        };
+
+        template <typename T>
+        struct as_float64
+        {
+          explicit as_float64 (T x) : x_ (x) {}
+          T x_;
+        };
+      };
+
+      template<typename S>
+      class ostream: public ostream_common
+      {
+      public:
+        explicit
+        ostream (S& s)
+            : s_ (s)
+        {
+        }
+
+        S&
+        impl ()
+        {
+          return s_;
+        }
+
+      private:
+        ostream (const ostream&);
+        ostream&
+        operator= (const ostream&);
+
+      private:
+        S& s_;
+      };
+
+
+      // 8-bit
+      //
+      template <typename S>
+      inline ostream<S>&
+      operator<< (ostream<S>& s, signed char x)
+      {
+        return s << ostream_common::as_int8<signed char> (x);
+      }
+
+      template <typename S>
+      inline ostream<S>&
+      operator<< (ostream<S>& s, unsigned char x)
+      {
+        return s << ostream_common::as_uint8<unsigned char> (x);
+      }
+
+
+      // 16-bit
+      //
+      template <typename S>
+      inline ostream<S>&
+      operator<< (ostream<S>& s, short x)
+      {
+        return s << ostream_common::as_int16<short> (x);
+      }
+
+      template <typename S>
+      inline ostream<S>&
+      operator<< (ostream<S>& s, unsigned short x)
+      {
+        return s << ostream_common::as_uint16<unsigned short> (x);
+      }
+
+
+      // 32-bit
+      //
+      template <typename S>
+      inline ostream<S>&
+      operator<< (ostream<S>& s, int x)
+      {
+        return s << ostream_common::as_int32<int> (x);
+      }
+
+      template <typename S>
+      inline ostream<S>&
+      operator<< (ostream<S>& s, unsigned int x)
+      {
+        return s << ostream_common::as_uint32<unsigned int> (x);
+      }
+
+
+      // 64-bit
+      //
+      template <typename S>
+      inline ostream<S>&
+      operator<< (ostream<S>& s, long long x)
+      {
+        return s << ostream_common::as_int64<long long> (x);
+      }
+
+      template <typename S>
+      inline ostream<S>&
+      operator<< (ostream<S>& s, unsigned long long x)
+      {
+        return s << ostream_common::as_uint64<unsigned long long> (x);
+      }
+
+      // Boolean
+      //
+      template <typename S>
+      inline ostream<S>&
+      operator<< (ostream<S>& s, bool x)
+      {
+        return s << ostream_common::as_bool<bool> (x);
+      }
+
+
+      // Floating-point
+      //
+      template <typename S>
+      inline ostream<S>&
+      operator<< (ostream<S>& s, float x)
+      {
+        return s << ostream_common::as_float32<float> (x);
+      }
+
+      template <typename S>
+      inline ostream<S>&
+      operator<< (ostream<S>& s, double x)
+      {
+        return s << ostream_common::as_float64<double> (x);
+      }
+    }
+  }
+}
+
+#endif  // XSD_CXX_TREE_OSTREAM_HXX
diff --git src/base/include/xsd/cxx/tree/parsing.hxx src/base/include/xsd/cxx/tree/parsing.hxx
new file mode 100644
index 0000000..84b3898
--- /dev/null
+++ src/base/include/xsd/cxx/tree/parsing.hxx
@@ -0,0 +1,12 @@
+// file      : xsd/cxx/tree/parsing.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_PARSING_HXX
+#define XSD_CXX_TREE_PARSING_HXX
+
+#include <xsd/cxx/tree/parsing.txx>
+#include <xsd/cxx/tree/parsing/date-time.txx>
+
+#endif  // XSD_CXX_TREE_PARSING_HXX
diff --git src/base/include/xsd/cxx/tree/parsing.txx src/base/include/xsd/cxx/tree/parsing.txx
new file mode 100644
index 0000000..db50775
--- /dev/null
+++ src/base/include/xsd/cxx/tree/parsing.txx
@@ -0,0 +1,914 @@
+// file      : xsd/cxx/tree/parsing.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#include <string>
+
+#include <xsd/cxx/ro-string.hxx>         // trim
+
+#include <xsd/cxx/xml/string.hxx>        // xml::{string, transcode}
+#include <xsd/cxx/xml/elements.hxx>      // xml::{prefix, uq_name}
+#include <xsd/cxx/xml/bits/literals.hxx> // xml::bits::{xml_prefix,
+                                         //             xml_namespace}
+
+#include <xsd/cxx/tree/exceptions.hxx>   // no_prefix_mapping
+#include <xsd/cxx/tree/elements.hxx>
+#include <xsd/cxx/tree/types.hxx>
+#include <xsd/cxx/tree/list.hxx>
+#include <xsd/cxx/tree/text.hxx>         // text_content
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      // Note that most of the types implemented here (except string,
+      // (normalizedString, and base64Binary) cannot have whitespaces
+      // in the value. As result we don't need to waste time collapsing
+      // whitespaces. All we need to do is trim the string representation
+      // which can be done without copying.
+      //
+
+      // type
+      //
+      inline _type::
+      _type (const xercesc::DOMElement& e, flags f, container* c)
+          : dom_info_ (0), container_ (c)
+      {
+        if (f & flags::keep_dom)
+        {
+          std::auto_ptr<dom_info> r (
+            dom_info_factory::create (e, *this, c == 0));
+          dom_info_ = r;
+        }
+      }
+
+      inline _type::
+      _type (const xercesc::DOMAttr& a, flags f, container* c)
+          : dom_info_ (0), container_ (c)
+      {
+        if (f & flags::keep_dom)
+        {
+          std::auto_ptr<dom_info> r (dom_info_factory::create (a, *this));
+          dom_info_ = r;
+        }
+      }
+
+      template <typename C>
+      inline _type::
+      _type (const std::basic_string<C>&,
+             const xercesc::DOMElement*,
+             flags,
+             container* c)
+          : dom_info_ (0), // List elements don't have associated DOM nodes.
+            container_ (c)
+      {
+      }
+
+      // simple_type
+      //
+      template <typename B>
+      inline simple_type<B>::
+      simple_type (const xercesc::DOMElement& e, flags f, container* c)
+          : B (e, f, c)
+      {
+      }
+
+      template <typename B>
+      inline simple_type<B>::
+      simple_type (const xercesc::DOMAttr& a, flags f, container* c)
+          : B (a, f, c)
+      {
+      }
+
+      template <typename B>
+      template <typename C>
+      inline simple_type<B>::
+      simple_type (const std::basic_string<C>& s,
+                   const xercesc::DOMElement* e,
+                   flags f,
+                   container* c)
+          : B (s, e, f, c)
+      {
+      }
+
+      // fundamental_base
+      //
+      template <typename T, typename C, typename B, schema_type::value ST>
+      fundamental_base<T, C, B, ST>::
+      fundamental_base (const xercesc::DOMElement& e, flags f, container* c)
+          : B (e, f, c),
+            facet_table_ (0),
+            x_ (traits<T, C, ST>::create (e, f, c))
+      {
+      }
+
+      template <typename T, typename C, typename B, schema_type::value ST>
+      fundamental_base<T, C, B, ST>::
+      fundamental_base (const xercesc::DOMAttr& a, flags f, container* c)
+          : B (a, f, c),
+            facet_table_ (0),
+            x_ (traits<T, C, ST>::create (a, f, c))
+      {
+      }
+
+      template <typename T, typename C, typename B, schema_type::value ST>
+      fundamental_base<T, C, B, ST>::
+      fundamental_base (const std::basic_string<C>& s,
+                        const xercesc::DOMElement* e,
+                        flags f,
+                        container* c)
+          : B (s, e, f, c),
+            facet_table_ (0),
+            x_ (traits<T, C, ST>::create (s, e, f, c))
+      {
+      }
+
+
+      // Parsing c-tors for list.
+      //
+
+      namespace bits
+      {
+        // Find first non-space character.
+        //
+        template <typename C>
+        typename std::basic_string<C>::size_type
+        find_ns (const C* s,
+                 typename std::basic_string<C>::size_type size,
+                 typename std::basic_string<C>::size_type pos)
+        {
+          while (pos < size &&
+                 (s[pos] == C (0x20) || // space
+                  s[pos] == C (0x0D) || // carriage return
+                  s[pos] == C (0x09) || // tab
+                  s[pos] == C (0x0A)))
+            ++pos;
+
+          return pos < size ? pos : std::basic_string<C>::npos;
+        }
+
+        // Find first space character.
+        //
+        template <typename C>
+        typename std::basic_string<C>::size_type
+        find_s (const C* s,
+                typename std::basic_string<C>::size_type size,
+                typename std::basic_string<C>::size_type pos)
+        {
+          while (pos < size &&
+                 s[pos] != C (0x20) && // space
+                 s[pos] != C (0x0D) && // carriage return
+                 s[pos] != C (0x09) && // tab
+                 s[pos] != C (0x0A))
+            ++pos;
+
+          return pos < size ? pos : std::basic_string<C>::npos;
+        }
+      }
+
+      // Individual items of the list have no DOM association. Therefore
+      // I clear keep_dom from flags.
+      //
+
+      template <typename T, typename C, schema_type::value ST>
+      list<T, C, ST, false>::
+      list (const xercesc::DOMElement& e, flags f, container* c)
+          : sequence<T> (flags (f & ~flags::keep_dom), c) // ambiguous
+      {
+        init (text_content<C> (e), &e);
+      }
+
+      template <typename T, typename C, schema_type::value ST>
+      list<T, C, ST, false>::
+      list (const xercesc::DOMAttr& a, flags f, container* c)
+          : sequence<T> (flags (f & ~flags::keep_dom), c) // ambiguous
+      {
+        init (xml::transcode<C> (a.getValue ()), a.getOwnerElement ());
+      }
+
+      template <typename T, typename C, schema_type::value ST>
+      list<T, C, ST, false>::
+      list (const std::basic_string<C>& s,
+            const xercesc::DOMElement* e,
+            flags f,
+            container* c)
+          : sequence<T> (flags (f & ~flags::keep_dom), c) // ambiguous
+      {
+        init (s, e);
+      }
+
+      template <typename T, typename C, schema_type::value ST>
+      void list<T, C, ST, false>::
+      init (const std::basic_string<C>& s, const xercesc::DOMElement* parent)
+      {
+        if (s.size () == 0)
+          return;
+
+        using std::basic_string;
+        typedef typename sequence<T>::ptr ptr;
+        typedef typename basic_string<C>::size_type size_type;
+
+        const C* data (s.c_str ());
+        size_type size (s.size ());
+
+        // Traverse the data while logically collapsing spaces.
+        //
+        for (size_type i (bits::find_ns<C> (data, size, 0));
+             i != basic_string<C>::npos;)
+        {
+          size_type j (bits::find_s (data, size, i));
+
+          if (j != basic_string<C>::npos)
+          {
+            ptr r (
+              new T (basic_string<C> (data + i, j - i),
+                     parent,
+                     this->flags_,
+                     this->container_));
+
+            this->v_.push_back (r);
+
+            i = bits::find_ns (data, size, j);
+          }
+          else
+          {
+            // Last element.
+            //
+            ptr r (
+              new T (basic_string<C> (data + i, size - i),
+                     parent,
+                     this->flags_,
+                     this->container_));
+
+            this->v_.push_back (r);
+
+            break;
+          }
+        }
+      }
+
+      template <typename T, typename C, schema_type::value ST>
+      list<T, C, ST, true>::
+      list (const xercesc::DOMElement& e, flags f, container* c)
+          : sequence<T> (flags (f & ~flags::keep_dom), c) // ambiguous
+      {
+        init (text_content<C> (e), &e);
+      }
+
+      template <typename T, typename C, schema_type::value ST>
+      inline list<T, C, ST, true>::
+      list (const xercesc::DOMAttr& a, flags f, container* c)
+          : sequence<T> (flags (f & ~flags::keep_dom), c) // ambiguous
+      {
+        init (xml::transcode<C> (a.getValue ()), a.getOwnerElement ());
+      }
+
+      template <typename T, typename C, schema_type::value ST>
+      inline list<T, C, ST, true>::
+      list (const std::basic_string<C>& s,
+            const xercesc::DOMElement* parent,
+            flags f,
+            container* c)
+          : sequence<T> (flags (f & ~flags::keep_dom), c) // ambiguous
+      {
+        init (s, parent);
+      }
+
+      template <typename T, typename C, schema_type::value ST>
+      inline void list<T, C, ST, true>::
+      init (const std::basic_string<C>& s, const xercesc::DOMElement* parent)
+      {
+        if (s.size () == 0)
+          return;
+
+        using std::basic_string;
+        typedef typename basic_string<C>::size_type size_type;
+
+        const C* data (s.c_str ());
+        size_type size (s.size ());
+
+        // Traverse the data while logically collapsing spaces.
+        //
+        for (size_type i (bits::find_ns<C> (data, size, 0));
+             i != basic_string<C>::npos;)
+        {
+          size_type j (bits::find_s (data, size, i));
+
+          if (j != basic_string<C>::npos)
+          {
+            this->push_back (
+              traits<T, C, ST>::create (
+                basic_string<C> (data + i, j - i), parent, 0, 0));
+
+            i = bits::find_ns (data, size, j);
+          }
+          else
+          {
+            // Last element.
+            //
+            this->push_back (
+              traits<T, C, ST>::create (
+                basic_string<C> (data + i, size - i), parent, 0, 0));
+
+            break;
+          }
+        }
+      }
+
+
+      // Parsing c-tors for built-in types.
+      //
+
+
+      // string
+      //
+      template <typename C, typename B>
+      string<C, B>::
+      string (const xercesc::DOMElement& e, flags f, container* c)
+          : B (e, f, c),
+            base_type (text_content<C> (e))
+      {
+      }
+
+      template <typename C, typename B>
+      string<C, B>::
+      string (const xercesc::DOMAttr& a, flags f, container* c)
+          : B (a, f, c),
+            base_type (xml::transcode<C> (a.getValue ()))
+      {
+      }
+
+      template <typename C, typename B>
+      string<C, B>::
+      string (const std::basic_string<C>& s,
+              const xercesc::DOMElement* e,
+              flags f,
+              container* c)
+          : B (s, e, f, c), base_type (s)
+      {
+      }
+
+
+      // normalized_string
+      //
+      template <typename C, typename B>
+      normalized_string<C, B>::
+      normalized_string (const xercesc::DOMElement& e, flags f, container* c)
+          : base_type (e, f, c)
+      {
+        normalize ();
+      }
+
+      template <typename C, typename B>
+      normalized_string<C, B>::
+      normalized_string (const xercesc::DOMAttr& a, flags f, container* c)
+          : base_type (a, f, c)
+      {
+        normalize ();
+      }
+
+      template <typename C, typename B>
+      normalized_string<C, B>::
+      normalized_string (const std::basic_string<C>& s,
+                         const xercesc::DOMElement* e,
+                         flags f,
+                         container* c)
+          : base_type (s, e, f, c)
+      {
+        normalize ();
+      }
+
+      template <typename C, typename B>
+      void normalized_string<C, B>::
+      normalize ()
+      {
+        typedef typename std::basic_string<C>::size_type size_type;
+
+        size_type size (this->size ());
+
+        for (size_type i (0); i < size; ++i)
+        {
+          C& c ((*this)[i]);
+
+          if (c == C (0x0D) || // carriage return
+              c == C (0x09) || // tab
+              c == C (0x0A))
+            c = C (0x20);
+        }
+      }
+
+
+      // token
+      //
+      template <typename C, typename B>
+      token<C, B>::
+      token (const xercesc::DOMElement& e, flags f, container* c)
+          : base_type (e, f, c)
+      {
+        collapse ();
+      }
+
+      template <typename C, typename B>
+      token<C, B>::
+      token (const xercesc::DOMAttr& a, flags f, container* c)
+          : base_type (a, f, c)
+      {
+        collapse ();
+      }
+
+      template <typename C, typename B>
+      token<C, B>::
+      token (const std::basic_string<C>& s,
+             const xercesc::DOMElement* e,
+             flags f,
+             container* c)
+          : base_type (s, e, f, c)
+      {
+        collapse ();
+      }
+
+      template <typename C, typename B>
+      void token<C, B>::
+      collapse ()
+      {
+        // We have all whitespace normilized by our base. We just
+        // need to collapse them.
+        //
+        typedef typename std::basic_string<C>::size_type size_type;
+
+        size_type size (this->size ()), j (0);
+        bool subs (false), trim (true);
+
+        for (size_type i (0); i < size; ++i)
+        {
+          C c ((*this)[i]);
+
+          if (c == C (0x20))
+          {
+            subs = true;
+          }
+          else
+          {
+            if (subs)
+            {
+              subs = false;
+
+              if (!trim)
+                (*this)[j++] = C (0x20);
+            }
+
+            if (trim)
+              trim = false;
+
+            (*this)[j++] = c;
+          }
+        }
+
+        this->resize (j);
+      }
+
+
+      // nmtoken
+      //
+      template <typename C, typename B>
+      nmtoken<C, B>::
+      nmtoken (const xercesc::DOMElement& e, flags f, container* c)
+          : base_type (e, f, c)
+      {
+      }
+
+      template <typename C, typename B>
+      nmtoken<C, B>::
+      nmtoken (const xercesc::DOMAttr& a, flags f, container* c)
+          : base_type (a, f, c)
+      {
+      }
+
+      template <typename C, typename B>
+      nmtoken<C, B>::
+      nmtoken (const std::basic_string<C>& s,
+               const xercesc::DOMElement* e,
+               flags f,
+               container* c)
+          : base_type (s, e, f, c)
+      {
+      }
+
+
+      // nmtokens
+      //
+      template <typename C, typename B, typename nmtoken>
+      nmtokens<C, B, nmtoken>::
+      nmtokens (const xercesc::DOMElement& e, flags f, container* c)
+          : B (e, f, c), base_type (e, f, this)
+      {
+      }
+
+      template <typename C, typename B, typename nmtoken>
+      nmtokens<C, B, nmtoken>::
+      nmtokens (const xercesc::DOMAttr& a, flags f, container* c)
+          : B (a, f, c), base_type (a, f, this)
+      {
+      }
+
+      template <typename C, typename B, typename nmtoken>
+      nmtokens<C, B, nmtoken>::
+      nmtokens (const std::basic_string<C>& s,
+                const xercesc::DOMElement* e,
+                flags f,
+                container* c)
+          : B (s, e, f, c), base_type (s, e, f, this)
+      {
+      }
+
+
+      // name
+      //
+      template <typename C, typename B>
+      name<C, B>::
+      name (const xercesc::DOMElement& e, flags f, container* c)
+          : base_type (e, f, c)
+      {
+      }
+
+      template <typename C, typename B>
+      name<C, B>::
+      name (const xercesc::DOMAttr& a, flags f, container* c)
+          : base_type (a, f, c)
+      {
+      }
+
+      template <typename C, typename B>
+      name<C, B>::
+      name (const std::basic_string<C>& s,
+            const xercesc::DOMElement* e,
+            flags f,
+            container* c)
+          : base_type (s, e, f, c)
+      {
+      }
+
+
+      // ncname
+      //
+      template <typename C, typename B>
+      ncname<C, B>::
+      ncname (const xercesc::DOMElement& e, flags f, container* c)
+          : base_type (e, f, c)
+      {
+      }
+
+      template <typename C, typename B>
+      ncname<C, B>::
+      ncname (const xercesc::DOMAttr& a, flags f, container* c)
+          : base_type (a, f, c)
+      {
+      }
+
+      template <typename C, typename B>
+      ncname<C, B>::
+      ncname (const std::basic_string<C>& s,
+              const xercesc::DOMElement* e,
+              flags f,
+              container* c)
+          : base_type (s, e, f, c)
+      {
+      }
+
+
+      // language
+      //
+      template <typename C, typename B>
+      language<C, B>::
+      language (const xercesc::DOMElement& e, flags f, container* c)
+          : base_type (e, f, c)
+      {
+      }
+
+      template <typename C, typename B>
+      language<C, B>::
+      language (const xercesc::DOMAttr& a, flags f, container* c)
+          : base_type (a, f, c)
+      {
+      }
+
+      template <typename C, typename B>
+      language<C, B>::
+      language (const std::basic_string<C>& s,
+                const xercesc::DOMElement* e,
+                flags f,
+                container* c)
+          : base_type (s, e, f, c)
+      {
+      }
+
+
+      // id
+      //
+      template <typename C, typename B>
+      id<C, B>::
+      id (const xercesc::DOMElement& e, flags f, container* c)
+          : base_type (e, f, c), identity_ (*this)
+      {
+        register_id ();
+      }
+
+      template <typename C, typename B>
+      id<C, B>::
+      id (const xercesc::DOMAttr& a, flags f, container* c)
+          : base_type (a, f, c), identity_ (*this)
+      {
+        register_id ();
+      }
+
+      template <typename C, typename B>
+      id<C, B>::
+      id (const std::basic_string<C>& s,
+          const xercesc::DOMElement* e,
+          flags f,
+          container* c)
+          : base_type (s, e, f, c), identity_ (*this)
+      {
+        register_id ();
+      }
+
+
+      // idref
+      //
+      template <typename C, typename B, typename T>
+      idref<C, B, T>::
+      idref (const xercesc::DOMElement& e, flags f, container* c)
+          : base_type (e, f, c), identity_ (*this)
+      {
+      }
+
+      template <typename C, typename B, typename T>
+      idref<C, B, T>::
+      idref (const xercesc::DOMAttr& a, flags f, container* c)
+          : base_type (a, f , c), identity_ (*this)
+      {
+      }
+
+      template <typename C, typename B, typename T>
+      idref<C, B, T>::
+      idref (const std::basic_string<C>& s,
+             const xercesc::DOMElement* e,
+             flags f,
+             container* c)
+          : base_type (s, e, f, c), identity_ (*this)
+      {
+      }
+
+
+      // idrefs
+      //
+      template <typename C, typename B, typename idref>
+      idrefs<C, B, idref>::
+      idrefs (const xercesc::DOMElement& e, flags f, container* c)
+          : B (e, f, c), base_type (e, f, this)
+      {
+      }
+
+      template <typename C, typename B, typename idref>
+      idrefs<C, B, idref>::
+      idrefs (const xercesc::DOMAttr& a, flags f, container* c)
+          : B (a, f, c), base_type (a, f, this)
+      {
+      }
+
+      template <typename C, typename B, typename idref>
+      idrefs<C, B, idref>::
+      idrefs (const std::basic_string<C>& s,
+              const xercesc::DOMElement* e,
+              flags f,
+              container* c)
+          : B (s, e, f, c), base_type (s, e, f, this)
+      {
+      }
+
+
+      // uri
+      //
+      template <typename C, typename B>
+      uri<C, B>::
+      uri (const xercesc::DOMElement& e, flags f, container* c)
+          : B (e, f, c),
+            base_type (trim (text_content<C> (e)))
+      {
+      }
+
+      template <typename C, typename B>
+      uri<C, B>::
+      uri (const xercesc::DOMAttr& a, flags f, container* c)
+          : B (a, f, c),
+            base_type (trim (xml::transcode<C> (a.getValue ())))
+      {
+      }
+
+      template <typename C, typename B>
+      uri<C, B>::
+      uri (const std::basic_string<C>& s,
+           const xercesc::DOMElement* e,
+           flags f,
+           container* c)
+          : B (s, e, f, c), base_type (trim (s))
+      {
+      }
+
+
+      // qname
+      //
+      template <typename C, typename B, typename uri, typename ncname>
+      qname<C, B, uri, ncname>::
+      qname (const xercesc::DOMElement& e, flags f, container* c)
+          : B (e, f, c)
+      {
+        std::basic_string<C> v (trim (text_content<C> (e)));
+        ns_ = resolve (v, &e);
+        name_ = xml::uq_name (v);
+      }
+
+      template <typename C, typename B, typename uri, typename ncname>
+      qname<C, B, uri, ncname>::
+      qname (const xercesc::DOMAttr& a, flags f, container* c)
+          : B (a, f, c)
+      {
+        std::basic_string<C> v (trim (xml::transcode<C> (a.getValue ())));
+        ns_ = resolve (v, a.getOwnerElement ());
+        name_ = xml::uq_name (v);
+      }
+
+      template <typename C, typename B, typename uri, typename ncname>
+      qname<C, B, uri, ncname>::
+      qname (const std::basic_string<C>& s,
+             const xercesc::DOMElement* e,
+             flags f,
+             container* c)
+          : B (s, e, f, c)
+      {
+        std::basic_string<C> v (trim (s));
+        ns_ = resolve (v, e);
+        name_ = xml::uq_name (v);
+      }
+
+      template <typename C, typename B, typename uri, typename ncname>
+      uri qname<C, B, uri, ncname>::
+      resolve (const std::basic_string<C>& s, const xercesc::DOMElement* e)
+      {
+        std::basic_string<C> p (xml::prefix (s));
+
+        if (e)
+        {
+          // This code is copied verbatim from xml/dom/elements.hxx.
+          //
+
+          // 'xml' prefix requires special handling and Xerces folks refuse
+          // to handle this in DOM so I have to do it myself.
+          //
+          if (p == xml::bits::xml_prefix<C> ())
+            return xml::bits::xml_namespace<C> ();
+
+          const XMLCh* xns (
+            e->lookupNamespaceURI (
+              p.empty () ? 0 : xml::string (p).c_str ()));
+
+          if (xns != 0)
+            return xml::transcode<C> (xns);
+          else if (p.empty ())
+            return std::basic_string<C> ();
+        }
+
+        throw no_prefix_mapping<C> (p);
+      }
+
+
+      // base64_binary
+      //
+      // We are not doing whitespace collapsing since the decode
+      // functions can handle it like this.
+      //
+      template <typename C, typename B>
+      base64_binary<C, B>::
+      base64_binary (const xercesc::DOMElement& e, flags f, container* c)
+          : B (e, f, c)
+      {
+        // This implementation is not optimal.
+        //
+        std::basic_string<C> str (trim (text_content<C> (e)));
+        decode (xml::string (str).c_str ());
+      }
+
+      template <typename C, typename B>
+      base64_binary<C, B>::
+      base64_binary (const xercesc::DOMAttr& a, flags f, container* c)
+          : B (a, f, c)
+      {
+        std::basic_string<C> str (trim (xml::transcode<C> (a.getValue ())));
+        decode (xml::string (str).c_str ());
+      }
+
+      template <typename C, typename B>
+      base64_binary<C, B>::
+      base64_binary (const std::basic_string<C>& s,
+                     const xercesc::DOMElement* e,
+                     flags f,
+                     container* c)
+          : B (s, e, f, c)
+      {
+        std::basic_string<C> str (trim (s));
+        decode (xml::string (str).c_str ());
+      }
+
+
+      // hex_binary
+      //
+      template <typename C, typename B>
+      hex_binary<C, B>::
+      hex_binary (const xercesc::DOMElement& e, flags f, container* c)
+          : B (e, f, c)
+      {
+        // This implementation is not optimal.
+        //
+        std::basic_string<C> str (trim (text_content<C> (e)));
+        decode (xml::string (str).c_str ());
+      }
+
+      template <typename C, typename B>
+      hex_binary<C, B>::
+      hex_binary (const xercesc::DOMAttr& a, flags f, container* c)
+          : B (a, f, c)
+      {
+        std::basic_string<C> str (trim (xml::transcode<C> (a.getValue ())));
+        decode (xml::string (str).c_str ());
+      }
+
+      template <typename C, typename B>
+      hex_binary<C, B>::
+      hex_binary (const std::basic_string<C>& s,
+                  const xercesc::DOMElement* e,
+                  flags f,
+                  container* c)
+          : B (s, e, f, c)
+      {
+        std::basic_string<C> str (trim (s));
+        decode (xml::string (str).c_str ());
+      }
+
+      // entity
+      //
+      template <typename C, typename B>
+      entity<C, B>::
+      entity (const xercesc::DOMElement& e, flags f, container* c)
+          : base_type (e, f, c)
+      {
+      }
+
+      template <typename C, typename B>
+      entity<C, B>::
+      entity (const xercesc::DOMAttr& a, flags f, container* c)
+          : base_type (a, f, c)
+      {
+      }
+
+      template <typename C, typename B>
+      entity<C, B>::
+      entity (const std::basic_string<C>& s,
+              const xercesc::DOMElement* e,
+              flags f,
+              container* c)
+          : base_type (s, e, f, c)
+      {
+      }
+
+
+      // entities
+      //
+      template <typename C, typename B, typename entity>
+      entities<C, B, entity>::
+      entities (const xercesc::DOMElement& e, flags f, container* c)
+          : B (e, f, c), base_type (e, f, this)
+      {
+      }
+
+      template <typename C, typename B, typename entity>
+      entities<C, B, entity>::
+      entities (const xercesc::DOMAttr& a, flags f, container* c)
+          : B (a, f, c), base_type (a, f, this)
+      {
+      }
+
+      template <typename C, typename B, typename entity>
+      entities<C, B, entity>::
+      entities (const std::basic_string<C>& s,
+                const xercesc::DOMElement* e,
+                flags f,
+                container* c)
+          : B (s, e, f, c), base_type (s, e, f, this)
+      {
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/tree/parsing/boolean.hxx src/base/include/xsd/cxx/tree/parsing/boolean.hxx
new file mode 100644
index 0000000..3dafdaa
--- /dev/null
+++ src/base/include/xsd/cxx/tree/parsing/boolean.hxx
@@ -0,0 +1,76 @@
+// file      : xsd/cxx/tree/parsing/boolean.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_PARSING_BOOLEAN_HXX
+#define XSD_CXX_TREE_PARSING_BOOLEAN_HXX
+
+#include <xsd/cxx/ro-string.hxx>
+#include <xsd/cxx/zc-istream.hxx>
+
+#include <xsd/cxx/xml/string.hxx> // xml::transcode
+
+#include <xsd/cxx/tree/text.hxx>  // text_content
+#include <xsd/cxx/tree/bits/literals.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      template <typename C>
+      struct traits<bool, C, schema_type::other>
+      {
+        typedef bool type;
+
+        static type
+        create (const xercesc::DOMElement& e, flags f, container* c);
+
+        static type
+        create (const xercesc::DOMAttr& a, flags f, container* c);
+
+        static type
+        create (const std::basic_string<C>& s,
+                const xercesc::DOMElement*,
+                flags,
+                container*);
+      };
+
+      template <typename C>
+      bool traits<bool, C, schema_type::other>::
+      create (const xercesc::DOMElement& e, flags f, container* c)
+      {
+        return create (text_content<C> (e), 0, f, c);
+      }
+
+      template <typename C>
+      bool traits<bool, C, schema_type::other>::
+      create (const xercesc::DOMAttr& a, flags f, container* c)
+      {
+        return create (xml::transcode<C> (a.getValue ()), 0, f, c);
+      }
+
+      template <typename C>
+      bool traits<bool, C, schema_type::other>::
+      create (const std::basic_string<C>& s,
+              const xercesc::DOMElement*,
+              flags,
+              container*)
+      {
+        // This type cannot have whitespaces in its values. As result we
+        // don't need to waste time collapsing whitespaces. All we need to
+        // do is trim the string representation which can be done without
+        // copying.
+        //
+        ro_string<C> tmp (s);
+        trim (tmp);
+
+        return tmp == bits::true_<C> () || tmp == bits::one<C> ();
+      }
+    }
+  }
+}
+
+#endif // XSD_CXX_TREE_PARSING_BOOLEAN_HXX
diff --git src/base/include/xsd/cxx/tree/parsing/byte.hxx src/base/include/xsd/cxx/tree/parsing/byte.hxx
new file mode 100644
index 0000000..0a127c9
--- /dev/null
+++ src/base/include/xsd/cxx/tree/parsing/byte.hxx
@@ -0,0 +1,80 @@
+// file      : xsd/cxx/tree/parsing/byte.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_PARSING_BYTE_HXX
+#define XSD_CXX_TREE_PARSING_BYTE_HXX
+
+#include <xsd/cxx/ro-string.hxx>
+#include <xsd/cxx/zc-istream.hxx>
+
+#include <xsd/cxx/xml/string.hxx> // xml::transcode
+
+#include <xsd/cxx/tree/text.hxx>  // text_content
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      template <typename C>
+      struct traits<signed char, C, schema_type::other>
+      {
+        typedef signed char type;
+
+        static type
+        create (const xercesc::DOMElement& e, flags f, container* c);
+
+        static type
+        create (const xercesc::DOMAttr& a, flags f, container* c);
+
+        static type
+        create (const std::basic_string<C>& s,
+                const xercesc::DOMElement*,
+                flags,
+                container*);
+      };
+
+      template <typename C>
+      signed char traits<signed char, C, schema_type::other>::
+      create (const xercesc::DOMElement& e, flags f, container* c)
+      {
+        return create (text_content<C> (e), 0, f, c);
+      }
+
+      template <typename C>
+      signed char traits<signed char, C, schema_type::other>::
+      create (const xercesc::DOMAttr& a, flags f, container* c)
+      {
+        return create (xml::transcode<C> (a.getValue ()), 0, f, c);
+      }
+
+      template <typename C>
+      signed char traits<signed char, C, schema_type::other>::
+      create (const std::basic_string<C>& s,
+              const xercesc::DOMElement*,
+              flags,
+              container*)
+      {
+        // This type cannot have whitespaces in its values. As result we
+        // don't need to waste time collapsing whitespaces. All we need to
+        // do is trim the string representation which can be done without
+        // copying.
+        //
+        ro_string<C> tmp (s);
+        trim (tmp);
+
+        zc_istream<C> is (tmp);
+
+        short t;
+        is >> t;
+
+        return static_cast<type> (t);
+      }
+    }
+  }
+}
+
+#endif // XSD_CXX_TREE_PARSING_BYTE_HXX
diff --git src/base/include/xsd/cxx/tree/parsing/date-time.txx src/base/include/xsd/cxx/tree/parsing/date-time.txx
new file mode 100644
index 0000000..913786c
--- /dev/null
+++ src/base/include/xsd/cxx/tree/parsing/date-time.txx
@@ -0,0 +1,702 @@
+// file      : xsd/cxx/tree/parsing/date-time.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#include <xsd/cxx/ro-string.hxx>
+#include <xsd/cxx/zc-istream.hxx>
+
+#include <xsd/cxx/xml/string.hxx> // xml::transcode
+
+#include <xsd/cxx/tree/text.hxx>  // text_content
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      // time_zone
+      //
+      template <typename C>
+      void time_zone::
+      zone_parse (const C* s, std::size_t n)
+      {
+        // time_zone := Z|(+|-)HH:MM
+        //
+        if (n == 0)
+        {
+          return;
+        }
+        else if (s[0] == C ('Z'))
+        {
+          hours_ = 0;
+          minutes_ = 0;
+          present_ = true;
+        }
+        else if (n == 6)
+        {
+          // Parse hours.
+          //
+          hours_ = 10 * (s[1] - C ('0')) + (s[2] - C ('0'));
+
+          // Parse minutes.
+          //
+          minutes_ = 10 * (s[4] - C ('0')) + (s[5] - C ('0'));
+
+          if (s[0] == C ('-'))
+          {
+            hours_ = -hours_;
+            minutes_ = -minutes_;
+          }
+          present_ = true;
+        }
+      }
+
+      // gday
+      //
+      template <typename C, typename B>
+      gday<C, B>::
+      gday (const xercesc::DOMElement& e, flags f, container* c)
+          : B (e, f, c)
+      {
+        parse (text_content<C> (e));
+      }
+
+      template <typename C, typename B>
+      gday<C, B>::
+      gday (const xercesc::DOMAttr& a, flags f, container* c)
+          : B (a, f, c)
+      {
+        parse (xml::transcode<C> (a.getValue ()));
+      }
+
+      template <typename C, typename B>
+      gday<C, B>::
+      gday (const std::basic_string<C>& s,
+            const xercesc::DOMElement* e,
+            flags f,
+            container* c)
+          : B (s, e, f, c)
+      {
+        parse (s);
+      }
+
+      template <typename C, typename B>
+      void gday<C, B>::
+      parse (const std::basic_string<C>& str)
+      {
+        typedef typename ro_string<C>::size_type size_type;
+
+        ro_string<C> tmp (str);
+        size_type n (trim (tmp));
+        const C* s (tmp.data ());
+
+        // gday := ---DD[Z|(+|-)HH:MM]
+        //
+        if (n >= 5)
+        {
+          day_ = 10 * (s[3] - C ('0')) + (s[4] - C ('0'));
+
+          if (n > 5)
+            zone_parse (s + 5, n - 5);
+        }
+      }
+
+      // gmonth
+      //
+      template <typename C, typename B>
+      gmonth<C, B>::
+      gmonth (const xercesc::DOMElement& e, flags f, container* c)
+          : B (e, f, c)
+      {
+        parse (text_content<C> (e));
+      }
+
+      template <typename C, typename B>
+      gmonth<C, B>::
+      gmonth (const xercesc::DOMAttr& a, flags f, container* c)
+          : B (a, f, c)
+      {
+        parse (xml::transcode<C> (a.getValue ()));
+      }
+
+      template <typename C, typename B>
+      gmonth<C, B>::
+      gmonth (const std::basic_string<C>& s,
+              const xercesc::DOMElement* e,
+              flags f,
+              container* c)
+          : B (s, e, f, c)
+      {
+        parse (s);
+      }
+
+      template <typename C, typename B>
+      void gmonth<C, B>::
+      parse (const std::basic_string<C>& str)
+      {
+        typedef typename ro_string<C>::size_type size_type;
+
+        ro_string<C> tmp (str);
+        size_type n (trim (tmp));
+        const C* s (tmp.data ());
+
+        // gmonth := --MM[Z|(+|-)HH:MM]
+        //
+        if (n >= 4)
+        {
+          month_ = 10 * (s[2] - C ('0')) + (s[3] - C ('0'));
+
+          if (n > 4)
+            zone_parse (s + 4, n - 4);
+        }
+      }
+
+      // gyear
+      //
+      template <typename C, typename B>
+      gyear<C, B>::
+      gyear (const xercesc::DOMElement& e, flags f, container* c)
+          : B (e, f, c)
+      {
+        parse (text_content<C> (e));
+      }
+
+      template <typename C, typename B>
+      gyear<C, B>::
+      gyear (const xercesc::DOMAttr& a, flags f, container* c)
+          : B (a, f, c)
+      {
+        parse (xml::transcode<C> (a.getValue ()));
+      }
+
+      template <typename C, typename B>
+      gyear<C, B>::
+      gyear (const std::basic_string<C>& s,
+             const xercesc::DOMElement* e,
+             flags f,
+             container* c)
+          : B (s, e, f, c)
+      {
+        parse (s);
+      }
+
+      template <typename C, typename B>
+      void gyear<C, B>::
+      parse (const std::basic_string<C>& str)
+      {
+        typedef typename ro_string<C>::size_type size_type;
+
+        ro_string<C> tmp (str);
+        size_type n (trim (tmp));
+        const C* s (tmp.data ());
+
+        // gyear := [-]CCYY[N]*[Z|(+|-)HH:MM]
+        //
+        if (n >= 4)
+        {
+          // Find the end of the year token.
+          //
+          size_type pos (4);
+          for (; pos < n; ++pos)
+          {
+            C c (s[pos]);
+
+            if (c == C ('Z') || c == C ('+') || c == C ('-'))
+              break;
+          }
+
+          ro_string<C> year_fragment (s, pos);
+          zc_istream<C> is (year_fragment);
+          is >> year_;
+
+          if (pos < n)
+            zone_parse (s + pos, n - pos);
+        }
+      }
+
+      // gmonth_day
+      //
+      template <typename C, typename B>
+      gmonth_day<C, B>::
+      gmonth_day (const xercesc::DOMElement& e, flags f, container* c)
+          : B (e, f, c)
+      {
+        parse (text_content<C> (e));
+      }
+
+      template <typename C, typename B>
+      gmonth_day<C, B>::
+      gmonth_day (const xercesc::DOMAttr& a, flags f, container* c)
+          : B (a, f, c)
+      {
+        parse (xml::transcode<C> (a.getValue ()));
+      }
+
+      template <typename C, typename B>
+      gmonth_day<C, B>::
+      gmonth_day (const std::basic_string<C>& s,
+                  const xercesc::DOMElement* e,
+                  flags f,
+                  container* c)
+          : B (s, e, f, c)
+      {
+        parse (s);
+      }
+
+      template <typename C, typename B>
+      void gmonth_day<C, B>::
+      parse (const std::basic_string<C>& str)
+      {
+        typedef typename ro_string<C>::size_type size_type;
+
+        ro_string<C> tmp (str);
+        size_type n (trim (tmp));
+        const C* s (tmp.data ());
+
+        // gmonth_day := --MM-DD[Z|(+|-)HH:MM]
+        //
+        if (n >= 7)
+        {
+          month_ = 10 * (s[2] - C ('0')) + (s[3] - C ('0'));
+          day_ = 10 * (s[5] - C ('0')) + (s[6] - C ('0'));
+
+          if (n > 7)
+            zone_parse (s + 7, n - 7);
+        }
+      }
+
+      // gyear_month
+      //
+      template <typename C, typename B>
+      gyear_month<C, B>::
+      gyear_month (const xercesc::DOMElement& e, flags f, container* c)
+          : B (e, f, c)
+      {
+        parse (text_content<C> (e));
+      }
+
+      template <typename C, typename B>
+      gyear_month<C, B>::
+      gyear_month (const xercesc::DOMAttr& a, flags f, container* c)
+          : B (a, f, c)
+      {
+        parse (xml::transcode<C> (a.getValue ()));
+      }
+
+      template <typename C, typename B>
+      gyear_month<C, B>::
+      gyear_month (const std::basic_string<C>& s,
+                   const xercesc::DOMElement* e,
+                   flags f,
+                   container* c)
+          : B (s, e, f, c)
+      {
+        parse (s);
+      }
+
+      template <typename C, typename B>
+      void gyear_month<C, B>::
+      parse (const std::basic_string<C>& str)
+      {
+        typedef typename ro_string<C>::size_type size_type;
+
+        ro_string<C> tmp (str);
+        size_type n (trim (tmp));
+        const C* s (tmp.data ());
+
+        // gyear_month := [-]CCYY[N]*-MM[Z|(+|-)HH:MM]
+        //
+
+        if (n >= 7)
+        {
+          // Find the end of the year token.
+          //
+          size_type pos (tmp.find (C ('-'), 4));
+
+          if (pos != ro_string<C>::npos && (n - pos - 1) >= 2)
+          {
+            ro_string<C> year_fragment (s, pos);
+            zc_istream<C> is (year_fragment);
+            is >> year_;
+
+            month_ = 10 * (s[pos + 1] - C ('0')) + (s[pos + 2] - C ('0'));
+
+            pos += 3;
+
+            if (pos < n)
+              zone_parse (s + pos, n - pos);
+          }
+        }
+      }
+
+      // date
+      //
+      template <typename C, typename B>
+      date<C, B>::
+      date (const xercesc::DOMElement& e, flags f, container* c)
+          : B (e, f, c)
+      {
+        parse (text_content<C> (e));
+      }
+
+      template <typename C, typename B>
+      date<C, B>::
+      date (const xercesc::DOMAttr& a, flags f, container* c)
+          : B (a, f, c)
+      {
+        parse (xml::transcode<C> (a.getValue ()));
+      }
+
+      template <typename C, typename B>
+      date<C, B>::
+      date (const std::basic_string<C>& s,
+            const xercesc::DOMElement* e,
+            flags f,
+            container* c)
+          : B (s, e, f, c)
+      {
+        parse (s);
+      }
+
+      template <typename C, typename B>
+      void date<C, B>::
+      parse (const std::basic_string<C>& str)
+      {
+        typedef typename ro_string<C>::size_type size_type;
+
+        ro_string<C> tmp (str);
+        size_type n (trim (tmp));
+        const C* s (tmp.data ());
+
+        // date := [-]CCYY[N]*-MM-DD[Z|(+|-)HH:MM]
+        //
+
+        if (n >= 10)
+        {
+          // Find the end of the year token.
+          //
+          size_type pos (tmp.find (C ('-'), 4));
+
+          if (pos != ro_string<C>::npos && (n - pos - 1) >= 5)
+          {
+            ro_string<C> year_fragment (s, pos);
+            zc_istream<C> is (year_fragment);
+            is >> year_;
+
+            month_ = 10 * (s[pos + 1] - C ('0')) + (s[pos + 2] - C ('0'));
+            day_ = 10 * (s[pos + 4] - C ('0')) + (s[pos + 5] - C ('0'));
+
+            pos += 6;
+
+            if (pos < n)
+              zone_parse (s + pos, n - pos);
+          }
+        }
+      }
+
+      // time
+      //
+      template <typename C, typename B>
+      time<C, B>::
+      time (const xercesc::DOMElement& e, flags f, container* c)
+          : B (e, f, c)
+      {
+        parse (text_content<C> (e));
+      }
+
+      template <typename C, typename B>
+      time<C, B>::
+      time (const xercesc::DOMAttr& a, flags f, container* c)
+          : B (a, f, c)
+      {
+        parse (xml::transcode<C> (a.getValue ()));
+      }
+
+      template <typename C, typename B>
+      time<C, B>::
+      time (const std::basic_string<C>& s,
+            const xercesc::DOMElement* e,
+            flags f,
+            container* c)
+          : B (s, e, f, c)
+      {
+        parse (s);
+      }
+
+      template <typename C, typename B>
+      void time<C, B>::
+      parse (const std::basic_string<C>& str)
+      {
+        typedef typename ro_string<C>::size_type size_type;
+
+        ro_string<C> tmp (str);
+        size_type n (trim (tmp));
+        const C* s (tmp.data ());
+
+        // time := HH:MM:SS[.S+][Z|(+|-)HH:MM]
+        //
+
+        if (n >= 8)
+        {
+          hours_ = 10 * (s[0] - '0') + (s[1] - '0');
+          minutes_ = 10 * (s[3] - '0') + (s[4] - '0');
+
+          // Find the end of the seconds fragment.
+          //
+          size_type pos (8);
+          for (; pos < n; ++pos)
+          {
+            C c (s[pos]);
+
+            if (c == C ('Z') || c == C ('+') || c == C ('-'))
+              break;
+          }
+
+          ro_string<C> seconds_fragment (s + 6, pos - 6);
+          zc_istream<C> is (seconds_fragment);
+          is >> seconds_;
+
+          if (pos < n)
+            zone_parse (s + pos, n - pos);
+        }
+      }
+
+      // date_time
+      //
+      template <typename C, typename B>
+      date_time<C, B>::
+      date_time (const xercesc::DOMElement& e, flags f, container* c)
+          : B (e, f, c)
+      {
+        parse (text_content<C> (e));
+      }
+
+      template <typename C, typename B>
+      date_time<C, B>::
+      date_time (const xercesc::DOMAttr& a, flags f, container* c)
+          : B (a, f, c)
+      {
+        parse (xml::transcode<C> (a.getValue ()));
+      }
+
+      template <typename C, typename B>
+      date_time<C, B>::
+      date_time (const std::basic_string<C>& s,
+                 const xercesc::DOMElement* e,
+                 flags f,
+                 container* c)
+          : B (s, e, f, c)
+      {
+        parse (s);
+      }
+
+      template <typename C, typename B>
+      void date_time<C, B>::
+      parse (const std::basic_string<C>& str)
+      {
+        typedef typename ro_string<C>::size_type size_type;
+
+        ro_string<C> tmp (str);
+        size_type n (trim (tmp));
+        const C* s (tmp.data ());
+
+        // date_time := [-]CCYY[N]*-MM-DDTHH:MM:SS[.S+][Z|(+|-)HH:MM]
+        //
+
+        if (n >= 19)
+        {
+          // Find the end of the year token.
+          //
+          size_type pos (tmp.find (C ('-'), 4));
+
+          if (pos != ro_string<C>::npos && (n - pos - 1) >= 14)
+          {
+            ro_string<C> year_fragment (s, pos);
+            zc_istream<C> yis (year_fragment);
+            yis >> year_;
+
+            month_ = 10 * (s[pos + 1] - C ('0')) + (s[pos + 2] - C ('0'));
+            pos += 3;
+
+            day_ = 10 * (s[pos + 1] - C ('0')) + (s[pos + 2] - C ('0'));
+            pos += 3;
+
+            hours_ = 10 * (s[pos + 1] - C ('0')) + (s[pos + 2] - C ('0'));
+            pos += 3;
+
+            minutes_ = 10 * (s[pos + 1] - C ('0')) + (s[pos + 2] - C ('0'));
+            pos += 4; // Point to the first S.
+
+            // Find the end of the seconds fragment.
+            //
+            size_type sec_end (pos + 2);
+            for (; sec_end < n; ++sec_end)
+            {
+              C c (s[sec_end]);
+
+              if (c == C ('Z') || c == C ('+') || c == C ('-'))
+                break;
+            }
+
+            ro_string<C> seconds_fragment (s + pos, sec_end - pos);
+            zc_istream<C> sis (seconds_fragment);
+            sis >> seconds_;
+
+            if (sec_end < n)
+              zone_parse (s + sec_end, n - sec_end);
+          }
+        }
+      }
+
+      // duration
+      //
+      template <typename C, typename B>
+      duration<C, B>::
+      duration (const xercesc::DOMElement& e, flags f, container* c)
+          : B (e, f, c)
+      {
+        parse (text_content<C> (e));
+      }
+
+      template <typename C, typename B>
+      duration<C, B>::
+      duration (const xercesc::DOMAttr& a, flags f, container* c)
+          : B (a, f, c)
+      {
+        parse (xml::transcode<C> (a.getValue ()));
+      }
+
+      template <typename C, typename B>
+      duration<C, B>::
+      duration (const std::basic_string<C>& s,
+                const xercesc::DOMElement* e,
+                flags f,
+                container* c)
+          : B (s, e, f, c)
+      {
+        parse (s);
+      }
+
+      namespace bits
+      {
+        template <typename C>
+        inline typename ro_string<C>::size_type
+        duration_delim (const C* s,
+                        typename ro_string<C>::size_type pos,
+                        typename ro_string<C>::size_type size)
+        {
+          const C* p (s + pos);
+          for (; p < (s + size); ++p)
+          {
+            if (*p == C ('Y') || *p == C ('D') || *p == C ('M') ||
+                *p == C ('H') || *p == C ('M') || *p == C ('S') ||
+                *p == C ('T'))
+              break;
+          }
+
+          return p - s;
+        }
+      }
+
+      template <typename C, typename B>
+      void duration<C, B>::
+      parse (const std::basic_string<C>& str)
+      {
+        typedef typename ro_string<C>::size_type size_type;
+
+        ro_string<C> tmp (str);
+        size_type n (trim (tmp));
+        const C* s (tmp.data ());
+
+        // Set all the fields since some of them may not be specified.
+        //
+        years_ = months_ = days_ = hours_ = minutes_ = 0;
+        seconds_ = 0.0;
+
+        // duration := [-]P[nY][nM][nD][TnHnMn[.n+]S]
+        //
+        if (n >= 3)
+        {
+          size_type pos (0);
+
+          if (s[0] == C ('-'))
+          {
+            negative_ = true;
+            pos++;
+          }
+          else
+            negative_ = false;
+
+          pos++; // Skip 'P'.
+
+          size_type del (bits::duration_delim (s, pos, n));
+
+          if (del != n && s[del] == C ('Y'))
+          {
+            ro_string<C> fragment (s + pos, del - pos);
+            zc_istream<C> is (fragment);
+            is >> years_;
+
+            pos = del + 1;
+            del = bits::duration_delim (s, pos, n);
+          }
+
+          if (del != n && s[del] == C ('M'))
+          {
+            ro_string<C> fragment (s + pos, del - pos);
+            zc_istream<C> is (fragment);
+            is >> months_;
+
+            pos = del + 1;
+            del = bits::duration_delim (s, pos, n);
+          }
+
+          if (del != n && s[del] == C ('D'))
+          {
+            ro_string<C> fragment (s + pos, del - pos);
+            zc_istream<C> is (fragment);
+            is >> days_;
+
+            pos = del + 1;
+            del = bits::duration_delim (s, pos, n);
+          }
+
+          if (del != n && s[del] == C ('T'))
+          {
+            pos = del + 1;
+            del = bits::duration_delim (s, pos, n);
+
+            if (del != n && s[del] == C ('H'))
+            {
+              ro_string<C> fragment (s + pos, del - pos);
+              zc_istream<C> is (fragment);
+              is >> hours_;
+
+              pos = del + 1;
+              del = bits::duration_delim (s, pos, n);
+            }
+
+            if (del != n && s[del] == C ('M'))
+            {
+              ro_string<C> fragment (s + pos, del - pos);
+              zc_istream<C> is (fragment);
+              is >> minutes_;
+
+              pos = del + 1;
+              del = bits::duration_delim (s, pos, n);
+            }
+
+            if (del != n && s[del] == C ('S'))
+            {
+              ro_string<C> fragment (s + pos, del - pos);
+              zc_istream<C> is (fragment);
+              is >> seconds_;
+            }
+          }
+        }
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/tree/parsing/decimal.hxx src/base/include/xsd/cxx/tree/parsing/decimal.hxx
new file mode 100644
index 0000000..636c0f5
--- /dev/null
+++ src/base/include/xsd/cxx/tree/parsing/decimal.hxx
@@ -0,0 +1,85 @@
+// file      : xsd/cxx/tree/parsing/decimal.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_PARSING_DECIMAL_HXX
+#define XSD_CXX_TREE_PARSING_DECIMAL_HXX
+
+#include <limits>
+#include <locale>
+
+#include <xsd/cxx/ro-string.hxx>
+#include <xsd/cxx/zc-istream.hxx>
+
+#include <xsd/cxx/xml/string.hxx> // xml::transcode
+
+#include <xsd/cxx/tree/text.hxx>  // text_content
+#include <xsd/cxx/tree/bits/literals.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      template <typename C>
+      struct traits<double, C, schema_type::decimal>
+      {
+        typedef double type;
+
+        static type
+        create (const xercesc::DOMElement& e, flags f, container* c);
+
+        static type
+        create (const xercesc::DOMAttr& a, flags f, container* c);
+
+        static type
+        create (const std::basic_string<C>& s,
+                const xercesc::DOMElement*,
+                flags,
+                container*);
+      };
+
+      template <typename C>
+      double traits<double, C, schema_type::decimal>::
+      create (const xercesc::DOMElement& e, flags f, container* c)
+      {
+        return create (text_content<C> (e), 0, f, c);
+      }
+
+      template <typename C>
+      double traits<double, C, schema_type::decimal>::
+      create (const xercesc::DOMAttr& a, flags f, container* c)
+      {
+        return create (xml::transcode<C> (a.getValue ()), 0, f, c);
+      }
+
+      template <typename C>
+      double traits<double, C, schema_type::decimal>::
+      create (const std::basic_string<C>& s,
+              const xercesc::DOMElement*,
+              flags,
+              container*)
+      {
+        // This type cannot have whitespaces in its values. As result we
+        // don't need to waste time collapsing whitespaces. All we need to
+        // do is trim the string representation which can be done without
+        // copying.
+        //
+        ro_string<C> tmp (s);
+        trim (tmp);
+
+        zc_istream<C> is (tmp);
+        is.imbue (std::locale::classic ());
+
+        type t;
+        is >> t;
+
+        return t;
+      }
+    }
+  }
+}
+
+#endif // XSD_CXX_TREE_PARSING_DECIMAL_HXX
diff --git src/base/include/xsd/cxx/tree/parsing/double.hxx src/base/include/xsd/cxx/tree/parsing/double.hxx
new file mode 100644
index 0000000..1507ccf
--- /dev/null
+++ src/base/include/xsd/cxx/tree/parsing/double.hxx
@@ -0,0 +1,94 @@
+// file      : xsd/cxx/tree/parsing/double.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_PARSING_DOUBLE_HXX
+#define XSD_CXX_TREE_PARSING_DOUBLE_HXX
+
+#include <limits>
+#include <locale>
+
+#include <xsd/cxx/ro-string.hxx>
+#include <xsd/cxx/zc-istream.hxx>
+
+#include <xsd/cxx/xml/string.hxx> // xml::transcode
+
+#include <xsd/cxx/tree/text.hxx>  // text_content
+#include <xsd/cxx/tree/bits/literals.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      template <typename C>
+      struct traits<double, C, schema_type::double_>
+      {
+        typedef double type;
+
+        static type
+        create (const xercesc::DOMElement& e, flags f, container* c);
+
+        static type
+        create (const xercesc::DOMAttr& a, flags f, container* c);
+
+        static type
+        create (const std::basic_string<C>& s,
+                const xercesc::DOMElement*,
+                flags,
+                container*);
+      };
+
+      template <typename C>
+      double traits<double, C, schema_type::double_>::
+      create (const xercesc::DOMElement& e, flags f, container* c)
+      {
+        return create (text_content<C> (e), 0, f, c);
+      }
+
+      template <typename C>
+      double traits<double, C, schema_type::double_>::
+      create (const xercesc::DOMAttr& a, flags f, container* c)
+      {
+        return create (xml::transcode<C> (a.getValue ()), 0, f, c);
+      }
+
+      template <typename C>
+      double traits<double, C, schema_type::double_>::
+      create (const std::basic_string<C>& s,
+              const xercesc::DOMElement*,
+              flags,
+              container*)
+      {
+        // This type cannot have whitespaces in its values. As result we
+        // don't need to waste time collapsing whitespaces. All we need to
+        // do is trim the string representation which can be done without
+        // copying.
+        //
+        ro_string<C> tmp (s);
+        trim (tmp);
+
+        if (tmp == bits::positive_inf<C> ())
+          return std::numeric_limits<double>::infinity ();
+
+        if (tmp == bits::negative_inf<C> ())
+          return -std::numeric_limits<double>::infinity ();
+
+        if (tmp == bits::nan<C> ())
+          return std::numeric_limits<double>::quiet_NaN ();
+
+        zc_istream<C> is (tmp);
+        is.imbue (std::locale::classic ());
+
+        type t;
+        is >> t;
+
+        return t;
+      }
+    }
+  }
+}
+
+#endif // XSD_CXX_TREE_PARSING_DOUBLE_HXX
diff --git src/base/include/xsd/cxx/tree/parsing/element-map.txx src/base/include/xsd/cxx/tree/parsing/element-map.txx
new file mode 100644
index 0000000..bb9a4c6
--- /dev/null
+++ src/base/include/xsd/cxx/tree/parsing/element-map.txx
@@ -0,0 +1,42 @@
+// file      : xsd/cxx/tree/parsing/element-map.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_PARSING_ELEMENT_MAP_TXX
+#define XSD_CXX_TREE_PARSING_ELEMENT_MAP_TXX
+
+#include <xsd/cxx/xml/dom/elements.hxx>
+
+#include <xsd/cxx/tree/exceptions.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      template <typename C, typename T>
+      std::auto_ptr<element_type<C, T> > element_map<C, T>::
+      parse (const xercesc::DOMElement& e, flags f)
+      {
+        const qualified_name n (xml::dom::name<C> (e));
+        typename map::const_iterator i (map_->find (n));
+
+        if (i != map_->end () && i->second.parser_ != 0)
+          return (i->second.parser_) (e, f);
+        else
+          throw no_element_info<C> (n.name (), n.namespace_ ());
+      }
+
+      template<typename T, typename C, typename B>
+      std::auto_ptr<element_type<C, B> >
+      parser_impl (const xercesc::DOMElement& e, flags f)
+      {
+        return std::auto_ptr<element_type<C, B> > (new T (e, f));
+      }
+    }
+  }
+}
+
+#endif // XSD_CXX_TREE_PARSING_ELEMENT_MAP_TXX
diff --git src/base/include/xsd/cxx/tree/parsing/float.hxx src/base/include/xsd/cxx/tree/parsing/float.hxx
new file mode 100644
index 0000000..3e34f93
--- /dev/null
+++ src/base/include/xsd/cxx/tree/parsing/float.hxx
@@ -0,0 +1,94 @@
+// file      : xsd/cxx/tree/parsing/float.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_PARSING_FLOAT_HXX
+#define XSD_CXX_TREE_PARSING_FLOAT_HXX
+
+#include <limits>
+#include <locale>
+
+#include <xsd/cxx/ro-string.hxx>
+#include <xsd/cxx/zc-istream.hxx>
+
+#include <xsd/cxx/xml/string.hxx> // xml::transcode
+
+#include <xsd/cxx/tree/text.hxx>  // text_content
+#include <xsd/cxx/tree/bits/literals.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      template <typename C>
+      struct traits<float, C, schema_type::other>
+      {
+        typedef float type;
+
+        static type
+        create (const xercesc::DOMElement& e, flags f, container* c);
+
+        static type
+        create (const xercesc::DOMAttr& a, flags f, container* c);
+
+        static type
+        create (const std::basic_string<C>& s,
+                const xercesc::DOMElement*,
+                flags,
+                container*);
+      };
+
+      template <typename C>
+      float traits<float, C, schema_type::other>::
+      create (const xercesc::DOMElement& e, flags f, container* c)
+      {
+        return create (text_content<C> (e), 0, f, c);
+      }
+
+      template <typename C>
+      float traits<float, C, schema_type::other>::
+      create (const xercesc::DOMAttr& a, flags f, container* c)
+      {
+        return create (xml::transcode<C> (a.getValue ()), 0, f, c);
+      }
+
+      template <typename C>
+      float traits<float, C, schema_type::other>::
+      create (const std::basic_string<C>& s,
+              const xercesc::DOMElement*,
+              flags,
+              container*)
+      {
+        // This type cannot have whitespaces in its values. As result we
+        // don't need to waste time collapsing whitespaces. All we need to
+        // do is trim the string representation which can be done without
+        // copying.
+        //
+        ro_string<C> tmp (s);
+        trim (tmp);
+
+        if (tmp == bits::positive_inf<C> ())
+          return std::numeric_limits<float>::infinity ();
+
+        if (tmp == bits::negative_inf<C> ())
+          return -std::numeric_limits<float>::infinity ();
+
+        if (tmp == bits::nan<C> ())
+          return std::numeric_limits<float>::quiet_NaN ();
+
+        zc_istream<C> is (tmp);
+        is.imbue (std::locale::classic ());
+
+        type t;
+        is >> t;
+
+        return t;
+      }
+    }
+  }
+}
+
+#endif // XSD_CXX_TREE_PARSING_FLOAT_HXX
diff --git src/base/include/xsd/cxx/tree/parsing/int.hxx src/base/include/xsd/cxx/tree/parsing/int.hxx
new file mode 100644
index 0000000..d996d3a
--- /dev/null
+++ src/base/include/xsd/cxx/tree/parsing/int.hxx
@@ -0,0 +1,80 @@
+// file      : xsd/cxx/tree/parsing/int.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_PARSING_INT_HXX
+#define XSD_CXX_TREE_PARSING_INT_HXX
+
+#include <xsd/cxx/ro-string.hxx>
+#include <xsd/cxx/zc-istream.hxx>
+
+#include <xsd/cxx/xml/string.hxx> // xml::transcode
+
+#include <xsd/cxx/tree/text.hxx>  // text_content
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      template <typename C>
+      struct traits<int, C, schema_type::other>
+      {
+        typedef int type;
+
+        static type
+        create (const xercesc::DOMElement& e, flags f, container* c);
+
+        static type
+        create (const xercesc::DOMAttr& a, flags f, container* c);
+
+        static type
+        create (const std::basic_string<C>& s,
+                const xercesc::DOMElement*,
+                flags,
+                container*);
+      };
+
+      template <typename C>
+      int traits<int, C, schema_type::other>::
+      create (const xercesc::DOMElement& e, flags f, container* c)
+      {
+        return create (text_content<C> (e), 0, f, c);
+      }
+
+      template <typename C>
+      int traits<int, C, schema_type::other>::
+      create (const xercesc::DOMAttr& a, flags f, container* c)
+      {
+        return create (xml::transcode<C> (a.getValue ()), 0, f, c);
+      }
+
+      template <typename C>
+      int traits<int, C, schema_type::other>::
+      create (const std::basic_string<C>& s,
+              const xercesc::DOMElement*,
+              flags,
+              container*)
+      {
+        // This type cannot have whitespaces in its values. As result we
+        // don't need to waste time collapsing whitespaces. All we need to
+        // do is trim the string representation which can be done without
+        // copying.
+        //
+        ro_string<C> tmp (s);
+        trim (tmp);
+
+        zc_istream<C> is (tmp);
+
+        type t;
+        is >> t;
+
+        return t;
+      }
+    }
+  }
+}
+
+#endif // XSD_CXX_TREE_PARSING_INT_HXX
diff --git src/base/include/xsd/cxx/tree/parsing/long.hxx src/base/include/xsd/cxx/tree/parsing/long.hxx
new file mode 100644
index 0000000..742ade1
--- /dev/null
+++ src/base/include/xsd/cxx/tree/parsing/long.hxx
@@ -0,0 +1,80 @@
+// file      : xsd/cxx/tree/parsing/long.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_PARSING_LONG_HXX
+#define XSD_CXX_TREE_PARSING_LONG_HXX
+
+#include <xsd/cxx/ro-string.hxx>
+#include <xsd/cxx/zc-istream.hxx>
+
+#include <xsd/cxx/xml/string.hxx> // xml::transcode
+
+#include <xsd/cxx/tree/text.hxx>  // text_content
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      template <typename C>
+      struct traits<long long, C, schema_type::other>
+      {
+        typedef long long type;
+
+        static type
+        create (const xercesc::DOMElement& e, flags f, container* c);
+
+        static type
+        create (const xercesc::DOMAttr& a, flags f, container* c);
+
+        static type
+        create (const std::basic_string<C>& s,
+                const xercesc::DOMElement*,
+                flags,
+                container*);
+      };
+
+      template <typename C>
+      long long traits<long long, C, schema_type::other>::
+      create (const xercesc::DOMElement& e, flags f, container* c)
+      {
+        return create (text_content<C> (e), 0, f, c);
+      }
+
+      template <typename C>
+      long long traits<long long, C, schema_type::other>::
+      create (const xercesc::DOMAttr& a, flags f, container* c)
+      {
+        return create (xml::transcode<C> (a.getValue ()), 0, f, c);
+      }
+
+      template <typename C>
+      long long traits<long long, C, schema_type::other>::
+      create (const std::basic_string<C>& s,
+              const xercesc::DOMElement*,
+              flags,
+              container*)
+      {
+        // This type cannot have whitespaces in its values. As result we
+        // don't need to waste time collapsing whitespaces. All we need to
+        // do is trim the string representation which can be done without
+        // copying.
+        //
+        ro_string<C> tmp (s);
+        trim (tmp);
+
+        zc_istream<C> is (tmp);
+
+        type t;
+        is >> t;
+
+        return t;
+      }
+    }
+  }
+}
+
+#endif // XSD_CXX_TREE_PARSING_LONG_HXX
diff --git src/base/include/xsd/cxx/tree/parsing/short.hxx src/base/include/xsd/cxx/tree/parsing/short.hxx
new file mode 100644
index 0000000..3a7ead8
--- /dev/null
+++ src/base/include/xsd/cxx/tree/parsing/short.hxx
@@ -0,0 +1,80 @@
+// file      : xsd/cxx/tree/parsing/short.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_PARSING_SHORT_HXX
+#define XSD_CXX_TREE_PARSING_SHORT_HXX
+
+#include <xsd/cxx/ro-string.hxx>
+#include <xsd/cxx/zc-istream.hxx>
+
+#include <xsd/cxx/xml/string.hxx> // xml::transcode
+
+#include <xsd/cxx/tree/text.hxx>  // text_content
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      template <typename C>
+      struct traits<short, C, schema_type::other>
+      {
+        typedef short type;
+
+        static type
+        create (const xercesc::DOMElement& e, flags f, container* c);
+
+        static type
+        create (const xercesc::DOMAttr& a, flags f, container* c);
+
+        static type
+        create (const std::basic_string<C>& s,
+                const xercesc::DOMElement*,
+                flags,
+                container*);
+      };
+
+      template <typename C>
+      short traits<short, C, schema_type::other>::
+      create (const xercesc::DOMElement& e, flags f, container* c)
+      {
+        return create (text_content<C> (e), 0, f, c);
+      }
+
+      template <typename C>
+      short traits<short, C, schema_type::other>::
+      create (const xercesc::DOMAttr& a, flags f, container* c)
+      {
+        return create (xml::transcode<C> (a.getValue ()), 0, f, c);
+      }
+
+      template <typename C>
+      short traits<short, C, schema_type::other>::
+      create (const std::basic_string<C>& s,
+              const xercesc::DOMElement*,
+              flags,
+              container*)
+      {
+        // This type cannot have whitespaces in its values. As result we
+        // don't need to waste time collapsing whitespaces. All we need to
+        // do is trim the string representation which can be done without
+        // copying.
+        //
+        ro_string<C> tmp (s);
+        trim (tmp);
+
+        zc_istream<C> is (tmp);
+
+        type t;
+        is >> t;
+
+        return t;
+      }
+    }
+  }
+}
+
+#endif // XSD_CXX_TREE_PARSING_SHORT_HXX
diff --git src/base/include/xsd/cxx/tree/parsing/unsigned-byte.hxx src/base/include/xsd/cxx/tree/parsing/unsigned-byte.hxx
new file mode 100644
index 0000000..ce336be
--- /dev/null
+++ src/base/include/xsd/cxx/tree/parsing/unsigned-byte.hxx
@@ -0,0 +1,80 @@
+// file      : xsd/cxx/tree/parsing/unsigned-byte.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_PARSING_UNSIGNED_BYTE_HXX
+#define XSD_CXX_TREE_PARSING_UNSIGNED_BYTE_HXX
+
+#include <xsd/cxx/ro-string.hxx>
+#include <xsd/cxx/zc-istream.hxx>
+
+#include <xsd/cxx/xml/string.hxx> // xml::transcode
+
+#include <xsd/cxx/tree/text.hxx>  // text_content
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      template <typename C>
+      struct traits<unsigned char, C, schema_type::other>
+      {
+        typedef unsigned char type;
+
+        static type
+        create (const xercesc::DOMElement& e, flags f, container* c);
+
+        static type
+        create (const xercesc::DOMAttr& a, flags f, container* c);
+
+        static type
+        create (const std::basic_string<C>& s,
+                const xercesc::DOMElement*,
+                flags,
+                container*);
+      };
+
+      template <typename C>
+      unsigned char traits<unsigned char, C, schema_type::other>::
+      create (const xercesc::DOMElement& e, flags f, container* c)
+      {
+        return create (text_content<C> (e), 0, f, c);
+      }
+
+      template <typename C>
+      unsigned char traits<unsigned char, C, schema_type::other>::
+      create (const xercesc::DOMAttr& a, flags f, container* c)
+      {
+        return create (xml::transcode<C> (a.getValue ()), 0, f, c);
+      }
+
+      template <typename C>
+      unsigned char traits<unsigned char, C, schema_type::other>::
+      create (const std::basic_string<C>& s,
+              const xercesc::DOMElement*,
+              flags,
+              container*)
+      {
+        // This type cannot have whitespaces in its values. As result we
+        // don't need to waste time collapsing whitespaces. All we need to
+        // do is trim the string representation which can be done without
+        // copying.
+        //
+        ro_string<C> tmp (s);
+        trim (tmp);
+
+        zc_istream<C> is (tmp);
+
+        unsigned short t;
+        is >> t;
+
+        return static_cast<type> (t);
+      }
+    }
+  }
+}
+
+#endif // XSD_CXX_TREE_PARSING_UNSIGNED_BYTE_HXX
diff --git src/base/include/xsd/cxx/tree/parsing/unsigned-int.hxx src/base/include/xsd/cxx/tree/parsing/unsigned-int.hxx
new file mode 100644
index 0000000..e908dd0
--- /dev/null
+++ src/base/include/xsd/cxx/tree/parsing/unsigned-int.hxx
@@ -0,0 +1,80 @@
+// file      : xsd/cxx/tree/parsing/unsigned-int.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_PARSING_UNSIGNED_INT_HXX
+#define XSD_CXX_TREE_PARSING_UNSIGNED_INT_HXX
+
+#include <xsd/cxx/ro-string.hxx>
+#include <xsd/cxx/zc-istream.hxx>
+
+#include <xsd/cxx/xml/string.hxx> // xml::transcode
+
+#include <xsd/cxx/tree/text.hxx>  // text_content
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      template <typename C>
+      struct traits<unsigned int, C, schema_type::other>
+      {
+        typedef unsigned int type;
+
+        static type
+        create (const xercesc::DOMElement& e, flags f, container* c);
+
+        static type
+        create (const xercesc::DOMAttr& a, flags f, container* c);
+
+        static type
+        create (const std::basic_string<C>& s,
+                const xercesc::DOMElement*,
+                flags,
+                container*);
+      };
+
+      template <typename C>
+      unsigned int traits<unsigned int, C, schema_type::other>::
+      create (const xercesc::DOMElement& e, flags f, container* c)
+      {
+        return create (text_content<C> (e), 0, f, c);
+      }
+
+      template <typename C>
+      unsigned int traits<unsigned int, C, schema_type::other>::
+      create (const xercesc::DOMAttr& a, flags f, container* c)
+      {
+        return create (xml::transcode<C> (a.getValue ()), 0, f, c);
+      }
+
+      template <typename C>
+      unsigned int traits<unsigned int, C, schema_type::other>::
+      create (const std::basic_string<C>& s,
+              const xercesc::DOMElement*,
+              flags,
+              container*)
+      {
+        // This type cannot have whitespaces in its values. As result we
+        // don't need to waste time collapsing whitespaces. All we need to
+        // do is trim the string representation which can be done without
+        // copying.
+        //
+        ro_string<C> tmp (s);
+        trim (tmp);
+
+        zc_istream<C> is (tmp);
+
+        type t;
+        is >> t;
+
+        return t;
+      }
+    }
+  }
+}
+
+#endif // XSD_CXX_TREE_PARSING_UNSIGNED_INT_HXX
diff --git src/base/include/xsd/cxx/tree/parsing/unsigned-long.hxx src/base/include/xsd/cxx/tree/parsing/unsigned-long.hxx
new file mode 100644
index 0000000..647b8dd
--- /dev/null
+++ src/base/include/xsd/cxx/tree/parsing/unsigned-long.hxx
@@ -0,0 +1,80 @@
+// file      : xsd/cxx/tree/parsing/unsigned-long.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_PARSING_UNSIGNED_LONG_HXX
+#define XSD_CXX_TREE_PARSING_UNSIGNED_LONG_HXX
+
+#include <xsd/cxx/ro-string.hxx>
+#include <xsd/cxx/zc-istream.hxx>
+
+#include <xsd/cxx/xml/string.hxx> // xml::transcode
+
+#include <xsd/cxx/tree/text.hxx>  // text_content
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      template <typename C>
+      struct traits<unsigned long long, C, schema_type::other>
+      {
+        typedef unsigned long long type;
+
+        static type
+        create (const xercesc::DOMElement& e, flags f, container* c);
+
+        static type
+        create (const xercesc::DOMAttr& a, flags f, container* c);
+
+        static type
+        create (const std::basic_string<C>& s,
+                const xercesc::DOMElement*,
+                flags,
+                container*);
+      };
+
+      template <typename C>
+      unsigned long long traits<unsigned long long, C, schema_type::other>::
+      create (const xercesc::DOMElement& e, flags f, container* c)
+      {
+        return create (text_content<C> (e), 0, f, c);
+      }
+
+      template <typename C>
+      unsigned long long traits<unsigned long long, C, schema_type::other>::
+      create (const xercesc::DOMAttr& a, flags f, container* c)
+      {
+        return create (xml::transcode<C> (a.getValue ()), 0, f, c);
+      }
+
+      template <typename C>
+      unsigned long long traits<unsigned long long, C, schema_type::other>::
+      create (const std::basic_string<C>& s,
+              const xercesc::DOMElement*,
+              flags,
+              container*)
+      {
+        // This type cannot have whitespaces in its values. As result we
+        // don't need to waste time collapsing whitespaces. All we need to
+        // do is trim the string representation which can be done without
+        // copying.
+        //
+        ro_string<C> tmp (s);
+        trim (tmp);
+
+        zc_istream<C> is (tmp);
+
+        type t;
+        is >> t;
+
+        return t;
+      }
+    }
+  }
+}
+
+#endif // XSD_CXX_TREE_PARSING_UNSIGNED_LONG_HXX
diff --git src/base/include/xsd/cxx/tree/parsing/unsigned-short.hxx src/base/include/xsd/cxx/tree/parsing/unsigned-short.hxx
new file mode 100644
index 0000000..f53c724
--- /dev/null
+++ src/base/include/xsd/cxx/tree/parsing/unsigned-short.hxx
@@ -0,0 +1,80 @@
+// file      : xsd/cxx/tree/parsing/unsigned-short.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_PARSING_UNSIGNED_SHORT_HXX
+#define XSD_CXX_TREE_PARSING_UNSIGNED_SHORT_HXX
+
+#include <xsd/cxx/ro-string.hxx>
+#include <xsd/cxx/zc-istream.hxx>
+
+#include <xsd/cxx/xml/string.hxx> // xml::transcode
+
+#include <xsd/cxx/tree/text.hxx>  // text_content
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      template <typename C>
+      struct traits<unsigned short, C, schema_type::other>
+      {
+        typedef unsigned short type;
+
+        static type
+        create (const xercesc::DOMElement& e, flags f, container* c);
+
+        static type
+        create (const xercesc::DOMAttr& a, flags f, container* c);
+
+        static type
+        create (const std::basic_string<C>& s,
+                const xercesc::DOMElement*,
+                flags,
+                container*);
+      };
+
+      template <typename C>
+      unsigned short traits<unsigned short, C, schema_type::other>::
+      create (const xercesc::DOMElement& e, flags f, container* c)
+      {
+        return create (text_content<C> (e), 0, f, c);
+      }
+
+      template <typename C>
+      unsigned short traits<unsigned short, C, schema_type::other>::
+      create (const xercesc::DOMAttr& a, flags f, container* c)
+      {
+        return create (xml::transcode<C> (a.getValue ()), 0, f, c);
+      }
+
+      template <typename C>
+      unsigned short traits<unsigned short, C, schema_type::other>::
+      create (const std::basic_string<C>& s,
+              const xercesc::DOMElement*,
+              flags,
+              container*)
+      {
+        // This type cannot have whitespaces in its values. As result we
+        // don't need to waste time collapsing whitespaces. All we need to
+        // do is trim the string representation which can be done without
+        // copying.
+        //
+        ro_string<C> tmp (s);
+        trim (tmp);
+
+        zc_istream<C> is (tmp);
+
+        type t;
+        is >> t;
+
+        return t;
+      }
+    }
+  }
+}
+
+#endif // XSD_CXX_TREE_PARSING_UNSIGNED_SHORT_HXX
diff --git src/base/include/xsd/cxx/tree/serialization.hxx src/base/include/xsd/cxx/tree/serialization.hxx
new file mode 100644
index 0000000..612185f
--- /dev/null
+++ src/base/include/xsd/cxx/tree/serialization.hxx
@@ -0,0 +1,66 @@
+// file      : xsd/cxx/tree/serialization.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_SERIALIZATION_HXX
+#define XSD_CXX_TREE_SERIALIZATION_HXX
+
+#include <sstream>
+
+#include <xercesc/dom/DOMElement.hpp>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      //
+      //
+      template <typename C>
+      class list_stream
+      {
+      public:
+        list_stream (std::basic_ostringstream<C>& os,
+                     xercesc::DOMElement& parent)
+            : os_ (os), parent_ (parent)
+        {
+        }
+
+        std::basic_ostringstream<C>& os_;
+        xercesc::DOMElement& parent_;
+      };
+
+      template <typename T>
+      class as_double
+      {
+      public:
+        as_double (const T& v)
+            : x (v)
+        {
+        }
+
+        const T& x;
+      };
+
+      template <typename T>
+      class as_decimal
+      {
+      public:
+        as_decimal (const T& v, const facet* f = 0)
+            : x (v), facets (f)
+        {
+        }
+
+        const T& x;
+        const facet* facets;
+      };
+    }
+  }
+}
+
+#include <xsd/cxx/tree/serialization.txx>
+#include <xsd/cxx/tree/serialization/date-time.txx>
+
+#endif  // XSD_CXX_TREE_SERIALIZATION_HXX
diff --git src/base/include/xsd/cxx/tree/serialization.txx src/base/include/xsd/cxx/tree/serialization.txx
new file mode 100644
index 0000000..29364f4
--- /dev/null
+++ src/base/include/xsd/cxx/tree/serialization.txx
@@ -0,0 +1,764 @@
+// file      : xsd/cxx/tree/serialization.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#include <string>
+#include <sstream>
+
+#include <xercesc/dom/DOMAttr.hpp>
+#include <xercesc/dom/DOMElement.hpp>
+
+#include <xsd/cxx/xml/string.hxx>        // xml::{string, transcode}
+#include <xsd/cxx/xml/dom/serialization-header.hxx>  // dom::{prefix, clear}
+
+#include <xsd/cxx/tree/elements.hxx>
+#include <xsd/cxx/tree/types.hxx>
+#include <xsd/cxx/tree/list.hxx>
+
+// The only way to make the following serialization operators
+// for fundamental types work is to defined them in the xercesc
+// namespace so that they can be found by ADL. Placing them into
+// the global namespace does not work.
+//
+
+namespace XERCES_CPP_NAMESPACE
+{
+  // Serialization of std::basic_string and C string. Used in other
+  // serializers. Also used to serialize enumerators.
+  //
+  template <typename C>
+  void
+  operator<< (xercesc::DOMElement& e, const C* s)
+  {
+    xsd::cxx::xml::dom::clear<char> (e);
+
+    if (*s != C (0))
+      e.setTextContent (xsd::cxx::xml::string (s).c_str ());
+  }
+
+  template <typename C>
+  void
+  operator<< (xercesc::DOMAttr& a, const C* s)
+  {
+    a.setValue (xsd::cxx::xml::string (s).c_str ());
+  }
+
+  // We duplicate the code above instead of delegating in order to
+  // allow the xml::string type to take advantage of cached string
+  // sizes.
+  //
+  template <typename C>
+  void
+  operator<< (xercesc::DOMElement& e, const std::basic_string<C>& s)
+  {
+    xsd::cxx::xml::dom::clear<char> (e);
+
+    if (!s.empty ())
+      e.setTextContent (xsd::cxx::xml::string (s).c_str ());
+  }
+
+  template <typename C>
+  void
+  operator<< (xercesc::DOMAttr& a, const std::basic_string<C>& s)
+  {
+    a.setValue (xsd::cxx::xml::string (s).c_str ());
+  }
+}
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      // List serialization operators for std::basic_string and C string.
+      //
+
+      template <typename C>
+      void
+      operator<< (list_stream<C>& ls, const C* s)
+      {
+        ls.os_ << s;
+      }
+
+      template <typename C>
+      void
+      operator<< (list_stream<C>& ls, const std::basic_string<C>& s)
+      {
+        ls.os_ << s;
+      }
+
+      // Insertion operators for type.
+      //
+      inline void
+      operator<< (xercesc::DOMElement& e, const type&)
+      {
+        xml::dom::clear<char> (e);
+      }
+
+      inline void
+      operator<< (xercesc::DOMAttr&, const type&)
+      {
+      }
+
+      template <typename C>
+      inline void
+      operator<< (list_stream<C>&, const type&)
+      {
+      }
+
+      // Insertion operators for simple_type.
+      //
+      template <typename B>
+      inline void
+      operator<< (xercesc::DOMElement& e, const simple_type<B>&)
+      {
+        xml::dom::clear<char> (e);
+      }
+
+      template <typename B>
+      inline void
+      operator<< (xercesc::DOMAttr&, const simple_type<B>&)
+      {
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (list_stream<C>&, const simple_type<B>&)
+      {
+      }
+
+      // Insertion operators for list.
+      //
+      template <typename C, typename T, schema_type::value ST, bool fund>
+      void
+      operator<< (xercesc::DOMElement& e, const list<T, C, ST, fund>& v)
+      {
+        std::basic_ostringstream<C> os;
+        list_stream<C> ls (os, e);
+
+        ls << v;
+
+        e << os.str ();
+      }
+
+      template <typename C, typename T, schema_type::value ST, bool fund>
+      void
+      operator<< (xercesc::DOMAttr& a, const list<T, C, ST, fund>& v)
+      {
+        std::basic_ostringstream<C> os;
+        list_stream<C> ls (os, *a.getOwnerElement ());
+
+        ls << v;
+
+        a << os.str ();
+      }
+
+      template <typename C, typename T, schema_type::value ST, bool fund>
+      void
+      operator<< (list_stream<C>& ls, const list<T, C, ST, fund>& v)
+      {
+        for (typename list<T, C, ST, fund>::const_iterator
+               b (v.begin ()), e (v.end ()), i (b); i != e; ++i)
+        {
+          if (i != b)
+            ls.os_ << C (' ');
+
+          ls << *i;
+        }
+      }
+
+      // Specializations for double and decimal.
+      //
+      template <typename C, typename T, bool fund>
+      void
+      operator<< (list_stream<C>& ls,
+                  const list<T, C, schema_type::double_, fund>& v)
+      {
+        for (typename list<T, C, schema_type::double_, fund>::const_iterator
+               b (v.begin ()), e (v.end ()), i (b); i != e; ++i)
+        {
+          if (i != b)
+            ls.os_ << C (' ');
+
+          ls << as_double<T> (*i);
+        }
+      }
+
+      template <typename C, typename T, bool fund>
+      void
+      operator<< (list_stream<C>& ls,
+                  const list<T, C, schema_type::decimal, fund>& v)
+      {
+        for (typename list<T, C, schema_type::decimal, fund>::const_iterator
+               b (v.begin ()), e (v.end ()), i (b); i != e; ++i)
+        {
+          if (i != b)
+            ls.os_ << C (' ');
+
+          ls << as_decimal<T> (*i);
+        }
+      }
+
+
+      // Insertion operators for fundamental_base.
+      //
+      template <typename T, typename C, typename B, schema_type::value ST>
+      void
+      operator<< (xercesc::DOMElement& e,
+                  const fundamental_base<T, C, B, ST>& x)
+      {
+        const T& r (x);
+        e << r;
+      }
+
+      template <typename T, typename C, typename B, schema_type::value ST>
+      void
+      operator<< (xercesc::DOMAttr& a, const fundamental_base<T, C, B, ST>& x)
+      {
+        const T& r (x);
+        a << r;
+      }
+
+      template <typename T, typename C, typename B, schema_type::value ST>
+      void
+      operator<< (list_stream<C>& ls, const fundamental_base<T, C, B, ST>& x)
+      {
+        const T& r (x);
+        ls << r;
+      }
+
+      // Specializations for double.
+      //
+      template <typename T, typename C, typename B>
+      void
+      operator<< (
+        xercesc::DOMElement& e,
+        const fundamental_base<T, C, B, schema_type::double_>& x)
+      {
+        e << as_double<T> (x);
+      }
+
+      template <typename T, typename C, typename B>
+      void
+      operator<< (
+        xercesc::DOMAttr& a,
+        const fundamental_base<T, C, B, schema_type::double_>& x)
+      {
+        a << as_double<T> (x);
+      }
+
+      template <typename T, typename C, typename B>
+      void
+      operator<< (
+        list_stream<C>& ls,
+        const fundamental_base<T, C, B, schema_type::double_>& x)
+      {
+        ls << as_double<T> (x);
+      }
+
+      // Specializations for decimal.
+      //
+      template <typename T, typename C, typename B>
+      void
+      operator<< (
+        xercesc::DOMElement& e,
+        const fundamental_base<T, C, B, schema_type::decimal>& x)
+      {
+        e << as_decimal<T> (x, x._facet_table ());
+      }
+
+      template <typename T, typename C, typename B>
+      void
+      operator<< (
+        xercesc::DOMAttr& a,
+        const fundamental_base<T, C, B, schema_type::decimal>& x)
+      {
+        a << as_decimal<T> (x, x._facet_table ());
+      }
+
+      template <typename T, typename C, typename B>
+      void
+      operator<< (
+        list_stream<C>& ls,
+        const fundamental_base<T, C, B, schema_type::decimal>& x)
+      {
+        ls << as_decimal<T> (x, x._facet_table ());
+      }
+
+      // Insertion operators for built-in types.
+      //
+
+      namespace bits
+      {
+        template <typename C, typename T>
+        void
+        insert (xercesc::DOMElement& e, const T& x)
+        {
+          std::basic_ostringstream<C> os;
+          os << x;
+          e << os.str ();
+        }
+
+        template <typename C, typename T>
+        void
+        insert (xercesc::DOMAttr& a, const T& x)
+        {
+          std::basic_ostringstream<C> os;
+          os << x;
+          a << os.str ();
+        }
+      }
+
+
+      // string
+      //
+      template <typename C, typename B>
+      inline void
+      operator<< (xercesc::DOMElement& e, const string<C, B>& x)
+      {
+        bits::insert<C> (e, x);
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (xercesc::DOMAttr& a, const string<C, B>& x)
+      {
+        bits::insert<C> (a, x);
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (list_stream<C>& ls, const string<C, B>& x)
+      {
+        ls.os_ << x;
+      }
+
+
+      // normalized_string
+      //
+      template <typename C, typename B>
+      inline void
+      operator<< (xercesc::DOMElement& e, const normalized_string<C, B>& x)
+      {
+        bits::insert<C> (e, x);
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (xercesc::DOMAttr& a, const normalized_string<C, B>& x)
+      {
+        bits::insert<C> (a, x);
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (list_stream<C>& ls, const normalized_string<C, B>& x)
+      {
+        ls.os_ << x;
+      }
+
+
+      // token
+      //
+      template <typename C, typename B>
+      inline void
+      operator<< (xercesc::DOMElement& e, const token<C, B>& x)
+      {
+        bits::insert<C> (e, x);
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (xercesc::DOMAttr& a, const token<C, B>& x)
+      {
+        bits::insert<C> (a, x);
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (list_stream<C>& ls, const token<C, B>& x)
+      {
+        ls.os_ << x;
+      }
+
+
+      // nmtoken
+      //
+      template <typename C, typename B>
+      inline void
+      operator<< (xercesc::DOMElement& e, const nmtoken<C, B>& x)
+      {
+        bits::insert<C> (e, x);
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (xercesc::DOMAttr& a, const nmtoken<C, B>& x)
+      {
+        bits::insert<C> (a, x);
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (list_stream<C>& ls, const nmtoken<C, B>& x)
+      {
+        ls.os_ << x;
+      }
+
+
+      // nmtokens
+      //
+      template <typename C, typename B, typename nmtoken>
+      inline void
+      operator<< (xercesc::DOMElement& e, const nmtokens<C, B, nmtoken>& v)
+      {
+        const list<nmtoken, C>& r (v);
+        e << r;
+      }
+
+      template <typename C, typename B, typename nmtoken>
+      inline void
+      operator<< (xercesc::DOMAttr& a, const nmtokens<C, B, nmtoken>& v)
+      {
+        const list<nmtoken, C>& r (v);
+        a << r;
+      }
+
+      template <typename C, typename B, typename nmtoken>
+      inline void
+      operator<< (list_stream<C>& ls, const nmtokens<C, B, nmtoken>& v)
+      {
+        const list<nmtoken, C>& r (v);
+        ls << r;
+      }
+
+
+      // name
+      //
+      template <typename C, typename B>
+      inline void
+      operator<< (xercesc::DOMElement& e, const name<C, B>& x)
+      {
+        bits::insert<C> (e, x);
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (xercesc::DOMAttr& a, const name<C, B>& x)
+      {
+        bits::insert<C> (a, x);
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (list_stream<C>& ls, const name<C, B>& x)
+      {
+        ls.os_ << x;
+      }
+
+
+      // ncname
+      //
+      template <typename C, typename B>
+      inline void
+      operator<< (xercesc::DOMElement& e, const ncname<C, B>& x)
+      {
+        bits::insert<C> (e, x);
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (xercesc::DOMAttr& a, const ncname<C, B>& x)
+      {
+        bits::insert<C> (a, x);
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (list_stream<C>& ls, const ncname<C, B>& x)
+      {
+        ls.os_ << x;
+      }
+
+
+      // language
+      //
+      template <typename C, typename B>
+      inline void
+      operator<< (xercesc::DOMElement& e, const language<C, B>& x)
+      {
+        bits::insert<C> (e, x);
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (xercesc::DOMAttr& a, const language<C, B>& x)
+      {
+        bits::insert<C> (a, x);
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (list_stream<C>& ls, const language<C, B>& x)
+      {
+        ls.os_ << x;
+      }
+
+
+      // id
+      //
+      template <typename C, typename B>
+      inline void
+      operator<< (xercesc::DOMElement& e, const id<C, B>& x)
+      {
+        bits::insert<C> (e, x);
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (xercesc::DOMAttr& a, const id<C, B>& x)
+      {
+        bits::insert<C> (a, x);
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (list_stream<C>& ls, const id<C, B>& x)
+      {
+        ls.os_ << x;
+      }
+
+
+      // idref
+      //
+      template <typename C, typename B, typename T>
+      inline void
+      operator<< (xercesc::DOMElement& e, const idref<C, B, T>& x)
+      {
+        bits::insert<C> (e, x);
+      }
+
+      template <typename C, typename B, typename T>
+      inline void
+      operator<< (xercesc::DOMAttr& a, const idref<C, B, T>& x)
+      {
+        bits::insert<C> (a, x);
+      }
+
+      template <typename C, typename B, typename T>
+      inline void
+      operator<< (list_stream<C>& ls, const idref<C, B, T>& x)
+      {
+        ls.os_ << x;
+      }
+
+
+      // idrefs
+      //
+      template <typename C, typename B, typename idref>
+      inline void
+      operator<< (xercesc::DOMElement& e, const idrefs<C, B, idref>& v)
+      {
+        const list<idref, C>& r (v);
+        e << r;
+      }
+
+      template <typename C, typename B, typename idref>
+      inline void
+      operator<< (xercesc::DOMAttr& a, const idrefs<C, B, idref>& v)
+      {
+        const list<idref, C>& r (v);
+        a << r;
+      }
+
+      template <typename C, typename B, typename idref>
+      inline void
+      operator<< (list_stream<C>& ls, const idrefs<C, B, idref>& v)
+      {
+        const list<idref, C>& r (v);
+        ls << r;
+      }
+
+
+      // uri
+      //
+      template <typename C, typename B>
+      inline void
+      operator<< (xercesc::DOMElement& e, const uri<C, B>& x)
+      {
+        bits::insert<C> (e, x);
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (xercesc::DOMAttr& a, const uri<C, B>& x)
+      {
+        bits::insert<C> (a, x);
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (list_stream<C>& ls, const uri<C, B>& x)
+      {
+        ls.os_ << x;
+      }
+
+
+      // qname
+      //
+      template <typename C, typename B, typename uri, typename ncname>
+      void
+      operator<< (xercesc::DOMElement& e, const qname<C, B, uri, ncname>& x)
+      {
+        std::basic_ostringstream<C> os;
+
+        if (x.qualified ())
+        {
+          std::basic_string<C> p (xml::dom::prefix (x.namespace_ (), e));
+
+          if (!p.empty ())
+            os << p << C (':');
+        }
+
+        os << x.name ();
+        e << os.str ();
+      }
+
+      template <typename C, typename B, typename uri, typename ncname>
+      void
+      operator<< (xercesc::DOMAttr& a, const qname<C, B, uri, ncname>& x)
+      {
+        std::basic_ostringstream<C> os;
+
+        if (x.qualified ())
+        {
+          std::basic_string<C> p (
+            xml::dom::prefix (x.namespace_ (), *a.getOwnerElement ()));
+
+          if (!p.empty ())
+            os << p << C (':');
+        }
+
+        os << x.name ();
+        a << os.str ();
+      }
+
+      template <typename C, typename B, typename uri, typename ncname>
+      void
+      operator<< (list_stream<C>& ls, const qname<C, B, uri, ncname>& x)
+      {
+        if (x.qualified ())
+        {
+          std::basic_string<C> p (
+            xml::dom::prefix (x.namespace_ (), ls.parent_));
+
+          if (!p.empty ())
+            ls.os_ << p << C (':');
+        }
+
+        ls.os_ << x.name ();
+      }
+
+
+      // base64_binary
+      //
+      template <typename C, typename B>
+      inline void
+      operator<< (xercesc::DOMElement& e, const base64_binary<C, B>& x)
+      {
+        e << x.encode ();
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (xercesc::DOMAttr& a, const base64_binary<C, B>& x)
+      {
+        a << x.encode ();
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (list_stream<C>& ls, const base64_binary<C, B>& x)
+      {
+        ls.os_ << x.encode ();
+      }
+
+
+      // hex_binary
+      //
+      template <typename C, typename B>
+      inline void
+      operator<< (xercesc::DOMElement& e, const hex_binary<C, B>& x)
+      {
+        e << x.encode ();
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (xercesc::DOMAttr& a, const hex_binary<C, B>& x)
+      {
+        a << x.encode ();
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (list_stream<C>& ls, const hex_binary<C, B>& x)
+      {
+        ls.os_ << x.encode ();
+      }
+
+
+      // entity
+      //
+      template <typename C, typename B>
+      inline void
+      operator<< (xercesc::DOMElement& e, const entity<C, B>& x)
+      {
+        bits::insert<C> (e, x);
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (xercesc::DOMAttr& a, const entity<C, B>& x)
+      {
+        bits::insert<C> (a, x);
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (list_stream<C>& ls, const entity<C, B>& x)
+      {
+        ls.os_ << x;
+      }
+
+
+      // entities
+      //
+      template <typename C, typename B, typename entity>
+      inline void
+      operator<< (xercesc::DOMElement& e, const entities<C, B, entity>& v)
+      {
+        const list<entity, C>& r (v);
+        e << r;
+      }
+
+      template <typename C, typename B, typename entity>
+      inline void
+      operator<< (xercesc::DOMAttr& a, const entities<C, B, entity>& v)
+      {
+        const list<entity, C>& r (v);
+        a << r;
+      }
+
+      template <typename C, typename B, typename entity>
+      inline void
+      operator<< (list_stream<C>& ls, const entities<C, B, entity>& v)
+      {
+        const list<entity, C>& r (v);
+        ls << r;
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/tree/serialization/boolean.hxx src/base/include/xsd/cxx/tree/serialization/boolean.hxx
new file mode 100644
index 0000000..ce34560
--- /dev/null
+++ src/base/include/xsd/cxx/tree/serialization/boolean.hxx
@@ -0,0 +1,52 @@
+// file      : xsd/cxx/tree/serialization/boolean.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_SERIALIZATION_BOOLEAN_HXX
+#define XSD_CXX_TREE_SERIALIZATION_BOOLEAN_HXX
+
+#include <sstream>
+
+namespace XERCES_CPP_NAMESPACE
+{
+  inline void
+  operator<< (xercesc::DOMElement& e, bool b)
+  {
+    std::basic_ostringstream<char> os;
+    os.setf (std::ios_base::boolalpha);
+    os << b;
+    e << os.str ();
+  }
+
+  inline void
+  operator<< (xercesc::DOMAttr& a, bool b)
+  {
+    std::basic_ostringstream<char> os;
+    os.setf (std::ios_base::boolalpha);
+    os << b;
+    a << os.str ();
+  }
+}
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      template <typename C>
+      inline void
+      operator<< (list_stream<C>& ls, bool b)
+      {
+        // We don't need to restore the original bool format flag
+        // since items in the list are all of the same type.
+        //
+        ls.os_.setf (std::ios_base::boolalpha);
+        ls.os_ << b;
+      }
+    }
+  }
+}
+
+#endif // XSD_CXX_TREE_SERIALIZATION_BOOLEAN_HXX
diff --git src/base/include/xsd/cxx/tree/serialization/byte.hxx src/base/include/xsd/cxx/tree/serialization/byte.hxx
new file mode 100644
index 0000000..583eda9
--- /dev/null
+++ src/base/include/xsd/cxx/tree/serialization/byte.hxx
@@ -0,0 +1,46 @@
+// file      : xsd/cxx/tree/serialization/byte.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_SERIALIZATION_BYTE_HXX
+#define XSD_CXX_TREE_SERIALIZATION_BYTE_HXX
+
+#include <sstream>
+
+namespace XERCES_CPP_NAMESPACE
+{
+  inline void
+  operator<< (xercesc::DOMElement& e, signed char c)
+  {
+    std::basic_ostringstream<char> os;
+    os << static_cast<short> (c);
+    e << os.str ();
+  }
+
+  inline void
+  operator<< (xercesc::DOMAttr& a, signed char c)
+  {
+    std::basic_ostringstream<char> os;
+    os << static_cast<short> (c);
+    a << os.str ();
+  }
+}
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      template <typename C>
+      inline void
+      operator<< (list_stream<C>& ls, signed char c)
+      {
+        ls.os_ << static_cast<short> (c);
+      }
+    }
+  }
+}
+
+#endif // XSD_CXX_TREE_SERIALIZATION_BYTE_HXX
diff --git src/base/include/xsd/cxx/tree/serialization/date-time.txx src/base/include/xsd/cxx/tree/serialization/date-time.txx
new file mode 100644
index 0000000..1180e1c
--- /dev/null
+++ src/base/include/xsd/cxx/tree/serialization/date-time.txx
@@ -0,0 +1,620 @@
+// file      : xsd/cxx/tree/serialization/date-time.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#include <locale>
+#include <string>
+#include <ostream>
+#include <sstream>
+
+#include <xsd/cxx/tree/bits/literals.hxx> // bits::{gday_prefix,gmonth_prefix}
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      // time_zone
+      //
+      namespace bits
+      {
+        // Assumes the fill character is set to '0'.
+        //
+        template <typename C>
+        void
+        zone_insert (std::basic_ostream<C>& os, const time_zone& z)
+        {
+          // time-zone := Z|(+|-)HH:MM
+          //
+          short h = z.zone_hours ();
+          short m = z.zone_minutes ();
+
+          if (h == 0 && m == 0)
+          {
+            os << C ('Z');
+          }
+          else
+          {
+            if (h < 0 || m < 0)
+            {
+              h = -h;
+              m = -m;
+              os << C ('-');
+            }
+            else
+              os << C ('+');
+
+            if (h >= 0 && h <= 14 && m >= 0 && m <= 59)
+            {
+              os.width (2);
+              os << h << C (':');
+              os.width (2);
+              os << m;
+            }
+          }
+        }
+      }
+
+      // gday
+      //
+      namespace bits
+      {
+        template <typename C, typename B>
+        void
+        insert (std::basic_ostream<C>& os, const tree::gday<C, B>& x)
+        {
+          if (x.day () < 32)
+          {
+            // Save some time and space by not restoring the fill character
+            // since it is the same in case of a list.
+            //
+            os.fill (C ('0'));
+            os << bits::gday_prefix<C> ();
+            os.width (2);
+            os << x.day ();
+
+            if (x.zone_present ())
+              zone_insert (os, x);
+          }
+        }
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (xercesc::DOMElement& e, const gday<C, B>& x)
+      {
+        std::basic_ostringstream<C> os;
+        bits::insert (os, x);
+        e << os.str ();
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (xercesc::DOMAttr& a, const gday<C, B>& x)
+      {
+        std::basic_ostringstream<C> os;
+        bits::insert (os, x);
+        a << os.str ();
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (list_stream<C>& ls, const gday<C, B>& x)
+      {
+        bits::insert (ls.os_, x);
+      }
+
+      // gmonth
+      //
+      namespace bits
+      {
+        template <typename C, typename B>
+        void
+        insert (std::basic_ostream<C>& os, const tree::gmonth<C, B>& x)
+        {
+          if (x.month () < 13)
+          {
+            os.fill (C ('0'));
+            os << bits::gmonth_prefix<C> ();
+            os.width (2);
+            os << x.month ();
+
+            if (x.zone_present ())
+              zone_insert (os, x);
+          }
+        }
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (xercesc::DOMElement& e, const gmonth<C, B>& x)
+      {
+        std::basic_ostringstream<C> os;
+        bits::insert (os, x);
+        e << os.str ();
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (xercesc::DOMAttr& a, const gmonth<C, B>& x)
+      {
+        std::basic_ostringstream<C> os;
+        bits::insert (os, x);
+        a << os.str ();
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (list_stream<C>& ls, const gmonth<C, B>& x)
+      {
+        bits::insert (ls.os_, x);
+      }
+
+      // gyear
+      //
+      namespace bits
+      {
+        template <typename C, typename B>
+        void
+        insert (std::basic_ostream<C>& os, const tree::gyear<C, B>& x)
+        {
+          os.fill (C ('0'));
+          os.width (4);
+          os << x.year ();
+
+          if (x.zone_present ())
+            zone_insert (os, x);
+        }
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (xercesc::DOMElement& e, const gyear<C, B>& x)
+      {
+        std::basic_ostringstream<C> os;
+        bits::insert (os, x);
+        e << os.str ();
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (xercesc::DOMAttr& a, const gyear<C, B>& x)
+      {
+        std::basic_ostringstream<C> os;
+        bits::insert (os, x);
+        a << os.str ();
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (list_stream<C>& ls, const gyear<C, B>& x)
+      {
+        bits::insert (ls.os_, x);
+      }
+
+      // gmonth_day
+      //
+      namespace bits
+      {
+        template <typename C, typename B>
+        void
+        insert (std::basic_ostream<C>& os, const tree::gmonth_day<C, B>& x)
+        {
+          if (x.month () < 13 && x.day () < 32)
+          {
+            os.fill (C ('0'));
+            os << bits::gmonth_prefix<C> ();
+            os.width (2);
+            os << x.month () << C ('-');
+            os.width (2);
+            os << x.day ();
+
+            if (x.zone_present ())
+              zone_insert (os, x);
+          }
+        }
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (xercesc::DOMElement& e, const gmonth_day<C, B>& x)
+      {
+        std::basic_ostringstream<C> os;
+        bits::insert (os, x);
+        e << os.str ();
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (xercesc::DOMAttr& a, const gmonth_day<C, B>& x)
+      {
+        std::basic_ostringstream<C> os;
+        bits::insert (os, x);
+        a << os.str ();
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (list_stream<C>& ls, const gmonth_day<C, B>& x)
+      {
+        bits::insert (ls.os_, x);
+      }
+
+      // gyear_month
+      //
+      namespace bits
+      {
+        template <typename C, typename B>
+        void
+        insert (std::basic_ostream<C>& os, const tree::gyear_month<C, B>& x)
+        {
+          if (x.month () < 13)
+          {
+            os.fill (C ('0'));
+            os.width (4);
+            os << x.year () << C ('-');
+            os.width (2);
+            os << x.month ();
+
+            if (x.zone_present ())
+              zone_insert (os, x);
+          }
+        }
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (xercesc::DOMElement& e, const gyear_month<C, B>& x)
+      {
+        std::basic_ostringstream<C> os;
+        bits::insert (os, x);
+        e << os.str ();
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (xercesc::DOMAttr& a, const gyear_month<C, B>& x)
+      {
+        std::basic_ostringstream<C> os;
+        bits::insert (os, x);
+        a << os.str ();
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (list_stream<C>& ls, const gyear_month<C, B>& x)
+      {
+        bits::insert (ls.os_, x);
+      }
+
+      // date
+      //
+      namespace bits
+      {
+        template <typename C, typename B>
+        void
+        insert (std::basic_ostream<C>& os, const tree::date<C, B>& x)
+        {
+          if (x.month () < 13 && x.day () < 32)
+          {
+            os.fill (C ('0'));
+            os.width (4);
+            os << x.year () << C ('-');
+            os.width (2);
+            os << x.month () << C ('-');
+            os.width (2);
+            os << x.day ();
+
+            if (x.zone_present ())
+              zone_insert (os, x);
+          }
+        }
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (xercesc::DOMElement& e, const date<C, B>& x)
+      {
+        std::basic_ostringstream<C> os;
+        bits::insert (os, x);
+        e << os.str ();
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (xercesc::DOMAttr& a, const date<C, B>& x)
+      {
+        std::basic_ostringstream<C> os;
+        bits::insert (os, x);
+        a << os.str ();
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (list_stream<C>& ls, const date<C, B>& x)
+      {
+        bits::insert (ls.os_, x);
+      }
+
+      // time
+      //
+      namespace bits
+      {
+        template <typename C, typename B>
+        void
+        insert (std::basic_ostream<C>& os, const tree::time<C, B>& x)
+        {
+          if (x.hours () <= 24 &&
+              x.minutes () <= 59 &&
+              x.seconds () >= 0.0 &&
+              x.seconds () < 60.0)
+          {
+            os.fill (C ('0'));
+            os.width (2);
+            os << x.hours () << C (':');
+
+            os.width (2);
+            os << x.minutes () << C (':');
+
+            std::basic_ostringstream<C> ostr;
+            ostr.imbue (std::locale::classic ());
+            ostr.width (9);
+            ostr.fill (C ('0'));
+            ostr << std::fixed << x.seconds ();
+
+            std::basic_string<C> s (ostr.str ());
+
+            // Remove the trailing zeros and the decimal point if necessary.
+            //
+            typedef typename std::basic_string<C>::size_type size_type;
+
+            size_type size (s.size ()), n (size);
+
+            for (; n > 0 && s[n - 1] == C ('0'); --n)/*noop*/;
+
+            if (n > 0 && s[n - 1] == C ('.'))
+              --n;
+
+            if (n != size)
+              s.resize (n);
+
+            os << s;
+
+            if (x.zone_present ())
+              zone_insert (os, x);
+          }
+        }
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (xercesc::DOMElement& e, const time<C, B>& x)
+      {
+        std::basic_ostringstream<C> os;
+        bits::insert (os, x);
+        e << os.str ();
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (xercesc::DOMAttr& a, const time<C, B>& x)
+      {
+        std::basic_ostringstream<C> os;
+        bits::insert (os, x);
+        a << os.str ();
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (list_stream<C>& ls, const time<C, B>& x)
+      {
+        bits::insert (ls.os_, x);
+      }
+
+      // date_time
+      //
+      namespace bits
+      {
+        template <typename C, typename B>
+        void
+        insert (std::basic_ostream<C>& os, const tree::date_time<C, B>& x)
+        {
+          if (x.month () <= 12 &&
+              x.day () <= 31 &&
+              x.hours () <= 24 &&
+              x.minutes () <= 59 &&
+              x.seconds () >= 0.0 &&
+              x.seconds () < 60.0)
+          {
+            os.fill (C ('0'));
+            os.width (4);
+            os << x.year () << C ('-');
+
+            os.width (2);
+            os << x.month () << C ('-');
+
+            os.width (2);
+            os << x.day () << C ('T');
+
+            os.width (2);
+            os << x.hours () << C (':');
+
+            os.width (2);
+            os << x.minutes () << C (':');
+
+            std::basic_ostringstream<C> ostr;
+            ostr.imbue (std::locale::classic ());
+            ostr.width (9);
+            ostr.fill (C ('0'));
+            ostr << std::fixed << x.seconds ();
+
+            std::basic_string<C> s (ostr.str ());
+
+            // Remove the trailing zeros and the decimal point if necessary.
+            //
+            typedef typename std::basic_string<C>::size_type size_type;
+
+            size_type size (s.size ()), n (size);
+
+            for (; n > 0 && s[n - 1] == C ('0'); --n)/*noop*/;
+
+            if (n > 0 && s[n - 1] == C ('.'))
+              --n;
+
+            if (n != size)
+              s.resize (n);
+
+            os << s;
+
+            if (x.zone_present ())
+              zone_insert (os, x);
+          }
+        }
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (xercesc::DOMElement& e, const date_time<C, B>& x)
+      {
+        std::basic_ostringstream<C> os;
+        bits::insert (os, x);
+        e << os.str ();
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (xercesc::DOMAttr& a, const date_time<C, B>& x)
+      {
+        std::basic_ostringstream<C> os;
+        bits::insert (os, x);
+        a << os.str ();
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (list_stream<C>& ls, const date_time<C, B>& x)
+      {
+        bits::insert (ls.os_, x);
+      }
+
+      // duration
+      //
+      namespace bits
+      {
+        template <typename C, typename B>
+        void
+        insert (std::basic_ostream<C>& os, const tree::duration<C, B>& x)
+        {
+          if (x.negative ())
+            os << C ('-');
+
+          os << C ('P');
+
+          // years
+          //
+          // In case it is 0-duration, use the years field to handle
+          // this case.
+          //
+          if (x.years () != 0 ||
+              (x.months () == 0 &&
+               x.days () == 0 &&
+               x.hours () == 0 &&
+               x.minutes () == 0 &&
+               x.seconds () == 0.0))
+          {
+            os << x.years () << C ('Y');
+          }
+
+          // months
+          //
+          if (x.months () != 0)
+          {
+            os << x.months () << C ('M');
+          }
+
+          // days
+          //
+          if (x.days () != 0)
+          {
+            os << x.days () << C ('D');
+          }
+
+          // Figure out if we need the 'T' delimiter.
+          //
+          if (x.hours () != 0 ||
+              x.minutes () != 0 ||
+              x.seconds () != 0.0)
+            os << C ('T');
+
+          // hours
+          //
+          if (x.hours () != 0)
+          {
+            os << x.hours () << C ('H');
+          }
+
+          // minutes
+          //
+          if (x.minutes () != 0)
+          {
+            os << x.minutes () << C ('M');
+          }
+
+          // seconds
+          //
+          if (x.seconds () > 0.0)
+          {
+            std::basic_ostringstream<C> ostr;
+            ostr.imbue (std::locale::classic ());
+            ostr << std::fixed << x.seconds ();
+
+            std::basic_string<C> s (ostr.str ());
+
+            // Remove the trailing zeros and the decimal point if necessary.
+            //
+            typedef typename std::basic_string<C>::size_type size_type;
+
+            size_type size (s.size ()), n (size);
+
+            for (; n > 0 && s[n - 1] == C ('0'); --n)/*noop*/;
+
+            if (n > 0 && s[n - 1] == C ('.'))
+              --n;
+
+            if (n != size)
+              s.resize (n);
+
+            os << s << C ('S');
+          }
+        }
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (xercesc::DOMElement& e, const duration<C, B>& x)
+      {
+        std::basic_ostringstream<C> os;
+        bits::insert (os, x);
+        e << os.str ();
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (xercesc::DOMAttr& a, const duration<C, B>& x)
+      {
+        std::basic_ostringstream<C> os;
+        bits::insert (os, x);
+        a << os.str ();
+      }
+
+      template <typename C, typename B>
+      inline void
+      operator<< (list_stream<C>& ls, const duration<C, B>& x)
+      {
+        bits::insert (ls.os_, x);
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/tree/serialization/decimal.hxx src/base/include/xsd/cxx/tree/serialization/decimal.hxx
new file mode 100644
index 0000000..971622f
--- /dev/null
+++ src/base/include/xsd/cxx/tree/serialization/decimal.hxx
@@ -0,0 +1,126 @@
+// file      : xsd/cxx/tree/serialization/decimal.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_SERIALIZATION_DECIMAL_HXX
+#define XSD_CXX_TREE_SERIALIZATION_DECIMAL_HXX
+
+#include <limits> // std::numeric_limits
+#include <locale>
+#include <sstream>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      namespace bits
+      {
+        // The formula for the number of decimla digits required is given in:
+        //
+        // http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1822.pdf
+        //
+        template <typename C>
+        std::basic_string<C>
+        insert (const as_decimal<double>& d)
+        {
+          std::basic_ostringstream<C> os;
+          os.imbue (std::locale::classic ());
+          std::streamsize prec;
+
+          const facet* f = d.facets ?
+            facet::find (d.facets, facet::fraction_digits) : 0;
+
+          if (f)
+            prec = static_cast<std::streamsize> (f->value);
+          else
+          {
+            // Precision.
+            //
+#if defined (XSD_CXX_TREE_DECIMAL_PRECISION_MAX)
+            prec = 2 + std::numeric_limits<double>::digits * 301/1000;
+#elif defined (XSD_CXX_TREE_DECIMAL_PRECISION)
+            prec = XSD_CXX_TREE_DECIMAL_PRECISION;
+#else
+            prec = std::numeric_limits<double>::digits10;
+#endif
+          }
+
+          os.precision (prec);
+          os << std::fixed << d.x;
+          std::basic_string<C> r (os.str ());
+          const C* cr (r.c_str ());
+
+          // Remove the trailing zeros and the decimal point if necessary.
+          //
+          typename std::basic_string<C>::size_type size (r.size ()), n (size);
+
+          if (prec != 0)
+          {
+            for (; n > 0 && cr[n - 1] == '0'; --n)/*noop*/;
+
+            if (n > 0 && cr[n - 1] == '.')
+              --n;
+          }
+
+          // See if we have a restriction on total digits.
+          //
+          f = d.facets ? facet::find (d.facets, facet::total_digits) : 0;
+
+          if (f && n > f->value)
+          {
+            // Point and sign do not count so figure out if we have them.
+            //
+            typename std::basic_string<C>::size_type extra (
+              cr[0] == '-' ? 1 : 0);
+
+            if (r.find ('.') < n)
+              extra++;
+
+            // Unless we have a point and the size difference is one,
+            // remove some digits.
+            //
+            if ((n - extra) > f->value)
+              n -= (n - extra - f->value);
+
+            if (n > 0 && cr[n - 1] == '.')
+              --n;
+          }
+
+          if (n != size)
+            r.resize (n);
+
+          return r;
+        }
+      }
+
+      template <typename C>
+      inline void
+      operator<< (list_stream<C>& ls, const as_decimal<double>& d)
+      {
+        ls.os_ << bits::insert<C> (d);
+      }
+    }
+  }
+}
+
+namespace XERCES_CPP_NAMESPACE
+{
+  inline void
+  operator<< (xercesc::DOMElement& e,
+              const xsd::cxx::tree::as_decimal<double>& d)
+  {
+    e << xsd::cxx::tree::bits::insert<char> (d);
+  }
+
+  inline void
+  operator<< (xercesc::DOMAttr& a,
+              const xsd::cxx::tree::as_decimal<double>& d)
+  {
+    a << xsd::cxx::tree::bits::insert<char> (d);
+  }
+}
+
+#endif // XSD_CXX_TREE_SERIALIZATION_DECIMAL_HXX
diff --git src/base/include/xsd/cxx/tree/serialization/double.hxx src/base/include/xsd/cxx/tree/serialization/double.hxx
new file mode 100644
index 0000000..6d21536
--- /dev/null
+++ src/base/include/xsd/cxx/tree/serialization/double.hxx
@@ -0,0 +1,96 @@
+// file      : xsd/cxx/tree/serialization/double.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_SERIALIZATION_DOUBLE_HXX
+#define XSD_CXX_TREE_SERIALIZATION_DOUBLE_HXX
+
+#include <limits> // std::numeric_limits
+#include <locale>
+#include <sstream>
+
+#include <xsd/cxx/tree/bits/literals.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      namespace bits
+      {
+        // The formula for the number of decimla digits required is given in:
+        //
+        // http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1822.pdf
+        //
+        template <typename C>
+        std::basic_string<C>
+        insert (const as_double<double>& d)
+        {
+          std::basic_string<C> r;
+
+          if (d.x == std::numeric_limits<double>::infinity ())
+            r = bits::positive_inf<C> ();
+          else if (d.x == -std::numeric_limits<double>::infinity ())
+            r = bits::negative_inf<C> ();
+          else if (!(d.x == d.x))
+            r = bits::nan<C> ();
+          else
+          {
+            std::basic_ostringstream<C> os;
+            os.imbue (std::locale::classic ());
+
+            // Precision.
+            //
+#if defined (XSD_CXX_TREE_DOUBLE_PRECISION_MAX)
+            os.precision (2 + std::numeric_limits<double>::digits * 301/1000);
+#elif defined (XSD_CXX_TREE_DOUBLE_PRECISION)
+            os.precision (XSD_CXX_TREE_DOUBLE_PRECISION);
+#else
+            os.precision (std::numeric_limits<double>::digits10);
+#endif
+            // Format.
+            //
+#if defined (XSD_CXX_TREE_DOUBLE_FIXED)
+            os << std::fixed << d.x;
+#elif defined (XSD_CXX_TREE_DOUBLE_SCIENTIFIC)
+            os << std::scientific << d.x;
+#else
+            os << d.x;
+#endif
+            r = os.str ();
+          }
+
+          return r;
+        }
+      }
+
+      template <typename C>
+      inline void
+      operator<< (list_stream<C>& ls, const as_double<double>& d)
+      {
+        ls.os_ << bits::insert<C> (d);
+      }
+    }
+  }
+}
+
+namespace XERCES_CPP_NAMESPACE
+{
+  inline void
+  operator<< (xercesc::DOMElement& e,
+              const xsd::cxx::tree::as_double<double>& d)
+  {
+    e << xsd::cxx::tree::bits::insert<char> (d);
+  }
+
+  inline void
+  operator<< (xercesc::DOMAttr& a,
+              const xsd::cxx::tree::as_double<double>& d)
+  {
+    a << xsd::cxx::tree::bits::insert<char> (d);
+  }
+}
+
+#endif // XSD_CXX_TREE_SERIALIZATION_DOUBLE_HXX
diff --git src/base/include/xsd/cxx/tree/serialization/element-map.txx src/base/include/xsd/cxx/tree/serialization/element-map.txx
new file mode 100644
index 0000000..9870ff2
--- /dev/null
+++ src/base/include/xsd/cxx/tree/serialization/element-map.txx
@@ -0,0 +1,40 @@
+// file      : xsd/cxx/tree/serialization/element-map.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_SERIALIZATION_ELEMENT_MAP_TXX
+#define XSD_CXX_TREE_SERIALIZATION_ELEMENT_MAP_TXX
+
+#include <xsd/cxx/tree/exceptions.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      template <typename C, typename T>
+      void element_map<C, T>::
+      serialize (xercesc::DOMElement& e, const element_type& x)
+      {
+        const qualified_name n (x._name (), x._namespace ());
+        typename map::const_iterator i (map_->find (n));
+
+        if (i != map_->end () && i->second.serializer_ != 0)
+          return (i->second.serializer_) (e, x);
+        else
+          throw no_element_info<C> (n.name (), n.namespace_ ());
+      }
+
+      template<typename T, typename C, typename B>
+      void
+      serializer_impl (xercesc::DOMElement& e, const element_type<C, B>& x)
+      {
+        e << static_cast<const T&> (x);
+      }
+    }
+  }
+}
+
+#endif // XSD_CXX_TREE_SERIALIZATION_ELEMENT_MAP_TXX
diff --git src/base/include/xsd/cxx/tree/serialization/float.hxx src/base/include/xsd/cxx/tree/serialization/float.hxx
new file mode 100644
index 0000000..2d37ae6
--- /dev/null
+++ src/base/include/xsd/cxx/tree/serialization/float.hxx
@@ -0,0 +1,94 @@
+// file      : xsd/cxx/tree/serialization/float.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_SERIALIZATION_FLOAT_HXX
+#define XSD_CXX_TREE_SERIALIZATION_FLOAT_HXX
+
+#include <limits> // std::numeric_limits
+#include <locale>
+#include <sstream>
+
+#include <xsd/cxx/tree/bits/literals.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      namespace bits
+      {
+        // The formula for the number of decimla digits required is given in:
+        //
+        // http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1822.pdf
+        //
+        template <typename C>
+        std::basic_string<C>
+        insert (float f)
+        {
+          std::basic_string<C> r;
+
+          if (f == std::numeric_limits<float>::infinity ())
+            r = bits::positive_inf<C> ();
+          else if (f == -std::numeric_limits<float>::infinity ())
+            r = bits::negative_inf<C> ();
+          else if (!(f == f))
+            r = bits::nan<C> ();
+          else
+          {
+            std::basic_ostringstream<C> os;
+            os.imbue (std::locale::classic ());
+
+            // Precision.
+            //
+#if defined (XSD_CXX_TREE_FLOAT_PRECISION_MAX)
+            os.precision (2 + std::numeric_limits<float>::digits * 301/1000);
+#elif defined (XSD_CXX_TREE_FLOAT_PRECISION)
+            os.precision (XSD_CXX_TREE_FLOAT_PRECISION);
+#else
+            os.precision (std::numeric_limits<float>::digits10);
+#endif
+            // Format.
+            //
+#if defined (XSD_CXX_TREE_FLOAT_FIXED)
+            os << std::fixed << f;
+#elif defined (XSD_CXX_TREE_FLOAT_SCIENTIFIC)
+            os << std::scientific << f;
+#else
+            os << f;
+#endif
+            r = os.str ();
+          }
+
+          return r;
+        }
+      }
+
+      template <typename C>
+      inline void
+      operator<< (list_stream<C>& ls, float f)
+      {
+        ls.os_ << bits::insert<C> (f);
+      }
+    }
+  }
+}
+
+namespace XERCES_CPP_NAMESPACE
+{
+  inline void
+  operator<< (xercesc::DOMElement& e, float f)
+  {
+    e << xsd::cxx::tree::bits::insert<char> (f);
+  }
+
+  inline void
+  operator<< (xercesc::DOMAttr& a, float f)
+  {
+    a << xsd::cxx::tree::bits::insert<char> (f);
+  }
+}
+
+#endif // XSD_CXX_TREE_SERIALIZATION_FLOAT_HXX
diff --git src/base/include/xsd/cxx/tree/serialization/int.hxx src/base/include/xsd/cxx/tree/serialization/int.hxx
new file mode 100644
index 0000000..f88d6b8
--- /dev/null
+++ src/base/include/xsd/cxx/tree/serialization/int.hxx
@@ -0,0 +1,46 @@
+// file      : xsd/cxx/tree/serialization/int.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_SERIALIZATION_INT_HXX
+#define XSD_CXX_TREE_SERIALIZATION_INT_HXX
+
+#include <sstream>
+
+namespace XERCES_CPP_NAMESPACE
+{
+  inline void
+  operator<< (xercesc::DOMElement& e, int i)
+  {
+    std::basic_ostringstream<char> os;
+    os << i;
+    e << os.str ();
+  }
+
+  inline void
+  operator<< (xercesc::DOMAttr& a, int i)
+  {
+    std::basic_ostringstream<char> os;
+    os << i;
+    a << os.str ();
+  }
+}
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      template <typename C>
+      inline void
+      operator<< (list_stream<C>& ls, int i)
+      {
+        ls.os_ << i;
+      }
+    }
+  }
+}
+
+#endif // XSD_CXX_TREE_SERIALIZATION_INT_HXX
diff --git src/base/include/xsd/cxx/tree/serialization/long.hxx src/base/include/xsd/cxx/tree/serialization/long.hxx
new file mode 100644
index 0000000..c37338b
--- /dev/null
+++ src/base/include/xsd/cxx/tree/serialization/long.hxx
@@ -0,0 +1,46 @@
+// file      : xsd/cxx/tree/serialization/long.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_SERIALIZATION_LONG_HXX
+#define XSD_CXX_TREE_SERIALIZATION_LONG_HXX
+
+#include <sstream>
+
+namespace XERCES_CPP_NAMESPACE
+{
+  inline void
+  operator<< (xercesc::DOMElement& e, long long l)
+  {
+    std::basic_ostringstream<char> os;
+    os << l;
+    e << os.str ();
+  }
+
+  inline void
+  operator<< (xercesc::DOMAttr& a, long long l)
+  {
+    std::basic_ostringstream<char> os;
+    os << l;
+    a << os.str ();
+  }
+}
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      template <typename C>
+      inline void
+      operator<< (list_stream<C>& ls, long long l)
+      {
+        ls.os_ << l;
+      }
+    }
+  }
+}
+
+#endif // XSD_CXX_TREE_SERIALIZATION_LONG_HXX
diff --git src/base/include/xsd/cxx/tree/serialization/short.hxx src/base/include/xsd/cxx/tree/serialization/short.hxx
new file mode 100644
index 0000000..7d885c1
--- /dev/null
+++ src/base/include/xsd/cxx/tree/serialization/short.hxx
@@ -0,0 +1,46 @@
+// file      : xsd/cxx/tree/serialization/short.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_SERIALIZATION_SHORT_HXX
+#define XSD_CXX_TREE_SERIALIZATION_SHORT_HXX
+
+#include <sstream>
+
+namespace XERCES_CPP_NAMESPACE
+{
+  inline void
+  operator<< (xercesc::DOMElement& e, short s)
+  {
+    std::basic_ostringstream<char> os;
+    os << s;
+    e << os.str ();
+  }
+
+  inline void
+  operator<< (xercesc::DOMAttr& a, short s)
+  {
+    std::basic_ostringstream<char> os;
+    os << s;
+    a << os.str ();
+  }
+}
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      template <typename C>
+      inline void
+      operator<< (list_stream<C>& ls, short s)
+      {
+        ls.os_ << s;
+      }
+    }
+  }
+}
+
+#endif // XSD_CXX_TREE_SERIALIZATION_SHORT_HXX
diff --git src/base/include/xsd/cxx/tree/serialization/unsigned-byte.hxx src/base/include/xsd/cxx/tree/serialization/unsigned-byte.hxx
new file mode 100644
index 0000000..114f1a1
--- /dev/null
+++ src/base/include/xsd/cxx/tree/serialization/unsigned-byte.hxx
@@ -0,0 +1,46 @@
+// file      : xsd/cxx/tree/serialization/unsigned-byte.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_SERIALIZATION_UNSIGNED_BYTE_HXX
+#define XSD_CXX_TREE_SERIALIZATION_UNSIGNED_BYTE_HXX
+
+#include <sstream>
+
+namespace XERCES_CPP_NAMESPACE
+{
+  inline void
+  operator<< (xercesc::DOMElement& e, unsigned char c)
+  {
+    std::basic_ostringstream<char> os;
+    os << static_cast<unsigned short> (c);
+    e << os.str ();
+  }
+
+  inline void
+  operator<< (xercesc::DOMAttr& a, unsigned char c)
+  {
+    std::basic_ostringstream<char> os;
+    os << static_cast<unsigned short> (c);
+    a << os.str ();
+  }
+}
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      template <typename C>
+      inline void
+      operator<< (list_stream<C>& ls, unsigned char c)
+      {
+        ls.os_ << static_cast<unsigned short> (c);
+      }
+    }
+  }
+}
+
+#endif // XSD_CXX_TREE_SERIALIZATION_UNSIGNED_BYTE_HXX
diff --git src/base/include/xsd/cxx/tree/serialization/unsigned-int.hxx src/base/include/xsd/cxx/tree/serialization/unsigned-int.hxx
new file mode 100644
index 0000000..f91fe21
--- /dev/null
+++ src/base/include/xsd/cxx/tree/serialization/unsigned-int.hxx
@@ -0,0 +1,46 @@
+// file      : xsd/cxx/tree/serialization/unsigned-int.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_SERIALIZATION_UNSIGNED_INT_HXX
+#define XSD_CXX_TREE_SERIALIZATION_UNSIGNED_INT_HXX
+
+#include <sstream>
+
+namespace XERCES_CPP_NAMESPACE
+{
+  inline void
+  operator<< (xercesc::DOMElement& e, unsigned int i)
+  {
+    std::basic_ostringstream<char> os;
+    os << i;
+    e << os.str ();
+  }
+
+  inline void
+  operator<< (xercesc::DOMAttr& a, unsigned int i)
+  {
+    std::basic_ostringstream<char> os;
+    os << i;
+    a << os.str ();
+  }
+}
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      template <typename C>
+      inline void
+      operator<< (list_stream<C>& ls, unsigned int i)
+      {
+        ls.os_ << i;
+      }
+    }
+  }
+}
+
+#endif // XSD_CXX_TREE_SERIALIZATION_UNSIGNED_INT_HXX
diff --git src/base/include/xsd/cxx/tree/serialization/unsigned-long.hxx src/base/include/xsd/cxx/tree/serialization/unsigned-long.hxx
new file mode 100644
index 0000000..f5f12f3
--- /dev/null
+++ src/base/include/xsd/cxx/tree/serialization/unsigned-long.hxx
@@ -0,0 +1,46 @@
+// file      : xsd/cxx/tree/serialization/unsigned-long.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_SERIALIZATION_UNSIGNED_LONG_HXX
+#define XSD_CXX_TREE_SERIALIZATION_UNSIGNED_LONG_HXX
+
+#include <sstream>
+
+namespace XERCES_CPP_NAMESPACE
+{
+  inline void
+  operator<< (xercesc::DOMElement& e, unsigned long long l)
+  {
+    std::basic_ostringstream<char> os;
+    os << l;
+    e << os.str ();
+  }
+
+  inline void
+  operator<< (xercesc::DOMAttr& a, unsigned long long l)
+  {
+    std::basic_ostringstream<char> os;
+    os << l;
+    a << os.str ();
+  }
+}
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      template <typename C>
+      inline void
+      operator<< (list_stream<C>& ls, unsigned long long l)
+      {
+        ls.os_ << l;
+      }
+    }
+  }
+}
+
+#endif // XSD_CXX_TREE_SERIALIZATION_UNSIGNED_LONG_HXX
diff --git src/base/include/xsd/cxx/tree/serialization/unsigned-short.hxx src/base/include/xsd/cxx/tree/serialization/unsigned-short.hxx
new file mode 100644
index 0000000..52437e0
--- /dev/null
+++ src/base/include/xsd/cxx/tree/serialization/unsigned-short.hxx
@@ -0,0 +1,46 @@
+// file      : xsd/cxx/tree/serialization/unsigned-short.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_SERIALIZATION_UNSIGNED_SHORT_HXX
+#define XSD_CXX_TREE_SERIALIZATION_UNSIGNED_SHORT_HXX
+
+#include <sstream>
+
+namespace XERCES_CPP_NAMESPACE
+{
+  inline void
+  operator<< (xercesc::DOMElement& e, unsigned short s)
+  {
+    std::basic_ostringstream<char> os;
+    os << s;
+    e << os.str ();
+  }
+
+  inline void
+  operator<< (xercesc::DOMAttr& a, unsigned short s)
+  {
+    std::basic_ostringstream<char> os;
+    os << s;
+    a << os.str ();
+  }
+}
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      template <typename C>
+      inline void
+      operator<< (list_stream<C>& ls, unsigned short s)
+      {
+        ls.os_ << s;
+      }
+    }
+  }
+}
+
+#endif // XSD_CXX_TREE_SERIALIZATION_UNSIGNED_SHORT_HXX
diff --git src/base/include/xsd/cxx/tree/std-ostream-map.hxx src/base/include/xsd/cxx/tree/std-ostream-map.hxx
new file mode 100644
index 0000000..28619a5
--- /dev/null
+++ src/base/include/xsd/cxx/tree/std-ostream-map.hxx
@@ -0,0 +1,114 @@
+// file      : xsd/cxx/tree/std-ostream-map.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_STD_OSTREAM_MAP_HXX
+#define XSD_CXX_TREE_STD_OSTREAM_MAP_HXX
+
+#include <map>
+#include <cstddef>  // std::size_t
+#include <ostream>
+#include <typeinfo>
+
+#include <xsd/cxx/tree/elements.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      template <typename C>
+      struct std_ostream_map
+      {
+        typedef std::type_info type_id;
+        typedef void (*inserter) (std::basic_ostream<C>&, const type&);
+
+        std_ostream_map ();
+
+        void
+        register_type (const type_id&, inserter, bool override = true);
+
+        void
+        unregister_type (const type_id&);
+
+        void
+        insert (std::basic_ostream<C>&, const type&);
+
+      public:
+        inserter
+        find (const type_id&) const;
+
+      private:
+        struct type_id_comparator
+        {
+          bool
+          operator() (const type_id* x, const type_id* y) const
+          {
+            // XL C++ on AIX has buggy type_info::before() in that
+            // it returns true for two different type_info objects
+            // that happened to be for the same type.
+            //
+#if defined(__xlC__) && defined(_AIX)
+            return *x != *y && x->before (*y);
+#else
+            return x->before (*y);
+#endif
+          }
+        };
+
+        typedef
+        std::map<const type_id*, inserter, type_id_comparator>
+        type_map;
+
+        type_map type_map_;
+      };
+
+      //
+      //
+      template<unsigned long id, typename C>
+      struct std_ostream_plate
+      {
+        static std_ostream_map<C>* map;
+        static std::size_t count;
+
+        std_ostream_plate ();
+        ~std_ostream_plate ();
+      };
+
+      template<unsigned long id, typename C>
+      std_ostream_map<C>* std_ostream_plate<id, C>::map = 0;
+
+      template<unsigned long id, typename C>
+      std::size_t std_ostream_plate<id, C>::count = 0;
+
+
+      //
+      //
+      template<unsigned long id, typename C>
+      inline std_ostream_map<C>&
+      std_ostream_map_instance ()
+      {
+        return *std_ostream_plate<id, C>::map;
+      }
+
+      //
+      //
+      template<typename C, typename T>
+      void
+      inserter_impl (std::basic_ostream<C>&, const type&);
+
+      template<unsigned long id, typename C, typename T>
+      struct std_ostream_initializer
+      {
+        std_ostream_initializer ();
+        ~std_ostream_initializer ();
+      };
+    }
+  }
+}
+
+#include <xsd/cxx/tree/std-ostream-map.txx>
+
+#endif // XSD_CXX_TREE_STD_OSTREAM_MAP_HXX
diff --git src/base/include/xsd/cxx/tree/std-ostream-map.txx src/base/include/xsd/cxx/tree/std-ostream-map.txx
new file mode 100644
index 0000000..6a748ec
--- /dev/null
+++ src/base/include/xsd/cxx/tree/std-ostream-map.txx
@@ -0,0 +1,293 @@
+// file      : xsd/cxx/tree/std-ostream-map.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#include <xsd/cxx/tree/types.hxx>
+#include <xsd/cxx/tree/std-ostream-operators.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      // std_ostream_map
+      //
+      template <typename C>
+      std_ostream_map<C>::
+      std_ostream_map ()
+      {
+        // anyType and anySimpleType.
+        //
+        register_type (
+          typeid (type),
+          &inserter_impl<C, type>,
+          false);
+
+        typedef simple_type<type> simple_type;
+        register_type (
+          typeid (simple_type),
+          &inserter_impl<C, simple_type>,
+          false);
+
+
+        // Strings
+        //
+        typedef string<C, simple_type> string;
+        register_type (
+          typeid (string),
+          &inserter_impl<C, string>,
+          false);
+
+        typedef normalized_string<C, string> normalized_string;
+        register_type (
+          typeid (normalized_string),
+          &inserter_impl<C, normalized_string>,
+          false);
+
+        typedef token<C, normalized_string> token;
+        register_type (
+          typeid (token),
+          &inserter_impl<C, token>,
+          false);
+
+        typedef name<C, token> name;
+        register_type (
+          typeid (name),
+          &inserter_impl<C, name>,
+          false);
+
+        typedef nmtoken<C, token> nmtoken;
+        register_type (
+          typeid (nmtoken),
+          &inserter_impl<C, nmtoken>,
+          false);
+
+        typedef nmtokens<C, simple_type, nmtoken> nmtokens;
+        register_type (
+          typeid (nmtokens),
+          &inserter_impl<C, nmtokens>,
+          false);
+
+        typedef ncname<C, name> ncname;
+        register_type (
+          typeid (ncname),
+          &inserter_impl<C, ncname>,
+          false);
+
+        typedef language<C, token> language;
+        register_type (
+          typeid (language),
+          &inserter_impl<C, language>,
+          false);
+
+
+        // ID/IDREF.
+        //
+        typedef id<C, ncname> id;
+        register_type (
+          typeid (id),
+          &inserter_impl<C, id>,
+          false);
+
+        typedef idref<C, ncname, type> idref;
+        register_type (
+          typeid (idref),
+          &inserter_impl<C, idref>,
+          false);
+
+        typedef idrefs<C, simple_type, idref> idrefs;
+        register_type (
+          typeid (idrefs),
+          &inserter_impl<C, idrefs>,
+          false);
+
+
+        // URI.
+        //
+        typedef uri<C, simple_type> uri;
+        register_type (
+          typeid (uri),
+          &inserter_impl<C, uri>,
+          false);
+
+
+        // Qualified name.
+        //
+        typedef qname<C, simple_type, uri, ncname> qname;
+        register_type (
+          typeid (qname),
+          &inserter_impl<C, qname>,
+          false);
+
+
+        // Binary.
+        //
+        typedef base64_binary<C, simple_type> base64_binary;
+        register_type (
+          typeid (base64_binary),
+          &inserter_impl<C, base64_binary>,
+          false);
+
+        typedef hex_binary<C, simple_type> hex_binary;
+        register_type (
+          typeid (hex_binary),
+          &inserter_impl<C, hex_binary>,
+          false);
+
+
+        // Date/time.
+        //
+        typedef gday<C, simple_type> gday;
+        register_type (
+          typeid (gday),
+          &inserter_impl<C, gday>,
+          false);
+
+        typedef gmonth<C, simple_type> gmonth;
+        register_type (
+          typeid (gmonth),
+          &inserter_impl<C, gmonth>,
+          false);
+
+        typedef gyear<C, simple_type> gyear;
+        register_type (
+          typeid (gyear),
+          &inserter_impl<C, gyear>,
+          false);
+
+        typedef gmonth_day<C, simple_type> gmonth_day;
+        register_type (
+          typeid (gmonth_day),
+          &inserter_impl<C, gmonth_day>,
+          false);
+
+        typedef gyear_month<C, simple_type> gyear_month;
+        register_type (
+          typeid (gyear_month),
+          &inserter_impl<C, gyear_month>,
+          false);
+
+        typedef date<C, simple_type> date;
+        register_type (
+          typeid (date),
+          &inserter_impl<C, date>,
+          false);
+
+        typedef time<C, simple_type> time;
+        register_type (
+          typeid (time),
+          &inserter_impl<C, time>,
+          false);
+
+        typedef date_time<C, simple_type> date_time;
+        register_type (
+          typeid (date_time),
+          &inserter_impl<C, date_time>,
+          false);
+
+        typedef duration<C, simple_type> duration;
+        register_type (
+          typeid (duration),
+          &inserter_impl<C, duration>,
+          false);
+
+
+        // Entity.
+        //
+        typedef entity<C, ncname> entity;
+        register_type (
+          typeid (entity),
+          &inserter_impl<C, entity>,
+          false);
+
+        typedef entities<C, simple_type, entity> entities;
+        register_type (
+          typeid (entities),
+          &inserter_impl<C, entities>,
+          false);
+      }
+
+      template <typename C>
+      void std_ostream_map<C>::
+      register_type (const type_id& tid, inserter i, bool override)
+      {
+        if (override || type_map_.find (&tid) == type_map_.end ())
+          type_map_[&tid] = i;
+      }
+
+      template <typename C>
+      void std_ostream_map<C>::
+      unregister_type (const type_id& tid)
+      {
+        type_map_.erase (&tid);
+      }
+
+      template <typename C>
+      void std_ostream_map<C>::
+      insert (std::basic_ostream<C>& os, const type& x)
+      {
+        if (inserter i = find (typeid (x)))
+          i (os, x);
+        else
+          throw no_type_info<C> (std::basic_string<C> (),
+                                 std::basic_string<C> ()); // @@ TODO
+      }
+
+      template <typename C>
+      typename std_ostream_map<C>::inserter std_ostream_map<C>::
+      find (const type_id& tid) const
+      {
+        typename type_map::const_iterator i (type_map_.find (&tid));
+        return i == type_map_.end () ? 0 : i->second;
+      }
+
+      // std_ostream_plate
+      //
+      template<unsigned long id, typename C>
+      std_ostream_plate<id, C>::
+      std_ostream_plate ()
+      {
+        if (count == 0)
+          map = new std_ostream_map<C>;
+
+        ++count;
+      }
+
+      template<unsigned long id, typename C>
+      std_ostream_plate<id, C>::
+      ~std_ostream_plate ()
+      {
+        if (--count == 0)
+          delete map;
+      }
+
+      //
+      //
+      template<typename C, typename T>
+      void
+      inserter_impl (std::basic_ostream<C>& os, const type& x)
+      {
+        os << static_cast<const T&> (x);
+      }
+
+      // std_ostream_initializer
+      //
+      template<unsigned long id, typename C, typename T>
+      std_ostream_initializer<id, C, T>::
+      std_ostream_initializer ()
+      {
+        std_ostream_map_instance<id, C> ().register_type (
+          typeid (T), &inserter_impl<C, T>);
+      }
+
+      template<unsigned long id, typename C, typename T>
+      std_ostream_initializer<id, C, T>::
+      ~std_ostream_initializer ()
+      {
+        std_ostream_map_instance<id, C> ().unregister_type (typeid (T));
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/tree/std-ostream-operators.hxx src/base/include/xsd/cxx/tree/std-ostream-operators.hxx
new file mode 100644
index 0000000..a7ab357
--- /dev/null
+++ src/base/include/xsd/cxx/tree/std-ostream-operators.hxx
@@ -0,0 +1,274 @@
+// file      : xsd/cxx/tree/std-ostream-operators.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_STD_OSTREAM_OPERATORS_HXX
+#define XSD_CXX_TREE_STD_OSTREAM_OPERATORS_HXX
+
+#include <ostream>
+
+#include <xsd/cxx/tree/elements.hxx>
+#include <xsd/cxx/tree/containers.hxx>
+#include <xsd/cxx/tree/types.hxx>
+#include <xsd/cxx/tree/list.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      // type
+      //
+      template <typename C>
+      inline std::basic_ostream<C>&
+      operator<< (std::basic_ostream<C>& os, const type&)
+      {
+        return os;
+      }
+
+
+      // simple_type
+      //
+      template <typename C, typename B>
+      inline std::basic_ostream<C>&
+      operator<< (std::basic_ostream<C>& os, const simple_type<B>&)
+      {
+        return os;
+      }
+
+
+      // fundamental_base
+      //
+      template <typename T, typename C, typename B, schema_type::value ST>
+      inline
+      std::basic_ostream<C>&
+      operator<< (std::basic_ostream<C>& os, fundamental_base<T, C, B, ST> x)
+      {
+        T& r (x);
+        return os << r;
+      }
+
+      // optional: see containers.hxx
+      //
+
+      // list
+      //
+
+      // This is an xsd:list-style format (space-separated).
+      //
+      template <typename C, typename T, schema_type::value ST, bool fund>
+      std::basic_ostream<C>&
+      operator<< (std::basic_ostream<C>& os, const list<T, C, ST, fund>& v)
+      {
+        for (typename list<T, C, ST, fund>::const_iterator
+               b (v.begin ()), e (v.end ()), i (b); i != e; ++i)
+        {
+          if (i != b)
+            os << C (' ');
+
+          os << *i;
+        }
+
+        return os;
+      }
+
+
+      // Operators for built-in types.
+      //
+
+
+      // string
+      //
+      template <typename C, typename B>
+      inline std::basic_ostream<C>&
+      operator<< (std::basic_ostream<C>& os, const string<C, B>& v)
+      {
+        const std::basic_string<C>& r (v);
+        return os << r;
+      }
+
+
+      // normalized_string
+      //
+      template <typename C, typename B>
+      inline std::basic_ostream<C>&
+      operator<< (std::basic_ostream<C>& os, const normalized_string<C, B>& v)
+      {
+        const B& r (v);
+        return os << r;
+      }
+
+
+      // token
+      //
+      template <typename C, typename B>
+      inline std::basic_ostream<C>&
+      operator<< (std::basic_ostream<C>& os, const token<C, B>& v)
+      {
+        const B& r (v);
+        return os << r;
+      }
+
+
+      // nmtoken
+      //
+      template <typename C, typename B>
+      inline std::basic_ostream<C>&
+      operator<< (std::basic_ostream<C>& os, const nmtoken<C, B>& v)
+      {
+        const B& r (v);
+        return os << r;
+      }
+
+
+      // nmtokens
+      //
+      template <typename C, typename B, typename nmtoken>
+      inline std::basic_ostream<C>&
+      operator<< (std::basic_ostream<C>& os, const nmtokens<C, B, nmtoken>& v)
+      {
+        const list<nmtoken, C>& r (v);
+        return os << r;
+      }
+
+
+      // name
+      //
+      template <typename C, typename B>
+      inline std::basic_ostream<C>&
+      operator<< (std::basic_ostream<C>& os, const name<C, B>& v)
+      {
+        const B& r (v);
+        return os << r;
+      }
+
+
+      // ncname
+      //
+      template <typename C, typename B>
+      inline std::basic_ostream<C>&
+      operator<< (std::basic_ostream<C>& os, const ncname<C, B>& v)
+      {
+        const B& r (v);
+        return os << r;
+      }
+
+
+      // language
+      //
+      template <typename C, typename B>
+      inline std::basic_ostream<C>&
+      operator<< (std::basic_ostream<C>& os, const language<C, B>& v)
+      {
+        const B& r (v);
+        return os << r;
+      }
+
+
+      // id
+      //
+      template <typename C, typename B>
+      inline std::basic_ostream<C>&
+      operator<< (std::basic_ostream<C>& os, const id<C, B>& v)
+      {
+        const B& r (v);
+        return os << r;
+      }
+
+
+      // idref
+      //
+      template <typename C, typename B, typename T>
+      inline std::basic_ostream<C>&
+      operator<< (std::basic_ostream<C>& os, const idref<C, B, T>& v)
+      {
+        const B& r (v);
+        return os << r;
+      }
+
+
+      // idrefs
+      //
+      template <typename C, typename B, typename idref>
+      inline std::basic_ostream<C>&
+      operator<< (std::basic_ostream<C>& os, const idrefs<C, B, idref>& v)
+      {
+        const list<idref, C>& r (v);
+        return os << r;
+      }
+
+
+      // uri
+      //
+      template <typename C, typename B>
+      inline std::basic_ostream<C>&
+      operator<< (std::basic_ostream<C>& os, const uri<C, B>& v)
+      {
+        const std::basic_string<C>& r (v);
+        return os << r;
+      }
+
+
+      // qname
+      //
+      template <typename C, typename B, typename uri, typename ncname>
+      inline std::basic_ostream<C>&
+      operator<< (std::basic_ostream<C>& os,
+                  const qname<C, B, uri, ncname>& n)
+      {
+        if (n.qualified ())
+          os << n.namespace_ () << C ('#');
+
+        return os << n.name ();
+      }
+
+
+      // base64_binary
+      //
+      template <typename C, typename B>
+      inline std::basic_ostream<C>&
+      operator<< (std::basic_ostream<C>& os, const base64_binary<C, B>& v)
+      {
+        return os << v.encode ();
+      }
+
+
+      // hex_binary
+      //
+      template <typename C, typename B>
+      inline std::basic_ostream<C>&
+      operator<< (std::basic_ostream<C>& os, const hex_binary<C, B>& v)
+      {
+        return os << v.encode ();
+      }
+
+
+      // entity
+      //
+      template <typename C, typename B>
+      inline std::basic_ostream<C>&
+      operator<< (std::basic_ostream<C>& os, const entity<C, B>& v)
+      {
+        const B& r (v);
+        return os << r;
+      }
+
+
+      // entities
+      //
+      template <typename C, typename B, typename entity>
+      inline std::basic_ostream<C>&
+      operator<< (std::basic_ostream<C>& os, const entities<C, B, entity>& v)
+      {
+        const list<entity, C>& r (v);
+        return os << r;
+      }
+    }
+  }
+}
+
+#include <xsd/cxx/tree/date-time-ostream.txx>
+
+#endif  // XSD_CXX_TREE_STD_OSTREAM_OPERATORS_HXX
diff --git src/base/include/xsd/cxx/tree/stream-extraction-map.hxx src/base/include/xsd/cxx/tree/stream-extraction-map.hxx
new file mode 100644
index 0000000..dd4c79a
--- /dev/null
+++ src/base/include/xsd/cxx/tree/stream-extraction-map.hxx
@@ -0,0 +1,105 @@
+// file      : xsd/cxx/tree/stream-extraction-map.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_STREAM_EXTRACTION_MAP_HXX
+#define XSD_CXX_TREE_STREAM_EXTRACTION_MAP_HXX
+
+#include <map>
+#include <memory>  // std::auto_ptr
+#include <cstddef> // std::size_t
+
+#include <xsd/cxx/tree/elements.hxx>
+#include <xsd/cxx/tree/istream.hxx>
+#include <xsd/cxx/xml/qualified-name.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      template <typename S, typename C>
+      struct stream_extraction_map
+      {
+        typedef xml::qualified_name<C> qualified_name;
+        typedef std::auto_ptr<type> (*extractor) (
+          istream<S>&, flags, container*);
+
+      public:
+        stream_extraction_map ();
+
+        void
+        register_type (const qualified_name& name,
+                       extractor,
+                       bool override = true);
+
+        void
+        unregister_type (const qualified_name& name);
+
+        std::auto_ptr<type>
+        extract (istream<S>&, flags, container*);
+
+      public:
+        extractor
+        find (const qualified_name& name) const;
+
+      private:
+        typedef std::map<qualified_name, extractor> type_map;
+
+        type_map type_map_;
+      };
+
+      //
+      //
+      template<unsigned long id, typename S, typename C>
+      struct stream_extraction_plate
+      {
+        static stream_extraction_map<S, C>* map;
+        static std::size_t count;
+
+        stream_extraction_plate ();
+        ~stream_extraction_plate ();
+      };
+
+      template<unsigned long id, typename S, typename C>
+      stream_extraction_map<S, C>* stream_extraction_plate<id, S, C>::map = 0;
+
+      template<unsigned long id, typename S, typename C>
+      std::size_t stream_extraction_plate<id, S, C>::count = 0;
+
+
+      //
+      //
+      template<unsigned long id, typename S, typename C>
+      inline stream_extraction_map<S, C>&
+      stream_extraction_map_instance ()
+      {
+        return *stream_extraction_plate<id, S, C>::map;
+      }
+
+      //
+      //
+      template<typename S, typename T>
+      std::auto_ptr<type>
+      extractor_impl (istream<S>&, flags, container*);
+
+
+      template<unsigned long id, typename S, typename C, typename T>
+      struct stream_extraction_initializer
+      {
+        stream_extraction_initializer (const C* name, const C* ns);
+        ~stream_extraction_initializer ();
+
+      private:
+        const C* name_;
+        const C* ns_;
+      };
+    }
+  }
+}
+
+#include <xsd/cxx/tree/stream-extraction-map.txx>
+
+#endif // XSD_CXX_TREE_STREAM_EXTRACTION_MAP_HXX
diff --git src/base/include/xsd/cxx/tree/stream-extraction-map.txx src/base/include/xsd/cxx/tree/stream-extraction-map.txx
new file mode 100644
index 0000000..a4e429e
--- /dev/null
+++ src/base/include/xsd/cxx/tree/stream-extraction-map.txx
@@ -0,0 +1,310 @@
+// file      : xsd/cxx/tree/stream-extraction-map.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#include <xsd/cxx/tree/types.hxx>
+#include <xsd/cxx/tree/stream-extraction.hxx>
+#include <xsd/cxx/tree/bits/literals.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      // stream_extraction_map
+      //
+      template <typename S, typename C>
+      stream_extraction_map<S, C>::
+      stream_extraction_map ()
+      {
+        // Register extractors for built-in non-fundamental types.
+        //
+        std::basic_string<C> xsd (bits::xml_schema<C> ());
+
+
+        // anyType and anySimpleType.
+        //
+        register_type (
+          qualified_name (bits::any_type<C> (), xsd),
+          &extractor_impl<S, type>,
+          false);
+
+        typedef simple_type<type> simple_type;
+        register_type (
+          qualified_name (bits::any_simple_type<C> (), xsd),
+          &extractor_impl<S, simple_type>,
+          false);
+
+
+        // Strings
+        //
+        typedef string<C, simple_type> string;
+        register_type (
+          qualified_name (bits::string<C> (), xsd),
+          &extractor_impl<S, string>,
+          false);
+
+        typedef normalized_string<C, string> normalized_string;
+        register_type (
+          qualified_name (bits::normalized_string<C> (), xsd),
+          &extractor_impl<S, normalized_string>,
+          false);
+
+        typedef token<C, normalized_string> token;
+        register_type (
+          qualified_name (bits::token<C> (), xsd),
+          &extractor_impl<S, token>,
+          false);
+
+        typedef name<C, token> name;
+        register_type (
+          qualified_name (bits::name<C> (), xsd),
+          &extractor_impl<S, name>,
+          false);
+
+        typedef nmtoken<C, token> nmtoken;
+        register_type (
+          qualified_name (bits::nmtoken<C> (), xsd),
+          &extractor_impl<S, nmtoken>,
+          false);
+
+        typedef nmtokens<C, simple_type, nmtoken> nmtokens;
+        register_type (
+          qualified_name (bits::nmtokens<C> (), xsd),
+          &extractor_impl<S, nmtokens>,
+          false);
+
+        typedef ncname<C, name> ncname;
+        register_type (
+          qualified_name (bits::ncname<C> (), xsd),
+          &extractor_impl<S, ncname>,
+          false);
+
+        typedef language<C, token> language;
+        register_type (
+          qualified_name (bits::language<C> (), xsd),
+          &extractor_impl<S, language>,
+          false);
+
+
+        // ID/IDREF.
+        //
+        typedef id<C, ncname> id;
+        register_type (
+          qualified_name (bits::id<C> (), xsd),
+          &extractor_impl<S, id>,
+          false);
+
+        typedef idref<C, ncname, type> idref;
+        register_type (
+          qualified_name (bits::idref<C> (), xsd),
+          &extractor_impl<S, idref>,
+          false);
+
+        typedef idrefs<C, simple_type, idref> idrefs;
+        register_type (
+          qualified_name (bits::idrefs<C> (), xsd),
+          &extractor_impl<S, idrefs>,
+          false);
+
+
+        // URI.
+        //
+        typedef uri<C, simple_type> uri;
+        register_type (
+          qualified_name (bits::any_uri<C> (), xsd),
+          &extractor_impl<S, uri>,
+          false);
+
+
+        // Qualified name.
+        //
+        typedef qname<C, simple_type, uri, ncname> qname;
+        register_type (
+          qualified_name (bits::qname<C> (), xsd),
+          &extractor_impl<S, qname>,
+          false);
+
+
+        // Binary.
+        //
+        typedef base64_binary<C, simple_type> base64_binary;
+        register_type (
+          qualified_name (bits::base64_binary<C> (), xsd),
+          &extractor_impl<S, base64_binary>,
+          false);
+
+        typedef hex_binary<C, simple_type> hex_binary;
+        register_type (
+          qualified_name (bits::hex_binary<C> (), xsd),
+          &extractor_impl<S, hex_binary>,
+          false);
+
+
+        // Date/time.
+        //
+        typedef gday<C, simple_type> gday;
+        register_type (
+          qualified_name (bits::gday<C> (), xsd),
+          &extractor_impl<S, gday>,
+          false);
+
+        typedef gmonth<C, simple_type> gmonth;
+        register_type (
+          qualified_name (bits::gmonth<C> (), xsd),
+          &extractor_impl<S, gmonth>,
+          false);
+
+        typedef gyear<C, simple_type> gyear;
+        register_type (
+          qualified_name (bits::gyear<C> (), xsd),
+          &extractor_impl<S, gyear>,
+          false);
+
+        typedef gmonth_day<C, simple_type> gmonth_day;
+        register_type (
+          qualified_name (bits::gmonth_day<C> (), xsd),
+          &extractor_impl<S, gmonth_day>,
+          false);
+
+        typedef gyear_month<C, simple_type> gyear_month;
+        register_type (
+          qualified_name (bits::gyear_month<C> (), xsd),
+          &extractor_impl<S, gyear_month>,
+          false);
+
+        typedef date<C, simple_type> date;
+        register_type (
+          qualified_name (bits::date<C> (), xsd),
+          &extractor_impl<S, date>,
+          false);
+
+        typedef time<C, simple_type> time;
+        register_type (
+          qualified_name (bits::time<C> (), xsd),
+          &extractor_impl<S, time>,
+          false);
+
+        typedef date_time<C, simple_type> date_time;
+        register_type (
+          qualified_name (bits::date_time<C> (), xsd),
+          &extractor_impl<S, date_time>,
+          false);
+
+        typedef duration<C, simple_type> duration;
+        register_type (
+          qualified_name (bits::duration<C> (), xsd),
+          &extractor_impl<S, duration>,
+          false);
+
+
+        // Entity.
+        //
+        typedef entity<C, ncname> entity;
+        register_type (
+          qualified_name (bits::entity<C> (), xsd),
+          &extractor_impl<S, entity>,
+          false);
+
+        typedef entities<C, simple_type, entity> entities;
+        register_type (
+          qualified_name (bits::entities<C> (), xsd),
+          &extractor_impl<S, entities>,
+          false);
+      }
+
+      template <typename S, typename C>
+      void stream_extraction_map<S, C>::
+      register_type (const qualified_name& name,
+                     extractor e,
+                     bool override)
+      {
+        if (override || type_map_.find (name) == type_map_.end ())
+          type_map_[name] = e;
+      }
+
+      template <typename S, typename C>
+      void stream_extraction_map<S, C>::
+      unregister_type (const qualified_name& name)
+      {
+        type_map_.erase (name);
+      }
+
+      template <typename S, typename C>
+      std::auto_ptr<type> stream_extraction_map<S, C>::
+      extract (istream<S>& s, flags f, container* c)
+      {
+        std::basic_string<C> name, ns;
+        s >> ns >> name;
+
+        if (extractor e = find (qualified_name (name, ns)))
+        {
+          return e (s, f, c);
+        }
+        else
+          throw no_type_info<C> (name, ns);
+      }
+
+      template <typename S, typename C>
+      typename stream_extraction_map<S, C>::extractor
+      stream_extraction_map<S, C>::
+      find (const qualified_name& name) const
+      {
+        typename type_map::const_iterator i (type_map_.find (name));
+        return i == type_map_.end () ? 0 : i->second;
+      }
+
+
+      // stream_extraction_plate
+      //
+      template<unsigned long id, typename S, typename C>
+      stream_extraction_plate<id, S, C>::
+      stream_extraction_plate ()
+      {
+        if (count == 0)
+          map = new stream_extraction_map<S, C>;
+
+        ++count;
+      }
+
+      template<unsigned long id, typename S, typename C>
+      stream_extraction_plate<id, S, C>::
+      ~stream_extraction_plate ()
+      {
+        if (--count == 0)
+          delete map;
+      }
+
+      //
+      //
+      template<typename S, typename T>
+      std::auto_ptr<type>
+      extractor_impl (istream<S>& s, flags f, container* c)
+      {
+        return std::auto_ptr<type> (new T (s, f, c));
+      }
+
+
+      // stream_extraction_initializer
+      //
+      template<unsigned long id, typename S, typename C, typename T>
+      stream_extraction_initializer<id, S, C, T>::
+      stream_extraction_initializer (const C* name, const C* ns)
+          : name_ (name), ns_ (ns)
+      {
+        stream_extraction_map_instance<id, S, C> ().register_type (
+          xml::qualified_name<C> (name, ns), &extractor_impl<S, T>);
+      }
+
+      template<unsigned long id, typename S, typename C, typename T>
+      stream_extraction_initializer<id, S, C, T>::
+      ~stream_extraction_initializer ()
+      {
+        stream_extraction_map_instance<id, S, C> ().unregister_type (
+          xml::qualified_name<C> (name_, ns_));
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/tree/stream-extraction.hxx src/base/include/xsd/cxx/tree/stream-extraction.hxx
new file mode 100644
index 0000000..a7106e7
--- /dev/null
+++ src/base/include/xsd/cxx/tree/stream-extraction.hxx
@@ -0,0 +1,303 @@
+// file      : xsd/cxx/tree/stream-extraction.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_STREAM_EXTRACTION_HXX
+#define XSD_CXX_TREE_STREAM_EXTRACTION_HXX
+
+#include <xsd/cxx/tree/elements.hxx>
+#include <xsd/cxx/tree/types.hxx>
+#include <xsd/cxx/tree/list.hxx>
+
+#include <xsd/cxx/tree/istream.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      // type
+      //
+      template <typename S>
+      inline _type::
+      _type (istream<S>&, flags, container* c)
+          : container_ (c)
+      {
+      }
+
+      // simple_type
+      //
+      template <typename B>
+      template <typename S>
+      inline simple_type<B>::
+      simple_type (istream<S>& s, flags f, container* c)
+          : type (s, f, c)
+      {
+      }
+
+      // fundamental_base
+      //
+      template <typename T, typename C, typename B, schema_type::value ST>
+      template <typename S>
+      inline fundamental_base<T, C, B, ST>::
+      fundamental_base (istream<S>& s, flags f, container* c)
+          : B (s, f, c), facet_table_ (0)
+      {
+        T& r (*this);
+        s >> r;
+      }
+
+      // list
+      //
+      template <typename T, typename C, schema_type::value ST>
+      template <typename S>
+      list<T, C, ST, false>::
+      list (istream<S>& s, flags f, container* c)
+          : sequence<T> (f, c)
+      {
+        std::size_t size;
+        istream_common::as_size<std::size_t> as_size (size);
+        s >> as_size;
+
+        if (size > 0)
+        {
+          this->reserve (size);
+
+          while (size--)
+          {
+            std::auto_ptr<T> p (new T (s, f, c));
+            push_back (p);
+          }
+        }
+      }
+
+      template <typename T, typename C, schema_type::value ST>
+      template <typename S>
+      list<T, C, ST, true>::
+      list (istream<S>& s, flags f, container* c)
+          : sequence<T> (f, c)
+      {
+        std::size_t size;
+        istream_common::as_size<std::size_t> as_size (size);
+        s >> as_size;
+
+        if (size > 0)
+        {
+          this->reserve (size);
+
+          while (size--)
+          {
+            T x;
+            s >> x;
+            push_back (x);
+          }
+        }
+      }
+
+      // Extraction operators for built-in types.
+      //
+
+
+      // string
+      //
+      template <typename C, typename B>
+      template <typename S>
+      inline string<C, B>::
+      string (istream<S>& s, flags f, container* c)
+          : B (s, f, c)
+      {
+        std::basic_string<C>& r (*this);
+        s >> r;
+      }
+
+
+      // normalized_string
+      //
+      template <typename C, typename B>
+      template <typename S>
+      inline normalized_string<C, B>::
+      normalized_string (istream<S>& s, flags f, container* c)
+          : B (s, f, c)
+      {
+      }
+
+
+      // token
+      //
+      template <typename C, typename B>
+      template <typename S>
+      inline token<C, B>::
+      token (istream<S>& s, flags f, container* c)
+          : B (s, f, c)
+      {
+      }
+
+
+      // nmtoken
+      //
+      template <typename C, typename B>
+      template <typename S>
+      inline nmtoken<C, B>::
+      nmtoken (istream<S>& s, flags f, container* c)
+          : B (s, f, c)
+      {
+      }
+
+
+      // nmtokens
+      //
+      template <typename C, typename B, typename nmtoken>
+      template <typename S>
+      inline nmtokens<C, B, nmtoken>::
+      nmtokens (istream<S>& s, flags f, container* c)
+          : B (s, f, c), base_type (s, f, this)
+      {
+      }
+
+
+      // name
+      //
+      template <typename C, typename B>
+      template <typename S>
+      inline name<C, B>::
+      name (istream<S>& s, flags f, container* c)
+          : B (s, f, c)
+      {
+      }
+
+
+      // ncname
+      //
+      template <typename C, typename B>
+      template <typename S>
+      inline ncname<C, B>::
+      ncname (istream<S>& s, flags f, container* c)
+          : B (s, f, c)
+      {
+      }
+
+
+      // language
+      //
+      template <typename C, typename B>
+      template <typename S>
+      inline language<C, B>::
+      language (istream<S>& s, flags f, container* c)
+          : B (s, f, c)
+      {
+      }
+
+
+      // id
+      //
+      template <typename C, typename B>
+      template <typename S>
+      inline id<C, B>::
+      id (istream<S>& s, flags f, container* c)
+          : B (s, f, c), identity_ (*this)
+      {
+        register_id ();
+      }
+
+
+      // idref
+      //
+      template <typename C, typename B, typename T>
+      template <typename S>
+      inline idref<C, B, T>::
+      idref (istream<S>& s, flags f, container* c)
+          : B (s, f, c), identity_ (*this)
+      {
+      }
+
+
+      // idrefs
+      //
+      template <typename C, typename B, typename idref>
+      template <typename S>
+      inline idrefs<C, B, idref>::
+      idrefs (istream<S>& s, flags f, container* c)
+          : B (s, f, c), base_type (s, f, this)
+      {
+      }
+
+
+      // uri
+      //
+      template <typename C, typename B>
+      template <typename S>
+      inline uri<C, B>::
+      uri (istream<S>& s, flags f, container* c)
+          : B (s, f, c)
+      {
+        std::basic_string<C>& r (*this);
+        s >> r;
+      }
+
+
+      // qname
+      //
+      template <typename C, typename B, typename uri, typename ncname>
+      template <typename S>
+      inline qname<C, B, uri, ncname>::
+      qname (istream<S>& s, flags f, container* c)
+          : B (s, f, c), ns_ (s), name_ (s)
+      {
+      }
+
+
+      // base64_binary
+      //
+      template <typename C, typename B>
+      template <typename S>
+      inline base64_binary<C, B>::
+      base64_binary (istream<S>& s, flags f, container* c)
+          : B (s, f, c)
+      {
+        buffer<C>& r (*this);
+        s >> r;
+      }
+
+
+      // hex_binary
+      //
+      template <typename C, typename B>
+      template <typename S>
+      inline hex_binary<C, B>::
+      hex_binary (istream<S>& s, flags f, container* c)
+          : B (s, f, c)
+      {
+        buffer<C>& r (*this);
+        s >> r;
+      }
+
+
+      // entity
+      //
+      template <typename C, typename B>
+      template <typename S>
+      inline entity<C, B>::
+      entity (istream<S>& s, flags f, container* c)
+          : B (s, f, c)
+      {
+      }
+
+
+      // entities
+      //
+      template <typename C, typename B, typename entity>
+      template <typename S>
+      inline entities<C, B, entity>::
+      entities (istream<S>& s, flags f, container* c)
+          : B (s, f, c), base_type (s, f, this)
+      {
+      }
+    }
+  }
+}
+
+#include <xsd/cxx/tree/date-time-extraction.txx>
+
+#endif  // XSD_CXX_TREE_STREAM_EXTRACTION_HXX
diff --git src/base/include/xsd/cxx/tree/stream-insertion-map.hxx src/base/include/xsd/cxx/tree/stream-insertion-map.hxx
new file mode 100644
index 0000000..e26a3da
--- /dev/null
+++ src/base/include/xsd/cxx/tree/stream-insertion-map.hxx
@@ -0,0 +1,154 @@
+// file      : xsd/cxx/tree/stream-insertion-map.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_STREAM_INSERTION_MAP_HXX
+#define XSD_CXX_TREE_STREAM_INSERTION_MAP_HXX
+
+#include <map>
+#include <string>
+#include <cstddef>  // std::size_t
+#include <typeinfo>
+
+#include <xsd/cxx/tree/elements.hxx>
+#include <xsd/cxx/tree/ostream.hxx>
+#include <xsd/cxx/xml/qualified-name.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      template <typename S, typename C>
+      struct stream_insertion_map
+      {
+        typedef std::type_info type_id;
+        typedef xml::qualified_name<C> qualified_name;
+        typedef void (*inserter) (ostream<S>&, const type&);
+
+        stream_insertion_map ();
+
+        void
+        register_type (const type_id&,
+                       const qualified_name& name,
+                       inserter,
+                       bool override = true);
+
+        void
+        unregister_type (const type_id&);
+
+        void
+        insert (ostream<S>&, const type&);
+
+      public:
+        struct type_info
+        {
+          type_info (const qualified_name& name,
+                     typename stream_insertion_map::inserter inserter)
+              : name_ (name), inserter_ (inserter)
+          {
+          }
+
+          const qualified_name&
+          name () const
+          {
+            return name_;
+          }
+
+          typename stream_insertion_map::inserter
+          inserter () const
+          {
+            return inserter_;
+          }
+
+          // For std::map.
+          //
+          type_info ()
+              : name_ (std::basic_string<C> (), std::basic_string<C> ()),
+                inserter_ (0)
+          {
+          }
+
+        private:
+          qualified_name name_;
+          typename stream_insertion_map::inserter inserter_;
+        };
+
+      public:
+        const type_info*
+        find (const type_id&) const;
+
+      private:
+        struct type_id_comparator
+        {
+          bool
+          operator() (const type_id* x, const type_id* y) const
+          {
+            // XL C++ on AIX has buggy type_info::before() in that
+            // it returns true for two different type_info objects
+            // that happened to be for the same type.
+            //
+#if defined(__xlC__) && defined(_AIX)
+            return *x != *y && x->before (*y);
+#else
+            return x->before (*y);
+#endif
+          }
+        };
+
+        typedef
+        std::map<const type_id*, type_info, type_id_comparator>
+        type_map;
+
+        type_map type_map_;
+      };
+
+      //
+      //
+      template<unsigned long id, typename S, typename C>
+      struct stream_insertion_plate
+      {
+        static stream_insertion_map<S, C>* map;
+        static std::size_t count;
+
+        stream_insertion_plate ();
+        ~stream_insertion_plate ();
+      };
+
+      template<unsigned long id, typename S, typename C>
+      stream_insertion_map<S, C>* stream_insertion_plate<id, S, C>::map = 0;
+
+      template<unsigned long id, typename S, typename C>
+      std::size_t stream_insertion_plate<id, S, C>::count = 0;
+
+
+      //
+      //
+      template<unsigned long id, typename S, typename C>
+      inline stream_insertion_map<S, C>&
+      stream_insertion_map_instance ()
+      {
+        return *stream_insertion_plate<id, S, C>::map;
+      }
+
+      //
+      //
+      template<typename S, typename T>
+      void
+      inserter_impl (ostream<S>&, const type&);
+
+      template<unsigned long id, typename S, typename C, typename T>
+      struct stream_insertion_initializer
+      {
+        stream_insertion_initializer (const C* name, const C* ns);
+        ~stream_insertion_initializer ();
+      };
+    }
+  }
+}
+
+#include <xsd/cxx/tree/stream-insertion-map.txx>
+
+#endif // XSD_CXX_TREE_STREAM_INSERTION_MAP_HXX
diff --git src/base/include/xsd/cxx/tree/stream-insertion-map.txx src/base/include/xsd/cxx/tree/stream-insertion-map.txx
new file mode 100644
index 0000000..07bfa8b
--- /dev/null
+++ src/base/include/xsd/cxx/tree/stream-insertion-map.txx
@@ -0,0 +1,340 @@
+// file      : xsd/cxx/tree/stream-insertion-map.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#include <xsd/cxx/tree/types.hxx>
+#include <xsd/cxx/tree/stream-insertion.hxx>
+#include <xsd/cxx/tree/bits/literals.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      // stream_insertion_map
+      //
+      template <typename S, typename C>
+      stream_insertion_map<S, C>::
+      stream_insertion_map ()
+      {
+        // Register inserters for built-in non-fundamental types.
+        //
+        std::basic_string<C> xsd (bits::xml_schema<C> ());
+
+
+        // anyType and anySimpleType.
+        //
+        register_type (
+          typeid (type),
+          qualified_name (bits::any_type<C> (), xsd),
+          &inserter_impl<S, type>,
+          false);
+
+        typedef simple_type<type> simple_type;
+        register_type (
+          typeid (simple_type),
+          qualified_name (bits::any_simple_type<C> (), xsd),
+          &inserter_impl<S, simple_type>,
+          false);
+
+
+        // Strings
+        //
+        typedef string<C, simple_type> string;
+        register_type (
+          typeid (string),
+          qualified_name (bits::string<C> (), xsd),
+          &inserter_impl<S, string>,
+          false);
+
+        typedef normalized_string<C, string> normalized_string;
+        register_type (
+          typeid (normalized_string),
+          qualified_name (bits::normalized_string<C> (), xsd),
+          &inserter_impl<S, normalized_string>,
+          false);
+
+        typedef token<C, normalized_string> token;
+        register_type (
+          typeid (token),
+          qualified_name (bits::token<C> (), xsd),
+          &inserter_impl<S, token>,
+          false);
+
+        typedef name<C, token> name;
+        register_type (
+          typeid (name),
+          qualified_name (bits::name<C> (), xsd),
+          &inserter_impl<S, name>,
+          false);
+
+        typedef nmtoken<C, token> nmtoken;
+        register_type (
+          typeid (nmtoken),
+          qualified_name (bits::nmtoken<C> (), xsd),
+          &inserter_impl<S, nmtoken>,
+          false);
+
+        typedef nmtokens<C, simple_type, nmtoken> nmtokens;
+        register_type (
+          typeid (nmtokens),
+          qualified_name (bits::nmtokens<C> (), xsd),
+          &inserter_impl<S, nmtokens>,
+          false);
+
+        typedef ncname<C, name> ncname;
+        register_type (
+          typeid (ncname),
+          qualified_name (bits::ncname<C> (), xsd),
+          &inserter_impl<S, ncname>,
+          false);
+
+        typedef language<C, token> language;
+        register_type (
+          typeid (language),
+          qualified_name (bits::language<C> (), xsd),
+          &inserter_impl<S, language>,
+          false);
+
+
+        // ID/IDREF.
+        //
+        typedef id<C, ncname> id;
+        register_type (
+          typeid (id),
+          qualified_name (bits::id<C> (), xsd),
+          &inserter_impl<S, id>,
+          false);
+
+        typedef idref<C, ncname, type> idref;
+        register_type (
+          typeid (idref),
+          qualified_name (bits::idref<C> (), xsd),
+          &inserter_impl<S, idref>,
+          false);
+
+        typedef idrefs<C, simple_type, idref> idrefs;
+        register_type (
+          typeid (idrefs),
+          qualified_name (bits::idrefs<C> (), xsd),
+          &inserter_impl<S, idrefs>,
+          false);
+
+
+        // URI.
+        //
+        typedef uri<C, simple_type> uri;
+        register_type (
+          typeid (uri),
+          qualified_name (bits::any_uri<C> (), xsd),
+          &inserter_impl<S, uri>,
+          false);
+
+
+        // Qualified name.
+        //
+        typedef qname<C, simple_type, uri, ncname> qname;
+        register_type (
+          typeid (qname),
+          qualified_name (bits::qname<C> (), xsd),
+          &inserter_impl<S, qname>,
+          false);
+
+
+        // Binary.
+        //
+        typedef base64_binary<C, simple_type> base64_binary;
+        register_type (
+          typeid (base64_binary),
+          qualified_name (bits::base64_binary<C> (), xsd),
+          &inserter_impl<S, base64_binary>,
+          false);
+
+        typedef hex_binary<C, simple_type> hex_binary;
+        register_type (
+          typeid (hex_binary),
+          qualified_name (bits::hex_binary<C> (), xsd),
+          &inserter_impl<S, hex_binary>,
+          false);
+
+
+        // Date/time.
+        //
+        typedef gday<C, simple_type> gday;
+        register_type (
+          typeid (gday),
+          qualified_name (bits::gday<C> (), xsd),
+          &inserter_impl<S, gday>,
+          false);
+
+        typedef gmonth<C, simple_type> gmonth;
+        register_type (
+          typeid (gmonth),
+          qualified_name (bits::gmonth<C> (), xsd),
+          &inserter_impl<S, gmonth>,
+          false);
+
+        typedef gyear<C, simple_type> gyear;
+        register_type (
+          typeid (gyear),
+          qualified_name (bits::gyear<C> (), xsd),
+          &inserter_impl<S, gyear>,
+          false);
+
+        typedef gmonth_day<C, simple_type> gmonth_day;
+        register_type (
+          typeid (gmonth_day),
+          qualified_name (bits::gmonth_day<C> (), xsd),
+          &inserter_impl<S, gmonth_day>,
+          false);
+
+        typedef gyear_month<C, simple_type> gyear_month;
+        register_type (
+          typeid (gyear_month),
+          qualified_name (bits::gyear_month<C> (), xsd),
+          &inserter_impl<S, gyear_month>,
+          false);
+
+        typedef date<C, simple_type> date;
+        register_type (
+          typeid (date),
+          qualified_name (bits::date<C> (), xsd),
+          &inserter_impl<S, date>,
+          false);
+
+        typedef time<C, simple_type> time;
+        register_type (
+          typeid (time),
+          qualified_name (bits::time<C> (), xsd),
+          &inserter_impl<S, time>,
+          false);
+
+        typedef date_time<C, simple_type> date_time;
+        register_type (
+          typeid (date_time),
+          qualified_name (bits::date_time<C> (), xsd),
+          &inserter_impl<S, date_time>,
+          false);
+
+        typedef duration<C, simple_type> duration;
+        register_type (
+          typeid (duration),
+          qualified_name (bits::duration<C> (), xsd),
+          &inserter_impl<S, duration>,
+          false);
+
+
+        // Entity.
+        //
+        typedef entity<C, ncname> entity;
+        register_type (
+          typeid (entity),
+          qualified_name (bits::entity<C> (), xsd),
+          &inserter_impl<S, entity>,
+          false);
+
+        typedef entities<C, simple_type, entity> entities;
+        register_type (
+          typeid (entities),
+          qualified_name (bits::entities<C> (), xsd),
+          &inserter_impl<S, entities>,
+          false);
+      }
+
+      template <typename S, typename C>
+      void stream_insertion_map<S, C>::
+      register_type (const type_id& tid,
+                     const qualified_name& name,
+                     inserter i,
+                     bool override)
+      {
+        if (override || type_map_.find (&tid) == type_map_.end ())
+          type_map_[&tid] = type_info (name, i);
+      }
+
+      template <typename S, typename C>
+      void stream_insertion_map<S, C>::
+      unregister_type (const type_id& tid)
+      {
+        type_map_.erase (&tid);
+      }
+
+      template <typename S, typename C>
+      void stream_insertion_map<S, C>::
+      insert (ostream<S>& s, const type& x)
+      {
+        if (const type_info* ti = find (typeid (x)))
+        {
+          const qualified_name& qn (ti->name ());
+
+          s << qn.namespace_ () << qn.name ();
+          ti->inserter () (s, x);
+        }
+        else
+          throw no_type_info<C> (std::basic_string<C> (),
+                                 std::basic_string<C> ()); // @@ TODO
+      }
+
+      template <typename S, typename C>
+      const typename stream_insertion_map<S, C>::type_info*
+      stream_insertion_map<S, C>::
+      find (const type_id& tid) const
+      {
+        typename type_map::const_iterator i (type_map_.find (&tid));
+        return i == type_map_.end () ? 0 : &i->second;
+      }
+
+
+      // stream_insertion_plate
+      //
+      template<unsigned long id, typename S, typename C>
+      stream_insertion_plate<id, S, C>::
+      stream_insertion_plate ()
+      {
+        if (count == 0)
+          map = new stream_insertion_map<S, C>;
+
+        ++count;
+      }
+
+      template<unsigned long id, typename S, typename C>
+      stream_insertion_plate<id, S, C>::
+      ~stream_insertion_plate ()
+      {
+        if (--count == 0)
+          delete map;
+      }
+
+      //
+      //
+      template<typename S, typename T>
+      void
+      inserter_impl (ostream<S>& s, const type& x)
+      {
+        s << static_cast<const T&> (x);
+      }
+
+      // stream_insertion_initializer
+      //
+      template<unsigned long id, typename S, typename C, typename T>
+      stream_insertion_initializer<id, S, C, T>::
+      stream_insertion_initializer (const C* name, const C* ns)
+      {
+        stream_insertion_map_instance<id, S, C> ().register_type (
+          typeid (T),
+          xml::qualified_name<C> (name, ns),
+          &inserter_impl<S, T>);
+      }
+
+      template<unsigned long id, typename S, typename C, typename T>
+      stream_insertion_initializer<id, S, C, T>::
+      ~stream_insertion_initializer ()
+      {
+        stream_insertion_map_instance<id, S, C> ().unregister_type (
+          typeid (T));
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/tree/stream-insertion.hxx src/base/include/xsd/cxx/tree/stream-insertion.hxx
new file mode 100644
index 0000000..c345e80
--- /dev/null
+++ src/base/include/xsd/cxx/tree/stream-insertion.hxx
@@ -0,0 +1,273 @@
+// file      : xsd/cxx/tree/stream-insertion.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_STREAM_INSERTION_HXX
+#define XSD_CXX_TREE_STREAM_INSERTION_HXX
+
+#include <xsd/cxx/tree/elements.hxx>
+#include <xsd/cxx/tree/types.hxx>
+#include <xsd/cxx/tree/list.hxx>
+
+#include <xsd/cxx/tree/ostream.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      // type
+      //
+      template <typename S>
+      inline ostream<S>&
+      operator<< (ostream<S>& s, const type&)
+      {
+        return s;
+      }
+
+      // simple_type
+      //
+      template <typename S, typename B>
+      inline ostream<S>&
+      operator<< (ostream<S>& s, const simple_type<B>&)
+      {
+        return s;
+      }
+
+      // fundamental_base
+      //
+      template <typename S,
+                typename T,
+                typename C,
+                typename B,
+                schema_type::value ST>
+      inline ostream<S>&
+      operator<< (ostream<S>& s, const fundamental_base<T, C, B, ST>& x)
+      {
+        const T& r (x);
+        return s << r;
+      }
+
+      // list
+      //
+      template <typename S,
+                typename T,
+                typename C,
+                schema_type::value ST,
+                bool fund>
+      ostream<S>&
+      operator<< (ostream<S>& s, const list<T, C, ST, fund>& x)
+      {
+        s << ostream_common::as_size<std::size_t> (x.size ());
+
+        for (typename list<T, C, ST, fund>::const_iterator
+               i (x.begin ()), e (x.end ()); i != e; ++i)
+        {
+          s << *i;
+        }
+
+        return s;
+      }
+
+
+      // Insertion operators for built-in types.
+      //
+
+
+      // string
+      //
+      template <typename S, typename C, typename B>
+      inline ostream<S>&
+      operator<< (ostream<S>& s, const string<C, B>& x)
+      {
+        const std::basic_string<C>& r (x);
+        return s << r;
+      }
+
+
+      // normalized_string
+      //
+      template <typename S, typename C, typename B>
+      inline ostream<S>&
+      operator<< (ostream<S>& s, const normalized_string<C, B>& x)
+      {
+        const B& r (x);
+        return s << r;
+      }
+
+
+      // token
+      //
+      template <typename S, typename C, typename B>
+      inline ostream<S>&
+      operator<< (ostream<S>& s, const token<C, B>& x)
+      {
+        const B& r (x);
+        return s << r;
+      }
+
+
+      // nmtoken
+      //
+      template <typename S, typename C, typename B>
+      inline ostream<S>&
+      operator<< (ostream<S>& s, const nmtoken<C, B>& x)
+      {
+        const B& r (x);
+        return s << r;
+      }
+
+
+      // nmtokens
+      //
+      template <typename S, typename C, typename B, typename nmtoken>
+      inline ostream<S>&
+      operator<< (ostream<S>& s, const nmtokens<C, B, nmtoken>& x)
+      {
+        const list<nmtoken, C>& r (x);
+        return s << r;
+      }
+
+
+      // name
+      //
+      template <typename S, typename C, typename B>
+      inline ostream<S>&
+      operator<< (ostream<S>& s, const name<C, B>& x)
+      {
+        const B& r (x);
+        return s << r;
+      }
+
+
+      // ncname
+      //
+      template <typename S, typename C, typename B>
+      inline ostream<S>&
+      operator<< (ostream<S>& s, const ncname<C, B>& x)
+      {
+        const B& r (x);
+        return s << r;
+      }
+
+
+      // language
+      //
+      template <typename S, typename C, typename B>
+      inline ostream<S>&
+      operator<< (ostream<S>& s, const language<C, B>& x)
+      {
+        const std::basic_string<C>& r (x);
+        return s << r;
+      }
+
+
+      // id
+      //
+      template <typename S, typename C, typename B>
+      inline ostream<S>&
+      operator<< (ostream<S>& s, const id<C, B>& x)
+      {
+        const std::basic_string<C>& r (x);
+        return s << r;
+      }
+
+
+      // idref
+      //
+      template <typename S, typename C, typename B, typename T>
+      inline ostream<S>&
+      operator<< (ostream<S>& s, const idref<C, B, T>& x)
+      {
+        const B& r (x);
+        return s << r;
+      }
+
+
+      // idrefs
+      //
+      template <typename S, typename C, typename B, typename idref>
+      inline ostream<S>&
+      operator<< (ostream<S>& s, const idrefs<C, B, idref>& x)
+      {
+        const list<idref, C>& r (x);
+        return s << r;
+      }
+
+
+      // uri
+      //
+      template <typename S, typename C, typename B>
+      inline ostream<S>&
+      operator<< (ostream<S>& s, const uri<C, B>& x)
+      {
+        const std::basic_string<C>& r (x);
+        return s << r;
+      }
+
+
+      // qname
+      //
+      template <typename S,
+                typename C,
+                typename B,
+                typename uri,
+                typename ncname>
+      inline ostream<S>&
+      operator<< (ostream<S>& s, const qname<C, B, uri, ncname>& x)
+      {
+        return s << x.namespace_ () << x.name ();
+      }
+
+
+      // base64_binary
+      //
+      template <typename S, typename C, typename B>
+      inline ostream<S>&
+      operator<< (ostream<S>& s, const base64_binary<C, B>& x)
+      {
+        const buffer<C>& r (x);
+        return s << r;
+      }
+
+
+      // hex_binary
+      //
+      template <typename S, typename C, typename B>
+      inline ostream<S>&
+      operator<< (ostream<S>& s, const hex_binary<C, B>& x)
+      {
+        const buffer<C>& r (x);
+        return s << r;
+      }
+
+
+      // entity
+      //
+      template <typename S, typename C, typename B>
+      inline ostream<S>&
+      operator<< (ostream<S>& s, const entity<C, B>& x)
+      {
+        const B& r (x);
+        return s << r;
+      }
+
+
+      // entities
+      //
+      template <typename S, typename C, typename B, typename entity>
+      inline ostream<S>&
+      operator<< (ostream<S>& s, const entities<C, B, entity>& x)
+      {
+        const list<entity, C>& r (x);
+        return s << r;
+      }
+    }
+  }
+}
+
+#include <xsd/cxx/tree/date-time-insertion.txx>
+
+#endif  // XSD_CXX_TREE_STREAM_INSERTION_HXX
diff --git src/base/include/xsd/cxx/tree/text.hxx src/base/include/xsd/cxx/tree/text.hxx
new file mode 100644
index 0000000..15f12dc
--- /dev/null
+++ src/base/include/xsd/cxx/tree/text.hxx
@@ -0,0 +1,30 @@
+// file      : xsd/cxx/tree/text.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_TEXT_HXX
+#define XSD_CXX_TREE_TEXT_HXX
+
+#include <string>
+
+#include <xercesc/dom/DOMElement.hpp>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      // Throws expected_text_content.
+      //
+      template <typename C>
+      std::basic_string<C>
+      text_content (const xercesc::DOMElement&);
+    }
+  }
+}
+
+#include <xsd/cxx/tree/text.txx>
+
+#endif // XSD_CXX_TREE_TEXT_HXX
diff --git src/base/include/xsd/cxx/tree/text.txx src/base/include/xsd/cxx/tree/text.txx
new file mode 100644
index 0000000..2d83c71
--- /dev/null
+++ src/base/include/xsd/cxx/tree/text.txx
@@ -0,0 +1,77 @@
+// file      : xsd/cxx/tree/text.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#include <xercesc/dom/DOMText.hpp>
+
+#include <xsd/cxx/xml/string.hxx>
+
+#include <xsd/cxx/tree/exceptions.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      template <typename C>
+      std::basic_string<C>
+      text_content (const xercesc::DOMElement& e)
+      {
+        using xercesc::DOMNode;
+        using xercesc::DOMText;
+
+        DOMNode* n (e.getFirstChild ());
+
+        // Fast path.
+        //
+        if (n != 0 &&
+            n->getNodeType () == DOMNode::TEXT_NODE &&
+            n->getNextSibling () == 0)
+        {
+          DOMText* t (static_cast<DOMText*> (n));
+
+          // Berkeley DB XML DOM does not implement getLength().
+          //
+#ifndef DBXML_DOM
+          return xml::transcode<C> (t->getData (), t->getLength ());
+#else
+	  return xml::transcode<C> (t->getData ());
+#endif
+        }
+
+        std::basic_string<C> r;
+
+        for (; n != 0; n = n->getNextSibling ())
+        {
+          switch (n->getNodeType ())
+          {
+          case DOMNode::TEXT_NODE:
+          case DOMNode::CDATA_SECTION_NODE:
+            {
+              DOMText* t (static_cast<DOMText*> (n));
+
+              // Berkeley DB XML DOM does not implement getLength().
+              //
+#ifndef DBXML_DOM
+              r += xml::transcode<C> (t->getData (), t->getLength ());
+#else
+	      r += xml::transcode<C> (t->getData ());
+#endif
+              break;
+            }
+          case DOMNode::ELEMENT_NODE:
+            {
+              throw expected_text_content<C> ();
+            }
+          default:
+            break; // ignore
+          }
+        }
+
+        return r;
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/tree/type-factory-map.hxx src/base/include/xsd/cxx/tree/type-factory-map.hxx
new file mode 100644
index 0000000..7e849db
--- /dev/null
+++ src/base/include/xsd/cxx/tree/type-factory-map.hxx
@@ -0,0 +1,173 @@
+// file      : xsd/cxx/tree/type-factory-map.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_TYPE_FACTORY_MAP_HXX
+#define XSD_CXX_TREE_TYPE_FACTORY_MAP_HXX
+
+#include <map>
+#include <string>
+#include <memory>  // std::auto_ptr
+#include <cstddef> // std::size_t
+
+#include <xercesc/dom/DOMElement.hpp>
+
+#include <xsd/cxx/tree/elements.hxx>
+#include <xsd/cxx/xml/qualified-name.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      template <typename C>
+      struct type_factory_map
+      {
+        typedef xml::qualified_name<C> qualified_name;
+        typedef std::auto_ptr<type> (*factory) (const xercesc::DOMElement&,
+                                                flags,
+                                                container*);
+      public:
+        type_factory_map ();
+
+        void
+        register_type (const qualified_name& name,
+                       factory,
+                       bool override = true);
+
+        void
+        unregister_type (const qualified_name& name);
+
+        void
+        register_element (const qualified_name& root,
+                          const qualified_name& subst,
+                          factory);
+
+        void
+        unregister_element (const qualified_name& root,
+                            const qualified_name& subst);
+
+        std::auto_ptr<type>
+        create (const C* name, // element name
+                const C* ns,   // element namespace
+                factory static_type,
+                bool global,
+                bool qualified,
+                const xercesc::DOMElement&,
+                const qualified_name&,
+                flags,
+                container*) const;
+
+      public:
+        factory
+        find (const qualified_name& name) const;
+
+      private:
+        template <typename T>
+        static std::auto_ptr<type>
+        traits_adapter (const xercesc::DOMElement&, flags, container*);
+
+      private:
+        typedef
+        std::map<qualified_name, factory>
+        type_map;
+
+        // Map of (root-element to map of (subst-element to factory)).
+        //
+        typedef
+        std::map<qualified_name, factory>
+        subst_map;
+
+        typedef
+        std::map<qualified_name, subst_map>
+        element_map;
+
+        type_map type_map_;
+        element_map element_map_;
+
+      private:
+        factory
+        find_substitution (const subst_map& start,
+                           const qualified_name& name) const;
+
+        // The name argument is as specified in xsi:type.
+        //
+        factory
+        find_type (const std::basic_string<C>& name,
+                   const xercesc::DOMElement&) const;
+      };
+
+
+      //
+      //
+      template<unsigned long id, typename C>
+      struct type_factory_plate
+      {
+        static type_factory_map<C>* map;
+        static std::size_t count;
+
+        type_factory_plate ();
+        ~type_factory_plate ();
+      };
+
+      template<unsigned long id, typename C>
+      type_factory_map<C>* type_factory_plate<id, C>::map = 0;
+
+      template<unsigned long id, typename C>
+      std::size_t type_factory_plate<id, C>::count = 0;
+
+
+      //
+      //
+      template<unsigned long id, typename C>
+      inline type_factory_map<C>&
+      type_factory_map_instance ()
+      {
+        return *type_factory_plate<id, C>::map;
+      }
+
+
+      //
+      //
+      template<typename T>
+      std::auto_ptr<type>
+      factory_impl (const xercesc::DOMElement&, flags, container*);
+
+      //
+      //
+      template<unsigned long id, typename C, typename T>
+      struct type_factory_initializer
+      {
+        type_factory_initializer (const C* name, const C* ns);
+        ~type_factory_initializer ();
+
+      private:
+        const C* name_;
+        const C* ns_;
+      };
+
+      //
+      //
+      template<unsigned long id, typename C, typename T>
+      struct element_factory_initializer
+      {
+        element_factory_initializer (const C* root_name, const C* root_ns,
+                                     const C* subst_name, const C* subst_ns);
+
+        ~element_factory_initializer ();
+
+      private:
+        const C* root_name_;
+        const C* root_ns_;
+        const C* subst_name_;
+        const C* subst_ns_;
+      };
+    }
+  }
+}
+
+#include <xsd/cxx/tree/type-factory-map.txx>
+
+#endif // XSD_CXX_TREE_TYPE_FACTORY_MAP_HXX
diff --git src/base/include/xsd/cxx/tree/type-factory-map.txx src/base/include/xsd/cxx/tree/type-factory-map.txx
new file mode 100644
index 0000000..b9e0a06
--- /dev/null
+++ src/base/include/xsd/cxx/tree/type-factory-map.txx
@@ -0,0 +1,481 @@
+// file      : xsd/cxx/tree/type-factory-map.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#include <xercesc/validators/schema/SchemaSymbols.hpp>
+
+#include <xsd/cxx/xml/string.hxx>        // xml::{string, transcode}
+#include <xsd/cxx/xml/elements.hxx>      // xml::{prefix, uq_name}
+#include <xsd/cxx/xml/bits/literals.hxx> // xml::bits::{xml_namespace, etc}
+
+#include <xsd/cxx/tree/types.hxx>
+#include <xsd/cxx/tree/bits/literals.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      // type_factory_map
+      //
+      template <typename C>
+      type_factory_map<C>::
+      type_factory_map ()
+      {
+        // Register factories for default instantiations of built-in,
+        // non-fundamental types.
+        //
+
+        std::basic_string<C> xsd (bits::xml_schema<C> ());
+
+
+        // anyType and anySimpleType.
+        //
+        register_type (
+          qualified_name (bits::any_type<C> (), xsd),
+          &factory_impl<type>,
+          false);
+
+        typedef simple_type<type> simple_type;
+        register_type (
+          qualified_name (bits::any_simple_type<C> (), xsd),
+          &factory_impl<simple_type>,
+          false);
+
+
+        // Strings
+        //
+        typedef string<C, simple_type> string;
+        register_type (
+          qualified_name (bits::string<C> (), xsd),
+          &factory_impl<string>,
+          false);
+
+        typedef normalized_string<C, string> normalized_string;
+        register_type (
+          qualified_name (bits::normalized_string<C> (), xsd),
+          &factory_impl<normalized_string>,
+          false);
+
+        typedef token<C, normalized_string> token;
+        register_type (
+          qualified_name (bits::token<C> (), xsd),
+          &factory_impl<token>,
+          false);
+
+        typedef name<C, token> name;
+        register_type (
+          qualified_name (bits::name<C> (), xsd),
+          &factory_impl<name>,
+          false);
+
+        typedef nmtoken<C, token> nmtoken;
+        register_type (
+          qualified_name (bits::nmtoken<C> (), xsd),
+          &factory_impl<nmtoken>,
+          false);
+
+        typedef nmtokens<C, simple_type, nmtoken> nmtokens;
+        register_type (
+          qualified_name (bits::nmtokens<C> (), xsd),
+          &factory_impl<nmtokens>,
+          false);
+
+        typedef ncname<C, name> ncname;
+        register_type (
+          qualified_name (bits::ncname<C> (), xsd),
+          &factory_impl<ncname>,
+          false);
+
+        typedef language<C, token> language;
+        register_type (
+          qualified_name (bits::language<C> (), xsd),
+          &factory_impl<language>,
+          false);
+
+
+        // ID/IDREF.
+        //
+        typedef id<C, ncname> id;
+        register_type (
+          qualified_name (bits::id<C> (), xsd),
+          &factory_impl<id>,
+          false);
+
+        typedef idref<C, ncname, type> idref;
+        register_type (
+          qualified_name (bits::idref<C> (), xsd),
+          &factory_impl<idref>,
+          false);
+
+        typedef idrefs<C, simple_type, idref> idrefs;
+        register_type (
+          qualified_name (bits::idrefs<C> (), xsd),
+          &factory_impl<idrefs>,
+          false);
+
+
+        // URI.
+        //
+        typedef uri<C, simple_type> uri;
+        register_type (
+          qualified_name (bits::any_uri<C> (), xsd),
+          &factory_impl<uri>,
+          false);
+
+
+        // Qualified name.
+        //
+        typedef qname<C, simple_type, uri, ncname> qname;
+        register_type (
+          qualified_name (bits::qname<C> (), xsd),
+          &factory_impl<qname>,
+          false);
+
+
+        // Binary.
+        //
+        typedef base64_binary<C, simple_type> base64_binary;
+        register_type (
+          qualified_name (bits::base64_binary<C> (), xsd),
+          &factory_impl<base64_binary>,
+          false);
+
+        typedef hex_binary<C, simple_type> hex_binary;
+        register_type (
+          qualified_name (bits::hex_binary<C> (), xsd),
+          &factory_impl<hex_binary>,
+          false);
+
+
+        // Date/time.
+        //
+        typedef gday<C, simple_type> gday;
+        register_type (
+          qualified_name (bits::gday<C> (), xsd),
+          &factory_impl<gday>,
+          false);
+
+        typedef gmonth<C, simple_type> gmonth;
+        register_type (
+          qualified_name (bits::gmonth<C> (), xsd),
+          &factory_impl<gmonth>,
+          false);
+
+        typedef gyear<C, simple_type> gyear;
+        register_type (
+          qualified_name (bits::gyear<C> (), xsd),
+          &factory_impl<gyear>,
+          false);
+
+        typedef gmonth_day<C, simple_type> gmonth_day;
+        register_type (
+          qualified_name (bits::gmonth_day<C> (), xsd),
+          &factory_impl<gmonth_day>,
+          false);
+
+        typedef gyear_month<C, simple_type> gyear_month;
+        register_type (
+          qualified_name (bits::gyear_month<C> (), xsd),
+          &factory_impl<gyear_month>,
+          false);
+
+        typedef date<C, simple_type> date;
+        register_type (
+          qualified_name (bits::date<C> (), xsd),
+          &factory_impl<date>,
+          false);
+
+        typedef time<C, simple_type> time;
+        register_type (
+          qualified_name (bits::time<C> (), xsd),
+          &factory_impl<time>,
+          false);
+
+        typedef date_time<C, simple_type> date_time;
+        register_type (
+          qualified_name (bits::date_time<C> (), xsd),
+          &factory_impl<date_time>,
+          false);
+
+        typedef duration<C, simple_type> duration;
+        register_type (
+          qualified_name (bits::duration<C> (), xsd),
+          &factory_impl<duration>,
+          false);
+
+
+        // Entity.
+        //
+        typedef entity<C, ncname> entity;
+        register_type (
+          qualified_name (bits::entity<C> (), xsd),
+          &factory_impl<entity>,
+          false);
+
+        typedef entities<C, simple_type, entity> entities;
+        register_type (
+          qualified_name (bits::entities<C> (), xsd),
+          &factory_impl<entities>,
+          false);
+      }
+
+      template <typename C>
+      void type_factory_map<C>::
+      register_type (const qualified_name& name,
+                     factory f,
+                     bool override)
+      {
+        if (override || type_map_.find (name) == type_map_.end ())
+          type_map_[name] = f;
+      }
+
+      template <typename C>
+      void type_factory_map<C>::
+      unregister_type (const qualified_name& name)
+      {
+        type_map_.erase (name);
+      }
+
+      template <typename C>
+      void type_factory_map<C>::
+      register_element (const qualified_name& root,
+                        const qualified_name& subst,
+                        factory f)
+      {
+        element_map_[root][subst] = f;
+      }
+
+      template <typename C>
+      void type_factory_map<C>::
+      unregister_element (const qualified_name& root,
+                          const qualified_name& subst)
+      {
+        typename element_map::iterator i (element_map_.find (root));
+
+        if (i != element_map_.end ())
+        {
+          i->second.erase (subst);
+
+          if (i->second.empty ())
+            element_map_.erase (i);
+        }
+      }
+
+      template <typename C>
+      typename type_factory_map<C>::factory type_factory_map<C>::
+      find (const qualified_name& name) const
+      {
+        typename type_map::const_iterator i (type_map_.find (name));
+        return i == type_map_.end () ? 0 : i->second;
+      }
+
+      template <typename C>
+      std::auto_ptr<type> type_factory_map<C>::
+      create (const C* name,
+              const C* ns,
+              factory static_type,
+              bool global,
+              bool qualified,
+              const xercesc::DOMElement& e,
+              const qualified_name& qn,
+              tree::flags flags,
+              container* c) const
+      {
+        factory f = 0;
+
+        // See if we've got a straight match.
+        //
+        if (qn.name () == name &&
+            (qualified ? qn.namespace_ () == ns : ns[0] == C ('\0')))
+        {
+          f = static_type;
+        }
+        else if (global)
+        {
+          // See if we have a substitution.
+          //
+          typename element_map::const_iterator i (
+            element_map_.find (qualified_name (name, ns)));
+
+          if (i != element_map_.end ())
+          {
+            f = find_substitution (i->second, qn);
+          }
+        }
+
+        if (f == 0)
+          return std::auto_ptr<type> (0); // No match.
+
+        // Check for xsi:type
+        //
+        {
+          const XMLCh* v (
+            e.getAttributeNS (
+              xercesc::SchemaSymbols::fgURI_XSI,
+              xercesc::SchemaSymbols::fgXSI_TYPE));
+
+          if (v != 0 && v[0] != XMLCh (0))
+            f = find_type (xml::transcode<C> (v), e);
+        }
+
+        return f (e, flags, c);
+      }
+
+      template <typename C>
+      template <typename T>
+      std::auto_ptr<type> type_factory_map<C>::
+      traits_adapter (const xercesc::DOMElement& e, flags f, container* c)
+      {
+        std::auto_ptr<T> r (traits<T, C>::create (e, f, c));
+        return std::auto_ptr<type> (r.release ());
+      }
+
+      template <typename C>
+      typename type_factory_map<C>::factory type_factory_map<C>::
+      find_substitution (const subst_map& start,
+                         const qualified_name& name) const
+      {
+        typename subst_map::const_iterator i (start.find (name));
+
+        if (i != start.end ())
+          return i->second;
+        else
+        {
+          for (i = start.begin (); i != start.end (); ++i)
+          {
+            typename element_map::const_iterator j (
+              element_map_.find (i->first));
+
+            if (j != element_map_.end ())
+            {
+              if (factory f = find_substitution (j->second, name))
+                return f;
+            }
+          }
+        }
+
+        return 0;
+      }
+
+      template <typename C>
+      typename type_factory_map<C>::factory type_factory_map<C>::
+      find_type (const std::basic_string<C>& name,
+                 const xercesc::DOMElement& e) const
+      {
+        using std::basic_string;
+
+        basic_string<C> ns_name, uq_name (xml::uq_name (name));
+
+        // Copied with modifications from xml/dom/elements.hxx.
+        //
+        std::basic_string<C> p (xml::prefix (name));
+
+        // 'xml' prefix requires special handling and Xerces folks refuse
+        // to handle this in DOM so I have to do it myself.
+        //
+        if (p == xml::bits::xml_prefix<C> ())
+          ns_name = xml::bits::xml_namespace<C> ();
+        else
+        {
+          const XMLCh* xns (
+            e.lookupNamespaceURI (
+              p.empty () ? 0 : xml::string (p).c_str ()));
+
+          if (xns != 0)
+            ns_name = xml::transcode<C> (xns);
+          else
+          {
+            // See if we've got any no-namespace types.
+            //
+            if (!p.empty ())
+              throw no_prefix_mapping<C> (p);
+          }
+        }
+
+        factory f (find (qualified_name (uq_name, ns_name)));
+
+        if (f == 0)
+          throw no_type_info<C> (uq_name, ns_name);
+
+        return f;
+      }
+
+
+      // type_factory_plate
+      //
+      template<unsigned long id, typename C>
+      type_factory_plate<id, C>::
+      type_factory_plate ()
+      {
+        if (count == 0)
+          map = new type_factory_map<C>;
+
+        ++count;
+      }
+
+      template<unsigned long id, typename C>
+      type_factory_plate<id, C>::
+      ~type_factory_plate ()
+      {
+        if (--count == 0)
+          delete map;
+      }
+
+
+      //
+      //
+      template<typename T>
+      std::auto_ptr<type>
+      factory_impl (const xercesc::DOMElement& e, flags f, container* c)
+      {
+        return std::auto_ptr<type> (new T (e, f, c));
+      }
+
+      //
+      //
+      template<unsigned long id, typename C, typename T>
+      type_factory_initializer<id, C, T>::
+      type_factory_initializer (const C* name, const C* ns)
+          : name_ (name), ns_ (ns)
+      {
+        type_factory_map_instance<id, C> ().register_type (
+          xml::qualified_name<C> (name, ns), &factory_impl<T>);
+      }
+
+      template<unsigned long id, typename C, typename T>
+      type_factory_initializer<id, C, T>::
+      ~type_factory_initializer ()
+      {
+        type_factory_map_instance<id, C> ().unregister_type (
+          xml::qualified_name<C> (name_, ns_));
+      }
+
+      //
+      //
+      template<unsigned long id, typename C, typename T>
+      element_factory_initializer<id, C, T>::
+      element_factory_initializer (const C* root_name, const C* root_ns,
+                                const C* subst_name, const C* subst_ns)
+          : root_name_ (root_name), root_ns_ (root_ns),
+            subst_name_ (subst_name), subst_ns_ (subst_ns)
+      {
+        type_factory_map_instance<id, C> ().register_element (
+          xml::qualified_name<C> (root_name, root_ns),
+          xml::qualified_name<C> (subst_name, subst_ns),
+          &factory_impl<T>);
+      }
+
+      template<unsigned long id, typename C, typename T>
+      element_factory_initializer<id, C, T>::
+      ~element_factory_initializer ()
+      {
+        type_factory_map_instance<id, C> ().unregister_element (
+          xml::qualified_name<C> (root_name_, root_ns_),
+          xml::qualified_name<C> (subst_name_, subst_ns_));
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/tree/type-serializer-map.hxx src/base/include/xsd/cxx/tree/type-serializer-map.hxx
new file mode 100644
index 0000000..491ad3b
--- /dev/null
+++ src/base/include/xsd/cxx/tree/type-serializer-map.hxx
@@ -0,0 +1,235 @@
+// file      : xsd/cxx/tree/type-serializer-map.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_TYPE_SERIALIZER_MAP_HXX
+#define XSD_CXX_TREE_TYPE_SERIALIZER_MAP_HXX
+
+#include <map>
+#include <string>
+#include <cstddef>  // std::size_t
+#include <typeinfo>
+
+#include <xercesc/dom/DOMElement.hpp>
+
+#include <xsd/cxx/tree/elements.hxx>
+
+#include <xsd/cxx/xml/qualified-name.hxx>
+#include <xsd/cxx/xml/dom/serialization-header.hxx> // namespace_infomap
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      template <typename C>
+      struct type_serializer_map
+      {
+        typedef std::type_info type_id;
+        typedef xml::qualified_name<C> qualified_name;
+        typedef void (*serializer) (xercesc::DOMElement&, const type&);
+
+        void
+        register_type (const type_id&,
+                       const qualified_name& name,
+                       serializer,
+                       bool override = true);
+
+        void
+        unregister_type (const type_id&);
+
+        void
+        register_element (const qualified_name& root,
+                          const qualified_name& subst,
+                          const type_id&,
+                          serializer);
+
+        void
+        unregister_element (const qualified_name& root, const type_id&);
+
+      public:
+        void
+        serialize (const C* name, // element name
+                   const C* ns,   // element namespace
+                   bool global,
+                   bool qualified,
+                   xercesc::DOMElement& parent,
+                   const type&) const;
+
+        // Serialize into existing element.
+        //
+        void
+        serialize (const C* static_name,
+                   const C* static_ns,
+                   xercesc::DOMElement&,
+                   const qualified_name&,
+                   const type&) const;
+
+        // Create DOMDocument with root element suitable for serializing
+        // x into it.
+        //
+        xml::dom::auto_ptr<xercesc::DOMDocument>
+        serialize (const C* name, // element name
+                   const C* ns,   // element namespace
+                   const xml::dom::namespace_infomap<C>&,
+                   const type& x,
+                   unsigned long flags) const;
+
+      public:
+        type_serializer_map ();
+
+      public:
+        struct type_info
+        {
+          type_info (const qualified_name& name,
+                     typename type_serializer_map::serializer serializer)
+              : name_ (name), serializer_ (serializer)
+          {
+          }
+
+          const qualified_name&
+          name () const
+          {
+            return name_;
+          }
+
+          typename type_serializer_map::serializer
+          serializer () const
+          {
+            return serializer_;
+          }
+
+          // For std::map.
+          //
+          type_info ()
+              : name_ (std::basic_string<C> (), std::basic_string<C> ()),
+                serializer_ (0)
+          {
+          }
+
+        private:
+          qualified_name name_;
+          typename type_serializer_map::serializer serializer_;
+        };
+
+      public:
+        const type_info*
+        find (const type_id&) const;
+
+      private:
+        struct type_id_comparator
+        {
+          bool
+          operator() (const type_id* x, const type_id* y) const
+          {
+            // XL C++ on AIX has buggy type_info::before() in that
+            // it returns true for two different type_info objects
+            // that happened to be for the same type.
+            //
+#if defined(__xlC__) && defined(_AIX)
+            return *x != *y && x->before (*y);
+#else
+            return x->before (*y);
+#endif
+          }
+        };
+
+        typedef
+        std::map<const type_id*, type_info, type_id_comparator>
+        type_map;
+
+        // Map of (root-element to map of (type_id to type_info)).
+        // Note that here type_info::name is element name.
+        //
+        typedef
+        std::map<const type_id*, type_info, type_id_comparator>
+        subst_map;
+
+        typedef
+        std::map<qualified_name, subst_map>
+        element_map;
+
+        type_map type_map_;
+        element_map element_map_;
+
+      private:
+        const type_info*
+        find_substitution (const subst_map& start, const type_id&) const;
+
+        // Sets an xsi:type attribute corresponding to the type_info.
+        //
+        void
+        set_xsi_type (xercesc::DOMElement& parent,
+                      xercesc::DOMElement&,
+                      const type_info&) const;
+      };
+
+
+      //
+      //
+      template<unsigned long id, typename C>
+      struct type_serializer_plate
+      {
+        static type_serializer_map<C>* map;
+        static std::size_t count;
+
+        type_serializer_plate ();
+        ~type_serializer_plate ();
+      };
+
+      template<unsigned long id, typename C>
+      type_serializer_map<C>* type_serializer_plate<id, C>::map = 0;
+
+      template<unsigned long id, typename C>
+      std::size_t type_serializer_plate<id, C>::count = 0;
+
+
+      //
+      //
+      template<unsigned long id, typename C>
+      inline type_serializer_map<C>&
+      type_serializer_map_instance ()
+      {
+        return *type_serializer_plate<id, C>::map;
+      }
+
+      //
+      //
+      template<typename T>
+      void
+      serializer_impl (xercesc::DOMElement&, const type&);
+
+
+      //
+      //
+      template<unsigned long id, typename C, typename T>
+      struct type_serializer_initializer
+      {
+        type_serializer_initializer (const C* name, const C* ns);
+        ~type_serializer_initializer ();
+      };
+
+
+      //
+      //
+      template<unsigned long id, typename C, typename T>
+      struct element_serializer_initializer
+      {
+        element_serializer_initializer (const C* root_name, const C* root_ns,
+                                        const C* subst_name, const C* subst_ns);
+
+        ~element_serializer_initializer ();
+
+      private:
+        const C* root_name_;
+        const C* root_ns_;
+      };
+    }
+  }
+}
+
+#include <xsd/cxx/tree/type-serializer-map.txx>
+
+#endif // XSD_CXX_TREE_TYPE_SERIALIZER_MAP_HXX
diff --git src/base/include/xsd/cxx/tree/type-serializer-map.txx src/base/include/xsd/cxx/tree/type-serializer-map.txx
new file mode 100644
index 0000000..859331f
--- /dev/null
+++ src/base/include/xsd/cxx/tree/type-serializer-map.txx
@@ -0,0 +1,576 @@
+// file      : xsd/cxx/tree/type-serializer-map.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#include <xercesc/util/XMLUni.hpp>
+#include <xercesc/validators/schema/SchemaSymbols.hpp>
+
+#include <xsd/cxx/xml/bits/literals.hxx> // xml::bits::{xsi_namespace, type}
+#include <xsd/cxx/xml/dom/serialization-source.hxx> // dom::{create_*, prefix}
+
+#include <xsd/cxx/tree/types.hxx>
+#include <xsd/cxx/tree/bits/literals.hxx>
+
+#include <iostream>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      // type_serializer_map
+      //
+      template <typename C>
+      type_serializer_map<C>::
+      type_serializer_map ()
+      {
+        // Register serializers for built-in non-fundamental types.
+        //
+        std::basic_string<C> xsd (bits::xml_schema<C> ());
+
+
+        // anyType and anySimpleType.
+        //
+        register_type (
+          typeid (type),
+          qualified_name (bits::any_type<C> (), xsd),
+          &serializer_impl<type>,
+          false);
+
+        typedef simple_type<type> simple_type;
+        register_type (
+          typeid (simple_type),
+          qualified_name (bits::any_simple_type<C> (), xsd),
+          &serializer_impl<simple_type>,
+          false);
+
+
+        // Strings
+        //
+        typedef string<C, simple_type> string;
+        register_type (
+          typeid (string),
+          qualified_name (bits::string<C> (), xsd),
+          &serializer_impl<string>,
+          false);
+
+        typedef normalized_string<C, string> normalized_string;
+        register_type (
+          typeid (normalized_string),
+          qualified_name (bits::normalized_string<C> (), xsd),
+          &serializer_impl<normalized_string>,
+          false);
+
+        typedef token<C, normalized_string> token;
+        register_type (
+          typeid (token),
+          qualified_name (bits::token<C> (), xsd),
+          &serializer_impl<token>,
+          false);
+
+        typedef name<C, token> name;
+        register_type (
+          typeid (name),
+          qualified_name (bits::name<C> (), xsd),
+          &serializer_impl<name>,
+          false);
+
+        typedef nmtoken<C, token> nmtoken;
+        register_type (
+          typeid (nmtoken),
+          qualified_name (bits::nmtoken<C> (), xsd),
+          &serializer_impl<nmtoken>,
+          false);
+
+        typedef nmtokens<C, simple_type, nmtoken> nmtokens;
+        register_type (
+          typeid (nmtokens),
+          qualified_name (bits::nmtokens<C> (), xsd),
+          &serializer_impl<nmtokens>,
+          false);
+
+        typedef ncname<C, name> ncname;
+        register_type (
+          typeid (ncname),
+          qualified_name (bits::ncname<C> (), xsd),
+          &serializer_impl<ncname>,
+          false);
+
+        typedef language<C, token> language;
+        register_type (
+          typeid (language),
+          qualified_name (bits::language<C> (), xsd),
+          &serializer_impl<language>,
+          false);
+
+
+        // ID/IDREF.
+        //
+        typedef id<C, ncname> id;
+        register_type (
+          typeid (id),
+          qualified_name (bits::id<C> (), xsd),
+          &serializer_impl<id>,
+          false);
+
+        typedef idref<C, ncname, type> idref;
+        register_type (
+          typeid (idref),
+          qualified_name (bits::idref<C> (), xsd),
+          &serializer_impl<idref>,
+          false);
+
+        typedef idrefs<C, simple_type, idref> idrefs;
+        register_type (
+          typeid (idrefs),
+          qualified_name (bits::idrefs<C> (), xsd),
+          &serializer_impl<idrefs>,
+          false);
+
+
+        // URI.
+        //
+        typedef uri<C, simple_type> uri;
+        register_type (
+          typeid (uri),
+          qualified_name (bits::any_uri<C> (), xsd),
+          &serializer_impl<uri>,
+          false);
+
+
+        // Qualified name.
+        //
+        typedef qname<C, simple_type, uri, ncname> qname;
+        register_type (
+          typeid (qname),
+          qualified_name (bits::qname<C> (), xsd),
+          &serializer_impl<qname>,
+          false);
+
+
+        // Binary.
+        //
+        typedef base64_binary<C, simple_type> base64_binary;
+        register_type (
+          typeid (base64_binary),
+          qualified_name (bits::base64_binary<C> (), xsd),
+          &serializer_impl<base64_binary>,
+          false);
+
+        typedef hex_binary<C, simple_type> hex_binary;
+        register_type (
+          typeid (hex_binary),
+          qualified_name (bits::hex_binary<C> (), xsd),
+          &serializer_impl<hex_binary>,
+          false);
+
+
+        // Date/time.
+        //
+        typedef gday<C, simple_type> gday;
+        register_type (
+          typeid (gday),
+          qualified_name (bits::gday<C> (), xsd),
+          &serializer_impl<gday>,
+          false);
+
+        typedef gmonth<C, simple_type> gmonth;
+        register_type (
+          typeid (gmonth),
+          qualified_name (bits::gmonth<C> (), xsd),
+          &serializer_impl<gmonth>,
+          false);
+
+        typedef gyear<C, simple_type> gyear;
+        register_type (
+          typeid (gyear),
+          qualified_name (bits::gyear<C> (), xsd),
+          &serializer_impl<gyear>,
+          false);
+
+        typedef gmonth_day<C, simple_type> gmonth_day;
+        register_type (
+          typeid (gmonth_day),
+          qualified_name (bits::gmonth_day<C> (), xsd),
+          &serializer_impl<gmonth_day>,
+          false);
+
+        typedef gyear_month<C, simple_type> gyear_month;
+        register_type (
+          typeid (gyear_month),
+          qualified_name (bits::gyear_month<C> (), xsd),
+          &serializer_impl<gyear_month>,
+          false);
+
+        typedef date<C, simple_type> date;
+        register_type (
+          typeid (date),
+          qualified_name (bits::date<C> (), xsd),
+          &serializer_impl<date>,
+          false);
+
+        typedef time<C, simple_type> time;
+        register_type (
+          typeid (time),
+          qualified_name (bits::time<C> (), xsd),
+          &serializer_impl<time>,
+          false);
+
+        typedef date_time<C, simple_type> date_time;
+        register_type (
+          typeid (date_time),
+          qualified_name (bits::date_time<C> (), xsd),
+          &serializer_impl<date_time>,
+          false);
+
+        typedef duration<C, simple_type> duration;
+        register_type (
+          typeid (duration),
+          qualified_name (bits::duration<C> (), xsd),
+          &serializer_impl<duration>,
+          false);
+
+
+        // Entity.
+        //
+        typedef entity<C, ncname> entity;
+        register_type (
+          typeid (entity),
+          qualified_name (bits::entity<C> (), xsd),
+          &serializer_impl<entity>,
+          false);
+
+        typedef entities<C, simple_type, entity> entities;
+        register_type (
+          typeid (entities),
+          qualified_name (bits::entities<C> (), xsd),
+          &serializer_impl<entities>,
+          false);
+      }
+
+      template <typename C>
+      void type_serializer_map<C>::
+      register_type (const type_id& tid,
+                     const qualified_name& name,
+                     serializer s,
+                     bool override)
+      {
+        if (override || type_map_.find (&tid) == type_map_.end ())
+          type_map_[&tid] = type_info (name, s);
+      }
+
+      template <typename C>
+      void type_serializer_map<C>::
+      unregister_type (const type_id& tid)
+      {
+        type_map_.erase (&tid);
+      }
+
+      template <typename C>
+      void type_serializer_map<C>::
+      register_element (const qualified_name& root,
+                        const qualified_name& subst,
+                        const type_id& tid,
+                        serializer s)
+      {
+        element_map_[root][&tid] = type_info (subst, s);
+      }
+
+      template <typename C>
+      void type_serializer_map<C>::
+      unregister_element (const qualified_name& root, const type_id& tid)
+      {
+        typename element_map::iterator i (element_map_.find (root));
+
+        if (i != element_map_.end ())
+        {
+          i->second.erase (&tid);
+
+          if (i->second.empty ())
+            element_map_.erase (root);
+        }
+      }
+
+      template <typename C>
+      void type_serializer_map<C>::
+      serialize (const C* name, // element name
+                 const C* ns,   // element namespace
+                 bool global,
+                 bool qualified,
+                 xercesc::DOMElement& parent,
+                 const type& x) const
+      {
+        const type_id& tid (typeid (x));
+
+        // First see if we can find a substitution.
+        //
+        if (global)
+        {
+          typename element_map::const_iterator i (
+            element_map_.find (qualified_name (name, ns)));
+
+          if (i != element_map_.end ())
+          {
+            if (const type_info* ti = find_substitution (i->second, tid))
+            {
+              xercesc::DOMElement& e (
+                xml::dom::create_element (
+                  ti->name ().name ().c_str (),
+                  ti->name ().namespace_ ().c_str (),
+                  parent));
+
+              ti->serializer () (e, x);
+              return;
+            }
+          }
+        }
+
+        // The last resort is xsi:type.
+        //
+        if (const type_info* ti = find (tid))
+        {
+          xercesc::DOMElement& e (
+            qualified
+            ? xml::dom::create_element (name, ns, parent)
+            : xml::dom::create_element (name, parent));
+
+          ti->serializer () (e, x);
+          set_xsi_type (parent, e, *ti);
+          return;
+        }
+
+        throw no_type_info<C> (std::basic_string<C> (),
+                               std::basic_string<C> ()); //@@ TODO
+      }
+
+      template <typename C>
+      void type_serializer_map<C>::
+      serialize (const C* static_name,
+                 const C* static_ns,
+                 xercesc::DOMElement& e,
+                 const qualified_name& qn,
+                 const type& x) const
+      {
+        const type_id& tid (typeid (x));
+
+        // First see if this is a substitution.
+        //
+        if (qn.name () != static_name || qn.namespace_ () != static_ns)
+        {
+          typename element_map::const_iterator i (
+            element_map_.find (qualified_name (static_name, static_ns)));
+
+          if (i != element_map_.end ())
+          {
+            if (const type_info* ti = find_substitution (i->second, tid))
+            {
+              if (ti->name ().name () != qn.name () ||
+                  ti->name ().namespace_ () != qn.namespace_ ())
+              {
+                throw unexpected_element<C> (
+                  qn.name (), qn.namespace_ (),
+                  ti->name ().name (), ti->name ().namespace_ ());
+              }
+
+              ti->serializer () (e, x);
+              return;
+            }
+          }
+
+          // This is not a valid substitution.
+          //
+          throw unexpected_element<C> (qn.name (), qn.namespace_ (),
+                                       static_name, static_ns);
+        }
+
+        // The last resort is xsi:type.
+        //
+        if (const type_info* ti = find (tid))
+        {
+          ti->serializer () (e, x);
+          set_xsi_type (e, e, *ti);
+          return;
+        }
+
+        throw no_type_info<C> (std::basic_string<C> (),
+                               std::basic_string<C> ()); //@@ TODO
+      }
+
+      template <typename C>
+      xml::dom::auto_ptr<xercesc::DOMDocument> type_serializer_map<C>::
+      serialize (const C* name,
+                 const C* ns,
+                 const xml::dom::namespace_infomap<C>& m,
+                 const type& x,
+                 unsigned long flags) const
+      {
+        const type_id& tid (typeid (x));
+
+        // See if we can find a substitution.
+        //
+        {
+          typename element_map::const_iterator i (
+            element_map_.find (qualified_name (name, ns)));
+
+          if (i != element_map_.end ())
+          {
+            if (const type_info* ti = find_substitution (i->second, tid))
+            {
+              return xml::dom::serialize<C> (
+                ti->name ().name (), ti->name ().namespace_ (), m, flags);
+            }
+          }
+        }
+
+        // If there is no substitution then serialize() will have to
+        // find suitable xsi:type.
+        //
+        return xml::dom::serialize<C> (name, ns, m, flags);
+      }
+
+      template <typename C>
+      const typename type_serializer_map<C>::type_info*
+      type_serializer_map<C>::
+      find (const type_id& tid) const
+      {
+        typename type_map::const_iterator i (type_map_.find (&tid));
+        return i == type_map_.end () ? 0 : &i->second;
+      }
+
+      template <typename C>
+      const typename type_serializer_map<C>::type_info*
+      type_serializer_map<C>::
+      find_substitution (const subst_map& start, const type_id& tid) const
+      {
+        typename subst_map::const_iterator i (start.find (&tid));
+
+        if (i != start.end ())
+          return &i->second;
+        else
+        {
+          for (i = start.begin (); i != start.end (); ++i)
+          {
+            typename element_map::const_iterator j (
+              element_map_.find (i->second.name ()));
+
+            if (j != element_map_.end ())
+            {
+              if (const type_info* ti = find_substitution (j->second, tid))
+                return ti;
+            }
+          }
+        }
+
+        return 0;
+      }
+
+      template <typename C>
+      void type_serializer_map<C>::
+      set_xsi_type (xercesc::DOMElement& parent,
+                    xercesc::DOMElement& e,
+                    const type_info& ti) const
+      {
+        std::basic_string<C> id;
+        const std::basic_string<C>& ns (ti.name ().namespace_ ());
+
+        if (!ns.empty ())
+        {
+          id = xml::dom::prefix (ns, e);
+
+          if (!id.empty ())
+            id += C (':');
+        }
+
+        id += ti.name ().name ();
+
+        std::basic_string<C> name = xml::dom::prefix (
+          xml::bits::xsi_namespace<C> (), parent, xml::bits::xsi_prefix<C> ());
+
+        if (!name.empty ())
+          name += C (':');
+
+        name += xml::bits::type<C> ();
+
+        e.setAttributeNS (
+          xercesc::SchemaSymbols::fgURI_XSI,
+          xml::string (name).c_str (),
+          xml::string (id).c_str ());
+      }
+
+
+      // type_serializer_plate
+      //
+      template<unsigned long id, typename C>
+      type_serializer_plate<id, C>::
+      type_serializer_plate ()
+      {
+        if (count == 0)
+          map = new type_serializer_map<C>;
+
+        ++count;
+      }
+
+      template<unsigned long id, typename C>
+      type_serializer_plate<id, C>::
+      ~type_serializer_plate ()
+      {
+        if (--count == 0)
+          delete map;
+      }
+
+
+      //
+      //
+      template<typename T>
+      void
+      serializer_impl (xercesc::DOMElement& e, const type& x)
+      {
+        e << static_cast<const T&> (x);
+      }
+
+      // type_serializer_initializer
+      //
+      template<unsigned long id, typename C, typename T>
+      type_serializer_initializer<id, C, T>::
+      type_serializer_initializer (const C* name, const C* ns)
+      {
+        type_serializer_map_instance<id, C> ().register_type (
+          typeid (T),
+          xml::qualified_name<C> (name, ns),
+          &serializer_impl<T>);
+      }
+
+      template<unsigned long id, typename C, typename T>
+      type_serializer_initializer<id, C, T>::
+      ~type_serializer_initializer ()
+      {
+        type_serializer_map_instance<id, C> ().unregister_type (typeid (T));
+      }
+
+      // element_serializer_initializer
+      //
+      template<unsigned long id, typename C, typename T>
+      element_serializer_initializer<id, C, T>::
+      element_serializer_initializer (const C* root_name, const C* root_ns,
+                                   const C* subst_name, const C* subst_ns)
+          : root_name_ (root_name), root_ns_ (root_ns)
+      {
+        type_serializer_map_instance<id, C> ().register_element (
+          xml::qualified_name<C> (root_name, root_ns),
+          xml::qualified_name<C> (subst_name, subst_ns),
+          typeid (T),
+          &serializer_impl<T>);
+      }
+
+      template<unsigned long id, typename C, typename T>
+      element_serializer_initializer<id, C, T>::
+      ~element_serializer_initializer ()
+      {
+        type_serializer_map_instance<id, C> ().unregister_element (
+          xml::qualified_name<C> (root_name_, root_ns_), typeid (T));
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/tree/types.hxx src/base/include/xsd/cxx/tree/types.hxx
new file mode 100644
index 0000000..299824f
--- /dev/null
+++ src/base/include/xsd/cxx/tree/types.hxx
@@ -0,0 +1,3791 @@
+// file      : xsd/cxx/tree/types.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+/**
+ * @file
+ *
+ * @brief Contains C++ class definitions for XML Schema built-in types.
+ *
+ * This is an internal header and is included by the generated code. You
+ * normally should not include it directly.
+ *
+ */
+
+#ifndef XSD_CXX_TREE_TYPES_HXX
+#define XSD_CXX_TREE_TYPES_HXX
+
+#include <string>
+#include <cstddef> // std::size_t
+
+#include <xercesc/dom/DOMAttr.hpp>
+#include <xercesc/dom/DOMElement.hpp>
+
+#include <xsd/cxx/tree/elements.hxx>
+#include <xsd/cxx/tree/list.hxx>
+#include <xsd/cxx/tree/buffer.hxx>
+#include <xsd/cxx/tree/istream-fwd.hxx>
+
+#include <xsd/cxx/tree/date-time.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    /**
+     * @brief C++/Tree mapping runtime namespace.
+     *
+     * This is an internal namespace and normally should not be referenced
+     * directly. Instead you should use the aliases for types in this
+     * namespaces that are created in the generated code.
+     *
+     */
+    namespace tree
+    {
+      /**
+       * @brief Class corresponding to the XML Schema %string built-in
+       * type.
+       *
+       * The %string class publicly inherits from and has the same set
+       * of constructors as @c std::basic_string. It therefore can be
+       * used as @c std::string (or @c std::wstring if you are using
+       * @c wchar_t as the character type).
+       *
+       * @nosubgrouping
+       */
+      template <typename C, typename B>
+      class string: public B, public std::basic_string<C>
+      {
+        typedef std::basic_string<C> base_type;
+
+        base_type&
+        base ()
+        {
+          return *this;
+        }
+
+      public:
+        /**
+         * @name Constructors
+         */
+        //@{
+
+        /**
+         * @brief Default constructor creates an empty %string.
+         */
+        string ()
+        {
+        }
+
+        /**
+         * @brief Initialize an instance with a copy of a C %string.
+         *
+         * @param s A C %string to copy.
+         */
+        string (const C* s)
+            : base_type (s)
+        {
+        }
+
+        /**
+         * @brief Initialize an instance with a character array.
+         *
+         * @param s A character array to copy.
+         * @param n A number of character to copy.
+         */
+        string (const C* s, std::size_t n)
+            : base_type (s, n)
+        {
+        }
+
+        /**
+         * @brief Initialize an instance with multiple copies of the same
+         * character.
+         *
+         * @param n A number of copies to create.
+         * @param c A character to copy.
+         */
+        string (std::size_t n, C c)
+            : base_type (n, c)
+        {
+        }
+
+        /**
+         * @brief Initialize an instance with a copy of a standard %string.
+         *
+         * @param s A standard %string to copy.
+         */
+        string (const std::basic_string<C>& s)
+            : base_type (s)
+        {
+        }
+
+        /**
+         * @brief Initialize an instance with a copy of a substring.
+         *
+         * @param s   A standard %string to copy the substring from.
+         * @param pos An index of the first character to copy from.
+         * @param n   A number of characters to copy.
+         */
+        string (const std::basic_string<C>& s,
+                std::size_t pos,
+                std::size_t n = std::basic_string<C>::npos)
+            : base_type (s, pos, n)
+        {
+        }
+
+      public:
+        /**
+         * @brief Copy constructor.
+         *
+         * @param x An instance to make a copy of.
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         *
+         * For polymorphic object models use the @c _clone function instead.
+         */
+        string (const string& x, flags f = 0, container* c = 0)
+            : B (x, f, c), base_type (x)
+        {
+        }
+
+        /**
+         * @brief Copy the instance polymorphically.
+         *
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         * @return A pointer to the dynamically allocated copy.
+         *
+         * This function ensures that the dynamic type of the instance
+         * is used for copying and should be used for polymorphic object
+         * models instead of the copy constructor.
+         */
+        virtual string*
+        _clone (flags f = 0, container* c = 0) const;
+
+      public:
+        /**
+         * @brief Create an instance from a data representation
+         * stream.
+         *
+         * @param s A stream to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        template <typename S>
+        string (istream<S>& s, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM element.
+         *
+         * @param e A DOM element to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        string (const xercesc::DOMElement& e, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM Attribute.
+         *
+         * @param a A DOM attribute to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        string (const xercesc::DOMAttr& a, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a %string fragment.
+         *
+         * @param s A %string fragment to extract the data from.
+         * @param e A pointer to DOM element containing the %string fragment.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        string (const std::basic_string<C>& s,
+                const xercesc::DOMElement* e,
+                flags f = 0,
+                container* c = 0);
+        //@}
+
+      public:
+        /**
+         * @brief Assign a character to the instance.
+         *
+         * The resulting %string has only one character.
+         *
+         * @param c A character to assign.
+         * @return A reference to the instance.
+         */
+        string&
+        operator= (C c)
+        {
+          base () = c;
+          return *this;
+        }
+
+        /**
+         * @brief Assign a C %string to the instance.
+         *
+         * The resulting %string contains a copy of the C %string.
+         *
+         * @param s A C %string to assign.
+         * @return A reference to the instance.
+         */
+        string&
+        operator= (const C* s)
+        {
+          base () = s;
+          return *this;
+        }
+
+        /**
+         * @brief Assign a standard %string to the instance.
+         *
+         * The resulting %string contains a copy of the standard %string.
+         *
+         * @param s A standard %string to assign.
+         * @return A reference to the instance.
+         */
+        string&
+        operator= (const std::basic_string<C>& s)
+        {
+          base () = s;
+          return *this;
+        }
+
+        /**
+         * @brief Copy assignment operator.
+         *
+         * @param x An instance to assign.
+         * @return A reference to the instance.
+         */
+        string&
+        operator= (const string& x)
+        {
+          base () = x;
+          return *this;
+        }
+      };
+
+
+      /**
+       * @brief Class corresponding to the XML Schema normalizedString
+       * built-in type.
+       *
+       * The %normalized_string class publicly inherits from and has
+       * the same set of constructors as @c std::basic_string. It
+       * therefore can be used as @c std::string (or @c std::wstring
+       * if you are using @c wchar_t as the character type).
+       *
+       * @nosubgrouping
+       */
+      template <typename C, typename B>
+      class normalized_string: public B
+      {
+        typedef B base_type;
+
+        base_type&
+        base ()
+        {
+          return *this;
+        }
+
+      public:
+        /**
+         * @name Constructors
+         */
+        //@{
+
+        /**
+         * @brief Default constructor creates an empty %normalized_string.
+         */
+        normalized_string ()
+        {
+        }
+
+        /**
+         * @brief Initialize an instance with a copy of a C %string.
+         *
+         * @param s A C %string to copy.
+         */
+        normalized_string (const C* s)
+            : base_type (s)
+        {
+        }
+
+        /**
+         * @brief Initialize an instance with a character array.
+         *
+         * @param s A character array to copy.
+         * @param n A number of character to copy.
+         */
+        normalized_string (const C* s, std::size_t n)
+            : base_type (s, n)
+        {
+        }
+
+        /**
+         * @brief Initialize an instance with multiple copies of the same
+         * character.
+         *
+         * @param n A number of copies to create.
+         * @param c A character to copy.
+         */
+        normalized_string (std::size_t n, C c)
+            : base_type (n, c)
+        {
+        }
+
+        /**
+         * @brief Initialize an instance with a copy of a standard %string.
+         *
+         * @param s A standard %string to copy.
+         */
+        normalized_string (const std::basic_string<C>& s)
+            : base_type (s)
+        {
+        }
+
+        /**
+         * @brief Initialize an instance with a copy of a substring.
+         *
+         * @param s   A standard %string to copy the substring from.
+         * @param pos An index of the first character to copy from.
+         * @param n   A number of characters to copy.
+         */
+        normalized_string (const std::basic_string<C>& s,
+                           std::size_t pos,
+                           std::size_t n = std::basic_string<C>::npos)
+            : base_type (s, pos, n)
+        {
+        }
+
+      public:
+        /**
+         * @brief Copy constructor.
+         *
+         * @param x An instance to make a copy of.
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         *
+         * For polymorphic object models use the @c _clone function instead.
+         */
+        normalized_string (const normalized_string& x,
+                           flags f = 0,
+                           container* c = 0)
+            : base_type (x, f, c)
+        {
+        }
+
+        /**
+         * @brief Copy the instance polymorphically.
+         *
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         * @return A pointer to the dynamically allocated copy.
+         *
+         * This function ensures that the dynamic type of the instance
+         * is used for copying and should be used for polymorphic object
+         * models instead of the copy constructor.
+         */
+        virtual normalized_string*
+        _clone (flags f = 0, container* c = 0) const;
+
+      public:
+        /**
+         * @brief Create an instance from a data representation
+         * stream.
+         *
+         * @param s A stream to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        template <typename S>
+        normalized_string (istream<S>& s, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM element.
+         *
+         * @param e A DOM element to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        normalized_string (const xercesc::DOMElement& e,
+                           flags f = 0,
+                           container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM Attribute.
+         *
+         * @param a A DOM attribute to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        normalized_string (const xercesc::DOMAttr& a,
+                           flags f = 0,
+                           container* c = 0);
+
+        /**
+         * @brief Create an instance from a %string fragment.
+         *
+         * @param s A %string fragment to extract the data from.
+         * @param e A pointer to DOM element containing the %string fragment.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        normalized_string (const std::basic_string<C>& s,
+                           const xercesc::DOMElement* e,
+                           flags f = 0,
+                           container* c = 0);
+        //@}
+
+      public:
+        /**
+         * @brief Assign a character to the instance.
+         *
+         * The resulting %normalized_string has only one character.
+         *
+         * @param c A character to assign.
+         * @return A reference to the instance.
+         */
+        normalized_string&
+        operator= (C c)
+        {
+          base () = c;
+          return *this;
+        }
+
+        /**
+         * @brief Assign a C %string to the instance.
+         *
+         * The resulting %normalized_string contains a copy of the C %string.
+         *
+         * @param s A C %string to assign.
+         * @return A reference to the instance.
+         */
+        normalized_string&
+        operator= (const C* s)
+        {
+          base () = s;
+          return *this;
+        }
+
+        /**
+         * @brief Assign a standard %string to the instance.
+         *
+         * The resulting %normalized_string contains a copy of the standard
+         * %string.
+         *
+         * @param s A standard %string to assign.
+         * @return A reference to the instance.
+         */
+        normalized_string&
+        operator= (const std::basic_string<C>& s)
+        {
+          base () = s;
+          return *this;
+        }
+
+        /**
+         * @brief Copy assignment operator.
+         *
+         * @param x An instance to assign.
+         * @return A reference to the instance.
+         */
+        normalized_string&
+        operator= (const normalized_string& x)
+        {
+          base () = x;
+          return *this;
+        }
+
+      protected:
+        //@cond
+
+        void
+        normalize ();
+
+        //@endcond
+      };
+
+
+      /**
+       * @brief Class corresponding to the XML Schema %token built-in
+       * type.
+       *
+       * The %token class publicly inherits from and has the same set
+       * of constructors as @c std::basic_string. It therefore can be
+       * used as @c std::string (or @c std::wstring if you are using
+       * @c wchar_t as the character type).
+       *
+       * @nosubgrouping
+       */
+      template <typename C, typename B>
+      class token: public B
+      {
+        typedef B base_type;
+
+        base_type&
+        base ()
+        {
+          return *this;
+        }
+
+      public:
+        /**
+         * @name Constructors
+         */
+        //@{
+
+        /**
+         * @brief Default constructor creates an empty %token.
+         */
+        token ()
+        {
+        }
+
+        /**
+         * @brief Initialize an instance with a copy of a C %string.
+         *
+         * @param s A C %string to copy.
+         */
+        token (const C* s)
+            : base_type (s)
+        {
+        }
+
+        /**
+         * @brief Initialize an instance with a character array.
+         *
+         * @param s A character array to copy.
+         * @param n A number of character to copy.
+         */
+        token (const C* s, std::size_t n)
+            : base_type (s, n)
+        {
+        }
+
+        /**
+         * @brief Initialize an instance with multiple copies of the same
+         * character.
+         *
+         * @param n A number of copies to create.
+         * @param c A character to copy.
+         */
+        token (std::size_t n, C c)
+            : base_type (n, c)
+        {
+        }
+
+        /**
+         * @brief Initialize an instance with a copy of a standard %string.
+         *
+         * @param s A standard %string to copy.
+         */
+        token (const std::basic_string<C>& s)
+            : base_type (s)
+        {
+        }
+
+        /**
+         * @brief Initialize an instance with a copy of a substring.
+         *
+         * @param s   A standard %string to copy the substring from.
+         * @param pos An index of the first character to copy from.
+         * @param n   A number of characters to copy.
+         */
+        token (const std::basic_string<C>& s,
+               std::size_t pos,
+               std::size_t n = std::basic_string<C>::npos)
+            : base_type (s, pos, n)
+        {
+        }
+
+      public:
+        /**
+         * @brief Copy constructor.
+         *
+         * @param x An instance to make a copy of.
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         *
+         * For polymorphic object models use the @c _clone function instead.
+         */
+        token (const token& x, flags f = 0, container* c = 0)
+            : base_type (x, f, c)
+        {
+        }
+
+        /**
+         * @brief Copy the instance polymorphically.
+         *
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         * @return A pointer to the dynamically allocated copy.
+         *
+         * This function ensures that the dynamic type of the instance
+         * is used for copying and should be used for polymorphic object
+         * models instead of the copy constructor.
+         */
+        virtual token*
+        _clone (flags f = 0, container* c = 0) const;
+
+      public:
+        /**
+         * @brief Create an instance from a data representation
+         * stream.
+         *
+         * @param s A stream to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        template <typename S>
+        token (istream<S>& s, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM element.
+         *
+         * @param e A DOM element to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        token (const xercesc::DOMElement& e, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM Attribute.
+         *
+         * @param a A DOM attribute to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        token (const xercesc::DOMAttr& a, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a %string fragment.
+         *
+         * @param s A %string fragment to extract the data from.
+         * @param e A pointer to DOM element containing the %string fragment.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        token (const std::basic_string<C>& s,
+               const xercesc::DOMElement* e,
+               flags f = 0,
+               container* c = 0);
+        //@}
+
+      public:
+        /**
+         * @brief Assign a character to the instance.
+         *
+         * The resulting %token has only one character.
+         *
+         * @param c A character to assign.
+         * @return A reference to the instance.
+         */
+        token&
+        operator= (C c)
+        {
+          base () = c;
+          return *this;
+        }
+
+        /**
+         * @brief Assign a C %string to the instance.
+         *
+         * The resulting %token contains a copy of the C %string.
+         *
+         * @param s A C %string to assign.
+         * @return A reference to the instance.
+         */
+        token&
+        operator= (const C* s)
+        {
+          base () = s;
+          return *this;
+        }
+
+        /**
+         * @brief Assign a standard %string to the instance.
+         *
+         * The resulting %token contains a copy of the standard %string.
+         *
+         * @param s A standard %string to assign.
+         * @return A reference to the instance.
+         */
+        token&
+        operator= (const std::basic_string<C>& s)
+        {
+          base () = s;
+          return *this;
+        }
+
+        /**
+         * @brief Copy assignment operator.
+         *
+         * @param x An instance to assign.
+         * @return A reference to the instance.
+         */
+        token&
+        operator= (const token& x)
+        {
+          base () = x;
+          return *this;
+        }
+
+      protected:
+        //@cond
+
+        void
+        collapse ();
+
+        //@endcond
+      };
+
+
+      /**
+       * @brief Class corresponding to the XML Schema NMTOKEN built-in
+       * type.
+       *
+       * The %nmtoken class publicly inherits from and has the same set
+       * of constructors as @c std::basic_string. It therefore can be
+       * used as @c std::string (or @c std::wstring if you are using
+       * @c wchar_t as the character type).
+       *
+       * @nosubgrouping
+       */
+      template <typename C, typename B>
+      class nmtoken: public B
+      {
+        typedef B base_type;
+
+        base_type&
+        base ()
+        {
+          return *this;
+        }
+
+      public:
+        /**
+         * @name Constructors
+         */
+        //@{
+
+        /**
+         * @brief Initialize an instance with a copy of a C %string.
+         *
+         * @param s A C %string to copy.
+         */
+        nmtoken (const C* s)
+            : base_type (s)
+        {
+        }
+
+        /**
+         * @brief Initialize an instance with a character array.
+         *
+         * @param s A character array to copy.
+         * @param n A number of character to copy.
+         */
+        nmtoken (const C* s, std::size_t n)
+            : base_type (s, n)
+        {
+        }
+
+        /**
+         * @brief Initialize an instance with multiple copies of the same
+         * character.
+         *
+         * @param n A number of copies to create.
+         * @param c A character to copy.
+         */
+        nmtoken (std::size_t n, C c)
+            : base_type (n, c)
+        {
+        }
+
+        /**
+         * @brief Initialize an instance with a copy of a standard %string.
+         *
+         * @param s A standard %string to copy.
+         */
+        nmtoken (const std::basic_string<C>& s)
+            : base_type (s)
+        {
+        }
+
+        /**
+         * @brief Initialize an instance with a copy of a substring.
+         *
+         * @param s   A standard %string to copy the substring from.
+         * @param pos An index of the first character to copy from.
+         * @param n   A number of characters to copy.
+         */
+        nmtoken (const std::basic_string<C>& s,
+                 std::size_t pos,
+                 std::size_t n = std::basic_string<C>::npos)
+            : base_type (s, pos, n)
+        {
+        }
+
+      public:
+        /**
+         * @brief Copy constructor.
+         *
+         * @param x An instance to make a copy of.
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         *
+         * For polymorphic object models use the @c _clone function instead.
+         */
+        nmtoken (const nmtoken& x, flags f = 0, container* c = 0)
+            : base_type (x, f, c)
+        {
+        }
+
+        /**
+         * @brief Copy the instance polymorphically.
+         *
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         * @return A pointer to the dynamically allocated copy.
+         *
+         * This function ensures that the dynamic type of the instance
+         * is used for copying and should be used for polymorphic object
+         * models instead of the copy constructor.
+         */
+        virtual nmtoken*
+        _clone (flags f = 0, container* c = 0) const;
+
+      public:
+        /**
+         * @brief Create an instance from a data representation
+         * stream.
+         *
+         * @param s A stream to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        template <typename S>
+        nmtoken (istream<S>& s, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM element.
+         *
+         * @param e A DOM element to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        nmtoken (const xercesc::DOMElement& e, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM Attribute.
+         *
+         * @param a A DOM attribute to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        nmtoken (const xercesc::DOMAttr& a, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a %string fragment.
+         *
+         * @param s A %string fragment to extract the data from.
+         * @param e A pointer to DOM element containing the %string fragment.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        nmtoken (const std::basic_string<C>& s,
+                 const xercesc::DOMElement* e,
+                 flags f = 0,
+                 container* c = 0);
+        //@}
+
+      public:
+        /**
+         * @brief Assign a character to the instance.
+         *
+         * The resulting %nmtoken has only one character.
+         *
+         * @param c A character to assign.
+         * @return A reference to the instance.
+         */
+        nmtoken&
+        operator= (C c)
+        {
+          base () = c;
+          return *this;
+        }
+
+        /**
+         * @brief Assign a C %string to the instance.
+         *
+         * The resulting %nmtoken contains a copy of the C %string.
+         *
+         * @param s A C %string to assign.
+         * @return A reference to the instance.
+         */
+        nmtoken&
+        operator= (const C* s)
+        {
+          base () = s;
+          return *this;
+        }
+
+        /**
+         * @brief Assign a standard %string to the instance.
+         *
+         * The resulting %nmtoken contains a copy of the standard %string.
+         *
+         * @param s A standard %string to assign.
+         * @return A reference to the instance.
+         */
+        nmtoken&
+        operator= (const std::basic_string<C>& s)
+        {
+          base () = s;
+          return *this;
+        }
+
+        /**
+         * @brief Copy assignment operator.
+         *
+         * @param x An instance to assign.
+         * @return A reference to the instance.
+         */
+        nmtoken&
+        operator= (const nmtoken& x)
+        {
+          base () = x;
+          return *this;
+        }
+
+      protected:
+        //@cond
+
+        nmtoken ()
+            : base_type ()
+        {
+        }
+
+        //@endcond
+      };
+
+
+      /**
+       * @brief Class corresponding to the XML Schema NMTOKENS built-in
+       * type.
+       *
+       * The %nmtokens class is a vector (or %list in XML Schema terminology)
+       * of nmtoken elements. It is implemented in terms of the list class
+       * template.
+       *
+       * @nosubgrouping
+       */
+      template <typename C, typename B, typename nmtoken>
+      class nmtokens: public B, public list<nmtoken, C>
+      {
+        typedef list<nmtoken, C> base_type;
+
+      public:
+        /**
+         * @name Constructors
+         */
+        //@{
+
+        /**
+         * @brief Default constructor creates no elements.
+         */
+        nmtokens ()
+            : base_type (0, this)
+        {
+        }
+
+        /**
+         * @brief Initialize the instance with copies of an exemplar elements.
+         *
+         * @param n A number of elements to copy.
+         * @param x An exemplar element to copy.
+         */
+        nmtokens (typename base_type::size_type n, const nmtoken& x)
+            : base_type (n, x, this)
+        {
+        }
+
+        /**
+         * @brief Initialize the instance with copies of elements from an
+         * iterator range.
+         *
+         * @param begin An iterator pointing to the first element.
+         * @param end An iterator pointing to the one past the last element.
+         */
+        template <typename I>
+        nmtokens (const I& begin, const I& end)
+            : base_type (begin, end, this)
+        {
+        }
+
+      public:
+        /**
+         * @brief Copy constructor.
+         *
+         * @param x An instance to make a copy of.
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         *
+         * For polymorphic object models use the @c _clone function instead.
+         */
+        nmtokens (const nmtokens& x, flags f, container* c = 0)
+            : B (x, f, c), base_type (x, f, this)
+        {
+        }
+
+        /**
+         * @brief Copy the instance polymorphically.
+         *
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         * @return A pointer to the dynamically allocated copy.
+         *
+         * This function ensures that the dynamic type of the instance
+         * is used for copying and should be used for polymorphic object
+         * models instead of the copy constructor.
+         */
+        virtual nmtokens*
+        _clone (flags f = 0, container* c = 0) const;
+
+      public:
+        /**
+         * @brief Create an instance from a data representation
+         * stream.
+         *
+         * @param s A stream to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        template <typename S>
+        nmtokens (istream<S>& s, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM element.
+         *
+         * @param e A DOM element to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        nmtokens (const xercesc::DOMElement& e, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM Attribute.
+         *
+         * @param a A DOM attribute to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        nmtokens (const xercesc::DOMAttr& a, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a %string fragment.
+         *
+         * @param s A %string fragment to extract the data from.
+         * @param e A pointer to DOM element containing the %string fragment.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        nmtokens (const std::basic_string<C>& s,
+                  const xercesc::DOMElement* e,
+                  flags f = 0,
+                  container* c = 0);
+        //@}
+      };
+
+
+      /**
+       * @brief Class corresponding to the XML Schema Name built-in
+       * type.
+       *
+       * The %name class publicly inherits from and has the same set
+       * of constructors as @c std::basic_string. It therefore can be
+       * used as @c std::string (or @c std::wstring if you are using
+       * @c wchar_t as the character type).
+       *
+       * @nosubgrouping
+       */
+      template <typename C, typename B>
+      class name: public B
+      {
+        typedef B base_type;
+
+        base_type&
+        base ()
+        {
+          return *this;
+        }
+
+      public:
+        /**
+         * @name Constructors
+         */
+        //@{
+
+        /**
+         * @brief Initialize an instance with a copy of a C %string.
+         *
+         * @param s A C %string to copy.
+         */
+        name (const C* s)
+            : base_type (s)
+        {
+        }
+
+        /**
+         * @brief Initialize an instance with a character array.
+         *
+         * @param s A character array to copy.
+         * @param n A number of character to copy.
+         */
+        name (const C* s, std::size_t n)
+            : base_type (s, n)
+        {
+        }
+
+        /**
+         * @brief Initialize an instance with multiple copies of the same
+         * character.
+         *
+         * @param n A number of copies to create.
+         * @param c A character to copy.
+         */
+        name (std::size_t n, C c)
+            : base_type (n, c)
+        {
+        }
+
+        /**
+         * @brief Initialize an instance with a copy of a standard %string.
+         *
+         * @param s A standard %string to copy.
+         */
+        name (const std::basic_string<C>& s)
+            : base_type (s)
+        {
+        }
+
+        /**
+         * @brief Initialize an instance with a copy of a substring.
+         *
+         * @param s   A standard %string to copy the substring from.
+         * @param pos An index of the first character to copy from.
+         * @param n   A number of characters to copy.
+         */
+        name (const std::basic_string<C>& s,
+              std::size_t pos,
+              std::size_t n = std::basic_string<C>::npos)
+            : base_type (s, pos, n)
+        {
+        }
+
+      public:
+        /**
+         * @brief Copy constructor.
+         *
+         * @param x An instance to make a copy of.
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         *
+         * For polymorphic object models use the @c _clone function instead.
+         */
+        name (const name& x, flags f = 0, container* c = 0)
+            : base_type (x, f, c)
+        {
+        }
+
+        /**
+         * @brief Copy the instance polymorphically.
+         *
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         * @return A pointer to the dynamically allocated copy.
+         *
+         * This function ensures that the dynamic type of the instance
+         * is used for copying and should be used for polymorphic object
+         * models instead of the copy constructor.
+         */
+        virtual name*
+        _clone (flags f = 0, container* c = 0) const;
+
+      public:
+        /**
+         * @brief Create an instance from a data representation
+         * stream.
+         *
+         * @param s A stream to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        template <typename S>
+        name (istream<S>& s, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM element.
+         *
+         * @param e A DOM element to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        name (const xercesc::DOMElement& e, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM Attribute.
+         *
+         * @param a A DOM attribute to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        name (const xercesc::DOMAttr& a, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a %string fragment.
+         *
+         * @param s A %string fragment to extract the data from.
+         * @param e A pointer to DOM element containing the %string fragment.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        name (const std::basic_string<C>& s,
+              const xercesc::DOMElement* e,
+              flags f = 0,
+              container* c = 0);
+        //@}
+
+      public:
+        /**
+         * @brief Assign a character to the instance.
+         *
+         * The resulting %name has only one character.
+         *
+         * @param c A character to assign.
+         * @return A reference to the instance.
+         */
+        name&
+        operator= (C c)
+        {
+          base () = c;
+          return *this;
+        }
+
+        /**
+         * @brief Assign a C %string to the instance.
+         *
+         * The resulting %name contains a copy of the C %string.
+         *
+         * @param s A C %string to assign.
+         * @return A reference to the instance.
+         */
+        name&
+        operator= (const C* s)
+        {
+          base () = s;
+          return *this;
+        }
+
+        /**
+         * @brief Assign a standard %string to the instance.
+         *
+         * The resulting %name contains a copy of the standard %string.
+         *
+         * @param s A standard %string to assign.
+         * @return A reference to the instance.
+         */
+        name&
+        operator= (const std::basic_string<C>& s)
+        {
+          base () = s;
+          return *this;
+        }
+
+        /**
+         * @brief Copy assignment operator.
+         *
+         * @param x An instance to assign.
+         * @return A reference to the instance.
+         */
+        name&
+        operator= (const name& x)
+        {
+          base () = x;
+          return *this;
+        }
+
+      protected:
+        //@cond
+
+        name ()
+            : base_type ()
+        {
+        }
+
+        //@endcond
+      };
+
+
+      // Forward declaration for Sun CC.
+      //
+      template <typename C, typename B, typename uri, typename ncname>
+      class qname;
+
+
+      /**
+       * @brief Class corresponding to the XML Schema NCame built-in
+       * type.
+       *
+       * The %ncname class publicly inherits from and has the same set
+       * of constructors as @c std::basic_string. It therefore can be
+       * used as @c std::string (or @c std::wstring if you are using
+       * @c wchar_t as the character type).
+       *
+       * @nosubgrouping
+       */
+      template <typename C, typename B>
+      class ncname: public B
+      {
+        typedef B base_type;
+
+        base_type&
+        base ()
+        {
+          return *this;
+        }
+
+      public:
+        /**
+         * @name Constructors
+         */
+        //@{
+
+        /**
+         * @brief Initialize an instance with a copy of a C %string.
+         *
+         * @param s A C %string to copy.
+         */
+        ncname (const C* s)
+            : base_type (s)
+        {
+        }
+
+        /**
+         * @brief Initialize an instance with a character array.
+         *
+         * @param s A character array to copy.
+         * @param n A number of character to copy.
+         */
+        ncname (const C* s, std::size_t n)
+            : base_type (s, n)
+        {
+        }
+
+        /**
+         * @brief Initialize an instance with multiple copies of the same
+         * character.
+         *
+         * @param n A number of copies to create.
+         * @param c A character to copy.
+         */
+        ncname (std::size_t n, C c)
+            : base_type (n, c)
+        {
+        }
+
+        /**
+         * @brief Initialize an instance with a copy of a standard %string.
+         *
+         * @param s A standard %string to copy.
+         */
+        ncname (const std::basic_string<C>& s)
+            : base_type (s)
+        {
+        }
+
+        /**
+         * @brief Initialize an instance with a copy of a substring.
+         *
+         * @param s   A standard %string to copy the substring from.
+         * @param pos An index of the first character to copy from.
+         * @param n   A number of characters to copy.
+         */
+        ncname (const std::basic_string<C>& s,
+                std::size_t pos,
+                std::size_t n = std::basic_string<C>::npos)
+            : base_type (s, pos, n)
+        {
+        }
+
+      public:
+        /**
+         * @brief Copy constructor.
+         *
+         * @param x An instance to make a copy of.
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         *
+         * For polymorphic object models use the @c _clone function instead.
+         */
+        ncname (const ncname& x, flags f = 0, container* c = 0)
+            : base_type (x, f, c)
+        {
+        }
+
+        /**
+         * @brief Copy the instance polymorphically.
+         *
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         * @return A pointer to the dynamically allocated copy.
+         *
+         * This function ensures that the dynamic type of the instance
+         * is used for copying and should be used for polymorphic object
+         * models instead of the copy constructor.
+         */
+        virtual ncname*
+        _clone (flags f = 0, container* c = 0) const;
+
+      public:
+        /**
+         * @brief Create an instance from a data representation
+         * stream.
+         *
+         * @param s A stream to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        template <typename S>
+        ncname (istream<S>& s, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM element.
+         *
+         * @param e A DOM element to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        ncname (const xercesc::DOMElement& e, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM Attribute.
+         *
+         * @param a A DOM attribute to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        ncname (const xercesc::DOMAttr& a, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a %string fragment.
+         *
+         * @param s A %string fragment to extract the data from.
+         * @param e A pointer to DOM element containing the %string fragment.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        ncname (const std::basic_string<C>& s,
+                const xercesc::DOMElement* e,
+                flags f = 0,
+                container* c = 0);
+        //@}
+
+      public:
+        /**
+         * @brief Assign a character to the instance.
+         *
+         * The resulting %ncname has only one character.
+         *
+         * @param c A character to assign.
+         * @return A reference to the instance.
+         */
+        ncname&
+        operator= (C c)
+        {
+          base () = c;
+          return *this;
+        }
+
+        /**
+         * @brief Assign a C %string to the instance.
+         *
+         * The resulting %ncname contains a copy of the C %string.
+         *
+         * @param s A C %string to assign.
+         * @return A reference to the instance.
+         */
+        ncname&
+        operator= (const C* s)
+        {
+          base () = s;
+          return *this;
+        }
+
+        /**
+         * @brief Assign a standard %string to the instance.
+         *
+         * The resulting %ncname contains a copy of the standard %string.
+         *
+         * @param s A standard %string to assign.
+         * @return A reference to the instance.
+         */
+        ncname&
+        operator= (const std::basic_string<C>& s)
+        {
+          base () = s;
+          return *this;
+        }
+
+        /**
+         * @brief Copy assignment operator.
+         *
+         * @param x An instance to assign.
+         * @return A reference to the instance.
+         */
+        ncname&
+        operator= (const ncname& x)
+        {
+          base () = x;
+          return *this;
+        }
+
+      protected:
+        //@cond
+
+        ncname ()
+            : base_type ()
+        {
+        }
+
+        //@endcond
+
+        template <typename, typename, typename, typename>
+        friend class qname;
+      };
+
+
+      /**
+       * @brief Class corresponding to the XML Schema %language built-in
+       * type.
+       *
+       * The %language class publicly inherits from and has the same set
+       * of constructors as @c std::basic_string. It therefore can be
+       * used as @c std::string (or @c std::wstring if you are using
+       * @c wchar_t as the character type).
+       *
+       * @nosubgrouping
+       */
+      template <typename C, typename B>
+      class language: public B
+      {
+        typedef B base_type;
+
+        base_type&
+        base ()
+        {
+          return *this;
+        }
+
+      public:
+        /**
+         * @name Constructors
+         */
+        //@{
+
+        /**
+         * @brief Initialize an instance with a copy of a C %string.
+         *
+         * @param s A C %string to copy.
+         */
+        language (const C* s)
+            : base_type (s)
+        {
+        }
+
+        /**
+         * @brief Initialize an instance with a character array.
+         *
+         * @param s A character array to copy.
+         * @param n A number of character to copy.
+         */
+        language (const C* s, std::size_t n)
+            : base_type (s, n)
+        {
+        }
+
+        /**
+         * @brief Initialize an instance with multiple copies of the same
+         * character.
+         *
+         * @param n A number of copies to create.
+         * @param c A character to copy.
+         */
+        language (std::size_t n, C c)
+            : base_type (n, c)
+        {
+        }
+
+        /**
+         * @brief Initialize an instance with a copy of a standard %string.
+         *
+         * @param s A standard %string to copy.
+         */
+        language (const std::basic_string<C>& s)
+            : base_type (s)
+        {
+        }
+
+        /**
+         * @brief Initialize an instance with a copy of a substring.
+         *
+         * @param s   A standard %string to copy the substring from.
+         * @param pos An index of the first character to copy from.
+         * @param n   A number of characters to copy.
+         */
+        language (const std::basic_string<C>& s,
+                  std::size_t pos,
+                  std::size_t n = std::basic_string<C>::npos)
+            : base_type (s, pos, n)
+        {
+        }
+
+      public:
+        /**
+         * @brief Copy constructor.
+         *
+         * @param x An instance to make a copy of.
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         *
+         * For polymorphic object models use the @c _clone function instead.
+         */
+        language (const language& x, flags f = 0, container* c = 0)
+            : base_type (x, f, c)
+        {
+        }
+
+        /**
+         * @brief Copy the instance polymorphically.
+         *
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         * @return A pointer to the dynamically allocated copy.
+         *
+         * This function ensures that the dynamic type of the instance
+         * is used for copying and should be used for polymorphic object
+         * models instead of the copy constructor.
+         */
+        virtual language*
+        _clone (flags f = 0, container* c = 0) const;
+
+      public:
+        /**
+         * @brief Create an instance from a data representation
+         * stream.
+         *
+         * @param s A stream to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        template <typename S>
+        language (istream<S>& s, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM element.
+         *
+         * @param e A DOM element to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        language (const xercesc::DOMElement& e, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM Attribute.
+         *
+         * @param a A DOM attribute to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        language (const xercesc::DOMAttr& a, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a %string fragment.
+         *
+         * @param s A %string fragment to extract the data from.
+         * @param e A pointer to DOM element containing the %string fragment.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        language (const std::basic_string<C>& s,
+                  const xercesc::DOMElement* e,
+                  flags f = 0,
+                  container* c = 0);
+        //@}
+
+      public:
+        /**
+         * @brief Assign a character to the instance.
+         *
+         * The resulting %language has only one character.
+         *
+         * @param c A character to assign.
+         * @return A reference to the instance.
+         */
+        language&
+        operator= (C c)
+        {
+          base () = c;
+          return *this;
+        }
+
+        /**
+         * @brief Assign a C %string to the instance.
+         *
+         * The resulting %language contains a copy of the C %string.
+         *
+         * @param s A C %string to assign.
+         * @return A reference to the instance.
+         */
+        language&
+        operator= (const C* s)
+        {
+          base () = s;
+          return *this;
+        }
+
+        /**
+         * @brief Assign a standard %string to the instance.
+         *
+         * The resulting %language contains a copy of the standard %string.
+         *
+         * @param s A standard %string to assign.
+         * @return A reference to the instance.
+         */
+        language&
+        operator= (const std::basic_string<C>& s)
+        {
+          base () = s;
+          return *this;
+        }
+
+        /**
+         * @brief Copy assignment operator.
+         *
+         * @param x An instance to assign.
+         * @return A reference to the instance.
+         */
+        language&
+        operator= (const language& x)
+        {
+          base () = x;
+          return *this;
+        }
+
+      protected:
+        //@cond
+
+        language ()
+            : base_type ()
+        {
+        }
+
+        //@endcond
+      };
+
+
+      //@cond
+
+      template <typename C, typename ncname>
+      struct identity_impl: identity
+      {
+        identity_impl (const ncname& id)
+            : id_ (id)
+        {
+        }
+
+        virtual bool
+        before (const identity& y) const;
+
+        virtual void
+        throw_duplicate_id () const;
+
+      private:
+        const ncname& id_;
+      };
+
+      //@endcond
+
+
+      /**
+       * @brief Class corresponding to the XML Schema ID built-in
+       * type.
+       *
+       * The %id class publicly inherits from and has the same set
+       * of constructors as @c std::basic_string. It therefore can be
+       * used as @c std::string (or @c std::wstring if you are using
+       * @c wchar_t as the character type).
+       *
+       * @nosubgrouping
+       */
+      template <typename C, typename B>
+      class id: public B
+      {
+        typedef B base_type;
+
+        base_type&
+        base ()
+        {
+          return *this;
+        }
+
+      public:
+        ~id()
+        {
+          unregister_id ();
+        }
+
+      public:
+        /**
+         * @name Constructors
+         */
+        //@{
+
+        /**
+         * @brief Initialize an instance with a copy of a C %string.
+         *
+         * @param s A C %string to copy.
+         */
+        id (const C* s)
+            : base_type (s), identity_ (*this)
+        {
+          register_id ();
+        }
+
+        /**
+         * @brief Initialize an instance with a character array.
+         *
+         * @param s A character array to copy.
+         * @param n A number of character to copy.
+         */
+        id (const C* s, std::size_t n)
+            : base_type (s, n), identity_ (*this)
+        {
+          register_id ();
+        }
+
+        /**
+         * @brief Initialize an instance with multiple copies of the same
+         * character.
+         *
+         * @param n A number of copies to create.
+         * @param c A character to copy.
+         */
+        id (std::size_t n, C c)
+            : base_type (n, c), identity_ (*this)
+        {
+          register_id ();
+        }
+
+        /**
+         * @brief Initialize an instance with a copy of a standard %string.
+         *
+         * @param s A standard %string to copy.
+         */
+        id (const std::basic_string<C>& s)
+            : base_type (s), identity_ (*this)
+        {
+          register_id ();
+        }
+
+        /**
+         * @brief Initialize an instance with a copy of a substring.
+         *
+         * @param s   A standard %string to copy the substring from.
+         * @param pos An index of the first character to copy from.
+         * @param n   A number of characters to copy.
+         */
+        id (const std::basic_string<C>& s,
+            std::size_t pos,
+            std::size_t n = std::basic_string<C>::npos)
+            : base_type (s, pos, n), identity_ (*this)
+        {
+          register_id ();
+        }
+
+      public:
+        /**
+         * @brief Copy constructor.
+         *
+         * @param x An instance to make a copy of.
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         *
+         * For polymorphic object models use the @c _clone function instead.
+         */
+        id (const id& x, flags f = 0, container* c = 0)
+            : base_type (x, f, c), identity_ (*this)
+        {
+          register_id ();
+        }
+
+        /**
+         * @brief Copy the instance polymorphically.
+         *
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         * @return A pointer to the dynamically allocated copy.
+         *
+         * This function ensures that the dynamic type of the instance
+         * is used for copying and should be used for polymorphic object
+         * models instead of the copy constructor.
+         */
+        virtual id*
+        _clone (flags f = 0, container* c = 0) const;
+
+      public:
+        /**
+         * @brief Create an instance from a data representation
+         * stream.
+         *
+         * @param s A stream to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        template <typename S>
+        id (istream<S>& s, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM element.
+         *
+         * @param e A DOM element to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        id (const xercesc::DOMElement& e, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM Attribute.
+         *
+         * @param a A DOM attribute to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        id (const xercesc::DOMAttr& a, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a %string fragment.
+         *
+         * @param s A %string fragment to extract the data from.
+         * @param e A pointer to DOM element containing the %string fragment.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        id (const std::basic_string<C>& s,
+            const xercesc::DOMElement* e,
+            flags f = 0,
+            container* c = 0);
+        //@}
+
+      public:
+        /**
+         * @brief Assign a character to the instance.
+         *
+         * The resulting %id has only one character.
+         *
+         * @param c A character to assign.
+         * @return A reference to the instance.
+         */
+        id&
+        operator= (C c);
+
+
+        /**
+         * @brief Assign a C %string to the instance.
+         *
+         * The resulting %id contains a copy of the C %string.
+         *
+         * @param s A C %string to assign.
+         * @return A reference to the instance.
+         */
+        id&
+        operator= (const C* s);
+
+        /**
+         * @brief Assign a standard %string to the instance.
+         *
+         * The resulting %id contains a copy of the standard %string.
+         *
+         * @param s A standard %string to assign.
+         * @return A reference to the instance.
+         */
+        id&
+        operator= (const std::basic_string<C>& s);
+
+        /**
+         * @brief Copy assignment operator.
+         *
+         * @param x An instance to assign.
+         * @return A reference to the instance.
+         */
+        id&
+        operator= (const id& x);
+
+      public:
+        //@cond
+
+        virtual void
+        _container (container*);
+
+        // The above override also hides other _container versions. We
+        // also cannot do using-declarations because of bugs in HP aCC3.
+        //
+        const container*
+        _container () const
+        {
+          return B::_container ();
+        }
+
+        container*
+        _container ()
+        {
+          return B::_container ();
+        }
+
+        //@endcond
+
+      protected:
+        //@cond
+
+        id ()
+            : base_type (), identity_ (*this)
+        {
+          register_id ();
+        }
+
+        //@endcond
+
+      private:
+        void
+        register_id ();
+
+        void
+        unregister_id ();
+
+      private:
+        identity_impl<C, B> identity_;
+      };
+
+
+      /**
+       * @brief Class corresponding to the XML Schema IDREF built-in
+       * type.
+       *
+       * The %idref class publicly inherits from and has the same set
+       * of constructors as @c std::basic_string. It therefore can be
+       * used as @c std::string (or @c std::wstring if you are using
+       * @c wchar_t as the character type).
+       *
+       * The %idref class also provides an autopointer-like interface
+       * for resolving referenced objects. By default the object is
+       * returned as type (mapping for anyType) but statically-typed
+       * %idref can be created using the XML Schema extension. See the
+       * C++/Tree Mapping User Manual for more information.
+       *
+       * @nosubgrouping
+       */
+      template <typename C, typename B, typename T>
+      class idref: public B
+      {
+        typedef B base_type;
+
+        base_type&
+        base ()
+        {
+          return *this;
+        }
+
+      public:
+        /**
+         * @brief Referenced type.
+         */
+        typedef T ref_type;
+
+      public:
+        /**
+         * @name Constructors
+         */
+        //@{
+
+        /**
+         * @brief Initialize an instance with a copy of a C %string.
+         *
+         * @param s A C %string to copy.
+         */
+        idref (const C* s)
+            : base_type (s), identity_ (*this)
+        {
+        }
+
+        /**
+         * @brief Initialize an instance with a character array.
+         *
+         * @param s A character array to copy.
+         * @param n A number of character to copy.
+         */
+        idref (const C* s, std::size_t n)
+            : base_type (s, n), identity_ (*this)
+        {
+        }
+
+        /**
+         * @brief Initialize an instance with multiple copies of the same
+         * character.
+         *
+         * @param n A number of copies to create.
+         * @param c A character to copy.
+         */
+        idref (std::size_t n, C c)
+            : base_type (n, c), identity_ (*this)
+        {
+        }
+
+        /**
+         * @brief Initialize an instance with a copy of a standard %string.
+         *
+         * @param s A standard %string to copy.
+         */
+        idref (const std::basic_string<C>& s)
+            : base_type (s), identity_ (*this)
+        {
+        }
+
+        /**
+         * @brief Initialize an instance with a copy of a substring.
+         *
+         * @param s   A standard %string to copy the substring from.
+         * @param pos An index of the first character to copy from.
+         * @param n   A number of characters to copy.
+         */
+        idref (const std::basic_string<C>& s,
+               std::size_t pos,
+               std::size_t n = std::basic_string<C>::npos)
+            : base_type (s, pos, n), identity_ (*this)
+        {
+        }
+
+      public:
+        /**
+         * @brief Copy constructor.
+         *
+         * @param x An instance to make a copy of.
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         *
+         * For polymorphic object models use the @c _clone function instead.
+         */
+        idref (const idref& x, flags f = 0, container* c = 0)
+            : base_type (x, f, c), identity_ (*this)
+        {
+        }
+
+        /**
+         * @brief Copy the instance polymorphically.
+         *
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         * @return A pointer to the dynamically allocated copy.
+         *
+         * This function ensures that the dynamic type of the instance
+         * is used for copying and should be used for polymorphic object
+         * models instead of the copy constructor.
+         */
+        virtual idref*
+        _clone (flags f = 0, container* c = 0) const;
+
+      public:
+        /**
+         * @brief Create an instance from a data representation
+         * stream.
+         *
+         * @param s A stream to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        template <typename S>
+        idref (istream<S>& s, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM element.
+         *
+         * @param e A DOM element to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        idref (const xercesc::DOMElement& e, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM Attribute.
+         *
+         * @param a A DOM attribute to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        idref (const xercesc::DOMAttr& a, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a %string fragment.
+         *
+         * @param s A %string fragment to extract the data from.
+         * @param e A pointer to DOM element containing the %string fragment.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        idref (const std::basic_string<C>& s,
+               const xercesc::DOMElement* e,
+               flags f = 0,
+               container* c = 0);
+        //@}
+
+      public:
+        /**
+         * @brief Assign a character to the instance.
+         *
+         * The resulting %idref has only one character.
+         *
+         * @param c A character to assign.
+         * @return A reference to the instance.
+         */
+        idref&
+        operator= (C c)
+        {
+          base () = c;
+          return *this;
+        }
+
+        /**
+         * @brief Assign a C %string to the instance.
+         *
+         * The resulting %idref contains a copy of the C %string.
+         *
+         * @param s A C %string to assign.
+         * @return A reference to the instance.
+         */
+        idref&
+        operator= (const C* s)
+        {
+          base () = s;
+          return *this;
+        }
+
+        /**
+         * @brief Assign a standard %string to the instance.
+         *
+         * The resulting %idref contains a copy of the standard %string.
+         *
+         * @param s A standard %string to assign.
+         * @return A reference to the instance.
+         */
+        idref&
+        operator= (const std::basic_string<C>& s)
+        {
+          base () = s;
+          return *this;
+        }
+
+        /**
+         * @brief Copy assignment operator.
+         *
+         * @param x An instance to assign.
+         * @return A reference to the instance.
+         */
+        idref&
+        operator= (const idref& x)
+        {
+          base () = x;
+          return *this;
+        }
+
+      public:
+        /**
+         * @brief Call referenced object.
+         *
+         * @return A constant pointer to the referenced object.
+         */
+        const ref_type*
+        operator-> () const
+        {
+          return get ();
+        }
+
+        /**
+         * @brief Call referenced object.
+         *
+         * @return A pointer to the referenced object.
+         */
+        ref_type*
+        operator-> ()
+        {
+          return get ();
+        }
+
+        /**
+         * @brief Dereference referenced object.
+         *
+         * @return A constant C++ reference to the referenced object.
+         */
+        const ref_type&
+        operator* () const
+        {
+          return *(get ());
+        }
+
+        /**
+         * @brief Dereference referenced object.
+         *
+         * @return A C++ reference to the referenced object.
+         */
+        ref_type&
+        operator* ()
+        {
+          return *(get ());
+        }
+
+        /**
+         * @brief Get a constant pointer to the referenced object.
+         *
+         * @return A constant pointer to the referenced object or 0 if
+         * the object is not found.
+         */
+        const ref_type*
+        get () const
+        {
+          return dynamic_cast<const ref_type*> (get_ ());
+        }
+
+        /**
+         * @brief Get a pointer to the referenced object.
+         *
+         * @return A pointer to the referenced object or 0 if the object
+         * is not found.
+         */
+        ref_type*
+        get ()
+        {
+          return dynamic_cast<ref_type*> (get_ ());
+        }
+
+        /**
+         * @brief Opaque type that can be evaluated as true or false.
+         */
+        typedef void (idref::*bool_convertible)();
+
+        /**
+         * @brief Implicit conversion to boolean type.
+         *
+         * @return True if the referenced object is found, false otherwise.
+         */
+        operator bool_convertible () const
+        {
+          return get_ () ? &idref::true_ : 0;
+        }
+
+      protected:
+        //@cond
+
+        idref ()
+            : base_type (), identity_ (*this)
+        {
+        }
+
+        //@endcond
+
+      private:
+        const _type*
+        get_ () const;
+
+        _type*
+        get_ ();
+
+        void
+        true_ ();
+
+      private:
+        identity_impl<C, B> identity_;
+      };
+
+
+      /**
+       * @brief Class corresponding to the XML Schema IDREFS built-in
+       * type.
+       *
+       * The %idrefs class is a vector (or %list in XML Schema terminology)
+       * of idref elements. It is implemented in terms of the list class
+       * template.
+       *
+       * @nosubgrouping
+       */
+      template <typename C, typename B, typename idref>
+      class idrefs: public B, public list<idref, C>
+      {
+        typedef list<idref, C> base_type;
+
+      public:
+        /**
+         * @name Constructors
+         */
+        //@{
+
+        /**
+         * @brief Default constructor creates no elements.
+         */
+        idrefs ()
+            : base_type (0, this)
+        {
+        }
+
+        /**
+         * @brief Initialize the instance with copies of an exemplar elements.
+         *
+         * @param n A number of elements to copy.
+         * @param x An exemplar element to copy.
+         */
+        idrefs (typename base_type::size_type n, const idref& x)
+            : base_type (n, x, this)
+        {
+        }
+
+        /**
+         * @brief Initialize the instance with copies of elements from an
+         * iterator range.
+         *
+         * @param begin An iterator pointing to the first element.
+         * @param end An iterator pointing to the one past the last element.
+         */
+        template <typename I>
+        idrefs (const I& begin, const I& end)
+            : base_type (begin, end, this)
+        {
+        }
+
+      public:
+        /**
+         * @brief Copy constructor.
+         *
+         * @param x An instance to make a copy of.
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         *
+         * For polymorphic object models use the @c _clone function instead.
+         */
+        idrefs (const idrefs& x, flags f = 0, container* c = 0)
+            : B (x, f, c), base_type (x, f, this)
+        {
+        }
+
+        /**
+         * @brief Copy the instance polymorphically.
+         *
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         * @return A pointer to the dynamically allocated copy.
+         *
+         * This function ensures that the dynamic type of the instance
+         * is used for copying and should be used for polymorphic object
+         * models instead of the copy constructor.
+         */
+        virtual idrefs*
+        _clone (flags f = 0, container* c = 0) const;
+
+      public:
+        /**
+         * @brief Create an instance from a data representation
+         * stream.
+         *
+         * @param s A stream to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        template <typename S>
+        idrefs (istream<S>& s, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM element.
+         *
+         * @param e A DOM element to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        idrefs (const xercesc::DOMElement& e, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM Attribute.
+         *
+         * @param a A DOM attribute to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        idrefs (const xercesc::DOMAttr& a, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a %string fragment.
+         *
+         * @param s A %string fragment to extract the data from.
+         * @param e A pointer to DOM element containing the %string fragment.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        idrefs (const std::basic_string<C>& s,
+                const xercesc::DOMElement* e,
+                flags f = 0,
+                container* c = 0);
+        //@}
+      };
+
+
+      /**
+       * @brief Class corresponding to the XML Schema anyURI built-in
+       * type.
+       *
+       * The %uri class publicly inherits from and has the same set
+       * of constructors as @c std::basic_string. It therefore can be
+       * used as @c std::string (or @c std::wstring if you are using
+       * @c wchar_t as the character type).
+       *
+       * @nosubgrouping
+       */
+      template <typename C, typename B>
+      class uri: public B, public std::basic_string<C>
+      {
+        typedef std::basic_string<C> base_type;
+
+        base_type&
+        base ()
+        {
+          return *this;
+        }
+
+      public:
+        /**
+         * @name Constructors
+         */
+        //@{
+
+        /**
+         * @brief Initialize an instance with a copy of a C %string.
+         *
+         * @param s A C %string to copy.
+         */
+        uri (const C* s)
+            : base_type (s)
+        {
+        }
+
+        /**
+         * @brief Initialize an instance with a character array.
+         *
+         * @param s A character array to copy.
+         * @param n A number of character to copy.
+         */
+        uri (const C* s, std::size_t n)
+            : base_type (s, n)
+        {
+        }
+
+        /**
+         * @brief Initialize an instance with multiple copies of the same
+         * character.
+         *
+         * @param n A number of copies to create.
+         * @param c A character to copy.
+         */
+        uri (std::size_t n, C c)
+            : base_type (n, c)
+        {
+        }
+
+        /**
+         * @brief Initialize an instance with a copy of a standard %string.
+         *
+         * @param s A standard %string to copy.
+         */
+        uri (const std::basic_string<C>& s)
+            : base_type (s)
+        {
+        }
+
+        /**
+         * @brief Initialize an instance with a copy of a substring.
+         *
+         * @param s   A standard %string to copy the substring from.
+         * @param pos An index of the first character to copy from.
+         * @param n   A number of characters to copy.
+         */
+        uri (const std::basic_string<C>& s,
+             std::size_t pos,
+             std::size_t n = std::basic_string<C>::npos)
+            : base_type (s, pos, n)
+        {
+        }
+
+      public:
+        /**
+         * @brief Copy constructor.
+         *
+         * @param x An instance to make a copy of.
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         *
+         * For polymorphic object models use the @c _clone function instead.
+         */
+        uri (const uri& x, flags f = 0, container* c = 0)
+            : B (x, f, c), base_type (x)
+        {
+        }
+
+        /**
+         * @brief Copy the instance polymorphically.
+         *
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         * @return A pointer to the dynamically allocated copy.
+         *
+         * This function ensures that the dynamic type of the instance
+         * is used for copying and should be used for polymorphic object
+         * models instead of the copy constructor.
+         */
+        virtual uri*
+        _clone (flags f = 0, container* c = 0) const;
+
+      public:
+        /**
+         * @brief Create an instance from a data representation
+         * stream.
+         *
+         * @param s A stream to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        template <typename S>
+        uri (istream<S>& s, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM element.
+         *
+         * @param e A DOM element to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        uri (const xercesc::DOMElement& e, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM Attribute.
+         *
+         * @param a A DOM attribute to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        uri (const xercesc::DOMAttr& a, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a %string fragment.
+         *
+         * @param s A %string fragment to extract the data from.
+         * @param e A pointer to DOM element containing the %string fragment.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        uri (const std::basic_string<C>& s,
+             const xercesc::DOMElement* e,
+             flags f = 0,
+             container* c = 0);
+        //@}
+
+      public:
+        /**
+         * @brief Assign a character to the instance.
+         *
+         * The resulting %uri has only one character.
+         *
+         * @param c A character to assign.
+         * @return A reference to the instance.
+         */
+        uri&
+        operator= (C c)
+        {
+          base () = c;
+          return *this;
+        }
+
+        /**
+         * @brief Assign a C %string to the instance.
+         *
+         * The resulting %uri contains a copy of the C %string.
+         *
+         * @param s A C %string to assign.
+         * @return A reference to the instance.
+         */
+        uri&
+        operator= (const C* s)
+        {
+          base () = s;
+          return *this;
+        }
+
+        /**
+         * @brief Assign a standard %string to the instance.
+         *
+         * The resulting %uri contains a copy of the standard %string.
+         *
+         * @param s A standard %string to assign.
+         * @return A reference to the instance.
+         */
+        uri&
+        operator= (const std::basic_string<C>& s)
+        {
+          base () = s;
+          return *this;
+        }
+
+        /**
+         * @brief Copy assignment operator.
+         *
+         * @param x An instance to assign.
+         * @return A reference to the instance.
+         */
+        uri&
+        operator= (const uri& x)
+        {
+          base () = x;
+          return *this;
+        }
+
+      protected:
+        //@cond
+
+        uri ()
+            : base_type ()
+        {
+        }
+
+        //@endcond
+
+        template <typename, typename, typename, typename>
+        friend class qname;
+      };
+
+
+      /**
+       * @brief Class corresponding to the XML Schema QName built-in
+       * type.
+       *
+       * The %qname class represents a potentially namespace-qualified
+       * XML %name.
+       *
+       * @nosubgrouping
+       */
+      template <typename C, typename B, typename uri, typename ncname>
+      class qname: public B
+      {
+      public:
+        /**
+         * @name Constructors
+         */
+        //@{
+
+        /**
+         * @brief Initialize an instance with a %name only.
+         *
+         * The resulting %qname is unqualified.
+         *
+         * @param n An XML %name (ncname).
+         */
+        qname (const ncname& n)
+            : ns_ (), name_ (n)
+        {
+        }
+
+        /**
+         * @brief Initialize an instance with a %name and a namespace.
+         *
+         * The resulting %qname is qualified.
+         *
+         * @param ns An XML namespace (uri).
+         * @param n  An XML %name (ncname).
+         */
+        qname (const uri& ns, const ncname& n)
+            : ns_ (ns), name_ (n)
+        {
+        }
+
+      public:
+        /**
+         * @brief Copy constructor.
+         *
+         * @param x An instance to make a copy of.
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         *
+         * For polymorphic object models use the @c _clone function instead.
+         */
+        qname (const qname& x, flags f = 0, container* c = 0)
+            : B (x, f, c),
+              ns_ (x.ns_),
+              name_ (x.name_)
+        {
+          // Note that ns_ and name_ have no DOM association.
+          //
+        }
+
+        /**
+         * @brief Copy the instance polymorphically.
+         *
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         * @return A pointer to the dynamically allocated copy.
+         *
+         * This function ensures that the dynamic type of the instance
+         * is used for copying and should be used for polymorphic object
+         * models instead of the copy constructor.
+         */
+        virtual qname*
+        _clone (flags f = 0, container* c = 0) const;
+
+      public:
+        /**
+         * @brief Create an instance from a data representation
+         * stream.
+         *
+         * @param s A stream to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        template <typename S>
+        qname (istream<S>& s, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM element.
+         *
+         * @param e A DOM element to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        qname (const xercesc::DOMElement& e, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM Attribute.
+         *
+         * @param a A DOM attribute to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        qname (const xercesc::DOMAttr& a, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a %string fragment.
+         *
+         * @param s A %string fragment to extract the data from.
+         * @param e A pointer to DOM element containing the %string fragment.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        qname (const std::basic_string<C>& s,
+               const xercesc::DOMElement* e,
+               flags f = 0,
+               container* c = 0);
+        //@}
+
+      public:
+        /**
+         * @brief Determine if the %name is qualified.
+         *
+         * @return True if the %name is qualified, false otherwise.
+         */
+        bool
+        qualified () const
+        {
+          return !ns_.empty ();
+        }
+
+        /**
+         * @brief Get XML namespace.
+         *
+         * @return A constant reference to qualifying XML namespace.
+         */
+        const uri&
+        namespace_ () const
+        {
+          return ns_;
+        }
+
+        /**
+         * @brief Get XML %name.
+         *
+         * @return A constant reference to unqualified XML %name.
+         */
+        const ncname&
+        name () const
+        {
+          return name_;
+        }
+
+      protected:
+        //@cond
+
+        qname ()
+            : ns_ (), name_ ()
+        {
+        }
+
+        //@endcond
+
+      private:
+        static uri
+        resolve (const std::basic_string<C>&, const xercesc::DOMElement*);
+
+      private:
+        uri ns_;
+        ncname name_;
+      };
+
+      /**
+       * @brief %qname comparison operator.
+       *
+       * @return True if the names are equal, false otherwise.
+       */
+      template <typename C, typename B, typename uri, typename ncname>
+      inline bool
+      operator== (const qname<C, B, uri, ncname>& a,
+                  const qname<C, B, uri, ncname>& b)
+      {
+        return a.name () == b.name () && a.namespace_ () == b.namespace_ ();
+      }
+
+      /**
+       * @brief %qname comparison operator.
+       *
+       * @return True if the names are not equal, false otherwise.
+       */
+      template <typename C, typename B, typename uri, typename ncname>
+      inline bool
+      operator!= (const qname<C, B, uri, ncname>& a,
+                  const qname<C, B, uri, ncname>& b)
+      {
+        return !(a == b);
+      }
+
+
+      /**
+       * @brief Class corresponding to the XML Schema base64Binary
+       * built-in type.
+       *
+       * The %base64_binary class is a binary %buffer abstraction with
+       * base64-encoded representation in XML. It publicly inherits from
+       * the buffer class which provides the %buffer functionality.
+       *
+       * @nosubgrouping
+       */
+      template <typename C, typename B>
+      class base64_binary: public B, public buffer<C>
+      {
+      public:
+        typedef typename buffer<C>::size_t size_t;
+
+      public:
+        /**
+         * @name Constructors
+         */
+        //@{
+
+        /**
+         * @brief Allocate a %buffer of the specified size.
+         *
+         * The resulting %buffer has the same size and capacity.
+         *
+         * @param size A %buffer size in bytes.
+         */
+        explicit
+        base64_binary (size_t size = 0);
+
+        /**
+         * @brief Allocate a %buffer of the specified size and capacity.
+         *
+         * @param size A %buffer size in bytes.
+         * @param capacity A %buffer capacity in bytes.
+         * @throw bounds If @a size exceeds @a capacity
+         */
+        base64_binary (size_t size, size_t capacity);
+
+        /**
+         * @brief Allocate a %buffer of the specified size and copy
+         * the data.
+         *
+         * The resulting %buffer has the same size and capacity with
+         * @a size bytes copied from @a data.
+         *
+         * @param data A %buffer to copy the data from.
+         * @param size A %buffer size in bytes.
+         */
+        base64_binary (const void* data, size_t size);
+
+        /**
+         * @brief Allocate a %buffer of the specified size and capacity
+         * and copy the data.
+         *
+         * @a size bytes are copied from @a data to the resulting
+         * %buffer.
+         *
+         * @param data A %buffer to copy the data from.
+         * @param size A %buffer size in bytes.
+         * @param capacity A %buffer capacity in bytes.
+         * @throw bounds If @a size exceeds @a capacity
+         */
+        base64_binary (const void* data, size_t size, size_t capacity);
+
+        /**
+         * @brief Reuse an existing %buffer.
+         *
+         * If the @a assume_ownership argument is true, the %buffer will
+         * assume ownership of @a data and will release the memory
+         * by calling @c operator @c delete().
+         *
+         * @param data A %buffer to reuse.
+         * @param size A %buffer size in bytes.
+         * @param capacity A %buffer capacity in bytes.
+         * @param assume_ownership A boolean value indication whether to
+         * assume ownership.
+         * @throw bounds If @a size exceeds @a capacity
+         */
+        base64_binary (void* data,
+                       size_t size,
+                       size_t capacity,
+                       bool assume_ownership);
+      public:
+        /**
+         * @brief Copy constructor.
+         *
+         * @param x An instance to make a copy of.
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         *
+         * For polymorphic object models use the @c _clone function instead.
+         */
+        base64_binary (const base64_binary& x,
+                       flags f = 0,
+                       container* c = 0)
+            : B (x, f, c), buffer<C> (x)
+        {
+        }
+
+        /**
+         * @brief Copy the instance polymorphically.
+         *
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         * @return A pointer to the dynamically allocated copy.
+         *
+         * This function ensures that the dynamic type of the instance
+         * is used for copying and should be used for polymorphic object
+         * models instead of the copy constructor.
+         */
+        virtual base64_binary*
+        _clone (flags f = 0, container* c = 0) const;
+
+      public:
+        /**
+         * @brief Create an instance from a data representation
+         * stream.
+         *
+         * @param s A stream to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        template <typename S>
+        base64_binary (istream<S>& s, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM element.
+         *
+         * @param e A DOM element to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        base64_binary (const xercesc::DOMElement& e,
+                       flags f = 0,
+                       container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM Attribute.
+         *
+         * @param a A DOM attribute to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        base64_binary (const xercesc::DOMAttr& a, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a %string fragment.
+         *
+         * @param s A %string fragment to extract the data from.
+         * @param e A pointer to DOM element containing the %string fragment.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        base64_binary (const std::basic_string<C>& s,
+                       const xercesc::DOMElement* e,
+                       flags f = 0,
+                       container* c = 0);
+        //@}
+
+      public:
+        /**
+         * @brief Copy assignment operator.
+         *
+         * @param x An instance to assign.
+         * @return A reference to the instance.
+         */
+        base64_binary&
+        operator= (const base64_binary& x)
+        {
+          buffer<C>& b (*this);
+          b = x;
+          return *this;
+        }
+
+      public:
+        /**
+         * @brief Encode the %buffer in base64 encoding.
+         *
+         * @return A %string with base64-encoded data.
+         */
+        std::basic_string<C>
+        encode () const;
+
+      private:
+        void
+        decode (const XMLCh*);
+      };
+
+
+      /**
+       * @brief Class corresponding to the XML Schema hexBinary
+       * built-in type.
+       *
+       * The %hex_binary class is a binary %buffer abstraction with
+       * hex-encoded representation in XML. It publicly inherits from
+       * the buffer class which provides the %buffer functionality.
+       *
+       * @nosubgrouping
+       */
+      template <typename C, typename B>
+      class hex_binary: public B, public buffer<C>
+      {
+      public:
+        typedef typename buffer<C>::size_t size_t;
+
+      public:
+        /**
+         * @name Constructors
+         */
+        //@{
+
+        /**
+         * @brief Allocate a %buffer of the specified size.
+         *
+         * The resulting %buffer has the same size and capacity.
+         *
+         * @param size A %buffer size in bytes.
+         */
+        explicit
+        hex_binary (size_t size = 0);
+
+        /**
+         * @brief Allocate a %buffer of the specified size and capacity.
+         *
+         * @param size A %buffer size in bytes.
+         * @param capacity A %buffer capacity in bytes.
+         * @throw bounds If @a size exceeds @a capacity
+         */
+        hex_binary (size_t size, size_t capacity);
+
+        /**
+         * @brief Allocate a %buffer of the specified size and copy
+         * the data.
+         *
+         * The resulting %buffer has the same size and capacity with
+         * @a size bytes copied from @a data.
+         *
+         * @param data A %buffer to copy the data from.
+         * @param size A %buffer size in bytes.
+         */
+        hex_binary (const void* data, size_t size);
+
+        /**
+         * @brief Allocate a %buffer of the specified size and capacity
+         * and copy the data.
+         *
+         * @a size bytes are copied from @a data to the resulting
+         * %buffer.
+         *
+         * @param data A %buffer to copy the data from.
+         * @param size A %buffer size in bytes.
+         * @param capacity A %buffer capacity in bytes.
+         * @throw bounds If @a size exceeds @a capacity
+         */
+        hex_binary (const void* data, size_t size, size_t capacity);
+
+        /**
+         * @brief Reuse an existing %buffer..
+         *
+         * If the @a assume_ownership argument is true, the %buffer will
+         * assume ownership of @a data and will release the memory
+         * by calling @c operator @c delete().
+         *
+         * @param data A %buffer to reuse.
+         * @param size A %buffer size in bytes.
+         * @param capacity A %buffer capacity in bytes.
+         * @param assume_ownership A boolean value indication whether to
+         * assume ownership.
+         * @throw bounds If @a size exceeds @a capacity
+         */
+        hex_binary (void* data,
+                    size_t size,
+                    size_t capacity,
+                    bool assume_ownership);
+
+      public:
+        /**
+         * @brief Copy constructor.
+         *
+         * @param x An instance to make a copy of.
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         *
+         * For polymorphic object models use the @c _clone function instead.
+         */
+        hex_binary (const hex_binary& x, flags f = 0, container* c = 0)
+            : B (x, f, c), buffer<C> (x)
+        {
+        }
+
+        /**
+         * @brief Copy the instance polymorphically.
+         *
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         * @return A pointer to the dynamically allocated copy.
+         *
+         * This function ensures that the dynamic type of the instance
+         * is used for copying and should be used for polymorphic object
+         * models instead of the copy constructor.
+         */
+        virtual hex_binary*
+        _clone (flags f = 0, container* c = 0) const;
+
+      public:
+        /**
+         * @brief Create an instance from a data representation
+         * stream.
+         *
+         * @param s A stream to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        template <typename S>
+        hex_binary (istream<S>& s, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM element.
+         *
+         * @param e A DOM element to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        hex_binary (const xercesc::DOMElement& e, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM Attribute.
+         *
+         * @param a A DOM attribute to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        hex_binary (const xercesc::DOMAttr& a, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a %string fragment.
+         *
+         * @param s A %string fragment to extract the data from.
+         * @param e A pointer to DOM element containing the %string fragment.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        hex_binary (const std::basic_string<C>& s,
+                    const xercesc::DOMElement* e,
+                    flags f = 0,
+                    container* c = 0);
+        //@}
+
+      public:
+        /**
+         * @brief Copy assignment operator.
+         *
+         * @param x An instance to assign.
+         * @return A reference to the instance.
+         */
+        hex_binary&
+        operator= (const hex_binary& x)
+        {
+          buffer<C>& b (*this);
+          b = x;
+          return *this;
+        }
+
+      public:
+        /**
+         * @brief Encode the %buffer in hex encoding.
+         *
+         * @return A %string with hex-encoded data.
+         */
+        std::basic_string<C>
+        encode () const;
+
+      private:
+        void
+        decode (const XMLCh*);
+      };
+
+
+      /**
+       * @brief Class corresponding to the XML Schema ENTITY built-in
+       * type.
+       *
+       * The %entity class publicly inherits from and has the same set
+       * of constructors as @c std::basic_string. It therefore can be
+       * used as @c std::string (or @c std::wstring if you are using
+       * @c wchar_t as the character type).
+       *
+       * @nosubgrouping
+       */
+      template <typename C, typename B>
+      class entity: public B
+      {
+        typedef B base_type;
+
+        base_type&
+        base ()
+        {
+          return *this;
+        }
+
+      public:
+        /**
+         * @name Constructors
+         */
+        //@{
+
+        /**
+         * @brief Initialize an instance with a copy of a C %string.
+         *
+         * @param s A C %string to copy.
+         */
+        entity (const C* s)
+            : base_type (s)
+        {
+        }
+
+        /**
+         * @brief Initialize an instance with a character array.
+         *
+         * @param s A character array to copy.
+         * @param n A number of character to copy.
+         */
+        entity (const C* s, std::size_t n)
+            : base_type (s, n)
+        {
+        }
+
+        /**
+         * @brief Initialize an instance with multiple copies of the same
+         * character.
+         *
+         * @param n A number of copies to create.
+         * @param c A character to copy.
+         */
+        entity (std::size_t n, C c)
+            : base_type (n, c)
+        {
+        }
+
+        /**
+         * @brief Initialize an instance with a copy of a standard %string.
+         *
+         * @param s A standard %string to copy.
+         */
+        entity (const std::basic_string<C>& s)
+            : base_type (s)
+        {
+        }
+
+        /**
+         * @brief Initialize an instance with a copy of a substring.
+         *
+         * @param s   A standard %string to copy the substring from.
+         * @param pos An index of the first character to copy from.
+         * @param n   A number of characters to copy.
+         */
+        entity (const std::basic_string<C>& s,
+                std::size_t pos,
+                std::size_t n = std::basic_string<C>::npos)
+            : base_type (s, pos, n)
+        {
+        }
+
+      public:
+        /**
+         * @brief Copy constructor.
+         *
+         * @param x An instance to make a copy of.
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         *
+         * For polymorphic object models use the @c _clone function instead.
+         */
+        entity (const entity& x, flags f = 0, container* c = 0)
+            : base_type (x, f, c)
+        {
+        }
+
+        /**
+         * @brief Copy the instance polymorphically.
+         *
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         * @return A pointer to the dynamically allocated copy.
+         *
+         * This function ensures that the dynamic type of the instance
+         * is used for copying and should be used for polymorphic object
+         * models instead of the copy constructor.
+         */
+        virtual entity*
+        _clone (flags f = 0, container* c = 0) const;
+
+      public:
+        /**
+         * @brief Create an instance from a data representation
+         * stream.
+         *
+         * @param s A stream to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        template <typename S>
+        entity (istream<S>& s, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM element.
+         *
+         * @param e A DOM element to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        entity (const xercesc::DOMElement& e, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM Attribute.
+         *
+         * @param a A DOM attribute to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        entity (const xercesc::DOMAttr& a, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a %string fragment.
+         *
+         * @param s A %string fragment to extract the data from.
+         * @param e A pointer to DOM element containing the %string fragment.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        entity (const std::basic_string<C>& s,
+                const xercesc::DOMElement* e,
+                flags f = 0,
+                container* c = 0);
+        //@}
+
+      public:
+        /**
+         * @brief Assign a character to the instance.
+         *
+         * The resulting %entity has only one character.
+         *
+         * @param c A character to assign.
+         * @return A reference to the instance.
+         */
+        entity&
+        operator= (C c)
+        {
+          base () = c;
+          return *this;
+        }
+
+        /**
+         * @brief Assign a C %string to the instance.
+         *
+         * The resulting %entity contains a copy of the C %string.
+         *
+         * @param s A C %string to assign.
+         * @return A reference to the instance.
+         */
+        entity&
+        operator= (const C* s)
+        {
+          base () = s;
+          return *this;
+        }
+
+        /**
+         * @brief Assign a standard %string to the instance.
+         *
+         * The resulting %entity contains a copy of the standard %string.
+         *
+         * @param s A standard %string to assign.
+         * @return A reference to the instance.
+         */
+        entity&
+        operator= (const std::basic_string<C>& s)
+        {
+          base () = s;
+          return *this;
+        }
+
+        /**
+         * @brief Copy assignment operator.
+         *
+         * @param x An instance to assign.
+         * @return A reference to the instance.
+         */
+        entity&
+        operator= (const entity& x)
+        {
+          base () = x;
+          return *this;
+        }
+
+      protected:
+        //@cond
+
+        entity ()
+            : base_type ()
+        {
+        }
+
+        //@endcond
+      };
+
+
+      /**
+       * @brief Class corresponding to the XML Schema ENTITIES built-in
+       * type.
+       *
+       * The %entities class is a vector (or %list in XML Schema terminology)
+       * of entity elements. It is implemented in terms of the list class
+       * template.
+       *
+       * @nosubgrouping
+       */
+      template <typename C, typename B, typename entity>
+      class entities: public B, public list<entity, C>
+      {
+        typedef list<entity, C> base_type;
+
+      public:
+        /**
+         * @name Constructors
+         */
+        //@{
+
+        /**
+         * @brief Default constructor creates no elements.
+         */
+        entities ()
+            : base_type (0, this)
+        {
+        }
+
+        /**
+         * @brief Initialize the instance with copies of an exemplar elements.
+         *
+         * @param n A number of elements to copy.
+         * @param x An exemplar element to copy.
+         */
+        entities (typename base_type::size_type n, const entity& x)
+            : base_type (n, x, this)
+        {
+        }
+
+        /**
+         * @brief Initialize the instance with copies of elements from an
+         * iterator range.
+         *
+         * @param begin An iterator pointing to the first element.
+         * @param end An iterator pointing to the one past the last element.
+         */
+        template <typename I>
+        entities (const I& begin, const I& end)
+            : base_type (begin, end, this)
+        {
+        }
+
+      public:
+        /**
+         * @brief Copy constructor.
+         *
+         * @param x An instance to make a copy of.
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         *
+         * For polymorphic object models use the @c _clone function instead.
+         */
+        entities (const entities& x, flags f = 0, container* c = 0)
+            : B (x, f, c), base_type (x, f, this)
+        {
+        }
+
+        /**
+         * @brief Copy the instance polymorphically.
+         *
+         * @param f Flags to create the copy with.
+         * @param c A pointer to the object that will contain the copy.
+         * @return A pointer to the dynamically allocated copy.
+         *
+         * This function ensures that the dynamic type of the instance
+         * is used for copying and should be used for polymorphic object
+         * models instead of the copy constructor.
+         */
+        virtual entities*
+        _clone (flags f = 0, container* c = 0) const;
+
+      public:
+        /**
+         * @brief Create an instance from a data representation
+         * stream.
+         *
+         * @param s A stream to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        template <typename S>
+        entities (istream<S>& s, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM element.
+         *
+         * @param e A DOM element to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        entities (const xercesc::DOMElement& e, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a DOM Attribute.
+         *
+         * @param a A DOM attribute to extract the data from.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        entities (const xercesc::DOMAttr& a, flags f = 0, container* c = 0);
+
+        /**
+         * @brief Create an instance from a %string fragment.
+         *
+         * @param s A %string fragment to extract the data from.
+         * @param e A pointer to DOM element containing the %string fragment.
+         * @param f Flags to create the new instance with.
+         * @param c A pointer to the object that will contain the new
+         * instance.
+         */
+        entities (const std::basic_string<C>& s,
+                  const xercesc::DOMElement* e,
+                  flags f = 0,
+                  container* c = 0);
+        //@}
+      };
+    }
+  }
+}
+
+#include <xsd/cxx/tree/types.txx>
+
+#endif  // XSD_CXX_TREE_TYPES_HXX
diff --git src/base/include/xsd/cxx/tree/types.txx src/base/include/xsd/cxx/tree/types.txx
new file mode 100644
index 0000000..8d6d79f
--- /dev/null
+++ src/base/include/xsd/cxx/tree/types.txx
@@ -0,0 +1,598 @@
+// file      : xsd/cxx/tree/types.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#include <xercesc/util/Base64.hpp>
+#include <xercesc/util/XMLString.hpp>
+#include <xercesc/util/XercesVersion.hpp>
+
+#include <xsd/cxx/auto-array.hxx>
+
+#include <xsd/cxx/xml/std-memory-manager.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+
+      // string
+      //
+      template <typename C, typename B>
+      string<C, B>* string<C, B>::
+      _clone (flags f, container* c) const
+      {
+        return new string (*this, f, c);
+      }
+
+
+      // normalized_string
+      //
+      template <typename C, typename B>
+      normalized_string<C, B>* normalized_string<C, B>::
+      _clone (flags f, container* c) const
+      {
+        return new normalized_string (*this, f, c);
+      }
+
+
+      // token
+      //
+      template <typename C, typename B>
+      token<C, B>* token<C, B>::
+      _clone (flags f, container* c) const
+      {
+        return new token (*this, f, c);
+      }
+
+
+      // nmtoken
+      //
+      template <typename C, typename B>
+      nmtoken<C, B>* nmtoken<C, B>::
+      _clone (flags f, container* c) const
+      {
+        return new nmtoken (*this, f, c);
+      }
+
+
+      // nmtokens
+      //
+      template <typename C, typename B, typename nmtoken>
+      nmtokens<C, B, nmtoken>* nmtokens<C, B, nmtoken>::
+      _clone (flags f, container* c) const
+      {
+        return new nmtokens (*this, f, c);
+      }
+
+
+      // name
+      //
+      template <typename C, typename B>
+      name<C, B>* name<C, B>::
+      _clone (flags f, container* c) const
+      {
+        return new name (*this, f, c);
+      }
+
+
+      // ncname
+      //
+      template <typename C, typename B>
+      ncname<C, B>* ncname<C, B>::
+      _clone (flags f, container* c) const
+      {
+        return new ncname (*this, f, c);
+      }
+
+
+      // language
+      //
+      template <typename C, typename B>
+      language<C, B>* language<C, B>::
+      _clone (flags f, container* c) const
+      {
+        return new language (*this, f, c);
+      }
+
+
+      // identity_impl
+      //
+      template <typename C, typename ncname>
+      bool identity_impl<C, ncname>::
+      before (const identity& y) const
+      {
+        return id_ < static_cast<const identity_impl&> (y).id_;
+      }
+
+      template <typename C, typename ncname>
+      void identity_impl<C, ncname>::
+      throw_duplicate_id () const
+      {
+        throw duplicate_id<C> (id_);
+      }
+
+
+      // id
+      //
+      template <typename C, typename B>
+      id<C, B>* id<C, B>::
+      _clone (flags f, container* c) const
+      {
+        return new id (*this, f, c);
+      }
+
+      template <typename C, typename B>
+      id<C, B>& id<C, B>::
+      operator= (C c)
+      {
+        unregister_id ();
+        base () = c;
+        register_id ();
+
+        return *this;
+      }
+
+      template <typename C, typename B>
+      id<C, B>& id<C, B>::
+      operator= (const C* s)
+      {
+        unregister_id ();
+        base () = s;
+        register_id ();
+
+        return *this;
+      }
+
+      template <typename C, typename B>
+      id<C, B>& id<C, B>::
+      operator= (const std::basic_string<C>& s)
+      {
+        unregister_id ();
+        base () = s;
+        register_id ();
+
+        return *this;
+      }
+
+      template <typename C, typename B>
+      id<C, B>& id<C, B>::
+      operator= (const id& x)
+      {
+        unregister_id ();
+        base () = x;
+        register_id ();
+
+        return *this;
+      }
+
+      // It would have been cleaner to mention empty and _container
+      // with the using-declaration but HP aCC3 can't handle it in
+      // some non-trivial to track down cases. So we are going to use
+      // the old-n-ugly this-> techniques.
+      //
+      template <typename C, typename B>
+      void id<C, B>::
+      _container (container* c)
+      {
+        B::_container (c);
+        register_id ();
+      }
+
+      template <typename C, typename B>
+      void id<C, B>::
+      register_id ()
+      {
+        container* r (this->_root ());
+
+        if (r != 0 && !this->empty ())
+          r->_register_id (identity_, this->_container ());
+      }
+
+      template <typename C, typename B>
+      void id<C, B>::
+      unregister_id ()
+      {
+        container* r (this->_root ());
+
+        if (r != 0 && !this->empty ())
+          r->_unregister_id (identity_);
+      }
+
+
+      // idref
+      //
+      template <typename C, typename B, typename T>
+      idref<C, B, T>* idref<C, B, T>::
+      _clone (flags f, container* c) const
+      {
+        return new idref (*this, f, c);
+      }
+
+      // It would have been cleaner to mention empty, _root, etc. with
+      // the using-declaration but HP aCC3 can't handle it in some
+      // non-trivial to track down cases. So we are going to use the
+      // old-n-ugly this-> techniques.
+      //
+      template <typename C, typename B, typename T>
+      const _type* idref<C, B, T>::
+      get_ () const
+      {
+        if (!this->empty () && this->_container () != 0)
+        {
+          return this->_root ()->_lookup_id (identity_);
+        }
+        else
+          return 0;
+      }
+
+      template <typename C, typename B, typename T>
+      _type* idref<C, B, T>::
+      get_ ()
+      {
+        if (!this->empty () && this->_container () != 0)
+        {
+          return this->_root ()->_lookup_id (identity_);
+        }
+        else
+          return 0;
+      }
+
+      template <typename C, typename B, typename T>
+      void idref<C, B, T>::
+      true_ ()
+      {
+      }
+
+
+      // idrefs
+      //
+      template <typename C, typename B, typename idref>
+      idrefs<C, B, idref>* idrefs<C, B, idref>::
+      _clone (flags f, container* c) const
+      {
+        return new idrefs (*this, f, c);
+      }
+
+
+      // uri
+      //
+      template <typename C, typename B>
+      uri<C, B>* uri<C, B>::
+      _clone (flags f, container* c) const
+      {
+        return new uri (*this, f, c);
+      }
+
+
+      // qname
+      //
+      template <typename C, typename B, typename uri, typename ncname>
+      qname<C, B, uri, ncname>* qname<C, B, uri, ncname>::
+      _clone (flags f, container* c) const
+      {
+        return new qname (*this, f, c);
+      }
+
+
+      // base64_binary
+      //
+      template <typename C, typename B>
+      base64_binary<C, B>::
+      base64_binary (size_t size)
+          : buffer<C> (size)
+      {
+      }
+
+      template <typename C, typename B>
+      base64_binary<C, B>::
+      base64_binary (size_t size, size_t capacity)
+          : buffer<C> (size, capacity)
+      {
+      }
+
+      template <typename C, typename B>
+      base64_binary<C, B>::
+      base64_binary (const void* data, size_t size)
+          : buffer<C> (data, size)
+      {
+      }
+
+      template <typename C, typename B>
+      base64_binary<C, B>::
+      base64_binary (const void* data, size_t size, size_t capacity)
+          : buffer<C> (data, size, capacity)
+      {
+      }
+
+      template <typename C, typename B>
+      base64_binary<C, B>::
+      base64_binary (void* data, size_t size, size_t capacity, bool own)
+          : buffer<C> (data, size, capacity, own)
+      {
+      }
+
+      template <typename C, typename B>
+      base64_binary<C, B>* base64_binary<C, B>::
+      _clone (flags f, container* c) const
+      {
+        return new base64_binary (*this, f, c);
+      }
+
+      // It would have been cleaner to mention size, and data with the
+      // using-declaration but HP aCC3 can't handle it in some non-
+      // trivial to track down cases. So we are going to use the
+      // old-n- ugly this-> techniques.
+      //
+      template <typename C, typename B>
+      std::basic_string<C> base64_binary<C, B>::
+      encode () const
+      {
+        // HP aCC3 cannot handle using namespace xercesc;
+        //
+        using xercesc::Base64;
+        std::basic_string<C> str;
+
+#if _XERCES_VERSION >= 30000
+        XMLSize_t n;
+
+        xml::std_memory_manager mm;
+        auto_array<XMLByte, xml::std_memory_manager> r (
+          Base64::encode (
+            reinterpret_cast<const XMLByte*> (this->data ()),
+            static_cast<XMLSize_t> (this->size ()),
+            &n,
+            &mm),
+	  mm);
+
+        if (r)
+        {
+          str.reserve (n + 1);
+          str.resize (n);
+
+          for (XMLSize_t i (0); i < n; ++i)
+            str[i] = C (r[i]);
+        }
+        else
+        {
+          //@@ throw
+        }
+#else
+        unsigned int n;
+
+        xml::std_memory_manager mm;
+        auto_array<XMLByte, xml::std_memory_manager> r (
+          Base64::encode (
+            reinterpret_cast<const XMLByte*> (this->data ()),
+            static_cast<unsigned int> (this->size ()),
+            &n,
+            &mm),
+	  mm);
+
+        if (r)
+        {
+          str.reserve (n + 1);
+          str.resize (n);
+
+          for (unsigned int i (0); i < n; ++i)
+            str[i] = C (r[i]);
+        }
+        else
+        {
+          //@@ throw
+        }
+#endif
+
+        return str;
+      }
+
+      template <typename C, typename B>
+      void base64_binary<C, B>::
+      decode (const XMLCh* src)
+      {
+        // HP aCC3 cannot handle using namespace xercesc;
+        //
+        using xercesc::Base64;
+
+        xml::std_memory_manager mm;
+
+        // Xerces 2.6.0 and earlier do not have decodeToXMLByte which
+        // makes my life harder and your code slower.
+        //
+#if _XERCES_VERSION >= 20700
+
+#if _XERCES_VERSION >= 30000
+        XMLSize_t size;
+        auto_array<XMLByte, xml::std_memory_manager> data (
+          Base64::decodeToXMLByte (src, &size, &mm, Base64::Conf_RFC2045),
+	  mm);
+#else
+        unsigned int size;
+        auto_array<XMLByte, xml::std_memory_manager> data (
+          Base64::decodeToXMLByte (src, &size, &mm, Base64::Conf_RFC2045),
+	  mm);
+#endif // _XERCES_VERSION >= 30000
+
+        if (data)
+        {
+          buffer<C> tmp (data.get (), size, size, true);
+          data.release ();
+          this->swap (tmp); // g++ 4.1 likes it qualified, not sure why.
+        }
+        else
+        {
+          //@@ throw
+        }
+#else
+        unsigned int size;
+
+#if _XERCES_VERSION >= 20600  // Xerces 2.5.0 does not have Conf_RFC2045.
+        auto_array<XMLCh, xml::std_memory_manager> data (
+          Base64::decode (src, &size, &mm, Base64::Conf_RFC2045),
+	  mm);
+#else
+        auto_array<XMLCh, xml::std_memory_manager> data (
+          Base64::decode (src, &size, &mm), mm);
+#endif // _XERCES_VERSION >= 20600
+
+        if (data)
+        {
+          buffer<C> tmp (size);
+          for (unsigned int i (0); i < size; ++i)
+            tmp.data ()[i] = static_cast<char> (data[i]);
+          this->swap (tmp); // g++ 4.1 likes it qualified, not sure why.
+        }
+        else
+        {
+          //@@ throw
+        }
+#endif  //_XERCES_VERSION >= 20700
+      }
+
+
+      // hex_binary
+      //
+      template <typename C, typename B>
+      hex_binary<C, B>::
+      hex_binary (size_t size)
+          : buffer<C> (size)
+      {
+      }
+
+      template <typename C, typename B>
+      hex_binary<C, B>::
+      hex_binary (size_t size, size_t capacity)
+          : buffer<C> (size, capacity)
+      {
+      }
+
+      template <typename C, typename B>
+      hex_binary<C, B>::
+      hex_binary (const void* data, size_t size)
+          : buffer<C> (data, size)
+      {
+      }
+
+      template <typename C, typename B>
+      hex_binary<C, B>::
+      hex_binary (const void* data, size_t size, size_t capacity)
+          : buffer<C> (data, size, capacity)
+      {
+      }
+
+      template <typename C, typename B>
+      hex_binary<C, B>::
+      hex_binary (void* data, size_t size, size_t capacity, bool own)
+          : buffer<C> (data, size, capacity, own)
+      {
+      }
+
+      template <typename C, typename B>
+      hex_binary<C, B>* hex_binary<C, B>::
+      _clone (flags f, container* c) const
+      {
+        return new hex_binary (*this, f, c);
+      }
+
+      // It would have been cleaner to mention size, and data with the
+      // using-declaration but HP aCC3 can't handle it in some non-
+      // trivial to track down cases. So we are going to use the
+      // old-n-ugly this-> techniques.
+      //
+      template <typename C, typename B>
+      std::basic_string<C> hex_binary<C, B>::
+      encode () const
+      {
+        std::basic_string<C> str;
+
+        const char tab[] = "0123456789ABCDEF";
+
+        if (size_t n = this->size ())
+        {
+          str.reserve (2 * n + 1);
+          str.resize (2 * n);
+
+          for (size_t i (0); i < n; ++i)
+          {
+            unsigned char byte (
+	      static_cast<unsigned char> (*(this->data () + i)));
+            unsigned char h (byte >> 4);
+            unsigned char l (byte & 0x0F);
+
+            str[2 * i] = C (tab[h]);
+            str[2 * i + 1] = C (tab[l]);
+          }
+        }
+
+        return str;
+      }
+
+      namespace bits
+      {
+        inline unsigned char
+        hex_decode (XMLCh c)
+        {
+          unsigned char r (0xFF);
+
+          if (c >= '0' && c <= '9')
+            r = static_cast<unsigned char> (c - '0');
+          else if (c >= 'A' && c <= 'F')
+            r = static_cast<unsigned char> (10 + (c - 'A'));
+          else if (c >= 'a' && c <= 'f')
+            r = static_cast<unsigned char> (10 + (c - 'a'));
+
+          return r;
+        }
+      }
+
+      template <typename C, typename B>
+      void hex_binary<C, B>::
+      decode (const XMLCh* src)
+      {
+        size_t src_n (xercesc::XMLString::stringLen (src));
+
+        if (src_n % 2 != 0)
+          return; // @@ throw
+
+        size_t n (src_n / 2);
+
+        buffer<C> tmp (n);
+
+        for (size_t i (0); i < n; ++i)
+        {
+          unsigned char h (bits::hex_decode (src[2 * i]));
+          unsigned char l (bits::hex_decode (src[2 * i + 1]));
+
+          if (h == 0xFF || l == 0xFF)
+            return; //@@ throw
+
+          tmp.data()[i] = (h << 4) | l;
+        }
+
+        this->swap (tmp); // g++ 4.1 likes it qualified, not sure why.
+      }
+
+
+      // entity
+      //
+      template <typename C, typename B>
+      entity<C, B>* entity<C, B>::
+      _clone (flags f, container* c) const
+      {
+        return new entity (*this, f, c);
+      }
+
+
+      // entities
+      //
+      template <typename C, typename B, typename entity>
+      entities<C, B, entity>* entities<C, B, entity>::
+      _clone (flags f, container* c) const
+      {
+        return new entities (*this, f, c);
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/tree/xdr-stream-common.hxx src/base/include/xsd/cxx/tree/xdr-stream-common.hxx
new file mode 100644
index 0000000..ebc3d22
--- /dev/null
+++ src/base/include/xsd/cxx/tree/xdr-stream-common.hxx
@@ -0,0 +1,26 @@
+// file      : xsd/cxx/tree/xdr-stream-common.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_XDR_STREAM_COMMON_HXX
+#define XSD_CXX_TREE_XDR_STREAM_COMMON_HXX
+
+#include <xsd/cxx/exceptions.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      // Base exception for XDR insertion/extraction exceptions.
+      //
+      struct xdr_stream_operation: xsd::cxx::exception
+      {
+      };
+    }
+  }
+}
+
+#endif  // XSD_CXX_TREE_XDR_STREAM_COMMON_HXX
diff --git src/base/include/xsd/cxx/tree/xdr-stream-extraction.hxx src/base/include/xsd/cxx/tree/xdr-stream-extraction.hxx
new file mode 100644
index 0000000..012c1e4
--- /dev/null
+++ src/base/include/xsd/cxx/tree/xdr-stream-extraction.hxx
@@ -0,0 +1,295 @@
+// file      : xsd/cxx/tree/xdr-stream-extraction.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_XDR_STREAM_EXTRACTION_HXX
+#define XSD_CXX_TREE_XDR_STREAM_EXTRACTION_HXX
+
+#include <rpc/types.h>
+#include <rpc/xdr.h>
+
+#include <string>
+
+#include <xsd/cxx/tree/buffer.hxx>
+#include <xsd/cxx/tree/istream.hxx>
+#include <xsd/cxx/tree/xdr-stream-common.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      struct xdr_stream_extraction: xdr_stream_operation
+      {
+        virtual const char*
+        what () const throw ()
+        {
+          return "XDR stream extraction operation failed";
+        }
+      };
+
+
+      // as_size
+      //
+#ifdef XSD_CXX_TREE_USE_64_BIT_SIZE
+      template <typename T>
+      inline istream<XDR>&
+      operator>> (istream<XDR>& s, istream<XDR>::as_size<T>& x)
+      {
+        uint64_t v;
+
+        if (!xdr_uint64_t (&s.impl (), &v) || v > ~(T (0)))
+          throw xdr_stream_extraction ();
+
+        x.x_ = static_cast<T> (v);
+
+        return s;
+      }
+#else
+      template <typename T>
+      inline istream<XDR>&
+      operator>> (istream<XDR>& s, istream<XDR>::as_size<T>& x)
+      {
+        uint32_t v;
+
+        if (!xdr_uint32_t (&s.impl (), &v))
+          throw xdr_stream_extraction ();
+
+        x.x_ = static_cast<T> (v);
+
+        return s;
+      }
+#endif
+
+
+      // 8-bit
+      //
+      template <typename T>
+      inline istream<XDR>&
+      operator>> (istream<XDR>& s, istream<XDR>::as_int8<T>& x)
+      {
+        int8_t v;
+
+        if (!xdr_int8_t (&s.impl (), &v))
+          throw xdr_stream_extraction ();
+
+        x.x_ = static_cast<T> (v);
+
+        return s;
+      }
+
+      template <typename T>
+      inline istream<XDR>&
+      operator>> (istream<XDR>& s, istream<XDR>::as_uint8<T>& x)
+      {
+        uint8_t v;
+
+        if (!xdr_uint8_t (&s.impl (), &v))
+          throw xdr_stream_extraction ();
+
+        x.x_ = static_cast<T> (v);
+
+        return s;
+      }
+
+
+      // 16-bit
+      //
+      template <typename T>
+      inline istream<XDR>&
+      operator>> (istream<XDR>& s, istream<XDR>::as_int16<T>& x)
+      {
+        int16_t v;
+
+        if (!xdr_int16_t (&s.impl (), &v))
+          throw xdr_stream_extraction ();
+
+        x.x_ = static_cast<T> (v);
+
+        return s;
+      }
+
+      template <typename T>
+      inline istream<XDR>&
+      operator>> (istream<XDR>& s, istream<XDR>::as_uint16<T>& x)
+      {
+        uint16_t v;
+
+        if (!xdr_uint16_t (&s.impl (), &v))
+          throw xdr_stream_extraction ();
+
+        x.x_ = static_cast<T> (v);
+
+        return s;
+      }
+
+
+      // 32-bit
+      //
+      template <typename T>
+      inline istream<XDR>&
+      operator>> (istream<XDR>& s, istream<XDR>::as_int32<T>& x)
+      {
+        int32_t v;
+
+        if (!xdr_int32_t (&s.impl (), &v))
+          throw xdr_stream_extraction ();
+
+        x.x_ = static_cast<T> (v);
+
+        return s;
+      }
+
+      template <typename T>
+      inline istream<XDR>&
+      operator>> (istream<XDR>& s, istream<XDR>::as_uint32<T>& x)
+      {
+        uint32_t v;
+
+        if (!xdr_uint32_t (&s.impl (), &v))
+          throw xdr_stream_extraction ();
+
+        x.x_ = static_cast<T> (v);
+
+        return s;
+      }
+
+
+      // 64-bit
+      //
+      template <typename T>
+      inline istream<XDR>&
+      operator>> (istream<XDR>& s, istream<XDR>::as_int64<T>& x)
+      {
+        int64_t v;
+
+        if (!xdr_int64_t (&s.impl (), &v))
+          throw xdr_stream_extraction ();
+
+        x.x_ = static_cast<T> (v);
+
+        return s;
+      }
+
+      template <typename T>
+      inline istream<XDR>&
+      operator>> (istream<XDR>& s, istream<XDR>::as_uint64<T>& x)
+      {
+        uint64_t v;
+
+        if (!xdr_uint64_t (&s.impl (), &v))
+          throw xdr_stream_extraction ();
+
+        x.x_ = static_cast<T> (v);
+
+        return s;
+      }
+
+
+      // Boolean
+      //
+      template <typename T>
+      inline istream<XDR>&
+      operator>> (istream<XDR>& s, istream<XDR>::as_bool<T>& x)
+      {
+        bool_t v;
+
+        if (!xdr_bool (&s.impl (), &v))
+          throw xdr_stream_extraction ();
+
+        x.x_ = static_cast<T> (v);
+
+        return s;
+      }
+
+
+      // Floating-point
+      //
+      template <typename T>
+      inline istream<XDR>&
+      operator>> (istream<XDR>& s, istream<XDR>::as_float32<T>& x)
+      {
+        float v;
+
+        if (!xdr_float (&s.impl (), &v))
+          throw xdr_stream_extraction ();
+
+        x.x_ = static_cast<T> (v);
+
+        return s;
+      }
+
+      template <typename T>
+      inline istream<XDR>&
+      operator>> (istream<XDR>& s, istream<XDR>::as_float64<T>& x)
+      {
+        double v;
+
+        if (!xdr_double (&s.impl (), &v))
+          throw xdr_stream_extraction ();
+
+        x.x_ = static_cast<T> (v);
+
+        return s;
+      }
+
+      // Extraction of std::basic_string.
+      //
+
+      inline istream<XDR>&
+      operator>> (istream<XDR>& s, std::basic_string<char>& x)
+      {
+        unsigned int n;
+
+        if (!xdr_u_int (&s.impl (), &n))
+          throw xdr_stream_extraction ();
+
+        // Dangerous but fast.
+        //
+	x.clear ();
+	
+	if (n != 0)
+	{
+          x.resize (n);
+          char* p (const_cast<char*> (x.c_str ()));
+
+          if (!xdr_opaque (&s.impl (), p, n))
+            throw xdr_stream_extraction ();
+	}
+
+        return s;
+      }
+
+      // Wide strings are not supported by XDR.
+      //
+      // inline istream<XDR>&
+      // operator>> (istream<XDR>& s, std::basic_string<wchar_t>& x)
+      // {
+      // }
+
+
+      // Extraction of a binary buffer.
+      //
+      template <typename C>
+      istream<XDR>&
+      operator>> (istream<XDR>& s, buffer<C>& x)
+      {
+        unsigned int n;
+
+        if (!xdr_u_int (&s.impl (), &n))
+          throw xdr_stream_extraction ();
+
+        x.size (n);
+
+        if (!xdr_opaque (&s.impl (), x.data (), n))
+          throw xdr_stream_extraction ();
+
+        return s;
+      }
+    }
+  }
+}
+
+#endif  // XSD_CXX_TREE_XDR_STREAM_EXTRACTION_HXX
diff --git src/base/include/xsd/cxx/tree/xdr-stream-insertion.hxx src/base/include/xsd/cxx/tree/xdr-stream-insertion.hxx
new file mode 100644
index 0000000..00031d2
--- /dev/null
+++ src/base/include/xsd/cxx/tree/xdr-stream-insertion.hxx
@@ -0,0 +1,259 @@
+// file      : xsd/cxx/tree/xdr-stream-insertion.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_TREE_XDR_STREAM_INSERTION_HXX
+#define XSD_CXX_TREE_XDR_STREAM_INSERTION_HXX
+
+#include <rpc/types.h>
+#include <rpc/xdr.h>
+
+#include <string>
+
+#include <xsd/cxx/tree/buffer.hxx>
+#include <xsd/cxx/tree/ostream.hxx>
+#include <xsd/cxx/tree/xdr-stream-common.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace tree
+    {
+      struct xdr_stream_insertion: xdr_stream_operation
+      {
+        virtual const char*
+        what () const throw ()
+        {
+          return "XDR stream insertion operation failed";
+        }
+      };
+
+      // as_size
+      //
+#ifdef XSD_CXX_TREE_USE_64_BIT_SIZE
+      template <typename T>
+      inline ostream<XDR>&
+      operator<< (ostream<XDR>& s, ostream<XDR>::as_size<T> x)
+      {
+        uint64_t v (static_cast<uint64_t> (x.x_));
+
+        if (!xdr_uint64_t (&s.impl (), &v))
+          throw xdr_stream_insertion ();
+
+        return s;
+      }
+#else
+      template <typename T>
+      inline ostream<XDR>&
+      operator<< (ostream<XDR>& s, ostream<XDR>::as_size<T> x)
+      {
+        uint32_t v (static_cast<uint32_t> (x.x_));
+
+        if (x.x_ > ~(uint32_t (0)) || !xdr_uint32_t (&s.impl (), &v))
+          throw xdr_stream_insertion ();
+
+        return s;
+      }
+#endif
+
+
+      // 8-bit
+      //
+      template <typename T>
+      inline ostream<XDR>&
+      operator<< (ostream<XDR>& s, ostream<XDR>::as_int8<T> x)
+      {
+        int8_t v (static_cast<int8_t> (x.x_));
+
+        if (!xdr_int8_t (&s.impl (), &v))
+          throw xdr_stream_insertion ();
+
+        return s;
+      }
+
+      template <typename T>
+      inline ostream<XDR>&
+      operator<< (ostream<XDR>& s, ostream<XDR>::as_uint8<T> x)
+      {
+        uint8_t v (static_cast<uint8_t> (x.x_));
+
+        if (!xdr_uint8_t (&s.impl (), &v))
+          throw xdr_stream_insertion ();
+
+        return s;
+      }
+
+
+      // 16-bit
+      //
+      template <typename T>
+      inline ostream<XDR>&
+      operator<< (ostream<XDR>& s, ostream<XDR>::as_int16<T> x)
+      {
+        int16_t v (static_cast<int16_t> (x.x_));
+
+        if (!xdr_int16_t (&s.impl (), &v))
+          throw xdr_stream_insertion ();
+
+        return s;
+      }
+
+      template <typename T>
+      inline ostream<XDR>&
+      operator<< (ostream<XDR>& s, ostream<XDR>::as_uint16<T> x)
+      {
+        uint16_t v (static_cast<uint16_t> (x.x_));
+
+        if (!xdr_uint16_t (&s.impl (), &v))
+          throw xdr_stream_insertion ();
+
+        return s;
+      }
+
+
+      // 32-bit
+      //
+      template <typename T>
+      inline ostream<XDR>&
+      operator<< (ostream<XDR>& s, ostream<XDR>::as_int32<T> x)
+      {
+        int32_t v (static_cast<int32_t> (x.x_));
+
+        if (!xdr_int32_t (&s.impl (), &v))
+          throw xdr_stream_insertion ();
+
+        return s;
+      }
+
+      template <typename T>
+      inline ostream<XDR>&
+      operator<< (ostream<XDR>& s, ostream<XDR>::as_uint32<T> x)
+      {
+        uint32_t v (static_cast<uint32_t> (x.x_));
+
+        if (!xdr_uint32_t (&s.impl (), &v))
+          throw xdr_stream_insertion ();
+
+        return s;
+      }
+
+
+      // 64-bit
+      //
+      template <typename T>
+      inline ostream<XDR>&
+      operator<< (ostream<XDR>& s, ostream<XDR>::as_int64<T> x)
+      {
+        int64_t v (static_cast<int64_t> (x.x_));
+
+        if (!xdr_int64_t (&s.impl (), &v))
+          throw xdr_stream_insertion ();
+
+        return s;
+      }
+
+      template <typename T>
+      inline ostream<XDR>&
+      operator<< (ostream<XDR>& s, ostream<XDR>::as_uint64<T> x)
+      {
+        uint64_t v (static_cast<uint64_t> (x.x_));
+
+        if (!xdr_uint64_t (&s.impl (), &v))
+          throw xdr_stream_insertion ();
+
+        return s;
+      }
+
+
+      // Boolean
+      //
+      template <typename T>
+      inline ostream<XDR>&
+      operator<< (ostream<XDR>& s, ostream<XDR>::as_bool<T> x)
+      {
+        bool_t v (static_cast<bool_t> (x.x_));
+
+        if (!xdr_bool (&s.impl (), &v))
+          throw xdr_stream_insertion ();
+
+        return s;
+      }
+
+
+      // Floating-point
+      //
+      template <typename T>
+      inline ostream<XDR>&
+      operator<< (ostream<XDR>& s, ostream<XDR>::as_float32<T> x)
+      {
+        float v (static_cast<float> (x.x_));
+
+        if (!xdr_float (&s.impl (), &v))
+          throw xdr_stream_insertion ();
+
+        return s;
+      }
+
+      template <typename T>
+      inline ostream<XDR>&
+      operator<< (ostream<XDR>& s, ostream<XDR>::as_float64<T> x)
+      {
+        double v (static_cast<double> (x.x_));
+
+        if (!xdr_double (&s.impl (), &v))
+          throw xdr_stream_insertion ();
+
+        return s;
+      }
+
+      // Insertion of std::basic_string.
+      //
+
+      inline ostream<XDR>&
+      operator<< (ostream<XDR>& s, const std::basic_string<char>& x)
+      {
+        // XDR strings are hard-wired with a 32 bit (unsigned int) length.
+        //
+        char* p (const_cast<char*> (x.c_str ()));
+        unsigned int n (static_cast<unsigned int> (x.length ()));
+
+        if (x.length () > ~((unsigned int) 0) ||
+            !xdr_u_int (&s.impl (), &n) ||
+            !xdr_opaque (&s.impl (), p, n))
+          throw xdr_stream_insertion ();
+
+        return s;
+      }
+
+      // Wide strings are not supported by XDR.
+      //
+      // inline ostream<XDR>&
+      // operator<< (ostream<XDR>& s, const std::basic_string<wchar_t>& x)
+      // {
+      // }
+
+
+      // Insertion of a binary buffer.
+      //
+      template <typename C>
+      ostream<XDR>&
+      operator<< (ostream<XDR>& s, const buffer<C>& x)
+      {
+        // It is not possible to write an array with a 64-bit size.
+        //
+        unsigned int n (static_cast<unsigned int> (x.size ()));
+
+        if (x.size () > ~((unsigned int) 0) ||
+            !xdr_u_int (&s.impl (), &n) ||
+            !xdr_opaque (&s.impl (), const_cast<char*> (x.data ()), n))
+          throw xdr_stream_insertion ();
+
+        return s;
+      }
+    }
+  }
+}
+
+#endif  // XSD_CXX_TREE_XDR_STREAM_INSERTION_HXX
diff --git src/base/include/xsd/cxx/version.hxx src/base/include/xsd/cxx/version.hxx
new file mode 100644
index 0000000..69bd1a1
--- /dev/null
+++ src/base/include/xsd/cxx/version.hxx
@@ -0,0 +1,29 @@
+// file      : xsd/cxx/version.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_VERSION_HXX
+#define XSD_CXX_VERSION_HXX
+
+// Version format is AABBCCDD where
+//
+// AA - major version number
+// BB - minor version number
+// CC - bugfix version number
+// DD - alpha / beta (DD + 50) version number
+//
+// When DD is not 00, 1 is subtracted from AABBCC. For example:
+//
+// Version     AABBCCDD
+// 2.0.0       02000000
+// 2.1.0       02010000
+// 2.1.1       02010100
+// 2.2.0.a1    02019901
+// 3.0.0.b2    02999952
+//
+
+#define XSD_STR_VERSION "3.3.0"
+#define XSD_INT_VERSION 3030000L
+
+#endif  // XSD_CXX_VERSION_HXX
diff --git src/base/include/xsd/cxx/xml/bits/literals.hxx src/base/include/xsd/cxx/xml/bits/literals.hxx
new file mode 100644
index 0000000..5b9fe99
--- /dev/null
+++ src/base/include/xsd/cxx/xml/bits/literals.hxx
@@ -0,0 +1,83 @@
+// file      : xsd/cxx/xml/bits/literals.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_XML_BITS_LITERALS_HXX
+#define XSD_CXX_XML_BITS_LITERALS_HXX
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace xml
+    {
+      namespace bits
+      {
+        template <typename C>
+        const C*
+        xml_prefix ();
+
+        template <typename C>
+        const C*
+        xml_namespace ();
+
+        template <typename C>
+        const C*
+        xmlns_prefix ();
+
+        template <typename C>
+        const C*
+        xmlns_namespace ();
+
+        template <typename C>
+        const C*
+        xsi_prefix ();
+
+        template <typename C>
+        const C*
+        xsi_namespace ();
+
+        template <typename C>
+        const C*
+        type ();
+
+        template <typename C>
+        const C*
+        nil_lit ();
+
+        template <typename C>
+        const C*
+        schema_location ();
+
+        template <typename C>
+        const C*
+        no_namespace_schema_location ();
+
+        template <typename C>
+        const C*
+        first_prefix ();
+
+        template <typename C>
+        const C*
+        second_prefix ();
+
+        template <typename C>
+        const C*
+        third_prefix ();
+
+        template <typename C>
+        const C*
+        fourth_prefix ();
+
+        template <typename C>
+        const C*
+        fifth_prefix ();
+      }
+    }
+  }
+}
+
+#endif  // XSD_CXX_XML_BITS_LITERALS_HXX
+
+#include <xsd/cxx/xml/bits/literals.ixx>
diff --git src/base/include/xsd/cxx/xml/bits/literals.ixx src/base/include/xsd/cxx/xml/bits/literals.ixx
new file mode 100644
index 0000000..f0ec6eb
--- /dev/null
+++ src/base/include/xsd/cxx/xml/bits/literals.ixx
@@ -0,0 +1,261 @@
+// file      : xsd/cxx/xml/bits/literals.ixx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_XML_BITS_LITERALS_IXX
+#define XSD_CXX_XML_BITS_LITERALS_IXX
+
+#endif // XSD_CXX_XML_BITS_LITERALS_IXX
+
+
+#if defined(XSD_USE_CHAR) || !defined(XSD_USE_WCHAR)
+
+#ifndef XSD_CXX_XML_BITS_LITERALS_IXX_CHAR
+#define XSD_CXX_XML_BITS_LITERALS_IXX_CHAR
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace xml
+    {
+      namespace bits
+      {
+        template <>
+        inline const char*
+        xml_prefix<char> ()
+        {
+          return "xml";
+        }
+
+        template <>
+        inline const char*
+        xml_namespace<char> ()
+        {
+          return "http://www.w3.org/XML/1998/namespace";
+        }
+
+        template <>
+        inline const char*
+        xmlns_prefix<char> ()
+        {
+          return "xmlns";
+        }
+
+        template <>
+        inline const char*
+        xmlns_namespace<char> ()
+        {
+          return "http://www.w3.org/2000/xmlns/";
+        }
+
+        template <>
+        inline const char*
+        xsi_prefix<char> ()
+        {
+          return "xsi";
+        }
+
+        template <>
+        inline const char*
+        xsi_namespace<char> ()
+        {
+          return "http://www.w3.org/2001/XMLSchema-instance";
+        }
+
+        template <>
+        inline const char*
+        type<char> ()
+        {
+          return "type";
+        }
+
+        template <>
+        inline const char*
+        nil_lit<char> ()
+        {
+          return "nil";
+        }
+
+        template <>
+        inline const char*
+        schema_location<char> ()
+        {
+          return "schemaLocation";
+        }
+
+        template <>
+        inline const char*
+        no_namespace_schema_location<char> ()
+        {
+          return "noNamespaceSchemaLocation";
+        }
+
+        template <>
+        inline const char*
+        first_prefix<char> ()
+        {
+          return "p1";
+        }
+
+        template <>
+        inline const char*
+        second_prefix<char> ()
+        {
+          return "p2";
+        }
+
+        template <>
+        inline const char*
+        third_prefix<char> ()
+        {
+          return "p3";
+        }
+
+        template <>
+        inline const char*
+        fourth_prefix<char> ()
+        {
+          return "p4";
+        }
+
+        template <>
+        inline const char*
+        fifth_prefix<char> ()
+        {
+          return "p5";
+        }
+      }
+    }
+  }
+}
+
+#endif // XSD_CXX_XML_BITS_LITERALS_IXX_CHAR
+#endif // XSD_USE_CHAR
+
+
+#if defined(XSD_USE_WCHAR) || !defined(XSD_USE_CHAR)
+
+#ifndef XSD_CXX_XML_BITS_LITERALS_IXX_WCHAR
+#define XSD_CXX_XML_BITS_LITERALS_IXX_WCHAR
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace xml
+    {
+      namespace bits
+      {
+        template <>
+        inline const wchar_t*
+        xml_prefix<wchar_t> ()
+        {
+          return L"xml";
+        }
+
+        template <>
+        inline const wchar_t*
+        xml_namespace<wchar_t> ()
+        {
+          return L"http://www.w3.org/XML/1998/namespace";
+        }
+
+        template <>
+        inline const wchar_t*
+        xmlns_prefix<wchar_t> ()
+        {
+          return L"xmlns";
+        }
+
+        template <>
+        inline const wchar_t*
+        xmlns_namespace<wchar_t> ()
+        {
+          return L"http://www.w3.org/2000/xmlns/";
+        }
+
+        template <>
+        inline const wchar_t*
+        xsi_prefix<wchar_t> ()
+        {
+          return L"xsi";
+        }
+
+        template <>
+        inline const wchar_t*
+        xsi_namespace<wchar_t> ()
+        {
+          return L"http://www.w3.org/2001/XMLSchema-instance";
+        }
+
+        template <>
+        inline const wchar_t*
+        type<wchar_t> ()
+        {
+          return L"type";
+        }
+
+        template <>
+        inline const wchar_t*
+        nil_lit<wchar_t> ()
+        {
+          return L"nil";
+        }
+
+        template <>
+        inline const wchar_t*
+        schema_location<wchar_t> ()
+        {
+          return L"schemaLocation";
+        }
+
+        template <>
+        inline const wchar_t*
+        no_namespace_schema_location<wchar_t> ()
+        {
+          return L"noNamespaceSchemaLocation";
+        }
+
+        template <>
+        inline const wchar_t*
+        first_prefix<wchar_t> ()
+        {
+          return L"p1";
+        }
+
+        template <>
+        inline const wchar_t*
+        second_prefix<wchar_t> ()
+        {
+          return L"p2";
+        }
+
+        template <>
+        inline const wchar_t*
+        third_prefix<wchar_t> ()
+        {
+          return L"p3";
+        }
+
+        template <>
+        inline const wchar_t*
+        fourth_prefix<wchar_t> ()
+        {
+          return L"p4";
+        }
+
+        template <>
+        inline const wchar_t*
+        fifth_prefix<wchar_t> ()
+        {
+          return L"p5";
+        }
+      }
+    }
+  }
+}
+
+#endif // XSD_CXX_XML_BITS_LITERALS_IXX_WCHAR
+#endif // XSD_USE_WCHAR
diff --git src/base/include/xsd/cxx/xml/char-iso8859-1.hxx src/base/include/xsd/cxx/xml/char-iso8859-1.hxx
new file mode 100644
index 0000000..c8ab507
--- /dev/null
+++ src/base/include/xsd/cxx/xml/char-iso8859-1.hxx
@@ -0,0 +1,72 @@
+// file      : xsd/cxx/xml/char-iso8859-1.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_XML_TRANSCODER
+#define XSD_CXX_XML_TRANSCODER
+#define XSD_CXX_XML_TRANSCODER_CHAR_ISO8859_1
+
+#include <string>
+#include <cstddef> // std::size_t
+
+#include <xercesc/util/XercesDefs.hpp> // XMLCh
+
+#include <xsd/cxx/xml/exceptions.hxx>  // invalid_utf16_string
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace xml
+    {
+      struct iso8859_1_unrepresentable {};
+
+      // UTF-16 to/from ISO-8859-1 transcoder.
+      //
+      template <typename C>
+      struct char_iso8859_1_transcoder
+      {
+        static std::basic_string<C>
+        to (const XMLCh* s, std::size_t length);
+
+        static XMLCh*
+        from (const C* s, std::size_t length);
+
+        // Get/set a replacement for unrepresentable characters. If set to
+        // 0 (the default value), throw iso8859_1_unrepresentable instead.
+        //
+        static C
+        unrep_char ()
+        {
+          return unrep_char_;
+        }
+
+        static void
+        unrep_char (C c)
+        {
+          unrep_char_ = c;
+        }
+
+      private:
+        static C unrep_char_;
+      };
+
+      typedef char_iso8859_1_transcoder<char> char_transcoder;
+    }
+  }
+}
+
+#include <xsd/cxx/xml/char-iso8859-1.txx>
+
+#else
+#  ifndef XSD_CXX_XML_TRANSCODER_CHAR_ISO8859_1
+     //
+     // If you get this error, it usually means that either you compiled
+     // your schemas with different --char-encoding values or you included
+     // some of the libxsd headers (e.g., xsd/cxx/xml/string.hxx) directly
+     // without first including the correct xsd/cxx/xml/char-*.hxx header.
+     //
+#    error conflicting character encoding detected
+#  endif
+#endif // XSD_CXX_XML_TRANSCODER
diff --git src/base/include/xsd/cxx/xml/char-iso8859-1.txx src/base/include/xsd/cxx/xml/char-iso8859-1.txx
new file mode 100644
index 0000000..cbf7cd8
--- /dev/null
+++ src/base/include/xsd/cxx/xml/char-iso8859-1.txx
@@ -0,0 +1,101 @@
+// file      : xsd/cxx/xml/char-iso8859-1.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#include <xsd/cxx/auto-array.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace xml
+    {
+      template <typename C>
+      C char_iso8859_1_transcoder<C>::unrep_char_ = 0;
+
+      template <typename C>
+      std::basic_string<C> char_iso8859_1_transcoder<C>::
+      to (const XMLCh* s, std::size_t len)
+      {
+        const XMLCh* end (s + len);
+
+        // Find what the resulting buffer size will be.
+        //
+        std::size_t rl (0);
+        unsigned int u (0); // Four byte UCS-4 char.
+
+        bool valid (true);
+        const XMLCh* p (s);
+
+        for (; p < end; ++p)
+        {
+          if (*p >= 0xD800 && *p <= 0xDBFF)
+          {
+            // Make sure we have one more char and it has a valid
+            // value for the second char in a surrogate pair.
+            //
+            if (++p == end || !((*p >= 0xDC00) && (*p <= 0xDFFF)))
+            {
+              valid = false;
+              break;
+            }
+          }
+
+          rl++;
+        }
+
+        if (!valid)
+          throw invalid_utf16_string ();
+
+        std::basic_string<C> r;
+        r.reserve (rl + 1);
+        r.resize (rl);
+        C* rs (const_cast<C*> (r.c_str ()));
+        std::size_t i (0);
+
+        p = s;
+
+        // Tight first loop for the common case.
+        //
+        for (; p < end && *p < 0x100; ++p)
+          rs[i++] = C (*p);
+
+        if (p < end && unrep_char_ == 0)
+          throw iso8859_1_unrepresentable ();
+
+        for (; p < end; ++p)
+        {
+          XMLCh x (*p);
+
+          if ((x >= 0xD800) && (x <= 0xDBFF))
+          {
+            u = ((x - 0xD800) << 10) + (*++p - 0xDC00) + 0x10000;
+          }
+          else
+            u = x;
+
+          rs[i++] = u < 0x100 ? C (u) : unrep_char_;
+        }
+
+        return r;
+      }
+
+      template <typename C>
+      XMLCh* char_iso8859_1_transcoder<C>::
+      from (const C* s, std::size_t len)
+      {
+        const C* end (s + len);
+
+        auto_array<XMLCh> r (new XMLCh[len + 1]);
+        XMLCh* ir (r.get ());
+
+        for (const C* p (s); p < end; ++p)
+          *ir++ = static_cast<unsigned char> (*p);
+
+        *ir = XMLCh (0);
+        return r.release ();
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/xml/char-lcp.hxx src/base/include/xsd/cxx/xml/char-lcp.hxx
new file mode 100644
index 0000000..c100bab
--- /dev/null
+++ src/base/include/xsd/cxx/xml/char-lcp.hxx
@@ -0,0 +1,56 @@
+// file      : xsd/cxx/xml/char-lcp.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_XML_TRANSCODER
+#define XSD_CXX_XML_TRANSCODER
+#define XSD_CXX_XML_TRANSCODER_CHAR_LCP
+
+#include <string>
+#include <cstddef> // std::size_t
+
+#include <xercesc/util/XercesDefs.hpp> // XMLCh
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace xml
+    {
+      // UTF-16 to/from Xerces-C++ local code page (LCP) transcoder.
+      //
+      // Note that this transcoder has a custom interface due to Xerces-C++
+      // idiosyncrasies. Don't use it as a base for your custom transcoder.
+      //
+      template <typename C>
+      struct char_lcp_transcoder
+      {
+        static std::basic_string<C>
+        to (const XMLCh* s);
+
+        static std::basic_string<C>
+        to (const XMLCh* s, std::size_t length);
+
+        static XMLCh*
+        from (const C* s);
+      };
+
+      typedef char_lcp_transcoder<char> char_transcoder;
+    }
+  }
+}
+
+#include <xsd/cxx/xml/char-lcp.txx>
+
+#else
+#  ifndef XSD_CXX_XML_TRANSCODER_CHAR_LCP
+     //
+     // If you get this error, it usually means that either you compiled
+     // your schemas with different --char-encoding values or you included
+     // some of the libxsd headers (e.g., xsd/cxx/xml/string.hxx) directly
+     // without first including the correct xsd/cxx/xml/char-*.hxx header.
+     //
+#    error conflicting character encoding detected
+#  endif
+#endif // XSD_CXX_XML_TRANSCODER
diff --git src/base/include/xsd/cxx/xml/char-lcp.txx src/base/include/xsd/cxx/xml/char-lcp.txx
new file mode 100644
index 0000000..4603537
--- /dev/null
+++ src/base/include/xsd/cxx/xml/char-lcp.txx
@@ -0,0 +1,55 @@
+// file      : xsd/cxx/xml/char-lcp.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#include <cstring> // std::memcpy
+
+#include <xercesc/util/XMLString.hpp>
+
+#include <xsd/cxx/auto-array.hxx>
+#include <xsd/cxx/xml/std-memory-manager.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace xml
+    {
+      template <typename C>
+      std::basic_string<C> char_lcp_transcoder<C>::
+      to (const XMLCh* s)
+      {
+        std_memory_manager mm;
+        auto_array<C, std_memory_manager> r (
+          xercesc::XMLString::transcode (s, &mm), mm);
+        return std::basic_string<C> (r.get ());
+      }
+
+      template <typename C>
+      std::basic_string<C> char_lcp_transcoder<C>::
+      to (const XMLCh* s, std::size_t len)
+      {
+        auto_array<XMLCh> tmp (new XMLCh[len + 1]);
+        std::memcpy (tmp.get (), s, len * sizeof (XMLCh));
+        tmp[len] = XMLCh (0);
+
+        std_memory_manager mm;
+        auto_array<C, std_memory_manager> r (
+          xercesc::XMLString::transcode (tmp.get (), &mm), mm);
+
+        tmp.reset ();
+
+        return std::basic_string<C> (r.get ());
+      }
+
+      template <typename C>
+      XMLCh* char_lcp_transcoder<C>::
+      from (const C* s)
+      {
+        std_memory_manager mm;
+        return xercesc::XMLString::transcode (s, &mm);
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/xml/char-utf8.hxx src/base/include/xsd/cxx/xml/char-utf8.hxx
new file mode 100644
index 0000000..719881b
--- /dev/null
+++ src/base/include/xsd/cxx/xml/char-utf8.hxx
@@ -0,0 +1,57 @@
+// file      : xsd/cxx/xml/char-utf8.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_XML_TRANSCODER
+#define XSD_CXX_XML_TRANSCODER
+#define XSD_CXX_XML_TRANSCODER_CHAR_UTF8
+
+#include <string>
+#include <cstddef> // std::size_t
+
+#include <xercesc/util/XercesDefs.hpp> // XMLCh
+
+#include <xsd/cxx/xml/exceptions.hxx>  // invalid_utf16_string
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace xml
+    {
+      struct invalid_utf8_string {};
+
+      // UTF-16 to/from UTF-8 transcoder.
+      //
+      template <typename C>
+      struct char_utf8_transcoder
+      {
+        static std::basic_string<C>
+        to (const XMLCh* s, std::size_t length);
+
+        static XMLCh*
+        from (const C* s, std::size_t length);
+
+      private:
+        static const unsigned char first_byte_mask_[5];
+      };
+
+      typedef char_utf8_transcoder<char> char_transcoder;
+    }
+  }
+}
+
+#include <xsd/cxx/xml/char-utf8.txx>
+
+#else
+#  ifndef XSD_CXX_XML_TRANSCODER_CHAR_UTF8
+     //
+     // If you get this error, it usually means that either you compiled
+     // your schemas with different --char-encoding values or you included
+     // some of the libxsd headers (e.g., xsd/cxx/xml/string.hxx) directly
+     // without first including the correct xsd/cxx/xml/char-*.hxx header.
+     //
+#    error conflicting character encoding detected
+#  endif
+#endif // XSD_CXX_XML_TRANSCODER
diff --git src/base/include/xsd/cxx/xml/char-utf8.txx src/base/include/xsd/cxx/xml/char-utf8.txx
new file mode 100644
index 0000000..9935daf
--- /dev/null
+++ src/base/include/xsd/cxx/xml/char-utf8.txx
@@ -0,0 +1,293 @@
+// file      : xsd/cxx/xml/char-utf8.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#include <xsd/cxx/auto-array.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace xml
+    {
+      template <typename C>
+      const unsigned char char_utf8_transcoder<C>::first_byte_mask_[5] =
+      {
+        0x00, 0x00, 0xC0, 0xE0, 0xF0
+      };
+
+      template <typename C>
+      std::basic_string<C> char_utf8_transcoder<C>::
+      to (const XMLCh* s, std::size_t len)
+      {
+        const XMLCh* end (s + len);
+
+        // Find what the resulting buffer size will be.
+        //
+        std::size_t rl (0);
+        unsigned int u (0); // Four byte UCS-4 char.
+
+        bool valid (true);
+        const XMLCh* p (s);
+
+        for (; p < end; ++p)
+        {
+          XMLCh x (*p);
+
+          if (x < 0xD800 || x > 0xDBFF)
+            u = x;
+          else
+          {
+            // Make sure we have one more char and it has a valid
+            // value for the second char in a surrogate pair.
+            //
+            if (++p == end || !((*p >= 0xDC00) && (*p <= 0xDFFF)))
+            {
+              valid = false;
+              break;
+            }
+
+            u = ((x - 0xD800) << 10) + (*p - 0xDC00) + 0x10000;
+          }
+
+          if (u < 0x80)
+            rl++;
+          else if (u < 0x800)
+            rl += 2;
+          else if (u < 0x10000)
+            rl += 3;
+          else if (u < 0x110000)
+            rl += 4;
+          else
+          {
+            valid = false;
+            break;
+          }
+        }
+
+        if (!valid)
+          throw invalid_utf16_string ();
+
+        std::basic_string<C> r;
+        r.reserve (rl + 1);
+        r.resize (rl);
+        C* rs (const_cast<C*> (r.c_str ()));
+
+        std::size_t i (0);
+        unsigned int count (0);
+
+        p = s;
+
+        // Tight first loop for the common case.
+        //
+        for (; p < end && *p < 0x80; ++p)
+          rs[i++] = C (*p);
+
+        for (; p < end; ++p)
+        {
+          XMLCh x (*p);
+
+          if ((x >= 0xD800) && (x <= 0xDBFF))
+          {
+            u = ((x - 0xD800) << 10) + (*++p - 0xDC00) + 0x10000;
+          }
+          else
+            u = x;
+
+          if (u < 0x80)
+            count = 1;
+          else if (u < 0x800)
+            count = 2;
+          else if (u < 0x10000)
+            count = 3;
+          else if (u < 0x110000)
+            count = 4;
+
+          switch(count)
+          {
+          case 4:
+            {
+              rs[i + 3] = C ((u | 0x80UL) & 0xBFUL);
+              u >>= 6;
+            }
+          case 3:
+            {
+              rs[i + 2] = C ((u | 0x80UL) & 0xBFUL);
+              u >>= 6;
+            }
+          case 2:
+            {
+              rs[i + 1] = C ((u | 0x80UL) & 0xBFUL);
+              u >>= 6;
+            }
+          case 1:
+            {
+              rs[i] = C (u | first_byte_mask_[count]);
+            }
+          }
+
+          i += count;
+        }
+
+        return r;
+      }
+
+      template <typename C>
+      XMLCh* char_utf8_transcoder<C>::
+      from (const C* s, std::size_t len)
+      {
+        bool valid (true);
+        const C* end (s + len);
+
+        // Find what the resulting buffer size will be.
+        //
+        std::size_t rl (0);
+        unsigned int count (0);
+
+        for (const C* p (s); p < end; ++p)
+        {
+          unsigned char c (*p);
+
+          if (c < 0x80)
+          {
+            // Fast path.
+            //
+            rl += 1;
+            continue;
+          }
+          else if ((c >> 5) == 0x06)
+            count = 2;
+          else if ((c >> 4) == 0x0E)
+            count = 3;
+          else if ((c >> 3) == 0x1E)
+            count = 4;
+          else
+          {
+            valid = false;
+            break;
+          }
+
+          p += count - 1; // One will be added in the for loop
+
+          if (p + 1 > end)
+          {
+            valid = false;
+            break;
+          }
+
+          // BMP is represented by up to 3 code points in UTF-8.
+          //
+          rl += count > 3 ? 2 : 1;
+        }
+
+        if (!valid)
+          throw invalid_utf8_string ();
+
+        auto_array<XMLCh> r (new XMLCh[rl + 1]);
+        XMLCh* ir (r.get ());
+
+        unsigned int u (0); // Four byte UCS-4 char.
+
+        for (const C* p (s); p < end; ++p)
+        {
+          unsigned char c (*p);
+
+          if (c < 0x80)
+          {
+            // Fast path.
+            //
+            *ir++ = static_cast<XMLCh> (c);
+            continue;
+          }
+          else if ((c >> 5) == 0x06)
+          {
+            // UTF-8:   110yyyyy 10zzzzzz
+            // Unicode: 00000yyy yyzzzzzz
+            //
+            u = (c & 0x1F) << 6;
+
+            c = *++p;
+            if ((c >> 6) != 2)
+            {
+              valid = false;
+              break;
+            }
+            u |= c & 0x3F;
+          }
+          else if ((c >> 4) == 0x0E)
+          {
+            // UTF-8:   1110xxxx 10yyyyyy 10zzzzzz
+            // Unicode: xxxxyyyy yyzzzzzz
+            //
+            u = (c & 0x0F) << 6;
+
+            c = *++p;
+            if ((c >> 6) != 2)
+            {
+              valid = false;
+              break;
+            }
+            u = (u | (c & 0x3F)) << 6;
+
+            c = *++p;
+            if ((c >> 6) != 2)
+            {
+              valid = false;
+              break;
+            }
+            u |= c & 0x3F;
+          }
+          else if ((c >> 3) == 0x1E)
+          {
+            // UTF-8:   000wwwxx xxxxyyyy yyzzzzzz
+            // Unicode: 11110www 10xxxxxx 10yyyyyy 10zzzzzz
+            //
+            u = (c & 0x07) << 6;
+
+            c = *++p;
+            if ((c >> 6) != 2)
+            {
+              valid = false;
+              break;
+            }
+            u = (u | (c & 0x3F)) << 6;
+
+            c = *++p;
+            if ((c >> 6) != 2)
+            {
+              valid = false;
+              break;
+            }
+            u = (u | (c & 0x3F)) << 6;
+
+            c = *++p;
+            if ((c >> 6) != 2)
+            {
+              valid = false;
+              break;
+            }
+            u |= c & 0x3F;
+          }
+
+          if (u & 0xFFFF0000)
+          {
+            // Surrogate pair.
+            //
+            *ir++ = static_cast<XMLCh> (((u - 0x10000) >> 10) + 0xD800);
+            *ir++ = static_cast<XMLCh> ((u & 0x3FF) + 0xDC00);
+          }
+          else
+            *ir++ = static_cast<XMLCh> (u);
+        }
+
+        if (!valid)
+          throw invalid_utf8_string ();
+
+        *ir = XMLCh (0);
+
+        return r.release ();
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/xml/dom/auto-ptr.hxx src/base/include/xsd/cxx/xml/dom/auto-ptr.hxx
new file mode 100644
index 0000000..f22e652
--- /dev/null
+++ src/base/include/xsd/cxx/xml/dom/auto-ptr.hxx
@@ -0,0 +1,158 @@
+// file      : xsd/cxx/xml/dom/auto-ptr.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_XML_DOM_AUTO_PTR_HXX
+#define XSD_CXX_XML_DOM_AUTO_PTR_HXX
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace xml
+    {
+      namespace dom
+      {
+        // Simple auto_ptr version that calls release() instead of delete.
+        //
+
+        template <typename T>
+        struct remove_c
+        {
+          typedef T r;
+        };
+
+        template <typename T>
+        struct remove_c<const T>
+        {
+          typedef T r;
+        };
+
+        template <typename T>
+        struct auto_ptr_ref
+        {
+          T* x_;
+
+          explicit
+          auto_ptr_ref (T* x)
+              : x_ (x)
+          {
+          }
+        };
+
+        template <typename T>
+        struct auto_ptr
+        {
+          ~auto_ptr ()
+          {
+            reset ();
+          }
+
+          explicit
+          auto_ptr (T* x = 0)
+              : x_ (x)
+          {
+          }
+
+          auto_ptr (auto_ptr& y)
+              : x_ (y.release ())
+          {
+          }
+
+          template <typename T2>
+          auto_ptr (auto_ptr<T2>& y)
+              : x_ (y.release ())
+          {
+          }
+
+          auto_ptr (auto_ptr_ref<T> r)
+              : x_ (r.x_)
+          {
+          }
+
+          auto_ptr&
+          operator= (auto_ptr& y)
+          {
+            if (x_ != y.x_)
+              reset (y.release ());
+
+            return *this;
+          }
+
+          template <typename T2>
+          auto_ptr&
+          operator= (auto_ptr<T2>& y)
+          {
+            if (x_ != y.x_)
+              reset (y.release ());
+
+            return *this;
+          }
+
+          auto_ptr&
+          operator= (auto_ptr_ref<T> r)
+          {
+            if (r.x_ != x_)
+              reset (r.x_);
+
+            return *this;
+          }
+
+          template <typename T2>
+          operator auto_ptr_ref<T2> ()
+          {
+            return auto_ptr_ref<T2> (release ());
+          }
+
+          template <typename T2>
+          operator auto_ptr<T2> ()
+          {
+            return auto_ptr<T2> (release ());
+          }
+
+        public:
+          T&
+          operator* () const
+          {
+            return *x_;
+          }
+
+          T*
+          operator-> () const
+          {
+            return x_;
+          }
+
+          T*
+          get () const
+          {
+            return x_;
+          }
+
+          T*
+          release ()
+          {
+            T* x (x_);
+            x_ = 0;
+            return x;
+          }
+
+          void
+          reset (T* x = 0)
+          {
+            if (x_)
+              const_cast<typename remove_c<T>::r*> (x_)->release ();
+
+            x_ = x;
+          }
+
+        private:
+          T* x_;
+        };
+      }
+    }
+  }
+}
+
+#endif // XSD_CXX_XML_DOM_AUTO_PTR_HXX
diff --git src/base/include/xsd/cxx/xml/dom/bits/error-handler-proxy.hxx src/base/include/xsd/cxx/xml/dom/bits/error-handler-proxy.hxx
new file mode 100644
index 0000000..83e9a7e
--- /dev/null
+++ src/base/include/xsd/cxx/xml/dom/bits/error-handler-proxy.hxx
@@ -0,0 +1,61 @@
+// file      : xsd/cxx/xml/dom/bits/error-handler-proxy.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_XML_DOM_BITS_ERROR_HANDLER_PROXY_HXX
+#define XSD_CXX_XML_DOM_BITS_ERROR_HANDLER_PROXY_HXX
+
+#include <xercesc/dom/DOMError.hpp>
+#include <xercesc/dom/DOMLocator.hpp>
+#include <xercesc/dom/DOMErrorHandler.hpp>
+
+#include <xsd/cxx/xml/error-handler.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace xml
+    {
+      namespace dom
+      {
+        namespace bits
+        {
+          template <typename C>
+          class error_handler_proxy: public xercesc::DOMErrorHandler
+          {
+          public:
+            error_handler_proxy (error_handler<C>& eh)
+                : failed_ (false), eh_ (&eh), native_eh_ (0)
+            {
+            }
+
+            error_handler_proxy (xercesc::DOMErrorHandler& eh)
+              : failed_ (false), eh_ (0), native_eh_ (&eh)
+            {
+            }
+
+            virtual bool
+            handleError (const xercesc::DOMError& e);
+
+            bool
+            failed () const
+            {
+              return failed_;
+            }
+
+          private:
+            bool failed_;
+            error_handler<C>* eh_;
+            xercesc::DOMErrorHandler* native_eh_;
+          };
+        }
+      }
+    }
+  }
+}
+
+#include <xsd/cxx/xml/dom/bits/error-handler-proxy.txx>
+
+#endif  // XSD_CXX_XML_DOM_BITS_ERROR_HANDLER_PROXY_HXX
diff --git src/base/include/xsd/cxx/xml/dom/bits/error-handler-proxy.txx src/base/include/xsd/cxx/xml/dom/bits/error-handler-proxy.txx
new file mode 100644
index 0000000..23e71cd
--- /dev/null
+++ src/base/include/xsd/cxx/xml/dom/bits/error-handler-proxy.txx
@@ -0,0 +1,80 @@
+// file      : xsd/cxx/xml/dom/bits/error-handler-proxy.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#include <xsd/cxx/xml/string.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace xml
+    {
+      namespace dom
+      {
+        namespace bits
+        {
+          template <typename C>
+          bool error_handler_proxy<C>::
+          handleError (const xercesc::DOMError& e)
+          {
+            using xercesc::DOMError;
+
+            if (e.getSeverity() != DOMError::DOM_SEVERITY_WARNING)
+              failed_ = true;
+
+            if (native_eh_)
+              return native_eh_->handleError (e);
+            else
+            {
+              typedef typename error_handler<C>::severity severity;
+
+              severity s (severity::error);
+
+              switch (e.getSeverity())
+              {
+              case DOMError::DOM_SEVERITY_WARNING:
+                {
+                  s = severity::warning;
+                  break;
+                }
+              case DOMError::DOM_SEVERITY_ERROR:
+                {
+                  s = severity::error;
+                  break;
+                }
+              case DOMError::DOM_SEVERITY_FATAL_ERROR:
+                {
+                  s = severity::fatal;
+                  break;
+                }
+              }
+
+              xercesc::DOMLocator* loc (e.getLocation ());
+
+#if _XERCES_VERSION >= 30000
+              return eh_->handle (
+                transcode<C> (loc->getURI ()),
+                static_cast<unsigned long> (loc->getLineNumber ()),
+                static_cast<unsigned long> (loc->getColumnNumber ()),
+                s,
+                transcode<C> (e.getMessage ()));
+#else
+              XMLSSize_t l (loc->getLineNumber ());
+              XMLSSize_t c (loc->getColumnNumber ());
+
+              return eh_->handle (
+                transcode<C> (loc->getURI ()),
+                (l == -1 ? 0 : static_cast<unsigned long> (l)),
+                (c == -1 ? 0 : static_cast<unsigned long> (c)),
+                s,
+                transcode<C> (e.getMessage ()));
+#endif
+            }
+          }
+        }
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/xml/dom/elements.hxx src/base/include/xsd/cxx/xml/dom/elements.hxx
new file mode 100644
index 0000000..e8ce8d2
--- /dev/null
+++ src/base/include/xsd/cxx/xml/dom/elements.hxx
@@ -0,0 +1,36 @@
+// file      : xsd/cxx/xml/dom/elements.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_XML_DOM_ELEMENTS_HXX
+#define XSD_CXX_XML_DOM_ELEMENTS_HXX
+
+#include <xercesc/dom/DOMAttr.hpp>
+#include <xercesc/dom/DOMElement.hpp>
+
+#include <xsd/cxx/xml/qualified-name.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace xml
+    {
+      namespace dom
+      {
+        template <typename C>
+        qualified_name<C>
+        name (const xercesc::DOMAttr&);
+
+        template <typename C>
+        qualified_name<C>
+        name (const xercesc::DOMElement&);
+      }
+    }
+  }
+}
+
+#include <xsd/cxx/xml/dom/elements.txx>
+
+#endif // XSD_CXX_XML_DOM_ELEMENTS_HXX
diff --git src/base/include/xsd/cxx/xml/dom/elements.txx src/base/include/xsd/cxx/xml/dom/elements.txx
new file mode 100644
index 0000000..540d0fb
--- /dev/null
+++ src/base/include/xsd/cxx/xml/dom/elements.txx
@@ -0,0 +1,57 @@
+// file      : xsd/cxx/xml/dom/elements.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#include <xsd/cxx/xml/string.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace xml
+    {
+      namespace dom
+      {
+        template <typename C>
+        qualified_name<C>
+        name (const xercesc::DOMAttr& a)
+        {
+          const XMLCh* n (a.getLocalName ());
+
+          // If this DOM doesn't support namespaces then use getName.
+          //
+          if (n != 0)
+          {
+            if (const XMLCh* ns = a.getNamespaceURI ())
+              return qualified_name<C> (transcode<C> (n), transcode<C> (ns));
+            else
+              return qualified_name<C> (transcode<C> (n));
+          }
+          else
+            return qualified_name<C> (transcode<C> (a.getName ()));
+        }
+
+
+        template <typename C>
+        qualified_name<C>
+        name (const xercesc::DOMElement& e)
+        {
+          const XMLCh* n (e.getLocalName ());
+
+          // If this DOM doesn't support namespaces then use getTagName.
+          //
+          if (n != 0)
+          {
+            if (const XMLCh* ns = e.getNamespaceURI ())
+              return qualified_name<C> (transcode<C> (n), transcode<C> (ns));
+            else
+              return qualified_name<C> (transcode<C> (n));
+          }
+          else
+            return qualified_name<C> (transcode<C> (e.getTagName ()));
+        }
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/xml/dom/parsing-header.hxx src/base/include/xsd/cxx/xml/dom/parsing-header.hxx
new file mode 100644
index 0000000..d9a3695
--- /dev/null
+++ src/base/include/xsd/cxx/xml/dom/parsing-header.hxx
@@ -0,0 +1,24 @@
+// file      : xsd/cxx/xml/dom/parsing-header.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_XML_DOM_PARSING_HEADER_HXX
+#define XSD_CXX_XML_DOM_PARSING_HEADER_HXX
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace xml
+    {
+      namespace dom
+      {
+        template <typename C>
+        class parser;
+      }
+    }
+  }
+}
+
+#endif // XSD_CXX_XML_DOM_PARSING_HEADER_HXX
diff --git src/base/include/xsd/cxx/xml/dom/parsing-source.hxx src/base/include/xsd/cxx/xml/dom/parsing-source.hxx
new file mode 100644
index 0000000..2c90cf3
--- /dev/null
+++ src/base/include/xsd/cxx/xml/dom/parsing-source.hxx
@@ -0,0 +1,138 @@
+// file      : xsd/cxx/xml/dom/parsing-source.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_XML_DOM_PARSING_SOURCE_HXX
+#define XSD_CXX_XML_DOM_PARSING_SOURCE_HXX
+
+#include <string>
+
+#include <xercesc/dom/DOMNode.hpp>
+#include <xercesc/dom/DOMAttr.hpp>
+#include <xercesc/dom/DOMElement.hpp>
+#include <xercesc/dom/DOMDocument.hpp>
+#include <xercesc/dom/DOMNamedNodeMap.hpp>
+#include <xercesc/dom/DOMErrorHandler.hpp>
+
+#include <xercesc/sax/InputSource.hpp>
+
+#include <xsd/cxx/xml/elements.hxx>      // properies
+#include <xsd/cxx/xml/error-handler.hxx>
+
+#include <xsd/cxx/xml/dom/auto-ptr.hxx>
+#include <xsd/cxx/xml/dom/elements.hxx>  // name
+#include <xsd/cxx/xml/dom/parsing-header.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace xml
+    {
+      namespace dom
+      {
+        // Parser state object. Can be used for parsing element, attributes,
+        // or both.
+        //
+        template <typename C>
+        class parser
+        {
+        public:
+          parser (const xercesc::DOMElement& e, bool ep, bool ap);
+
+          bool
+          more_elements ()
+          {
+            return next_element_ != 0;
+          }
+
+          const xercesc::DOMElement&
+          cur_element ()
+          {
+            return *static_cast<const xercesc::DOMElement*> (next_element_);
+          }
+
+          void
+          next_element ();
+
+          bool
+          more_attributes ()
+          {
+            return as_ > ai_;
+          }
+
+          const xercesc::DOMAttr&
+          next_attribute ()
+          {
+            return *static_cast<const xercesc::DOMAttr*> (a_->item (ai_++));
+          }
+
+          void
+          reset_attributes ()
+          {
+            ai_ = 0;
+          }
+
+          const xercesc::DOMElement&
+          element () const
+          {
+            return element_;
+          }
+
+        private:
+          parser (const parser&);
+
+          parser&
+          operator= (const parser&);
+
+        private:
+          const xercesc::DOMElement& element_;
+          const xercesc::DOMNode* next_element_;
+
+          const xercesc::DOMNamedNodeMap* a_;
+          XMLSize_t ai_; // Index of the next DOMAttr.
+          XMLSize_t as_; // Cached size of a_.
+        };
+
+
+        // Parsing flags.
+        //
+        const unsigned long dont_validate      = 0x00000400UL;
+        const unsigned long no_muliple_imports = 0x00000800UL;
+
+        template <typename C>
+        xml::dom::auto_ptr<xercesc::DOMDocument>
+        parse (xercesc::InputSource&,
+               error_handler<C>&,
+               const properties<C>&,
+               unsigned long flags);
+
+        template <typename C>
+        xml::dom::auto_ptr<xercesc::DOMDocument>
+        parse (xercesc::InputSource&,
+               xercesc::DOMErrorHandler&,
+               const properties<C>&,
+               unsigned long flags);
+
+        template <typename C>
+        xml::dom::auto_ptr<xercesc::DOMDocument>
+        parse (const std::basic_string<C>& uri,
+               error_handler<C>&,
+               const properties<C>&,
+               unsigned long flags);
+
+        template <typename C>
+        xml::dom::auto_ptr<xercesc::DOMDocument>
+        parse (const std::basic_string<C>& uri,
+               xercesc::DOMErrorHandler&,
+               const properties<C>&,
+               unsigned long flags);
+      }
+    }
+  }
+}
+
+#include <xsd/cxx/xml/dom/parsing-source.txx>
+
+#endif // XSD_CXX_XML_DOM_PARSING_SOURCE_HXX
diff --git src/base/include/xsd/cxx/xml/dom/parsing-source.txx src/base/include/xsd/cxx/xml/dom/parsing-source.txx
new file mode 100644
index 0000000..50fa285
--- /dev/null
+++ src/base/include/xsd/cxx/xml/dom/parsing-source.txx
@@ -0,0 +1,510 @@
+// file      : xsd/cxx/xml/dom/parsing-source.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#if _XERCES_VERSION >= 30000
+#  include <xercesc/dom/DOMLSParser.hpp>
+#  include <xercesc/dom/DOMLSException.hpp>
+#else
+#  include <xercesc/dom/DOMBuilder.hpp>
+#endif
+#include <xercesc/dom/DOMNamedNodeMap.hpp>
+#include <xercesc/dom/DOMImplementation.hpp>
+#include <xercesc/dom/DOMImplementationRegistry.hpp>
+
+#include <xercesc/util/XMLUni.hpp>     // xercesc::fg*
+#include <xercesc/util/XMLUniDefs.hpp> // chLatin_L, etc
+
+#include <xercesc/framework/Wrapper4InputSource.hpp>
+
+#include <xsd/cxx/xml/string.hxx>
+#include <xsd/cxx/xml/dom/bits/error-handler-proxy.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace xml
+    {
+      namespace dom
+      {
+        // parser
+        //
+        template <typename C>
+        parser<C>::
+        parser (const xercesc::DOMElement& e, bool ep, bool ap)
+            : element_ (e),
+              next_element_ (0),
+              a_ (0),
+              ai_ (0)
+        {
+          using xercesc::DOMNode;
+
+          if (ep)
+          {
+            for (next_element_ = e.getFirstChild ();
+                 next_element_ != 0 &&
+                   next_element_->getNodeType () != DOMNode::ELEMENT_NODE;
+                 next_element_ = next_element_->getNextSibling ()) /*noop*/;
+          }
+
+          if (ap)
+          {
+            a_ = e.getAttributes ();
+            as_ = a_->getLength ();
+          }
+        }
+
+        template <typename C>
+        void parser<C>::
+        next_element ()
+        {
+          using xercesc::DOMNode;
+
+          for (next_element_ = next_element_->getNextSibling ();
+               next_element_ != 0 &&
+                 next_element_->getNodeType () != DOMNode::ELEMENT_NODE;
+               next_element_ = next_element_->getNextSibling ())/*noop*/;
+        }
+
+        // parse()
+        //
+        template <typename C>
+        xml::dom::auto_ptr<xercesc::DOMDocument>
+        parse (xercesc::InputSource& is,
+               error_handler<C>& eh,
+               const properties<C>& prop,
+               unsigned long flags)
+        {
+          bits::error_handler_proxy<C> ehp (eh);
+          return xml::dom::parse (is, ehp, prop, flags);
+        }
+
+        template <typename C>
+        auto_ptr<xercesc::DOMDocument>
+        parse (xercesc::InputSource& is,
+               xercesc::DOMErrorHandler& eh,
+               const properties<C>& prop,
+               unsigned long flags)
+        {
+          // HP aCC cannot handle using namespace xercesc;
+          //
+          using xercesc::DOMImplementationRegistry;
+          using xercesc::DOMImplementationLS;
+          using xercesc::DOMImplementation;
+          using xercesc::DOMDocument;
+#if _XERCES_VERSION >= 30000
+          using xercesc::DOMLSParser;
+          using xercesc::DOMConfiguration;
+#else
+          using xercesc::DOMBuilder;
+#endif
+
+          using xercesc::Wrapper4InputSource;
+          using xercesc::XMLUni;
+
+
+          // Instantiate the DOM parser.
+          //
+          const XMLCh ls_id[] = {xercesc::chLatin_L,
+                                 xercesc::chLatin_S,
+                                 xercesc::chNull};
+
+          // Get an implementation of the Load-Store (LS) interface.
+          //
+          DOMImplementation* impl (
+            DOMImplementationRegistry::getDOMImplementation (ls_id));
+
+#if _XERCES_VERSION >= 30000
+          auto_ptr<DOMLSParser> parser (
+            impl->createLSParser (DOMImplementationLS::MODE_SYNCHRONOUS, 0));
+
+          DOMConfiguration* conf (parser->getDomConfig ());
+
+          // Discard comment nodes in the document.
+          //
+          conf->setParameter (XMLUni::fgDOMComments, false);
+
+          // Enable datatype normalization.
+          //
+          conf->setParameter (XMLUni::fgDOMDatatypeNormalization, true);
+
+          // Do not create EntityReference nodes in the DOM tree. No
+          // EntityReference nodes will be created, only the nodes
+          // corresponding to their fully expanded substitution text
+          // will be created.
+          //
+          conf->setParameter (XMLUni::fgDOMEntities, false);
+
+          // Perform namespace processing.
+          //
+          conf->setParameter (XMLUni::fgDOMNamespaces, true);
+
+          // Do not include ignorable whitespace in the DOM tree.
+          //
+          conf->setParameter (XMLUni::fgDOMElementContentWhitespace, false);
+
+          if (flags & dont_validate)
+          {
+            conf->setParameter (XMLUni::fgDOMValidate, false);
+            conf->setParameter (XMLUni::fgXercesSchema, false);
+            conf->setParameter (XMLUni::fgXercesSchemaFullChecking, false);
+          }
+          else
+          {
+            conf->setParameter (XMLUni::fgDOMValidate, true);
+            conf->setParameter (XMLUni::fgXercesSchema, true);
+
+            // Xerces-C++ 3.1.0 is the first version with working multi import
+            // support.
+            //
+#if _XERCES_VERSION >= 30100
+            if (!(flags & no_muliple_imports))
+              conf->setParameter (XMLUni::fgXercesHandleMultipleImports, true);
+#endif
+
+            // This feature checks the schema grammar for additional
+            // errors. We most likely do not need it when validating
+            // instances (assuming the schema is valid).
+            //
+            conf->setParameter (XMLUni::fgXercesSchemaFullChecking, false);
+          }
+
+          // We will release DOM ourselves.
+          //
+          conf->setParameter (XMLUni::fgXercesUserAdoptsDOMDocument, true);
+
+
+          // Transfer properies if any.
+          //
+
+          if (!prop.schema_location ().empty ())
+          {
+            xml::string sl (prop.schema_location ());
+            const void* v (sl.c_str ());
+
+            conf->setParameter (
+              XMLUni::fgXercesSchemaExternalSchemaLocation,
+              const_cast<void*> (v));
+          }
+
+          if (!prop.no_namespace_schema_location ().empty ())
+          {
+            xml::string sl (prop.no_namespace_schema_location ());
+            const void* v (sl.c_str ());
+
+            conf->setParameter (
+              XMLUni::fgXercesSchemaExternalNoNameSpaceSchemaLocation,
+              const_cast<void*> (v));
+          }
+
+          // If external schema location was specified, disable loading
+          // schemas via the schema location attributes in the document.
+          //
+#if _XERCES_VERSION >= 30100
+          if (!prop.schema_location ().empty () ||
+              !prop.no_namespace_schema_location ().empty ())
+          {
+            conf->setParameter (XMLUni::fgXercesLoadSchema, false);
+          }
+#endif
+          // Set error handler.
+          //
+          bits::error_handler_proxy<C> ehp (eh);
+          conf->setParameter (XMLUni::fgDOMErrorHandler, &ehp);
+
+#else // _XERCES_VERSION >= 30000
+
+          // Same as above but for Xerces-C++ 2 series.
+          //
+          auto_ptr<DOMBuilder> parser (
+            impl->createDOMBuilder (DOMImplementationLS::MODE_SYNCHRONOUS, 0));
+
+          parser->setFeature (XMLUni::fgDOMComments, false);
+          parser->setFeature (XMLUni::fgDOMDatatypeNormalization, true);
+          parser->setFeature (XMLUni::fgDOMEntities, false);
+          parser->setFeature (XMLUni::fgDOMNamespaces, true);
+          parser->setFeature (XMLUni::fgDOMWhitespaceInElementContent, false);
+
+          if (flags & dont_validate)
+          {
+            parser->setFeature (XMLUni::fgDOMValidation, false);
+            parser->setFeature (XMLUni::fgXercesSchema, false);
+            parser->setFeature (XMLUni::fgXercesSchemaFullChecking, false);
+          }
+          else
+          {
+            parser->setFeature (XMLUni::fgDOMValidation, true);
+            parser->setFeature (XMLUni::fgXercesSchema, true);
+            parser->setFeature (XMLUni::fgXercesSchemaFullChecking, false);
+          }
+
+          parser->setFeature (XMLUni::fgXercesUserAdoptsDOMDocument, true);
+
+          if (!prop.schema_location ().empty ())
+          {
+            xml::string sl (prop.schema_location ());
+            const void* v (sl.c_str ());
+
+            parser->setProperty (
+              XMLUni::fgXercesSchemaExternalSchemaLocation,
+              const_cast<void*> (v));
+          }
+
+          if (!prop.no_namespace_schema_location ().empty ())
+          {
+            xml::string sl (prop.no_namespace_schema_location ());
+            const void* v (sl.c_str ());
+
+            parser->setProperty (
+              XMLUni::fgXercesSchemaExternalNoNameSpaceSchemaLocation,
+              const_cast<void*> (v));
+          }
+
+          bits::error_handler_proxy<C> ehp (eh);
+          parser->setErrorHandler (&ehp);
+
+#endif // _XERCES_VERSION >= 30000
+
+          xercesc::Wrapper4InputSource wrap (&is, false);
+
+#if _XERCES_VERSION >= 30000
+          auto_ptr<DOMDocument> doc;
+
+          try
+          {
+            doc.reset (parser->parse (&wrap));
+          }
+          catch (const xercesc::DOMLSException&)
+          {
+          }
+#else
+          auto_ptr<DOMDocument> doc (parser->parse (wrap));
+#endif
+          if (ehp.failed ())
+            doc.reset ();
+
+          return doc;
+        }
+
+        template <typename C>
+        xml::dom::auto_ptr<xercesc::DOMDocument>
+        parse (const std::basic_string<C>& uri,
+               error_handler<C>& eh,
+               const properties<C>& prop,
+               unsigned long flags)
+        {
+          bits::error_handler_proxy<C> ehp (eh);
+          return xml::dom::parse (uri, ehp, prop, flags);
+        }
+
+        template <typename C>
+        auto_ptr<xercesc::DOMDocument>
+        parse (const std::basic_string<C>& uri,
+               xercesc::DOMErrorHandler& eh,
+               const properties<C>& prop,
+               unsigned long flags)
+        {
+          // HP aCC cannot handle using namespace xercesc;
+          //
+          using xercesc::DOMImplementationRegistry;
+          using xercesc::DOMImplementationLS;
+          using xercesc::DOMImplementation;
+          using xercesc::DOMDocument;
+#if _XERCES_VERSION >= 30000
+          using xercesc::DOMLSParser;
+          using xercesc::DOMConfiguration;
+#else
+          using xercesc::DOMBuilder;
+#endif
+          using xercesc::XMLUni;
+
+
+          // Instantiate the DOM parser.
+          //
+          const XMLCh ls_id[] = {xercesc::chLatin_L,
+                                 xercesc::chLatin_S,
+                                 xercesc::chNull};
+
+          // Get an implementation of the Load-Store (LS) interface.
+          //
+          DOMImplementation* impl (
+            DOMImplementationRegistry::getDOMImplementation (ls_id));
+
+#if _XERCES_VERSION >= 30000
+          auto_ptr<DOMLSParser> parser (
+            impl->createLSParser(DOMImplementationLS::MODE_SYNCHRONOUS, 0));
+
+          DOMConfiguration* conf (parser->getDomConfig ());
+
+          // Discard comment nodes in the document.
+          //
+          conf->setParameter (XMLUni::fgDOMComments, false);
+
+          // Enable datatype normalization.
+          //
+          conf->setParameter (XMLUni::fgDOMDatatypeNormalization, true);
+
+          // Do not create EntityReference nodes in the DOM tree. No
+          // EntityReference nodes will be created, only the nodes
+          // corresponding to their fully expanded substitution text
+          // will be created.
+          //
+          conf->setParameter (XMLUni::fgDOMEntities, false);
+
+          // Perform namespace processing.
+          //
+          conf->setParameter (XMLUni::fgDOMNamespaces, true);
+
+          // Do not include ignorable whitespace in the DOM tree.
+          //
+          conf->setParameter (XMLUni::fgDOMElementContentWhitespace, false);
+
+          if (flags & dont_validate)
+          {
+            conf->setParameter (XMLUni::fgDOMValidate, false);
+            conf->setParameter (XMLUni::fgXercesSchema, false);
+            conf->setParameter (XMLUni::fgXercesSchemaFullChecking, false);
+          }
+          else
+          {
+            conf->setParameter (XMLUni::fgDOMValidate, true);
+            conf->setParameter (XMLUni::fgXercesSchema, true);
+
+            // Xerces-C++ 3.1.0 is the first version with working multi import
+            // support.
+            //
+#if _XERCES_VERSION >= 30100
+            if (!(flags & no_muliple_imports))
+              conf->setParameter (XMLUni::fgXercesHandleMultipleImports, true);
+#endif
+
+            // This feature checks the schema grammar for additional
+            // errors. We most likely do not need it when validating
+            // instances (assuming the schema is valid).
+            //
+            conf->setParameter (XMLUni::fgXercesSchemaFullChecking, false);
+          }
+
+          // We will release DOM ourselves.
+          //
+          conf->setParameter (XMLUni::fgXercesUserAdoptsDOMDocument, true);
+
+
+          // Transfer properies if any.
+          //
+
+          if (!prop.schema_location ().empty ())
+          {
+            xml::string sl (prop.schema_location ());
+            const void* v (sl.c_str ());
+
+            conf->setParameter (
+              XMLUni::fgXercesSchemaExternalSchemaLocation,
+              const_cast<void*> (v));
+          }
+
+          if (!prop.no_namespace_schema_location ().empty ())
+          {
+            xml::string sl (prop.no_namespace_schema_location ());
+            const void* v (sl.c_str ());
+
+            conf->setParameter (
+              XMLUni::fgXercesSchemaExternalNoNameSpaceSchemaLocation,
+              const_cast<void*> (v));
+          }
+
+          // If external schema location was specified, disable loading
+          // schemas via the schema location attributes in the document.
+          //
+#if _XERCES_VERSION >= 30100
+          if (!prop.schema_location ().empty () ||
+              !prop.no_namespace_schema_location ().empty ())
+          {
+            conf->setParameter (XMLUni::fgXercesLoadSchema, false);
+          }
+#endif
+          // Set error handler.
+          //
+          bits::error_handler_proxy<C> ehp (eh);
+          conf->setParameter (XMLUni::fgDOMErrorHandler, &ehp);
+
+#else // _XERCES_VERSION >= 30000
+
+          // Same as above but for Xerces-C++ 2 series.
+          //
+          auto_ptr<DOMBuilder> parser (
+            impl->createDOMBuilder(DOMImplementationLS::MODE_SYNCHRONOUS, 0));
+
+          parser->setFeature (XMLUni::fgDOMComments, false);
+          parser->setFeature (XMLUni::fgDOMDatatypeNormalization, true);
+          parser->setFeature (XMLUni::fgDOMEntities, false);
+          parser->setFeature (XMLUni::fgDOMNamespaces, true);
+          parser->setFeature (XMLUni::fgDOMWhitespaceInElementContent, false);
+
+          if (flags & dont_validate)
+          {
+            parser->setFeature (XMLUni::fgDOMValidation, false);
+            parser->setFeature (XMLUni::fgXercesSchema, false);
+            parser->setFeature (XMLUni::fgXercesSchemaFullChecking, false);
+          }
+          else
+          {
+            parser->setFeature (XMLUni::fgDOMValidation, true);
+            parser->setFeature (XMLUni::fgXercesSchema, true);
+            parser->setFeature (XMLUni::fgXercesSchemaFullChecking, false);
+          }
+
+          parser->setFeature (XMLUni::fgXercesUserAdoptsDOMDocument, true);
+
+          if (!prop.schema_location ().empty ())
+          {
+            xml::string sl (prop.schema_location ());
+            const void* v (sl.c_str ());
+
+            parser->setProperty (
+              XMLUni::fgXercesSchemaExternalSchemaLocation,
+              const_cast<void*> (v));
+          }
+
+          if (!prop.no_namespace_schema_location ().empty ())
+          {
+            xml::string sl (prop.no_namespace_schema_location ());
+            const void* v (sl.c_str ());
+
+            parser->setProperty (
+              XMLUni::fgXercesSchemaExternalNoNameSpaceSchemaLocation,
+              const_cast<void*> (v));
+          }
+
+          bits::error_handler_proxy<C> ehp (eh);
+          parser->setErrorHandler (&ehp);
+
+#endif // _XERCES_VERSION >= 30000
+
+
+#if _XERCES_VERSION >= 30000
+          auto_ptr<DOMDocument> doc;
+
+          try
+          {
+            doc.reset (parser->parseURI (string (uri).c_str ()));
+          }
+          catch (const xercesc::DOMLSException&)
+          {
+          }
+#else
+          auto_ptr<DOMDocument> doc (
+            parser->parseURI (string (uri).c_str ()));
+#endif
+
+          if (ehp.failed ())
+            doc.reset ();
+
+          return doc;
+        }
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/xml/dom/serialization-header.hxx src/base/include/xsd/cxx/xml/dom/serialization-header.hxx
new file mode 100644
index 0000000..3b879b1
--- /dev/null
+++ src/base/include/xsd/cxx/xml/dom/serialization-header.hxx
@@ -0,0 +1,81 @@
+// file      : xsd/cxx/xml/dom/serialization-header.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_XML_DOM_SERIALIZATION_HEADER_HXX
+#define XSD_CXX_XML_DOM_SERIALIZATION_HEADER_HXX
+
+#include <map>
+#include <string>
+
+#include <xercesc/dom/DOMElement.hpp>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace xml
+    {
+      namespace dom
+      {
+        // Find an existing prefix or establish a new one. Try to use
+        // hint if provided and available.
+        //
+        template <typename C>
+        std::basic_string<C>
+        prefix (const C* ns, xercesc::DOMElement&, const C* hint = 0);
+
+        template <typename C>
+        inline std::basic_string<C>
+        prefix (const std::basic_string<C>& ns,
+                xercesc::DOMElement& e,
+                const C* hint = 0)
+        {
+          return prefix (ns.c_str (), e, hint);
+        }
+
+        //
+        //
+        template <typename C>
+        void
+        clear (xercesc::DOMElement&);
+
+        //
+        //
+        template <typename C>
+        class namespace_info
+        {
+	public:
+          typedef std::basic_string<C> string;
+
+          namespace_info ()
+          {
+          }
+
+          namespace_info (const string& name_, const string& schema_)
+              : name (name_),
+                schema (schema_)
+          {
+          }
+
+          std::basic_string<C> name;
+          std::basic_string<C> schema;
+        };
+
+
+        // Map of namespace prefix to namespace_info.
+        //
+        template <typename C>
+        class namespace_infomap:
+          public std::map<std::basic_string<C>, namespace_info<C> >
+        {
+        };
+      }
+    }
+  }
+}
+
+#include <xsd/cxx/xml/dom/serialization-header.txx>
+
+#endif  // XSD_CXX_XML_DOM_SERIALIZATION_HEADER_HXX
diff --git src/base/include/xsd/cxx/xml/dom/serialization-header.txx src/base/include/xsd/cxx/xml/dom/serialization-header.txx
new file mode 100644
index 0000000..3052b7e
--- /dev/null
+++ src/base/include/xsd/cxx/xml/dom/serialization-header.txx
@@ -0,0 +1,192 @@
+// file      : xsd/cxx/xml/dom/serialization-header.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#include <vector>
+#include <sstream>
+#include <cstddef> // std::size_t
+
+#include <xercesc/dom/DOMNode.hpp>
+#include <xercesc/dom/DOMAttr.hpp>
+#include <xercesc/dom/DOMNamedNodeMap.hpp>
+
+#include <xercesc/util/XMLUni.hpp>    // xercesc::fg*
+#include <xercesc/util/XMLString.hpp>
+#include <xercesc/validators/schema/SchemaSymbols.hpp>
+
+#include <xsd/cxx/xml/string.hxx>
+#include <xsd/cxx/xml/bits/literals.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace xml
+    {
+      namespace dom
+      {
+        //
+        //
+        template <typename C>
+        std::basic_string<C>
+        prefix (const C* ns, xercesc::DOMElement& e, const C* hint)
+        {
+          string xns (ns);
+
+#if _XERCES_VERSION >= 30000
+          const XMLCh* p (e.lookupPrefix (xns.c_str ()));
+#else
+          const XMLCh* p (e.lookupNamespacePrefix (xns.c_str (), false));
+#endif
+          if (p != 0)
+            return transcode<C> (p);
+
+          if (e.isDefaultNamespace (xns.c_str ()))
+            return std::basic_string<C> ();
+
+          // 'xml' prefix requires special handling and Xerces folks
+          // refuse to handle this in DOM so I have to do it myself.
+          //
+          if (std::basic_string<C> (ns) == xml::bits::xml_namespace<C> ())
+            return xml::bits::xml_prefix<C> ();
+
+          // No prefix for this namespace. Will need to establish one.
+          //
+          std::basic_string<C> prefix;
+
+          if (hint != 0 &&
+              e.lookupNamespaceURI (xml::string (hint).c_str ()) == 0)
+          {
+            prefix = hint;
+          }
+          else
+          {
+            for (unsigned long n (1);; ++n)
+            {
+              // Make finding the first few prefixes fast.
+              //
+              switch (n)
+              {
+              case 1:
+                {
+                  prefix = xml::bits::first_prefix<C> ();
+                  break;
+                }
+              case 2:
+                {
+                  prefix = xml::bits::second_prefix<C> ();
+                  break;
+                }
+              case 3:
+                {
+                  prefix = xml::bits::third_prefix<C> ();
+                  break;
+                }
+              case 4:
+                {
+                  prefix = xml::bits::fourth_prefix<C> ();
+                  break;
+                }
+              case 5:
+                {
+                  prefix = xml::bits::fifth_prefix<C> ();
+                  break;
+                }
+              default:
+                {
+                  std::basic_ostringstream<C> ostr;
+                  ostr << C ('p') << n;
+                  prefix = ostr.str ();
+                  break;
+                }
+              }
+
+              if (e.lookupNamespaceURI (xml::string (prefix).c_str ()) == 0)
+                break;
+            }
+          }
+
+          std::basic_string<C> name (xml::bits::xmlns_prefix<C> ());
+          name += C(':');
+          name += prefix;
+
+          e.setAttributeNS (
+            xercesc::XMLUni::fgXMLNSURIName,
+            xml::string (name).c_str (),
+            xns.c_str ());
+
+          return prefix;
+        }
+
+        //
+        //
+        template <typename C>
+        void
+        clear (xercesc::DOMElement& e)
+        {
+          // HP aCC cannot handle using namespace xercesc;
+          //
+          using xercesc::DOMNode;
+          using xercesc::DOMAttr;
+          using xercesc::DOMNamedNodeMap;
+          using xercesc::XMLString;
+          using xercesc::SchemaSymbols;
+
+          // Remove child nodes.
+          //
+          while (xercesc::DOMNode* n = e.getFirstChild ())
+          {
+            e.removeChild (n);
+            n->release ();
+          }
+
+          // Remove attributes.
+          //
+          DOMNamedNodeMap* att_map (e.getAttributes ());
+          XMLSize_t n (att_map->getLength ());
+
+          if (n != 0)
+          {
+            std::vector<DOMAttr*> atts;
+
+            // Collect all attributes to be removed while filtering
+            // out special cases (xmlns & xsi).
+            //
+            for (XMLSize_t i (0); i != n; ++i)
+            {
+              DOMAttr* a (static_cast<DOMAttr*> (att_map->item (i)));
+              const XMLCh* ns (a->getNamespaceURI ());
+
+              if (ns != 0)
+              {
+                if (XMLString::equals (ns, xercesc::XMLUni::fgXMLNSURIName))
+                  continue;
+
+                if (XMLString::equals (ns, SchemaSymbols::fgURI_XSI))
+                {
+                  const XMLCh* name (a->getLocalName ());
+
+                  if (XMLString::equals (
+                        name, SchemaSymbols::fgXSI_SCHEMALOCACTION) ||
+                      XMLString::equals (
+                        name, SchemaSymbols::fgXSI_NONAMESPACESCHEMALOCACTION))
+                    continue;
+                }
+              }
+
+              atts.push_back (a);
+            }
+
+            for (std::vector<DOMAttr*>::iterator i (atts.begin ()),
+                   end (atts.end ()); i != end; ++i)
+            {
+              e.removeAttributeNode (*i);
+              (*i)->release ();
+            }
+          }
+        }
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/xml/dom/serialization-source.hxx src/base/include/xsd/cxx/xml/dom/serialization-source.hxx
new file mode 100644
index 0000000..325c1ec
--- /dev/null
+++ src/base/include/xsd/cxx/xml/dom/serialization-source.hxx
@@ -0,0 +1,181 @@
+// file      : xsd/cxx/xml/dom/serialization-source.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_XML_DOM_SERIALIZATION_SOURCE_HXX
+#define XSD_CXX_XML_DOM_SERIALIZATION_SOURCE_HXX
+
+#include <string>
+#include <cstring> // std::memcpy
+#include <ostream>
+
+#include <xercesc/dom/DOMAttr.hpp>
+#include <xercesc/dom/DOMElement.hpp>
+#include <xercesc/dom/DOMDocument.hpp>
+#include <xercesc/dom/DOMErrorHandler.hpp>
+#include <xercesc/framework/XMLFormatter.hpp> // XMLFormatTarget, XMLFormatter
+
+#include <xsd/cxx/xml/error-handler.hxx>
+#include <xsd/cxx/xml/dom/auto-ptr.hxx>
+#include <xsd/cxx/xml/dom/elements.hxx> // name
+#include <xsd/cxx/xml/dom/serialization-header.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace xml
+    {
+      namespace dom
+      {
+        //
+        //
+        template <typename C>
+        xercesc::DOMAttr&
+        create_attribute (const C* name, xercesc::DOMElement&);
+
+        template <typename C>
+        xercesc::DOMAttr&
+        create_attribute (const C* name, const C* ns, xercesc::DOMElement&);
+
+        template <typename C>
+        xercesc::DOMElement&
+        create_element (const C* name, xercesc::DOMElement&);
+
+        template <typename C>
+        xercesc::DOMElement&
+        create_element (const C* name, const C* ns, xercesc::DOMElement&);
+
+        // Serialization flags.
+        //
+        const unsigned long no_xml_declaration = 0x00010000UL;
+        const unsigned long dont_pretty_print  = 0x00020000UL;
+
+        template <typename C>
+        xml::dom::auto_ptr<xercesc::DOMDocument>
+        serialize (const std::basic_string<C>& root_element,
+                   const std::basic_string<C>& root_element_namespace,
+                   const namespace_infomap<C>& map,
+                   unsigned long flags);
+
+        // This one helps Sun C++ to overcome its fears.
+        //
+        template <typename C>
+        inline xml::dom::auto_ptr<xercesc::DOMDocument>
+        serialize (const C* root_element,
+                   const C* root_element_namespace,
+                   const namespace_infomap<C>& map,
+                   unsigned long flags)
+        {
+          return serialize (std::basic_string<C> (root_element),
+                            std::basic_string<C> (root_element_namespace),
+                            map,
+                            flags);
+        }
+
+        //
+        //
+        template <typename C>
+        bool
+        serialize (xercesc::XMLFormatTarget& target,
+                   const xercesc::DOMDocument& doc,
+                   const std::basic_string<C>& enconding,
+                   error_handler<C>& eh,
+                   unsigned long flags);
+
+        template <typename C>
+        bool
+        serialize (xercesc::XMLFormatTarget& target,
+                   const xercesc::DOMDocument& doc,
+                   const std::basic_string<C>& enconding,
+                   xercesc::DOMErrorHandler& eh,
+                   unsigned long flags);
+
+
+        class ostream_format_target: public xercesc::XMLFormatTarget
+        {
+        public:
+          ostream_format_target (std::ostream& os)
+              : n_ (0), os_ (os)
+          {
+          }
+
+        public:
+          // I know, some of those consts are stupid. But that's what
+          // Xerces folks put into their interfaces and VC-7.1 thinks
+          // there are different signatures if one strips this fluff off.
+          //
+          virtual void
+          writeChars (const XMLByte* const buf,
+#if _XERCES_VERSION >= 30000
+                      const XMLSize_t size,
+#else
+                      const unsigned int size,
+#endif
+                      xercesc::XMLFormatter* const)
+          {
+            // Ignore the write request if there was a stream failure and the
+            // stream is not using exceptions.
+            //
+            if (os_.fail ())
+              return;
+
+            // Flush the buffer if the block is too large or if we don't have
+            // any space left.
+            //
+            if ((size >= buf_size_ / 8 || n_ + size > buf_size_) && n_ != 0)
+            {
+              os_.write (buf_, static_cast<std::streamsize> (n_));
+              n_ = 0;
+
+              if (os_.fail ())
+                return;
+            }
+
+            if (size < buf_size_ / 8)
+            {
+              std::memcpy (buf_ + n_, reinterpret_cast<const char*> (buf), size);
+              n_ += size;
+            }
+            else
+              os_.write (reinterpret_cast<const char*> (buf),
+                         static_cast<std::streamsize> (size));
+          }
+
+
+          virtual void
+          flush ()
+          {
+            // Ignore the flush request if there was a stream failure
+            // and the stream is not using exceptions.
+            //
+            if (!os_.fail ())
+            {
+              if (n_ != 0)
+              {
+                os_.write (buf_, static_cast<std::streamsize> (n_));
+                n_ = 0;
+
+                if (os_.fail ())
+                  return;
+              }
+
+              os_.flush ();
+            }
+          }
+
+        private:
+          static const std::size_t buf_size_ = 1024;
+          char buf_[buf_size_];
+          std::size_t n_;
+          std::ostream& os_;
+        };
+      }
+    }
+  }
+}
+
+#include <xsd/cxx/xml/dom/serialization-source.txx>
+
+#endif  // XSD_CXX_XML_DOM_SERIALIZATION_SOURCE_HXX
diff --git src/base/include/xsd/cxx/xml/dom/serialization-source.txx src/base/include/xsd/cxx/xml/dom/serialization-source.txx
new file mode 100644
index 0000000..2b27dd5
--- /dev/null
+++ src/base/include/xsd/cxx/xml/dom/serialization-source.txx
@@ -0,0 +1,394 @@
+// file      : xsd/cxx/xml/dom/serialization-source.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#include <xercesc/util/XMLUni.hpp>     // xercesc::fg*
+#include <xercesc/util/XMLUniDefs.hpp> // chLatin_L, etc
+#include <xercesc/validators/schema/SchemaSymbols.hpp>
+
+#if _XERCES_VERSION >= 30000
+#  include <xercesc/dom/DOMLSOutput.hpp>
+#  include <xercesc/dom/DOMLSSerializer.hpp>
+#else
+#  include <xercesc/dom/DOMWriter.hpp>
+#endif
+#include <xercesc/dom/DOMElement.hpp>
+#include <xercesc/dom/DOMImplementation.hpp>
+#include <xercesc/dom/DOMImplementationRegistry.hpp>
+
+#include <xsd/cxx/xml/string.hxx>
+#include <xsd/cxx/xml/bits/literals.hxx>
+#include <xsd/cxx/xml/dom/bits/error-handler-proxy.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace xml
+    {
+      namespace dom
+      {
+        //
+        //
+        template <typename C>
+        xercesc::DOMAttr&
+        create_attribute (const C* name, xercesc::DOMElement& parent)
+        {
+          xercesc::DOMDocument* doc (parent.getOwnerDocument ());
+          xercesc::DOMAttr* a (doc->createAttribute (string (name).c_str ()));
+          parent.setAttributeNode (a);
+          return *a;
+        }
+
+        template <typename C>
+        xercesc::DOMAttr&
+        create_attribute (const C* name,
+                          const C* ns,
+                          xercesc::DOMElement& parent)
+        {
+          if (ns[0] == C ('\0'))
+            return create_attribute (name, parent);
+
+          xercesc::DOMDocument* doc (parent.getOwnerDocument ());
+
+          xercesc::DOMAttr* a;
+          std::basic_string<C> p (prefix<C> (ns, parent));
+
+          if (!p.empty ())
+          {
+            p += ':';
+            p += name;
+            a = doc->createAttributeNS (string (ns).c_str (),
+                                        string (p).c_str ());
+          }
+          else
+            a = doc->createAttributeNS (string (ns).c_str (),
+                                        string (name).c_str ());
+
+          parent.setAttributeNodeNS (a);
+          return *a;
+        }
+
+        template <typename C>
+        xercesc::DOMElement&
+        create_element (const C* name, xercesc::DOMElement& parent)
+        {
+          xercesc::DOMDocument* doc (parent.getOwnerDocument ());
+          xercesc::DOMElement* e (doc->createElement (string (name).c_str ()));
+          parent.appendChild (e);
+          return *e;
+        }
+
+        template <typename C>
+        xercesc::DOMElement&
+        create_element (const C* name,
+                        const C* ns,
+                        xercesc::DOMElement& parent)
+        {
+          if (ns[0] == C ('\0'))
+            return create_element (name, parent);
+
+          xercesc::DOMDocument* doc (parent.getOwnerDocument ());
+
+          xercesc::DOMElement* e;
+          std::basic_string<C> p (prefix<C> (ns, parent));
+
+          if (!p.empty ())
+          {
+            p += ':';
+            p += name;
+            e = doc->createElementNS (string (ns).c_str (),
+                                      string (p).c_str ());
+          }
+          else
+            e = doc->createElementNS (string (ns).c_str (),
+                                      string (name).c_str ());
+
+          parent.appendChild (e);
+          return *e;
+        }
+
+
+        //
+        //
+        template <typename C>
+        auto_ptr<xercesc::DOMDocument>
+        serialize (const std::basic_string<C>& el,
+                   const std::basic_string<C>& ns,
+                   const namespace_infomap<C>& map,
+                   unsigned long)
+        {
+          // HP aCC cannot handle using namespace xercesc;
+          //
+          using xercesc::DOMImplementationRegistry;
+          using xercesc::DOMImplementation;
+          using xercesc::DOMDocument;
+          using xercesc::DOMElement;
+
+          //
+          //
+          typedef std::basic_string<C> string;
+          typedef namespace_infomap<C> infomap;
+          typedef typename infomap::const_iterator infomap_iterator;
+
+          C colon (':'), space (' ');
+
+          string prefix;
+
+          if (!ns.empty ())
+          {
+            infomap_iterator i (map.begin ()), e (map.end ());
+
+            for ( ;i != e; ++i)
+            {
+              if (i->second.name == ns)
+              {
+                prefix = i->first;
+                break;
+              }
+            }
+
+            // Since this is the first namespace in document we don't
+            // need to worry about conflicts.
+            //
+            if (i == e)
+              prefix = xml::bits::first_prefix<C> ();
+          }
+
+          const XMLCh ls[] = {xercesc::chLatin_L,
+                              xercesc::chLatin_S,
+                              xercesc::chNull};
+
+          DOMImplementation* impl (
+            DOMImplementationRegistry::getDOMImplementation (ls));
+
+          auto_ptr<DOMDocument> doc (
+            impl->createDocument (
+              (ns.empty () ? 0 : xml::string (ns).c_str ()),
+              xml::string ((prefix.empty ()
+                            ? el
+                            : prefix + colon + el)).c_str (),
+              0));
+
+          DOMElement* root (doc->getDocumentElement ());
+
+          // Check if we need to provide xsi mapping.
+          //
+          bool xsi (false);
+          string xsi_prefix;
+          string xmlns_prefix (xml::bits::xmlns_prefix<C> ());
+
+          for (infomap_iterator i (map.begin ()), e (map.end ()); i != e; ++i)
+          {
+            if (!i->second.schema.empty ())
+            {
+              xsi = true;
+              break;
+            }
+          }
+
+          // Check if we were told to provide xsi mapping.
+          //
+          if (xsi)
+          {
+            for (infomap_iterator i (map.begin ()), e (map.end ());
+                 i != e;
+                 ++i)
+            {
+              if (i->second.name == xml::bits::xsi_namespace<C> ())
+              {
+                xsi_prefix = i->first;
+                xsi = false;
+                break;
+              }
+            }
+          }
+
+          // Create user-defined mappings.
+          //
+          for (infomap_iterator i (map.begin ()), e (map.end ()); i != e; ++i)
+          {
+            if (i->first.empty ())
+            {
+              // Empty prefix.
+              //
+              if (!i->second.name.empty ())
+                root->setAttributeNS (
+                  xercesc::XMLUni::fgXMLNSURIName,
+                  xml::string (xmlns_prefix).c_str (),
+                  xml::string (i->second.name).c_str ());
+            }
+            else
+            {
+              root->setAttributeNS (
+                xercesc::XMLUni::fgXMLNSURIName,
+                xml::string (xmlns_prefix + colon + i->first).c_str (),
+                xml::string (i->second.name).c_str ());
+            }
+          }
+
+          // If we were not told to provide xsi mapping but we need it
+          // then we will have to add it ourselves.
+          //
+          if (xsi)
+            xsi_prefix = dom::prefix (xml::bits::xsi_namespace<C> (),
+                                      *root,
+                                      xml::bits::xsi_prefix<C> ());
+
+          // Create xsi:schemaLocation and xsi:noNamespaceSchemaLocation
+          // attributes.
+          //
+          string schema_location;
+          string no_namespace_schema_location;
+
+          for (infomap_iterator i (map.begin ()), e (map.end ()); i != e; ++i)
+          {
+            if (!i->second.schema.empty ())
+            {
+              if (i->second.name.empty ())
+              {
+                if (!no_namespace_schema_location.empty ())
+                  no_namespace_schema_location += space;
+
+                no_namespace_schema_location += i->second.schema;
+              }
+              else
+              {
+                if (!schema_location.empty ())
+                  schema_location += space;
+
+                schema_location += i->second.name + space + i->second.schema;
+              }
+            }
+          }
+
+          if (!schema_location.empty ())
+          {
+            root->setAttributeNS (
+              xercesc::SchemaSymbols::fgURI_XSI,
+              xml::string (xsi_prefix + colon +
+                           xml::bits::schema_location<C> ()).c_str (),
+              xml::string (schema_location).c_str ());
+          }
+
+          if (!no_namespace_schema_location.empty ())
+          {
+            root->setAttributeNS (
+              xercesc::SchemaSymbols::fgURI_XSI,
+              xml::string (
+                xsi_prefix + colon +
+                xml::bits::no_namespace_schema_location<C> ()).c_str (),
+              xml::string (no_namespace_schema_location).c_str ());
+          }
+
+          return doc;
+        }
+
+
+        template <typename C>
+        bool
+        serialize (xercesc::XMLFormatTarget& target,
+                   const xercesc::DOMDocument& doc,
+                   const std::basic_string<C>& encoding,
+                   xercesc::DOMErrorHandler& eh,
+                   unsigned long flags)
+        {
+          // HP aCC cannot handle using namespace xercesc;
+          //
+          using xercesc::DOMImplementationRegistry;
+          using xercesc::DOMImplementation;
+#if _XERCES_VERSION >= 30000
+          using xercesc::DOMLSSerializer;
+          using xercesc::DOMConfiguration;
+          using xercesc::DOMLSOutput;
+#else
+          using xercesc::DOMWriter;
+#endif
+          using xercesc::XMLUni;
+
+          const XMLCh ls[] = {xercesc::chLatin_L,
+                              xercesc::chLatin_S,
+                              xercesc::chNull};
+
+          DOMImplementation* impl (
+            DOMImplementationRegistry::getDOMImplementation (ls));
+
+          bits::error_handler_proxy<C> ehp (eh);
+
+#if _XERCES_VERSION >= 30000
+          xml::dom::auto_ptr<DOMLSSerializer> writer (
+            impl->createLSSerializer ());
+
+          DOMConfiguration* conf (writer->getDomConfig ());
+
+          conf->setParameter (XMLUni::fgDOMErrorHandler, &ehp);
+
+          // Set some nice features if the serializer supports them.
+          //
+          if (conf->canSetParameter (
+                XMLUni::fgDOMWRTDiscardDefaultContent, true))
+            conf->setParameter (XMLUni::fgDOMWRTDiscardDefaultContent, true);
+
+          if (!(flags & dont_pretty_print) &&
+              conf->canSetParameter (XMLUni::fgDOMWRTFormatPrettyPrint, true))
+            conf->setParameter (XMLUni::fgDOMWRTFormatPrettyPrint, true);
+
+          // See if we need to write XML declaration.
+          //
+          if ((flags & no_xml_declaration) &&
+              conf->canSetParameter (XMLUni::fgDOMXMLDeclaration, false))
+            conf->setParameter (XMLUni::fgDOMXMLDeclaration, false);
+
+          xml::dom::auto_ptr<DOMLSOutput> out (impl->createLSOutput ());
+
+          out->setEncoding (xml::string (encoding).c_str ());
+          out->setByteStream (&target);
+
+          bool r (writer->write (&doc, out.get ()));
+#else
+          xml::dom::auto_ptr<DOMWriter> writer (impl->createDOMWriter ());
+
+          writer->setErrorHandler (&ehp);
+          writer->setEncoding (xml::string (encoding).c_str ());
+
+          // Set some nice features if the serializer supports them.
+          //
+          if (writer->canSetFeature (
+                XMLUni::fgDOMWRTDiscardDefaultContent, true))
+            writer->setFeature (XMLUni::fgDOMWRTDiscardDefaultContent, true);
+
+          if (!(flags & dont_pretty_print) &&
+              writer->canSetFeature (XMLUni::fgDOMWRTFormatPrettyPrint, true))
+            writer->setFeature (XMLUni::fgDOMWRTFormatPrettyPrint, true);
+
+          // See if we need to write XML declaration.
+          //
+          if ((flags & no_xml_declaration) &&
+              writer->canSetFeature (XMLUni::fgDOMXMLDeclaration, false))
+            writer->setFeature (XMLUni::fgDOMXMLDeclaration, false);
+
+          bool r (writer->writeNode (&target, doc));
+#endif
+
+          if (!r || ehp.failed ())
+            return false;
+
+          return true;
+        }
+
+        template <typename C>
+        bool
+        serialize (xercesc::XMLFormatTarget& target,
+                   const xercesc::DOMDocument& doc,
+                   const std::basic_string<C>& enconding,
+                   error_handler<C>& eh,
+                   unsigned long flags)
+        {
+          bits::error_handler_proxy<C> ehp (eh);
+          return serialize (target, doc, enconding, ehp, flags);
+        }
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/xml/dom/wildcard-source.hxx src/base/include/xsd/cxx/xml/dom/wildcard-source.hxx
new file mode 100644
index 0000000..11d7114
--- /dev/null
+++ src/base/include/xsd/cxx/xml/dom/wildcard-source.hxx
@@ -0,0 +1,31 @@
+// file      : xsd/cxx/xml/dom/wildcard-source.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_XML_DOM_WILDCARD_SOURCE_HXX
+#define XSD_CXX_XML_DOM_WILDCARD_SOURCE_HXX
+
+#include <xercesc/dom/DOMDocument.hpp>
+
+#include <xsd/cxx/xml/dom/auto-ptr.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace xml
+    {
+      namespace dom
+      {
+        template <typename C>
+        xml::dom::auto_ptr<xercesc::DOMDocument>
+        create_document ();
+      }
+    }
+  }
+}
+
+#include <xsd/cxx/xml/dom/wildcard-source.txx>
+
+#endif // XSD_CXX_XML_DOM_WILDCARD_SOURCE_HXX
diff --git src/base/include/xsd/cxx/xml/dom/wildcard-source.txx src/base/include/xsd/cxx/xml/dom/wildcard-source.txx
new file mode 100644
index 0000000..32043c0
--- /dev/null
+++ src/base/include/xsd/cxx/xml/dom/wildcard-source.txx
@@ -0,0 +1,38 @@
+// file      : xsd/cxx/xml/dom/wildcard-source.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#include <xercesc/util/XMLUniDefs.hpp> // chLatin_L, etc
+
+#include <xercesc/dom/DOMImplementation.hpp>
+#include <xercesc/dom/DOMImplementationRegistry.hpp>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace xml
+    {
+      namespace dom
+      {
+        template <typename C>
+        xml::dom::auto_ptr<xercesc::DOMDocument>
+        create_document ()
+        {
+          const XMLCh ls[] = {xercesc::chLatin_L,
+                              xercesc::chLatin_S,
+                              xercesc::chNull};
+
+          // Get an implementation of the Load-Store (LS) interface.
+          //
+          xercesc::DOMImplementation* impl (
+            xercesc::DOMImplementationRegistry::getDOMImplementation (ls));
+
+          return xml::dom::auto_ptr<xercesc::DOMDocument> (
+            impl->createDocument ());
+        }
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/xml/elements.hxx src/base/include/xsd/cxx/xml/elements.hxx
new file mode 100644
index 0000000..d9f8a50
--- /dev/null
+++ src/base/include/xsd/cxx/xml/elements.hxx
@@ -0,0 +1,113 @@
+// file      : xsd/cxx/xml/elements.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_XML_ELEMENTS_HXX
+#define XSD_CXX_XML_ELEMENTS_HXX
+
+#include <string>
+
+#include <xercesc/util/PlatformUtils.hpp>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace xml
+    {
+      template <typename C>
+      class properties
+      {
+      public:
+        struct argument {};
+
+
+        // Schema location properties. Note that all locations are
+        // relative to an instance document unless they are full
+        // URIs. For example if you want to use a local schema then
+        // you will need to use 'file:///absolute/path/to/your/schema'.
+        //
+
+        // Add a location for a schema with a target namespace.
+        //
+        void
+        schema_location (const std::basic_string<C>& namespace_,
+                         const std::basic_string<C>& location);
+
+        // Add a location for a schema without a target namespace.
+        //
+        void
+        no_namespace_schema_location (const std::basic_string<C>& location);
+
+      public:
+        const std::basic_string<C>&
+        schema_location () const
+        {
+          return schema_location_;
+        }
+
+        const std::basic_string<C>&
+        no_namespace_schema_location () const
+        {
+          return no_namespace_schema_location_;
+        }
+
+      private:
+        std::basic_string<C> schema_location_;
+        std::basic_string<C> no_namespace_schema_location_;
+      };
+
+
+      //
+      //
+
+      template <typename C>
+      std::basic_string<C>
+      prefix (const std::basic_string<C>& n);
+
+      template <typename C>
+      std::basic_string<C>
+      uq_name (const std::basic_string<C>& n);
+
+
+      //
+      //
+
+      inline void
+      initialize ()
+      {
+        xercesc::XMLPlatformUtils::Initialize ();
+      }
+
+      inline void
+      terminate ()
+      {
+        xercesc::XMLPlatformUtils::Terminate ();
+      }
+
+      struct auto_initializer
+      {
+        auto_initializer (bool initialize = true, bool terminate = true)
+            : terminate_ (initialize && terminate)
+        {
+          if (initialize)
+            xml::initialize ();
+        }
+
+        ~auto_initializer ()
+        {
+          if (terminate_)
+            terminate ();
+        }
+
+      private:
+        bool terminate_;
+      };
+    }
+  }
+}
+
+#include <xsd/cxx/xml/elements.txx>
+
+#endif  // XSD_CXX_XML_ELEMENTS_HXX
diff --git src/base/include/xsd/cxx/xml/elements.txx src/base/include/xsd/cxx/xml/elements.txx
new file mode 100644
index 0000000..8ba07df
--- /dev/null
+++ src/base/include/xsd/cxx/xml/elements.txx
@@ -0,0 +1,73 @@
+// file      : xsd/cxx/xml/elements.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace xml
+    {
+      // properties
+      //
+
+      template <typename C>
+      void properties<C>::
+      schema_location (const std::basic_string<C>& ns,
+                       const std::basic_string<C>& loc)
+      {
+        if (ns.empty () || loc.empty ())
+          throw argument ();
+
+        if (!schema_location_.empty ())
+          schema_location_ += C (' ');
+
+        schema_location_ += ns + C (' ') + loc;
+      }
+
+      template <typename C>
+      void properties<C>::
+      no_namespace_schema_location (const std::basic_string<C>& loc)
+      {
+        if (loc.empty ())
+          throw argument ();
+
+        if (!no_namespace_schema_location_.empty ())
+          no_namespace_schema_location_ += C (' ');
+
+        no_namespace_schema_location_ += loc;
+      }
+
+
+      //
+      //
+
+      template <typename C>
+      std::basic_string<C>
+      prefix (const std::basic_string<C>& n)
+      {
+        std::size_t i (0);
+
+        while (i < n.length () && n[i] != ':')
+          ++i;
+
+        return std::basic_string<C> (n, i == n.length () ? i : 0, i);
+      }
+
+      template <typename C>
+      std::basic_string<C>
+      uq_name (const std::basic_string<C>& n)
+      {
+        std::size_t i (0);
+
+        while (i < n.length () && n[i] != ':')
+          ++i;
+
+        return std::basic_string<C> (
+          n.c_str () + (i == n.length () ? 0 : i + 1));
+      }
+    }
+  }
+}
+
diff --git src/base/include/xsd/cxx/xml/error-handler.hxx src/base/include/xsd/cxx/xml/error-handler.hxx
new file mode 100644
index 0000000..bf0b3d7
--- /dev/null
+++ src/base/include/xsd/cxx/xml/error-handler.hxx
@@ -0,0 +1,59 @@
+// file      : xsd/cxx/xml/error-handler.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_XML_ERROR_HANDLER_HXX
+#define XSD_CXX_XML_ERROR_HANDLER_HXX
+
+#include <string>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace xml
+    {
+      template <typename C>
+      class error_handler
+      {
+      public:
+        virtual
+        ~error_handler ()
+        {
+        }
+
+      public:
+
+        // The fatal severity level results in termination
+        // of the parsing process no matter what is returned
+        // from handle.
+        //
+        struct severity
+        {
+          enum value
+          {
+            warning,
+            error,
+            fatal
+          };
+
+          severity (value v) : v_ (v) {}
+          operator value () const { return v_; }
+
+        private:
+          value v_;
+        };
+
+        virtual bool
+        handle (const std::basic_string<C>& id,
+                unsigned long line,
+                unsigned long column,
+                severity,
+                const std::basic_string<C>& message) = 0;
+      };
+    }
+  }
+}
+
+#endif  // XSD_CXX_XML_ERROR_HANDLER_HXX
diff --git src/base/include/xsd/cxx/xml/exceptions.hxx src/base/include/xsd/cxx/xml/exceptions.hxx
new file mode 100644
index 0000000..1ed93d8
--- /dev/null
+++ src/base/include/xsd/cxx/xml/exceptions.hxx
@@ -0,0 +1,20 @@
+// file      : xsd/cxx/xml/exceptions.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_XML_EXCEPTIONS_HXX
+#define XSD_CXX_XML_EXCEPTIONS_HXX
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace xml
+    {
+      struct invalid_utf16_string {};
+    }
+  }
+}
+
+#endif // XSD_CXX_XML_EXCEPTIONS_HXX
diff --git src/base/include/xsd/cxx/xml/qualified-name.hxx src/base/include/xsd/cxx/xml/qualified-name.hxx
new file mode 100644
index 0000000..1a0e032
--- /dev/null
+++ src/base/include/xsd/cxx/xml/qualified-name.hxx
@@ -0,0 +1,84 @@
+// file      : xsd/cxx/xml/qualified-name.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_XML_QUALIFIED_NAME_HXX
+#define XSD_CXX_XML_QUALIFIED_NAME_HXX
+
+#include <string>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace xml
+    {
+      template <typename C>
+      struct qualified_name
+      {
+        qualified_name (const C* name,
+                        const C* namespace_)
+            : name_ (name), namespace__ (namespace_)
+        {
+        }
+
+        qualified_name (const std::basic_string<C>& name,
+                        const std::basic_string<C>& namespace_)
+            : name_ (name), namespace__ (namespace_)
+        {
+        }
+
+        qualified_name (const C* name)
+            : name_ (name)
+        {
+        }
+
+        qualified_name (const std::basic_string<C>& name)
+            : name_ (name)
+        {
+        }
+
+        const std::basic_string<C>&
+        name () const
+        {
+          return name_;
+        }
+
+        const std::basic_string<C>&
+        namespace_ () const
+        {
+          return namespace__;
+        }
+
+      private:
+        std::basic_string<C> name_;
+        std::basic_string<C> namespace__;
+      };
+
+      template <typename C>
+      inline bool
+      operator== (const qualified_name<C>& x, const qualified_name<C>& y)
+      {
+        return x.name () == y.name () && x.namespace_ () == y.namespace_ ();
+      }
+
+      template <typename C>
+      inline bool
+      operator!= (const qualified_name<C>& x, const qualified_name<C>& y)
+      {
+        return !(x == y);
+      }
+
+      template <typename C>
+      inline bool
+      operator< (const qualified_name<C>& x, const qualified_name<C>& y)
+      {
+        int r (x.name ().compare (y.name ()));
+        return (r < 0) || (r == 0 && x.namespace_ () < y.namespace_ ());
+      }
+    }
+  }
+}
+
+#endif // XSD_CXX_XML_QUALIFIED_NAME_HXX
diff --git src/base/include/xsd/cxx/xml/sax/bits/error-handler-proxy.hxx src/base/include/xsd/cxx/xml/sax/bits/error-handler-proxy.hxx
new file mode 100644
index 0000000..f92b6ab
--- /dev/null
+++ src/base/include/xsd/cxx/xml/sax/bits/error-handler-proxy.hxx
@@ -0,0 +1,80 @@
+// file      : xsd/cxx/xml/sax/bits/error-handler-proxy.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_XML_SAX_ERROR_HANDLER_PROXY_HXX
+#define XSD_CXX_XML_SAX_ERROR_HANDLER_PROXY_HXX
+
+#include <xercesc/sax/ErrorHandler.hpp>
+#include <xercesc/sax/SAXParseException.hpp>
+
+#include <xsd/cxx/xml/error-handler.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace xml
+    {
+      namespace sax
+      {
+        namespace bits
+        {
+          template <typename C>
+          class error_handler_proxy: public xercesc::ErrorHandler
+          {
+          public:
+            error_handler_proxy (error_handler<C>& eh)
+                : failed_ (false), eh_ (&eh), native_eh_ (0)
+            {
+            }
+
+            error_handler_proxy (xercesc::ErrorHandler& eh)
+                : failed_ (false), eh_ (0), native_eh_ (&eh)
+            {
+            }
+
+          public:
+            virtual void
+            warning (const xercesc::SAXParseException& e);
+
+            virtual void
+            error (const xercesc::SAXParseException& e);
+
+            virtual void
+            fatalError (const xercesc::SAXParseException& e);
+
+          public:
+            bool
+            failed () const
+            {
+              return failed_;
+            }
+
+            virtual void
+            resetErrors()
+            {
+              failed_ = false;
+            }
+
+          private:
+            typedef typename error_handler<C>::severity severity;
+
+            void
+            handle (const xercesc::SAXParseException&, severity);
+
+          private:
+            bool failed_;
+            error_handler<C>* eh_;
+            xercesc::ErrorHandler* native_eh_;
+          };
+        }
+      }
+    }
+  }
+}
+
+#include <xsd/cxx/xml/sax/bits/error-handler-proxy.txx>
+
+#endif  // XSD_CXX_XML_SAX_ERROR_HANDLER_PROXY_HXX
diff --git src/base/include/xsd/cxx/xml/sax/bits/error-handler-proxy.txx src/base/include/xsd/cxx/xml/sax/bits/error-handler-proxy.txx
new file mode 100644
index 0000000..f8ca26d
--- /dev/null
+++ src/base/include/xsd/cxx/xml/sax/bits/error-handler-proxy.txx
@@ -0,0 +1,89 @@
+// file      : xsd/cxx/xml/sax/bits/error-handler-proxy.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#include <xsd/cxx/xml/string.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace xml
+    {
+      namespace sax
+      {
+        namespace bits
+        {
+          template <typename C>
+          void error_handler_proxy<C>::
+          warning (const xercesc::SAXParseException& e)
+          {
+            if (native_eh_)
+              native_eh_->warning (e);
+            else
+              handle (e, severity::warning);
+          }
+
+
+          template <typename C>
+          void error_handler_proxy<C>::
+          error (const xercesc::SAXParseException& e)
+          {
+            failed_ = true;
+
+            if (native_eh_)
+              native_eh_->error (e);
+            else
+              handle (e, severity::error);
+          }
+
+
+          template <typename C>
+          void error_handler_proxy<C>::
+          fatalError (const xercesc::SAXParseException& e)
+          {
+            failed_ = true;
+
+            if (native_eh_)
+              native_eh_->fatalError (e);
+            else
+              handle (e, severity::fatal);
+          }
+
+
+          template <typename C>
+          void error_handler_proxy<C>::
+          handle (const xercesc::SAXParseException& e, severity s)
+          {
+            //@@ I do not honor return values from the handler. This
+            //   is not too bad at the moment because I set
+            //   all-errors-are-fatal flag on the parser.
+            //
+            const XMLCh* id (e.getPublicId ());
+
+            if (id == 0)
+              id = e.getSystemId ();
+
+#if _XERCES_VERSION >= 30000
+            eh_->handle (transcode<C> (id),
+                         static_cast<unsigned long> (e.getLineNumber ()),
+                         static_cast<unsigned long> (e.getColumnNumber ()),
+                         s,
+                         transcode<C> (e.getMessage ()));
+#else
+            XMLSSize_t l (e.getLineNumber ());
+            XMLSSize_t c (e.getColumnNumber ());
+
+            eh_->handle (transcode<C> (id),
+                         (l == -1 ? 0 : static_cast<unsigned long> (l)),
+                         (c == -1 ? 0 : static_cast<unsigned long> (c)),
+                         s,
+                         transcode<C> (e.getMessage ()));
+#endif
+          }
+        }
+      }
+    }
+  }
+}
diff --git src/base/include/xsd/cxx/xml/sax/std-input-source.hxx src/base/include/xsd/cxx/xml/sax/std-input-source.hxx
new file mode 100644
index 0000000..71760a9
--- /dev/null
+++ src/base/include/xsd/cxx/xml/sax/std-input-source.hxx
@@ -0,0 +1,174 @@
+// file      : xsd/cxx/xml/sax/std-input-source.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_XML_SAX_STD_INPUT_SOURCE_HXX
+#define XSD_CXX_XML_SAX_STD_INPUT_SOURCE_HXX
+
+#include <istream>
+
+#include <xsd/cxx/xml/string.hxx>
+
+#include <xercesc/sax/InputSource.hpp>
+#include <xercesc/util/BinInputStream.hpp>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace xml
+    {
+      namespace sax
+      {
+        class std_input_stream: public xercesc::BinInputStream
+        {
+        public:
+          std_input_stream (std::istream& is)
+              : is_ (is)
+          {
+          }
+
+#if _XERCES_VERSION >= 30000
+          virtual XMLFilePos
+          curPos () const
+          {
+            return static_cast<XMLFilePos> (is_.tellg ());
+          }
+#else
+          virtual unsigned int
+          curPos () const
+          {
+            return static_cast<unsigned int> (is_.tellg ());
+          }
+#endif
+
+#if _XERCES_VERSION >= 30000
+          virtual XMLSize_t
+          readBytes (XMLByte* const buf, const XMLSize_t size)
+#else
+          virtual unsigned int
+          readBytes (XMLByte* const buf, const unsigned int size)
+#endif
+          {
+            // Some implementations don't clear gcount if you
+            // call read() on a stream that is in the eof state.
+            //
+            if (is_.eof ())
+              return 0;
+
+            // Unset the exception failbit while we are working
+            // with the stream.
+            //
+            std::ios_base::iostate old (is_.exceptions ());
+            is_.exceptions (old & ~std::ios_base::failbit);
+
+            is_.read (reinterpret_cast<char*> (buf),
+                      static_cast<std::streamsize> (size));
+
+            // Clear the fail bit if it was caused by eof and restore
+            // the original exception state. If there are any pending
+            // errors then the exception will be thrown now.
+            //
+            if (is_.fail () && is_.eof ())
+              is_.clear (is_.rdstate () & ~std::ios_base::failbit);
+
+            is_.exceptions (old);
+
+            // Make sure that if we failed, readBytes won't be called
+            // again.
+            //
+            if (!is_.fail ())
+            {
+#if _XERCES_VERSION >= 30000
+              return static_cast<XMLSize_t> (is_.gcount ());
+#else
+              return static_cast<unsigned int> (is_.gcount ());
+#endif
+            }
+            else
+              return 0;
+          }
+
+#if _XERCES_VERSION >= 30000
+          virtual const XMLCh*
+          getContentType () const
+          {
+            return 0;
+          }
+#endif
+        private:
+          std::istream& is_;
+        };
+
+
+        class std_input_source: public xercesc::InputSource
+        {
+        public:
+          std_input_source (std::istream& is)
+              : is_ (&is)
+          {
+          }
+
+          template <typename C>
+          std_input_source (std::istream& is, const C* system_id)
+              : xercesc::InputSource (xml::string (system_id).c_str ()),
+                is_ (&is)
+          {
+          }
+
+          template <typename C>
+          std_input_source (std::istream& is,
+                            const std::basic_string<C>& system_id)
+              : xercesc::InputSource (xml::string (system_id).c_str ()),
+                is_ (&is)
+          {
+          }
+
+          template <typename C>
+          std_input_source (std::istream& is,
+                            const C* system_id,
+                            const C* public_id)
+              : xercesc::InputSource (xml::string (system_id).c_str (),
+                                      xml::string (public_id).c_str ()),
+                is_ (&is)
+          {
+          }
+
+          template <typename C>
+          std_input_source (std::istream& is,
+                            const std::basic_string<C>& system_id,
+                            const std::basic_string<C>& public_id)
+              : xercesc::InputSource (xml::string (system_id).c_str (),
+                                      xml::string (public_id).c_str ()),
+                is_ (&is)
+          {
+          }
+
+          struct copy {};
+
+          // Throws the copy exception if this function is called more
+          // than once.
+          //
+          virtual xercesc::BinInputStream*
+          makeStream () const
+          {
+            if (is_ == 0)
+              throw copy ();
+
+            std::istream& is (*is_);
+
+            is_ = 0;
+
+            return new std_input_stream (is);
+          }
+
+        private:
+          mutable std::istream* is_;
+        };
+      }
+    }
+  }
+}
+
+#endif  // XSD_CXX_XML_SAX_STD_INPUT_SOURCE_HXX
diff --git src/base/include/xsd/cxx/xml/std-memory-manager.hxx src/base/include/xsd/cxx/xml/std-memory-manager.hxx
new file mode 100644
index 0000000..b5cfaf9
--- /dev/null
+++ src/base/include/xsd/cxx/xml/std-memory-manager.hxx
@@ -0,0 +1,50 @@
+// file      : xsd/cxx/xml/std-memory-manager.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_XML_STD_MEMORY_MANAGER_HXX
+#define XSD_CXX_XML_STD_MEMORY_MANAGER_HXX
+
+#include <new> // operator new, delete
+#include <xercesc/framework/MemoryManager.hpp>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace xml
+    {
+      class std_memory_manager: public xercesc::MemoryManager
+      {
+      public:
+        virtual void*
+#if _XERCES_VERSION >= 30000
+        allocate(XMLSize_t size)
+#else
+        allocate(size_t size)
+#endif
+        {
+          return operator new (size);
+        }
+
+        virtual void
+        deallocate(void* p)
+        {
+          if (p)
+	    operator delete (p);
+        }
+
+#if _XERCES_VERSION >= 30000
+        virtual xercesc::MemoryManager*
+        getExceptionMemoryManager()
+        {
+          return xercesc::XMLPlatformUtils::fgMemoryManager;
+        }
+#endif
+      };
+    }
+  }
+}
+
+#endif  // XSD_CXX_XML_STD_MEMORY_MANAGER_HXX
diff --git src/base/include/xsd/cxx/xml/string.hxx src/base/include/xsd/cxx/xml/string.hxx
new file mode 100644
index 0000000..f79e66e
--- /dev/null
+++ src/base/include/xsd/cxx/xml/string.hxx
@@ -0,0 +1,85 @@
+// file      : xsd/cxx/xml/string.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_XML_STRING_HXX
+#define XSD_CXX_XML_STRING_HXX
+
+#include <string>
+#include <cstddef> // std::size_t
+
+#include <xsd/cxx/auto-array.hxx>
+#include <xercesc/util/XercesDefs.hpp> // XMLCh
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace xml
+    {
+      // Transcode a null-terminated string.
+      //
+      template <typename C>
+      std::basic_string<C>
+      transcode (const XMLCh* s);
+
+      // Transcode a potentially non-null-terminated string.
+      //
+      template <typename C>
+      std::basic_string<C>
+      transcode (const XMLCh* s, std::size_t length);
+
+
+      // For VC7.1 wchar_t and XMLCh are the same type so we cannot
+      // overload the transcode name. You should not use these functions
+      // anyway and instead use the xml::string class below.
+      //
+      template <typename C>
+      XMLCh*
+      transcode_to_xmlch (const C*);
+
+      template <typename C>
+      XMLCh*
+      transcode_to_xmlch (const std::basic_string<C>& s);
+
+      //
+      //
+      class string
+      {
+      public :
+        template <typename C>
+        string (const std::basic_string<C>& s)
+            : s_ (transcode_to_xmlch<C> (s))
+        {
+        }
+
+        template <typename C>
+        string (const C* s)
+            : s_ (transcode_to_xmlch<C> (s))
+        {
+        }
+
+        const XMLCh*
+        c_str () const
+        {
+          return s_.get ();
+        }
+
+      private:
+        string (const string&);
+
+        string&
+        operator= (const string&);
+
+      private:
+        auto_array<XMLCh> s_;
+      };
+    }
+  }
+}
+
+#endif // XSD_CXX_XML_STRING_HXX
+
+#include <xsd/cxx/xml/string.ixx>
+#include <xsd/cxx/xml/string.txx>
diff --git src/base/include/xsd/cxx/xml/string.ixx src/base/include/xsd/cxx/xml/string.ixx
new file mode 100644
index 0000000..0f46f4d
--- /dev/null
+++ src/base/include/xsd/cxx/xml/string.ixx
@@ -0,0 +1,171 @@
+// file      : xsd/cxx/xml/string.ixx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_XML_STRING_IXX
+#define XSD_CXX_XML_STRING_IXX
+
+#include <xercesc/util/XMLString.hpp>
+
+// If no transcoder has been included, use the default UTF-8.
+//
+#ifndef XSD_CXX_XML_TRANSCODER
+#  include <xsd/cxx/xml/char-utf8.hxx>
+#endif
+
+// We sometimes need this functionality even if we are building for
+// wchar_t.
+//
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace xml
+    {
+      template <>
+      inline std::basic_string<char>
+      transcode<char> (const XMLCh* s)
+      {
+        if (s == 0 || *s == XMLCh (0))
+          return std::basic_string<char> ();
+
+#ifndef XSD_CXX_XML_TRANSCODER_CHAR_LCP
+        return char_transcoder::to (s, xercesc::XMLString::stringLen (s));
+#else
+        return char_transcoder::to (s);
+#endif
+      }
+
+      template <>
+      inline std::basic_string<char>
+      transcode<char> (const XMLCh* s, std::size_t len)
+      {
+        if (s == 0 || len == 0)
+          return std::basic_string<char> ();
+
+        return char_transcoder::to (s, len);
+      }
+
+      template <>
+      inline XMLCh*
+      transcode_to_xmlch (const char* s)
+      {
+#ifndef XSD_CXX_XML_TRANSCODER_CHAR_LCP
+        return char_transcoder::from (s, std::char_traits<char>::length (s));
+#else
+        return char_transcoder::from (s);
+#endif
+      }
+
+      template <>
+      inline XMLCh*
+      transcode_to_xmlch (const std::basic_string<char>& s)
+      {
+#ifndef XSD_CXX_XML_TRANSCODER_CHAR_LCP
+        return char_transcoder::from (s.c_str (), s.length ());
+#else
+        return char_transcoder::from (s.c_str ());
+#endif
+      }
+    }
+  }
+}
+
+#endif // XSD_CXX_XML_STRING_IXX
+
+
+#if defined(XSD_USE_CHAR) || !defined(XSD_USE_WCHAR)
+
+#ifndef XSD_CXX_XML_STRING_IXX_CHAR
+#define XSD_CXX_XML_STRING_IXX_CHAR
+
+#endif // XSD_CXX_XML_STRING_IXX_CHAR
+#endif // XSD_USE_CHAR
+
+
+#if defined(XSD_USE_WCHAR) || !defined(XSD_USE_CHAR)
+
+#ifndef XSD_CXX_XML_STRING_IXX_WCHAR
+#define XSD_CXX_XML_STRING_IXX_WCHAR
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace xml
+    {
+      namespace bits
+      {
+        template <typename W, std::size_t S>
+        struct wchar_transcoder;
+
+        // Specialization for 2-byte wchar_t (resulting encoding is UTF-16).
+        //
+        template <typename W>
+        struct wchar_transcoder<W, 2>
+        {
+          static std::basic_string<W>
+          to (const XMLCh* s, std::size_t length);
+
+          static XMLCh*
+          from (const W* s, std::size_t length);
+        };
+
+
+        // Specialization for 4-byte wchar_t (resulting encoding is UCS-4).
+        //
+        template <typename W>
+        struct wchar_transcoder<W, 4>
+        {
+          static std::basic_string<W>
+          to (const XMLCh* s, std::size_t length);
+
+          static XMLCh*
+          from (const W* s, std::size_t length);
+        };
+      }
+
+      template <>
+      inline std::basic_string<wchar_t>
+      transcode<wchar_t> (const XMLCh* s)
+      {
+        if (s == 0)
+          return std::basic_string<wchar_t> ();
+
+        return bits::wchar_transcoder<wchar_t, sizeof (wchar_t)>::to (
+          s, xercesc::XMLString::stringLen (s));
+      }
+
+      template <>
+      inline std::basic_string<wchar_t>
+      transcode<wchar_t> (const XMLCh* s, std::size_t len)
+      {
+        if (s == 0 || len == 0)
+          return std::basic_string<wchar_t> ();
+
+        return bits::wchar_transcoder<wchar_t, sizeof (wchar_t)>::to (
+          s, len);
+      }
+
+      template <>
+      inline XMLCh*
+      transcode_to_xmlch (const wchar_t* s)
+      {
+        return bits::wchar_transcoder<wchar_t, sizeof (wchar_t)>::from (
+          s, std::char_traits<wchar_t>::length (s));
+      }
+
+      template <>
+      inline XMLCh*
+      transcode_to_xmlch (const std::basic_string<wchar_t>& s)
+      {
+        return bits::wchar_transcoder<wchar_t, sizeof (wchar_t)>::from (
+          s.c_str (), s.length ());
+      }
+    }
+  }
+}
+
+#endif // XSD_CXX_XML_STRING_IXX_WCHAR
+#endif // XSD_USE_WCHAR
diff --git src/base/include/xsd/cxx/xml/string.txx src/base/include/xsd/cxx/xml/string.txx
new file mode 100644
index 0000000..df0fb74
--- /dev/null
+++ src/base/include/xsd/cxx/xml/string.txx
@@ -0,0 +1,151 @@
+// file      : xsd/cxx/xml/string.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_XML_STRING_TXX
+#define XSD_CXX_XML_STRING_TXX
+
+
+#endif // XSD_CXX_XML_STRING_TXX
+
+#if defined(XSD_USE_WCHAR) || !defined(XSD_USE_CHAR)
+
+#ifndef XSD_CXX_XML_STRING_TXX_WCHAR
+#define XSD_CXX_XML_STRING_TXX_WCHAR
+
+#include <xsd/cxx/xml/exceptions.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    namespace xml
+    {
+      namespace bits
+      {
+        // wchar_transcoder (specialization for 2-byte wchar_t)
+        //
+        template <typename W>
+        std::basic_string<W> wchar_transcoder<W, 2>::
+        to (const XMLCh* s, std::size_t length)
+        {
+          std::basic_string<W> r;
+          r.reserve (length + 1);
+          r.resize (length);
+          W* rs (const_cast<W*> (r.c_str ()));
+
+          for (std::size_t i (0); i < length; ++s, ++i)
+          {
+            rs[i] = *s;
+          }
+
+          return r;
+        }
+
+        template <typename W>
+        XMLCh* wchar_transcoder<W, 2>::
+        from (const W* s, std::size_t length)
+        {
+          auto_array<XMLCh> r (new XMLCh[length + 1]);
+          XMLCh* ir (r.get ());
+
+          for (std::size_t i (0); i < length; ++ir, ++i)
+          {
+            *ir = static_cast<XMLCh> (s[i]);
+          }
+
+          *ir = XMLCh (0);
+
+          return r.release ();
+        }
+
+
+        // wchar_transcoder (specialization for 4-byte wchar_t)
+        //
+        template <typename W>
+        std::basic_string<W> wchar_transcoder<W, 4>::
+        to (const XMLCh* s, std::size_t length)
+        {
+          const XMLCh* end (s + length);
+
+          // Find what the resulting buffer size will be.
+          //
+          std::size_t rl (0);
+
+          for (const XMLCh* p (s); p < end; ++p)
+          {
+            rl++;
+
+            if ((*p >= 0xD800) && (*p <= 0xDBFF))
+            {
+              // Make sure we have one more char and it has a valid
+              // value for the second char in a surrogate pair.
+              //
+              if (++p == end || !((*p >= 0xDC00) && (*p <= 0xDFFF)))
+                throw invalid_utf16_string ();
+            }
+          }
+
+          std::basic_string<W> r;
+          r.reserve (rl + 1);
+          r.resize (rl);
+          W* rs (const_cast<W*> (r.c_str ()));
+
+          std::size_t i (0);
+
+          for (const XMLCh* p (s); p < end; ++p)
+          {
+            XMLCh x (*p);
+
+            if (x < 0xD800 || x > 0xDBFF)
+              rs[i++] = W (x);
+            else
+              rs[i++] = ((x - 0xD800) << 10) + (*++p - 0xDC00) + 0x10000;
+          }
+
+          return r;
+        }
+
+        template <typename W>
+        XMLCh* wchar_transcoder<W, 4>::
+        from (const W* s, std::size_t length)
+        {
+          // Find what the resulting buffer size will be.
+          //
+          std::size_t rl (0);
+
+          for (const W* p (s); p < s + length; ++p)
+          {
+            rl += (*p & 0xFFFF0000) ? 2 : 1;
+          }
+
+          auto_array<XMLCh> r (new XMLCh[rl + 1]);
+          XMLCh* ir (r.get ());
+
+          for (const W* p (s); p < s + length; ++p)
+          {
+            W w (*p);
+
+            if (w & 0xFFFF0000)
+            {
+              // Surrogate pair.
+              //
+              *ir++ = static_cast<XMLCh> (((w - 0x10000) >> 10) + 0xD800);
+              *ir++ = static_cast<XMLCh> ((w & 0x3FF) + 0xDC00);
+            }
+            else
+              *ir++ = static_cast<XMLCh> (w);
+          }
+
+          *ir = XMLCh (0);
+
+          return r.release ();
+        }
+      }
+    }
+  }
+}
+
+#endif // XSD_CXX_XML_STRING_TXX_WCHAR
+#endif // XSD_USE_WCHAR
diff --git src/base/include/xsd/cxx/zc-istream.hxx src/base/include/xsd/cxx/zc-istream.hxx
new file mode 100644
index 0000000..2ae345f
--- /dev/null
+++ src/base/include/xsd/cxx/zc-istream.hxx
@@ -0,0 +1,217 @@
+// file      : xsd/cxx/zc-istream.hxx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+#ifndef XSD_CXX_ZC_ISTREAM_HXX
+#define XSD_CXX_ZC_ISTREAM_HXX
+
+#include <string>
+#include <istream>
+
+#include <xsd/cxx/ro-string.hxx>
+
+namespace xsd
+{
+  namespace cxx
+  {
+    // Input streambuffer that does not copy the underlying
+    // buffer (zero copy).
+    //
+    template <typename C>
+    class zc_streambuf: public std::basic_streambuf<C>
+    {
+    public:
+      typedef typename std::basic_streambuf<C>::int_type int_type;
+      typedef typename std::basic_streambuf<C>::traits_type traits_type;
+
+    public:
+      zc_streambuf (const ro_string<C>&);
+      zc_streambuf (const std::basic_string<C>&);
+
+    protected:
+      virtual std::streamsize
+      showmanyc ();
+
+      virtual int_type
+      underflow ();
+
+    private:
+      void
+      init ();
+
+    private:
+      zc_streambuf (const zc_streambuf&);
+
+      zc_streambuf&
+      operator= (const zc_streambuf&);
+
+    private:
+      ro_string<C> str_;
+    };
+
+
+    // Input string stream that does not copy the underlying string.
+    //
+    template <typename C>
+    class zc_istream_base
+    {
+    protected:
+      zc_istream_base (const ro_string<C>&);
+      zc_istream_base (const std::basic_string<C>&);
+
+    protected:
+      zc_streambuf<C> buf_;
+    };
+
+    template <typename C>
+    class zc_istream: protected zc_istream_base<C>,
+                      public std::basic_istream<C>
+    {
+      typedef std::basic_istream<C> base;
+
+    public:
+      zc_istream (const ro_string<C>&);
+      zc_istream (const std::basic_string<C>&);
+
+      bool
+      exhausted ()
+      {
+        return this->get () == std::basic_istream<C>::traits_type::eof ();
+      }
+
+      zc_istream&
+      operator>> (unsigned char& x)
+      {
+        if (check_unsigned ())
+          static_cast<base&> (*this) >> x;
+
+        return *this;
+      }
+
+      zc_istream&
+      operator>> (signed char& x)
+      {
+        if (check_signed ())
+          static_cast<base&> (*this) >> x;
+
+        return *this;
+      }
+
+      zc_istream&
+      operator>> (unsigned short& x)
+      {
+        if (check_unsigned ())
+          static_cast<base&> (*this) >> x;
+
+        return *this;
+      }
+
+      zc_istream&
+      operator>> (short& x)
+      {
+        if (check_signed ())
+          static_cast<base&> (*this) >> x;
+
+        return *this;
+      }
+
+      zc_istream&
+      operator>> (unsigned int& x)
+      {
+        if (check_unsigned ())
+          static_cast<base&> (*this) >> x;
+
+        return *this;
+      }
+
+      zc_istream&
+      operator>> (int& x)
+      {
+        if (check_signed ())
+          static_cast<base&> (*this) >> x;
+
+        return *this;
+      }
+
+      zc_istream&
+      operator>> (unsigned long& x)
+      {
+        if (check_unsigned ())
+          static_cast<base&> (*this) >> x;
+
+        return *this;
+      }
+
+      zc_istream&
+      operator>> (long& x)
+      {
+        if (check_signed ())
+          static_cast<base&> (*this) >> x;
+
+        return *this;
+      }
+
+      zc_istream&
+      operator>> (unsigned long long& x)
+      {
+        if (check_unsigned ())
+          static_cast<base&> (*this) >> x;
+
+        return *this;
+      }
+
+      zc_istream&
+      operator>> (long long& x)
+      {
+        if (check_signed ())
+          static_cast<base&> (*this) >> x;
+
+        return *this;
+      }
+
+      template <typename X>
+      zc_istream&
+      operator>> (X& x)
+      {
+        static_cast<base&> (*this) >> x;
+        return *this;
+      }
+
+    private:
+      bool
+      check_signed ()
+      {
+        typename std::basic_istream<C>::traits_type::int_type p (this->peek ());
+        bool r ((p >= C ('0') && p <= C ('9')) || p == C ('-') || p == C ('+'));
+
+        if (!r)
+          this->setstate (std::ios_base::failbit);
+
+        return r;
+      }
+
+      bool
+      check_unsigned ()
+      {
+        typename std::basic_istream<C>::traits_type::int_type p (this->peek ());
+        bool r ((p >= C ('0') && p <= C ('9')) || p == C ('+'));
+
+        if (!r)
+          this->setstate (std::ios_base::failbit);
+
+        return r;
+      }
+
+    private:
+      zc_istream (const zc_istream&);
+
+      zc_istream&
+      operator= (const zc_istream&);
+    };
+  }
+}
+
+#include <xsd/cxx/zc-istream.txx>
+
+#endif  // XSD_CXX_ZC_ISTREAM_HXX
diff --git src/base/include/xsd/cxx/zc-istream.txx src/base/include/xsd/cxx/zc-istream.txx
new file mode 100644
index 0000000..8c00a5b
--- /dev/null
+++ src/base/include/xsd/cxx/zc-istream.txx
@@ -0,0 +1,94 @@
+// file      : xsd/cxx/zc-istream.txx
+// author    : Boris Kolpackov <boris@codesynthesis.com>
+// copyright : Copyright (c) 2005-2010 Code Synthesis Tools CC
+// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file
+
+namespace xsd
+{
+  namespace cxx
+  {
+    // zc_streambuf
+    //
+    template <typename C>
+    zc_streambuf<C>::
+    zc_streambuf (const ro_string<C>& str)
+        : str_ (str.data (), str.size ())
+    {
+      init ();
+    }
+
+    template <typename C>
+    zc_streambuf<C>::
+    zc_streambuf (const std::basic_string<C>& str)
+        : str_ (str)
+    {
+      init ();
+    }
+
+    template <typename C>
+    void zc_streambuf<C>::
+    init ()
+    {
+      C* b (const_cast<C*> (str_.data ()));
+      C* e (b + str_.size ());
+
+      this->setg (b, b, e);
+    }
+
+    template <typename C>
+    std::streamsize zc_streambuf<C>::
+    showmanyc ()
+    {
+      return static_cast<std::streamsize> (
+        this->egptr () - this->gptr ());
+    }
+
+    template <typename C>
+    typename zc_streambuf<C>::int_type zc_streambuf<C>::
+    underflow ()
+    {
+      int_type r = traits_type::eof ();
+
+      if (this->gptr () < this->egptr ())
+        r = traits_type::to_int_type (*this->gptr ());
+
+      return r;
+    }
+
+
+    // zc_istream_base
+    //
+    template <typename C>
+    zc_istream_base<C>::
+    zc_istream_base (const ro_string<C>& str)
+        : buf_ (str)
+    {
+    }
+
+    template <typename C>
+    zc_istream_base<C>::
+    zc_istream_base (const std::basic_string<C>& str)
+        : buf_ (str)
+    {
+    }
+
+
+    // zc_istream
+    //
+    template <typename C>
+    zc_istream<C>::
+    zc_istream (const ro_string<C>& str)
+        : zc_istream_base<C> (str),
+          std::basic_istream<C> (&this->buf_)
+    {
+    }
+
+    template <typename C>
+    zc_istream<C>::
+    zc_istream (const std::basic_string<C>& str)
+        : zc_istream_base<C> (str),
+          std::basic_istream<C> (&this->buf_)
+    {
+    }
+  }
+}
diff --git src/configure.ac src/configure.ac
index 25272be..d4743f6 100644
--- src/configure.ac
+++ src/configure.ac
@@ -101,20 +101,6 @@ idldir=`pkg-config --variable=idldir omniORB4`
 AC_MSG_RESULT([$idldir])
 AC_SUBST(IDLDIR, [$idldir])
 
-dnl Executable is named xsdcxx in Fedora epel repo, REDHAWK dep is named xsd
-AC_CHECK_PROGS([XSD], [xsdcxx xsd], [no])
-if test x"$XSD" = xno ; then
-	AC_MSG_ERROR([Required program 'xsdcxx' is missing.])
-fi
-# Get the XSD version
-AC_MSG_CHECKING([xsd version])
-xsd_version=`${XSD} version 2>&1 | head -n 1 | awk '{print $8}'`
-if test "x$xsd_version" != "x3.3.0"; then
-    AC_MSG_FAILURE([XSD version 3.3.0 required])
-else
-    AC_MSG_RESULT([$xsd_version])
-fi
-AC_CHECK_HEADER([xsd/cxx/config.hxx], [], [AC_MSG_ERROR([missing XSD headers])])
 AC_CHECK_PROG([XMLCATALOG], [xmlcatalog], [xmlcatalog], [no])
 AM_CONDITIONAL(HAVE_XMLCATALOG, test $XMLCATALOG != "no")
 
@@ -146,16 +132,6 @@ OSSIE_ENABLE_PERSISTENCE
 
 m4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])
 
-AC_ARG_ENABLE([xml_validation], AS_HELP_STRING([--disable-xml-validation], [Disable xml validation in the parsers]))
-AC_MSG_CHECKING([if xml parsers should perform validation])
-if test "x$enable_xml_validation" != "xno"; then
-  AC_SUBST(OSSIE_XSDFLAGS, "--generate-validation")
-  AC_MSG_RESULT([yes])
-else
-  AC_SUBST(OSSIE_XSDFLAGS, "--suppress-validation")
-  AC_MSG_RESULT([no])
-fi
-
 # Allow user to explictly prevent JAVA compilation
 AC_ARG_ENABLE([java], AS_HELP_STRING([--disable-java], [Disable framework java support]))
 
diff --git src/control/parser/Makefile.am src/control/parser/Makefile.am
index da69166..c1a0168 100644
--- src/control/parser/Makefile.am
+++ src/control/parser/Makefile.am
@@ -46,23 +46,6 @@ libossieparser_la_SOURCES = Properties.cpp \
 			    internal/prf-pimpl.cpp \
 			    internal/profile-pimpl.cpp
 
-BUILT_SOURCES = internal/dcd-pskel.cpp \
-                internal/dmd-pskel.cpp \
-                internal/dpd-pskel.cpp \
-                internal/prf-pskel.cpp \
-                internal/profile-pskel.cpp \
-                internal/sad-pskel.cpp \
-                internal/scd-pskel.cpp \
-                internal/spd-pskel.cpp
-
-CLEANFILES = internal/dcd-pskel.h internal/dcd-pskel.cpp \
-             internal/dmd-pskel.h internal/dmd-pskel.cpp \
-             internal/dpd-pskel.h internal/dpd-pskel.cpp \
-             internal/prf-pskel.h internal/prf-pskel.cpp \
-             internal/profile-pskel.h internal/profile-pskel.cpp \
-             internal/sad-pskel.h internal/sad-pskel.cpp \
-             internal/scd-pskel.h internal/scd-pskel.cpp \
-             internal/spd-pskel.h internal/spd-pskel.cpp
 
 libossieparser_la_CXXFLAGS = -Wall $(STDINTF_CFLAGS) $(EXPAT_CFLAGS) $(BOOST_CPPFLAGS) 
 libossieparser_la_LIBADD = $(STDINTF_LIBS) $(EXPAT_LIBS)
@@ -70,55 +53,27 @@ libossieparser_la_LDFLAGS = -Wall $(EXPAT_LDFLAGS)
 
 AM_CPPFLAGS = -I../include -I. -I$(top_srcdir)/base/include
 
-XSDFLAGS = --hxx-suffix .h --cxx-suffix .cpp --xml-parser expat --output-dir internal $(OSSIE_XSDFLAGS)
-
 internal/dmd-pskel.cpp: $(top_srcdir)/xml/xsd/dmd.xsd internal/dmd.map
-# We need to keep xmlns items in the XSD, but we have to remove them from validation
-	-$(XSD) cxx-parser --root-element domainmanagerconfiguration --type-map internal/dmd.map $(XSDFLAGS) $<; sed -i 's/ns == "urn:mil:jpeojtrs:sca:dmd"/ns.empty()/g' internal/dmd-pskel.cpp; sed -i 's/"urn:mil:jpeojtrs:sca:dmd"/""/g' internal/dmd-pskel.cpp 
 
 internal/dcd-pskel.cpp: $(top_srcdir)/xml/xsd/dcd.xsd internal/dcd.map
-# We need to keep xmlns items in the XSD, but we have to remove them from validation
-	-$(XSD) cxx-parser --root-element deviceconfiguration --type-map internal/dcd.map $(XSDFLAGS) $<; sed -i 's/ns == "urn:mil:jpeojtrs:sca:dcd"/ns.empty()/g' internal/dcd-pskel.cpp; sed -i 's/"urn:mil:jpeojtrs:sca:dcd"/""/g' internal/dcd-pskel.cpp 
 
 internal/spd-pskel.cpp: $(top_srcdir)/xml/xsd/spd.xsd internal/spd.map
-# We need to keep xmlns items in the XSD, but we have to remove them from validation
-	-$(XSD) cxx-parser --root-element softpkg --type-map internal/spd.map $(XSDFLAGS) $<; sed -i 's/ns == "urn:mil:jpeojtrs:sca:spd"/ns.empty()/g' internal/spd-pskel.cpp; sed -i 's/"urn:mil:jpeojtrs:sca:spd"/""/g' internal/spd-pskel.cpp 
 
 internal/scd-pskel.cpp: $(top_srcdir)/xml/xsd/scd.xsd internal/scd.map
-	-$(XSD) cxx-parser --root-element softwarecomponent --type-map internal/scd.map $(XSDFLAGS) $<; sed -i 's/ns == "urn:mil:jpeojtrs:sca:scd"/ns.empty()/g' internal/scd-pskel.cpp; sed -i 's/"urn:mil:jpeojtrs:sca:scd"/""/g' internal/scd-pskel.cpp
 
 internal/sad-pskel.cpp: $(top_srcdir)/xml/xsd/sad.xsd internal/sad.map
-# We need to keep xmlns items in the XSD, but we have to remove them from validation
-	-$(XSD) cxx-parser --root-element softwareassembly --type-map internal/sad.map $(XSDFLAGS) $<; sed -i 's/ns == "urn:mil:jpeojtrs:sca:sad"/ns.empty()/g' internal/sad-pskel.cpp; sed -i 's/"urn:mil:jpeojtrs:sca:sad"/""/g' internal/sad-pskel.cpp
 
 internal/prf-pskel.cpp: $(top_srcdir)/xml/xsd/prf.xsd internal/prf.map
-# We need to keep xmlns items in the XSD, but we have to remove them from validation
-	-$(XSD) cxx-parser --root-element properties --type-map internal/prf.map $(XSDFLAGS) $<; sed -i 's/ns == "urn:mil:jpeojtrs:sca:prf"/ns.empty()/g' internal/prf-pskel.cpp; sed -i 's/"urn:mil:jpeojtrs:sca:prf"/""/g' internal/prf-pskel.cpp
 
 internal/dpd-pskel.cpp: $(top_srcdir)/xml/xsd/dpd.xsd
-	-$(XSD) cxx-parser --root-element devicepkg $(XSDFLAGS) $<
 
 internal/profile-pskel.cpp: $(top_srcdir)/xml/xsd/profile.xsd
-	-$(XSD) cxx-parser --root-element profile $(XSDFLAGS) $<
 
 .PHONY: generate_noop_impl generate_test_driver
 
 generate_noop_impl:
-	-$(XSD) cxx-parser --output-dir internal --root-element domainmanagerconfiguration --type-map internal/dmd.map $(XSDFLAGS) --generate-noop-impl $(top_srcdir)/xml/xsd/dmd.xsd
-	-$(XSD) cxx-parser --output-dir internal --root-element properties --type-map internal/prf.map $(XSDFLAGS) --generate-noop-impl $(top_srcdir)/xml/xsd/prf.xsd
-	-$(XSD) cxx-parser --output-dir internal --root-element softwarecomponent --type-map internal/scd.map $(XSDFLAGS) --generate-noop-impl $(top_srcdir)/xml/xsd/scd.xsd
-	-$(XSD) cxx-parser --output-dir internal --root-element softpkg --type-map internal/spd.map $(XSDFLAGS) --generate-noop-impl $(top_srcdir)/xml/xsd/spd.xsd
-	-$(XSD) cxx-parser --output-dir internal --root-element deviceconfiguration --type-map internal/dcd.map $(XSDFLAGS) --generate-noop-impl $(top_srcdir)/xml/xsd/dcd.xsd
-	-$(XSD) cxx-parser --output-dir internal --root-element softwareassembly --type-map internal/sad.map $(XSDFLAGS) --generate-noop-impl $(top_srcdir)/xml/xsd/sad.xsd
 
 generate_test_driver:
-	rm -f internal/*-driver.cpp
-	-$(XSD) cxx-parser --output-dir internal --root-element domainmanagerconfiguration --type-map internal/dmd.map $(XSDFLAGS) --generate-test-driver $(top_srcdir)/xml/xsd/dmd.xsd
-	-$(XSD) cxx-parser --output-dir internal --root-element properties --type-map internal/prf.map $(XSDFLAGS) --generate-test-driver $(top_srcdir)/xml/xsd/prf.xsd
-	-$(XSD) cxx-parser --output-dir internal --root-element softwarecomponent --type-map internal/scd.map $(XSDFLAGS) --generate-test-driver $(top_srcdir)/xml/xsd/scd.xsd
-	-$(XSD) cxx-parser --output-dir internal --root-element softpkg --type-map internal/spd.map $(XSDFLAGS) --generate-test-driver $(top_srcdir)/xml/xsd/spd.xsd
-	-$(XSD) cxx-parser --output-dir internal --root-element deviceconfiguration --type-map internal/dcd.map $(XSDFLAGS) --generate-test-driver $(top_srcdir)/xml/xsd/dcd.xsd
-	-$(XSD) cxx-parser --output-dir internal --root-element softwareassembly --type-map internal/sad.map $(XSDFLAGS) --generate-test-driver $(top_srcdir)/xml/xsd/sad.xsd
 
 clean-local:
 	rm -f internal/*-driver.cpp
diff --git src/control/parser/internal/.gitignore src/control/parser/internal/.gitignore
deleted file mode 100644
index 8e1bf49..0000000
--- src/control/parser/internal/.gitignore
+++ /dev/null
@@ -1,17 +0,0 @@
-dcd-pskel.cpp
-dcd-pskel.h
-dmd-pskel.cpp
-dmd-pskel.h
-dpd-pskel.cpp
-dpd-pskel.h
-prf-pskel.cpp
-prf-pskel.h
-profile-pskel.cpp
-profile-pskel.h
-sad-pskel.cpp
-sad-pskel.h
-scd-pskel.cpp
-scd-pskel.h
-spd-pskel.cpp
-spd-pskel.h
-
diff --git src/control/parser/internal/dcd-pskel.cpp src/control/parser/internal/dcd-pskel.cpp
new file mode 100644
index 0000000..87a8ce5
--- /dev/null
+++ src/control/parser/internal/dcd-pskel.cpp
@@ -0,0 +1,8273 @@
+// Copyright (C) 2005-2010 Code Synthesis Tools CC
+//
+// This program was generated by CodeSynthesis XSD, an XML Schema to
+// C++ data binding compiler.
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 2 as
+// published by the Free Software Foundation.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+//
+// In addition, as a special exception, Code Synthesis Tools CC gives
+// permission to link this program with the Xerces-C++ library (or with
+// modified versions of Xerces-C++ that use the same license as Xerces-C++),
+// and distribute linked combinations including the two. You must obey
+// the GNU General Public License version 2 in all respects for all of
+// the code used other than Xerces-C++. If you modify this copy of the
+// program, you may extend this exception to your version of the program,
+// but you are not obligated to do so. If you do not wish to do so, delete
+// this exception statement from your version.
+//
+// Furthermore, Code Synthesis Tools CC makes a special exception for
+// the Free/Libre and Open Source Software (FLOSS) which is described
+// in the accompanying FLOSSE file.
+//
+
+// Begin prologue.
+//
+//
+// End prologue.
+
+#include "dcd-pskel.h"
+
+namespace dcd
+{
+  // deviceconfiguration_pskel
+  //
+
+  void deviceconfiguration_pskel::
+  description_parser (::xml_schema::string_pskel& p)
+  {
+    this->description_parser_ = &p;
+  }
+
+  void deviceconfiguration_pskel::
+  devicemanagersoftpkg_parser (::dcd::devicemanagersoftpkg_pskel& p)
+  {
+    this->devicemanagersoftpkg_parser_ = &p;
+  }
+
+  void deviceconfiguration_pskel::
+  componentfiles_parser (::dcd::componentfiles_pskel& p)
+  {
+    this->componentfiles_parser_ = &p;
+  }
+
+  void deviceconfiguration_pskel::
+  partitioning_parser (::dcd::partitioning_pskel& p)
+  {
+    this->partitioning_parser_ = &p;
+  }
+
+  void deviceconfiguration_pskel::
+  connections_parser (::dcd::connections_pskel& p)
+  {
+    this->connections_parser_ = &p;
+  }
+
+  void deviceconfiguration_pskel::
+  domainmanager_parser (::dcd::domainmanager_pskel& p)
+  {
+    this->domainmanager_parser_ = &p;
+  }
+
+  void deviceconfiguration_pskel::
+  filesystemnames_parser (::dcd::filesystemnames_pskel& p)
+  {
+    this->filesystemnames_parser_ = &p;
+  }
+
+  void deviceconfiguration_pskel::
+  id_parser (::xml_schema::string_pskel& p)
+  {
+    this->id_parser_ = &p;
+  }
+
+  void deviceconfiguration_pskel::
+  name_parser (::xml_schema::string_pskel& p)
+  {
+    this->name_parser_ = &p;
+  }
+
+  void deviceconfiguration_pskel::
+  parsers (::xml_schema::string_pskel& description,
+           ::dcd::devicemanagersoftpkg_pskel& devicemanagersoftpkg,
+           ::dcd::componentfiles_pskel& componentfiles,
+           ::dcd::partitioning_pskel& partitioning,
+           ::dcd::connections_pskel& connections,
+           ::dcd::domainmanager_pskel& domainmanager,
+           ::dcd::filesystemnames_pskel& filesystemnames,
+           ::xml_schema::string_pskel& id,
+           ::xml_schema::string_pskel& name)
+  {
+    this->description_parser_ = &description;
+    this->devicemanagersoftpkg_parser_ = &devicemanagersoftpkg;
+    this->componentfiles_parser_ = &componentfiles;
+    this->partitioning_parser_ = &partitioning;
+    this->connections_parser_ = &connections;
+    this->domainmanager_parser_ = &domainmanager;
+    this->filesystemnames_parser_ = &filesystemnames;
+    this->id_parser_ = &id;
+    this->name_parser_ = &name;
+  }
+
+  deviceconfiguration_pskel::
+  deviceconfiguration_pskel ()
+  : description_parser_ (0),
+    devicemanagersoftpkg_parser_ (0),
+    componentfiles_parser_ (0),
+    partitioning_parser_ (0),
+    connections_parser_ (0),
+    domainmanager_parser_ (0),
+    filesystemnames_parser_ (0),
+    id_parser_ (0),
+    name_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // devicemanagersoftpkg_pskel
+  //
+
+  void devicemanagersoftpkg_pskel::
+  localfile_parser (::dcd::localfile_pskel& p)
+  {
+    this->localfile_parser_ = &p;
+  }
+
+  void devicemanagersoftpkg_pskel::
+  parsers (::dcd::localfile_pskel& localfile)
+  {
+    this->localfile_parser_ = &localfile;
+  }
+
+  devicemanagersoftpkg_pskel::
+  devicemanagersoftpkg_pskel ()
+  : localfile_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // componentfiles_pskel
+  //
+
+  void componentfiles_pskel::
+  componentfile_parser (::dcd::componentfile_pskel& p)
+  {
+    this->componentfile_parser_ = &p;
+  }
+
+  void componentfiles_pskel::
+  parsers (::dcd::componentfile_pskel& componentfile)
+  {
+    this->componentfile_parser_ = &componentfile;
+  }
+
+  componentfiles_pskel::
+  componentfiles_pskel ()
+  : componentfile_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // componentfile_pskel
+  //
+
+  void componentfile_pskel::
+  localfile_parser (::dcd::localfile_pskel& p)
+  {
+    this->localfile_parser_ = &p;
+  }
+
+  void componentfile_pskel::
+  id_parser (::xml_schema::string_pskel& p)
+  {
+    this->id_parser_ = &p;
+  }
+
+  void componentfile_pskel::
+  type_parser (::xml_schema::string_pskel& p)
+  {
+    this->type_parser_ = &p;
+  }
+
+  void componentfile_pskel::
+  parsers (::dcd::localfile_pskel& localfile,
+           ::xml_schema::string_pskel& id,
+           ::xml_schema::string_pskel& type)
+  {
+    this->localfile_parser_ = &localfile;
+    this->id_parser_ = &id;
+    this->type_parser_ = &type;
+  }
+
+  componentfile_pskel::
+  componentfile_pskel ()
+  : localfile_parser_ (0),
+    id_parser_ (0),
+    type_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // localfile_pskel
+  //
+
+  void localfile_pskel::
+  name_parser (::xml_schema::string_pskel& p)
+  {
+    this->name_parser_ = &p;
+  }
+
+  void localfile_pskel::
+  parsers (::xml_schema::string_pskel& name)
+  {
+    this->name_parser_ = &name;
+  }
+
+  localfile_pskel::
+  localfile_pskel ()
+  : name_parser_ (0),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // partitioning_pskel
+  //
+
+  void partitioning_pskel::
+  componentplacement_parser (::dcd::componentplacement_pskel& p)
+  {
+    this->componentplacement_parser_ = &p;
+  }
+
+  void partitioning_pskel::
+  parsers (::dcd::componentplacement_pskel& componentplacement)
+  {
+    this->componentplacement_parser_ = &componentplacement;
+  }
+
+  partitioning_pskel::
+  partitioning_pskel ()
+  : componentplacement_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // componentplacement_pskel
+  //
+
+  void componentplacement_pskel::
+  componentfileref_parser (::dcd::componentfileref_pskel& p)
+  {
+    this->componentfileref_parser_ = &p;
+  }
+
+  void componentplacement_pskel::
+  deployondevice_parser (::dcd::deployondevice_pskel& p)
+  {
+    this->deployondevice_parser_ = &p;
+  }
+
+  void componentplacement_pskel::
+  compositepartofdevice_parser (::dcd::compositepartofdevice_pskel& p)
+  {
+    this->compositepartofdevice_parser_ = &p;
+  }
+
+  void componentplacement_pskel::
+  devicepkgfile_parser (::dcd::devicepkgfile_pskel& p)
+  {
+    this->devicepkgfile_parser_ = &p;
+  }
+
+  void componentplacement_pskel::
+  componentinstantiation_parser (::dcd::componentinstantiation_pskel& p)
+  {
+    this->componentinstantiation_parser_ = &p;
+  }
+
+  void componentplacement_pskel::
+  parsers (::dcd::componentfileref_pskel& componentfileref,
+           ::dcd::deployondevice_pskel& deployondevice,
+           ::dcd::compositepartofdevice_pskel& compositepartofdevice,
+           ::dcd::devicepkgfile_pskel& devicepkgfile,
+           ::dcd::componentinstantiation_pskel& componentinstantiation)
+  {
+    this->componentfileref_parser_ = &componentfileref;
+    this->deployondevice_parser_ = &deployondevice;
+    this->compositepartofdevice_parser_ = &compositepartofdevice;
+    this->devicepkgfile_parser_ = &devicepkgfile;
+    this->componentinstantiation_parser_ = &componentinstantiation;
+  }
+
+  componentplacement_pskel::
+  componentplacement_pskel ()
+  : componentfileref_parser_ (0),
+    deployondevice_parser_ (0),
+    compositepartofdevice_parser_ (0),
+    devicepkgfile_parser_ (0),
+    componentinstantiation_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // componentfileref_pskel
+  //
+
+  void componentfileref_pskel::
+  refid_parser (::xml_schema::string_pskel& p)
+  {
+    this->refid_parser_ = &p;
+  }
+
+  void componentfileref_pskel::
+  parsers (::xml_schema::string_pskel& refid)
+  {
+    this->refid_parser_ = &refid;
+  }
+
+  componentfileref_pskel::
+  componentfileref_pskel ()
+  : refid_parser_ (0),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // deployondevice_pskel
+  //
+
+  void deployondevice_pskel::
+  refid_parser (::xml_schema::string_pskel& p)
+  {
+    this->refid_parser_ = &p;
+  }
+
+  void deployondevice_pskel::
+  parsers (::xml_schema::string_pskel& refid)
+  {
+    this->refid_parser_ = &refid;
+  }
+
+  deployondevice_pskel::
+  deployondevice_pskel ()
+  : refid_parser_ (0),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // compositepartofdevice_pskel
+  //
+
+  void compositepartofdevice_pskel::
+  refid_parser (::xml_schema::string_pskel& p)
+  {
+    this->refid_parser_ = &p;
+  }
+
+  void compositepartofdevice_pskel::
+  parsers (::xml_schema::string_pskel& refid)
+  {
+    this->refid_parser_ = &refid;
+  }
+
+  compositepartofdevice_pskel::
+  compositepartofdevice_pskel ()
+  : refid_parser_ (0),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // devicepkgfile_pskel
+  //
+
+  void devicepkgfile_pskel::
+  localfile_parser (::dcd::localfile_pskel& p)
+  {
+    this->localfile_parser_ = &p;
+  }
+
+  void devicepkgfile_pskel::
+  type_parser (::xml_schema::string_pskel& p)
+  {
+    this->type_parser_ = &p;
+  }
+
+  void devicepkgfile_pskel::
+  parsers (::dcd::localfile_pskel& localfile,
+           ::xml_schema::string_pskel& type)
+  {
+    this->localfile_parser_ = &localfile;
+    this->type_parser_ = &type;
+  }
+
+  devicepkgfile_pskel::
+  devicepkgfile_pskel ()
+  : localfile_parser_ (0),
+    type_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // componentinstantiation_pskel
+  //
+
+  void componentinstantiation_pskel::
+  usagename_parser (::xml_schema::string_pskel& p)
+  {
+    this->usagename_parser_ = &p;
+  }
+
+  void componentinstantiation_pskel::
+  componentproperties_parser (::dcd::componentproperties_pskel& p)
+  {
+    this->componentproperties_parser_ = &p;
+  }
+
+  void componentinstantiation_pskel::
+  affinity_parser (::dcd::affinity_pskel& p)
+  {
+    this->affinity_parser_ = &p;
+  }
+
+  void componentinstantiation_pskel::
+  loggingconfig_parser (::dcd::loggingconfig_pskel& p)
+  {
+    this->loggingconfig_parser_ = &p;
+  }
+
+  void componentinstantiation_pskel::
+  id_parser (::xml_schema::string_pskel& p)
+  {
+    this->id_parser_ = &p;
+  }
+
+  void componentinstantiation_pskel::
+  parsers (::xml_schema::string_pskel& usagename,
+           ::dcd::componentproperties_pskel& componentproperties,
+           ::dcd::affinity_pskel& affinity,
+           ::dcd::loggingconfig_pskel& loggingconfig,
+           ::xml_schema::string_pskel& id)
+  {
+    this->usagename_parser_ = &usagename;
+    this->componentproperties_parser_ = &componentproperties;
+    this->affinity_parser_ = &affinity;
+    this->loggingconfig_parser_ = &loggingconfig;
+    this->id_parser_ = &id;
+  }
+
+  componentinstantiation_pskel::
+  componentinstantiation_pskel ()
+  : usagename_parser_ (0),
+    componentproperties_parser_ (0),
+    affinity_parser_ (0),
+    loggingconfig_parser_ (0),
+    id_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // loggingconfig_pskel
+  //
+
+  void loggingconfig_pskel::
+  level_parser (::xml_schema::string_pskel& p)
+  {
+    this->level_parser_ = &p;
+  }
+
+  void loggingconfig_pskel::
+  parsers (::xml_schema::string_pskel& level)
+  {
+    this->level_parser_ = &level;
+  }
+
+  loggingconfig_pskel::
+  loggingconfig_pskel ()
+  : level_parser_ (0)
+  {
+  }
+
+  // affinity_pskel
+  //
+
+  void affinity_pskel::
+  simpleref_parser (::dcd::simpleref_pskel& p)
+  {
+    this->simpleref_parser_ = &p;
+  }
+
+  void affinity_pskel::
+  simplesequenceref_parser (::dcd::simplesequenceref_pskel& p)
+  {
+    this->simplesequenceref_parser_ = &p;
+  }
+
+  void affinity_pskel::
+  structref_parser (::dcd::structref_pskel& p)
+  {
+    this->structref_parser_ = &p;
+  }
+
+  void affinity_pskel::
+  structsequenceref_parser (::dcd::structsequenceref_pskel& p)
+  {
+    this->structsequenceref_parser_ = &p;
+  }
+
+  void affinity_pskel::
+  parsers (::dcd::simpleref_pskel& simpleref,
+           ::dcd::simplesequenceref_pskel& simplesequenceref,
+           ::dcd::structref_pskel& structref,
+           ::dcd::structsequenceref_pskel& structsequenceref)
+  {
+    this->simpleref_parser_ = &simpleref;
+    this->simplesequenceref_parser_ = &simplesequenceref;
+    this->structref_parser_ = &structref;
+    this->structsequenceref_parser_ = &structsequenceref;
+  }
+
+  affinity_pskel::
+  affinity_pskel ()
+  : simpleref_parser_ (0),
+    simplesequenceref_parser_ (0),
+    structref_parser_ (0),
+    structsequenceref_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // componentproperties_pskel
+  //
+
+  void componentproperties_pskel::
+  simpleref_parser (::dcd::simpleref_pskel& p)
+  {
+    this->simpleref_parser_ = &p;
+  }
+
+  void componentproperties_pskel::
+  simplesequenceref_parser (::dcd::simplesequenceref_pskel& p)
+  {
+    this->simplesequenceref_parser_ = &p;
+  }
+
+  void componentproperties_pskel::
+  structref_parser (::dcd::structref_pskel& p)
+  {
+    this->structref_parser_ = &p;
+  }
+
+  void componentproperties_pskel::
+  structsequenceref_parser (::dcd::structsequenceref_pskel& p)
+  {
+    this->structsequenceref_parser_ = &p;
+  }
+
+  void componentproperties_pskel::
+  parsers (::dcd::simpleref_pskel& simpleref,
+           ::dcd::simplesequenceref_pskel& simplesequenceref,
+           ::dcd::structref_pskel& structref,
+           ::dcd::structsequenceref_pskel& structsequenceref)
+  {
+    this->simpleref_parser_ = &simpleref;
+    this->simplesequenceref_parser_ = &simplesequenceref;
+    this->structref_parser_ = &structref;
+    this->structsequenceref_parser_ = &structsequenceref;
+  }
+
+  componentproperties_pskel::
+  componentproperties_pskel ()
+  : simpleref_parser_ (0),
+    simplesequenceref_parser_ (0),
+    structref_parser_ (0),
+    structsequenceref_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // devicethatloadedthiscomponentref_pskel
+  //
+
+  void devicethatloadedthiscomponentref_pskel::
+  refid_parser (::xml_schema::string_pskel& p)
+  {
+    this->refid_parser_ = &p;
+  }
+
+  void devicethatloadedthiscomponentref_pskel::
+  parsers (::xml_schema::string_pskel& refid)
+  {
+    this->refid_parser_ = &refid;
+  }
+
+  devicethatloadedthiscomponentref_pskel::
+  devicethatloadedthiscomponentref_pskel ()
+  : refid_parser_ (0),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // deviceusedbythiscomponentref_pskel
+  //
+
+  void deviceusedbythiscomponentref_pskel::
+  refid_parser (::xml_schema::string_pskel& p)
+  {
+    this->refid_parser_ = &p;
+  }
+
+  void deviceusedbythiscomponentref_pskel::
+  usesrefid_parser (::xml_schema::string_pskel& p)
+  {
+    this->usesrefid_parser_ = &p;
+  }
+
+  void deviceusedbythiscomponentref_pskel::
+  parsers (::xml_schema::string_pskel& refid,
+           ::xml_schema::string_pskel& usesrefid)
+  {
+    this->refid_parser_ = &refid;
+    this->usesrefid_parser_ = &usesrefid;
+  }
+
+  deviceusedbythiscomponentref_pskel::
+  deviceusedbythiscomponentref_pskel ()
+  : refid_parser_ (0),
+    usesrefid_parser_ (0),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // simpleref_pskel
+  //
+
+  void simpleref_pskel::
+  refid_parser (::xml_schema::string_pskel& p)
+  {
+    this->refid_parser_ = &p;
+  }
+
+  void simpleref_pskel::
+  value_parser (::xml_schema::string_pskel& p)
+  {
+    this->value_parser_ = &p;
+  }
+
+  void simpleref_pskel::
+  parsers (::xml_schema::string_pskel& refid,
+           ::xml_schema::string_pskel& value)
+  {
+    this->refid_parser_ = &refid;
+    this->value_parser_ = &value;
+  }
+
+  simpleref_pskel::
+  simpleref_pskel ()
+  : refid_parser_ (0),
+    value_parser_ (0),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // simplesequenceref_pskel
+  //
+
+  void simplesequenceref_pskel::
+  values_parser (::dcd::values_pskel& p)
+  {
+    this->values_parser_ = &p;
+  }
+
+  void simplesequenceref_pskel::
+  refid_parser (::xml_schema::string_pskel& p)
+  {
+    this->refid_parser_ = &p;
+  }
+
+  void simplesequenceref_pskel::
+  parsers (::dcd::values_pskel& values,
+           ::xml_schema::string_pskel& refid)
+  {
+    this->values_parser_ = &values;
+    this->refid_parser_ = &refid;
+  }
+
+  simplesequenceref_pskel::
+  simplesequenceref_pskel ()
+  : values_parser_ (0),
+    refid_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // structref_pskel
+  //
+
+  void structref_pskel::
+  simpleref_parser (::dcd::simpleref_pskel& p)
+  {
+    this->simpleref_parser_ = &p;
+  }
+
+  void structref_pskel::
+  simplesequenceref_parser (::dcd::simplesequenceref_pskel& p)
+  {
+    this->simplesequenceref_parser_ = &p;
+  }
+
+  void structref_pskel::
+  refid_parser (::xml_schema::string_pskel& p)
+  {
+    this->refid_parser_ = &p;
+  }
+
+  void structref_pskel::
+  parsers (::dcd::simpleref_pskel& simpleref,
+           ::dcd::simplesequenceref_pskel& simplesequenceref,
+           ::xml_schema::string_pskel& refid)
+  {
+    this->simpleref_parser_ = &simpleref;
+    this->simplesequenceref_parser_ = &simplesequenceref;
+    this->refid_parser_ = &refid;
+  }
+
+  structref_pskel::
+  structref_pskel ()
+  : simpleref_parser_ (0),
+    simplesequenceref_parser_ (0),
+    refid_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // structsequenceref_pskel
+  //
+
+  void structsequenceref_pskel::
+  structvalue_parser (::dcd::structvalue_pskel& p)
+  {
+    this->structvalue_parser_ = &p;
+  }
+
+  void structsequenceref_pskel::
+  refid_parser (::xml_schema::string_pskel& p)
+  {
+    this->refid_parser_ = &p;
+  }
+
+  void structsequenceref_pskel::
+  parsers (::dcd::structvalue_pskel& structvalue,
+           ::xml_schema::string_pskel& refid)
+  {
+    this->structvalue_parser_ = &structvalue;
+    this->refid_parser_ = &refid;
+  }
+
+  structsequenceref_pskel::
+  structsequenceref_pskel ()
+  : structvalue_parser_ (0),
+    refid_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // structvalue_pskel
+  //
+
+  void structvalue_pskel::
+  simpleref_parser (::dcd::simpleref_pskel& p)
+  {
+    this->simpleref_parser_ = &p;
+  }
+
+  void structvalue_pskel::
+  simplesequenceref_parser (::dcd::simplesequenceref_pskel& p)
+  {
+    this->simplesequenceref_parser_ = &p;
+  }
+
+  void structvalue_pskel::
+  parsers (::dcd::simpleref_pskel& simpleref,
+           ::dcd::simplesequenceref_pskel& simplesequenceref)
+  {
+    this->simpleref_parser_ = &simpleref;
+    this->simplesequenceref_parser_ = &simplesequenceref;
+  }
+
+  structvalue_pskel::
+  structvalue_pskel ()
+  : simpleref_parser_ (0),
+    simplesequenceref_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // values_pskel
+  //
+
+  void values_pskel::
+  value_parser (::xml_schema::string_pskel& p)
+  {
+    this->value_parser_ = &p;
+  }
+
+  void values_pskel::
+  parsers (::xml_schema::string_pskel& value)
+  {
+    this->value_parser_ = &value;
+  }
+
+  values_pskel::
+  values_pskel ()
+  : value_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // componentinstantiationref_pskel
+  //
+
+  void componentinstantiationref_pskel::
+  refid_parser (::xml_schema::string_pskel& p)
+  {
+    this->refid_parser_ = &p;
+  }
+
+  void componentinstantiationref_pskel::
+  parsers (::xml_schema::string_pskel& refid)
+  {
+    this->refid_parser_ = &refid;
+  }
+
+  componentinstantiationref_pskel::
+  componentinstantiationref_pskel ()
+  : refid_parser_ (0),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // domainmanager_pskel
+  //
+
+  void domainmanager_pskel::
+  namingservice_parser (::dcd::namingservice_pskel& p)
+  {
+    this->namingservice_parser_ = &p;
+  }
+
+  void domainmanager_pskel::
+  stringifiedobjectref_parser (::xml_schema::string_pskel& p)
+  {
+    this->stringifiedobjectref_parser_ = &p;
+  }
+
+  void domainmanager_pskel::
+  parsers (::dcd::namingservice_pskel& namingservice,
+           ::xml_schema::string_pskel& stringifiedobjectref)
+  {
+    this->namingservice_parser_ = &namingservice;
+    this->stringifiedobjectref_parser_ = &stringifiedobjectref;
+  }
+
+  domainmanager_pskel::
+  domainmanager_pskel ()
+  : namingservice_parser_ (0),
+    stringifiedobjectref_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // findby_pskel
+  //
+
+  void findby_pskel::
+  namingservice_parser (::dcd::namingservice_pskel& p)
+  {
+    this->namingservice_parser_ = &p;
+  }
+
+  void findby_pskel::
+  stringifiedobjectref_parser (::xml_schema::string_pskel& p)
+  {
+    this->stringifiedobjectref_parser_ = &p;
+  }
+
+  void findby_pskel::
+  domainfinder_parser (::dcd::domainfinder_pskel& p)
+  {
+    this->domainfinder_parser_ = &p;
+  }
+
+  void findby_pskel::
+  parsers (::dcd::namingservice_pskel& namingservice,
+           ::xml_schema::string_pskel& stringifiedobjectref,
+           ::dcd::domainfinder_pskel& domainfinder)
+  {
+    this->namingservice_parser_ = &namingservice;
+    this->stringifiedobjectref_parser_ = &stringifiedobjectref;
+    this->domainfinder_parser_ = &domainfinder;
+  }
+
+  findby_pskel::
+  findby_pskel ()
+  : namingservice_parser_ (0),
+    stringifiedobjectref_parser_ (0),
+    domainfinder_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // namingservice_pskel
+  //
+
+  void namingservice_pskel::
+  name_parser (::xml_schema::string_pskel& p)
+  {
+    this->name_parser_ = &p;
+  }
+
+  void namingservice_pskel::
+  parsers (::xml_schema::string_pskel& name)
+  {
+    this->name_parser_ = &name;
+  }
+
+  namingservice_pskel::
+  namingservice_pskel ()
+  : name_parser_ (0),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // domainfinder_pskel
+  //
+
+  void domainfinder_pskel::
+  type_parser (::xml_schema::string_pskel& p)
+  {
+    this->type_parser_ = &p;
+  }
+
+  void domainfinder_pskel::
+  name_parser (::xml_schema::string_pskel& p)
+  {
+    this->name_parser_ = &p;
+  }
+
+  void domainfinder_pskel::
+  parsers (::xml_schema::string_pskel& type,
+           ::xml_schema::string_pskel& name)
+  {
+    this->type_parser_ = &type;
+    this->name_parser_ = &name;
+  }
+
+  domainfinder_pskel::
+  domainfinder_pskel ()
+  : type_parser_ (0),
+    name_parser_ (0),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // filesystemnames_pskel
+  //
+
+  void filesystemnames_pskel::
+  filesystemname_parser (::dcd::filesystemname_pskel& p)
+  {
+    this->filesystemname_parser_ = &p;
+  }
+
+  void filesystemnames_pskel::
+  parsers (::dcd::filesystemname_pskel& filesystemname)
+  {
+    this->filesystemname_parser_ = &filesystemname;
+  }
+
+  filesystemnames_pskel::
+  filesystemnames_pskel ()
+  : filesystemname_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // filesystemname_pskel
+  //
+
+  void filesystemname_pskel::
+  mountname_parser (::xml_schema::string_pskel& p)
+  {
+    this->mountname_parser_ = &p;
+  }
+
+  void filesystemname_pskel::
+  deviceid_parser (::xml_schema::string_pskel& p)
+  {
+    this->deviceid_parser_ = &p;
+  }
+
+  void filesystemname_pskel::
+  parsers (::xml_schema::string_pskel& mountname,
+           ::xml_schema::string_pskel& deviceid)
+  {
+    this->mountname_parser_ = &mountname;
+    this->deviceid_parser_ = &deviceid;
+  }
+
+  filesystemname_pskel::
+  filesystemname_pskel ()
+  : mountname_parser_ (0),
+    deviceid_parser_ (0),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // connections_pskel
+  //
+
+  void connections_pskel::
+  connectinterface_parser (::dcd::connectinterface_pskel& p)
+  {
+    this->connectinterface_parser_ = &p;
+  }
+
+  void connections_pskel::
+  parsers (::dcd::connectinterface_pskel& connectinterface)
+  {
+    this->connectinterface_parser_ = &connectinterface;
+  }
+
+  connections_pskel::
+  connections_pskel ()
+  : connectinterface_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // connectinterface_pskel
+  //
+
+  void connectinterface_pskel::
+  usesport_parser (::dcd::usesport_pskel& p)
+  {
+    this->usesport_parser_ = &p;
+  }
+
+  void connectinterface_pskel::
+  providesport_parser (::dcd::providesport_pskel& p)
+  {
+    this->providesport_parser_ = &p;
+  }
+
+  void connectinterface_pskel::
+  componentsupportedinterface_parser (::dcd::componentsupportedinterface_pskel& p)
+  {
+    this->componentsupportedinterface_parser_ = &p;
+  }
+
+  void connectinterface_pskel::
+  findby_parser (::dcd::findby_pskel& p)
+  {
+    this->findby_parser_ = &p;
+  }
+
+  void connectinterface_pskel::
+  id_parser (::xml_schema::string_pskel& p)
+  {
+    this->id_parser_ = &p;
+  }
+
+  void connectinterface_pskel::
+  parsers (::dcd::usesport_pskel& usesport,
+           ::dcd::providesport_pskel& providesport,
+           ::dcd::componentsupportedinterface_pskel& componentsupportedinterface,
+           ::dcd::findby_pskel& findby,
+           ::xml_schema::string_pskel& id)
+  {
+    this->usesport_parser_ = &usesport;
+    this->providesport_parser_ = &providesport;
+    this->componentsupportedinterface_parser_ = &componentsupportedinterface;
+    this->findby_parser_ = &findby;
+    this->id_parser_ = &id;
+  }
+
+  connectinterface_pskel::
+  connectinterface_pskel ()
+  : usesport_parser_ (0),
+    providesport_parser_ (0),
+    componentsupportedinterface_parser_ (0),
+    findby_parser_ (0),
+    id_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // usesport_pskel
+  //
+
+  void usesport_pskel::
+  usesidentifier_parser (::xml_schema::string_pskel& p)
+  {
+    this->usesidentifier_parser_ = &p;
+  }
+
+  void usesport_pskel::
+  componentinstantiationref_parser (::dcd::componentinstantiationref_pskel& p)
+  {
+    this->componentinstantiationref_parser_ = &p;
+  }
+
+  void usesport_pskel::
+  devicethatloadedthiscomponentref_parser (::dcd::devicethatloadedthiscomponentref_pskel& p)
+  {
+    this->devicethatloadedthiscomponentref_parser_ = &p;
+  }
+
+  void usesport_pskel::
+  deviceusedbythiscomponentref_parser (::dcd::deviceusedbythiscomponentref_pskel& p)
+  {
+    this->deviceusedbythiscomponentref_parser_ = &p;
+  }
+
+  void usesport_pskel::
+  findby_parser (::dcd::findby_pskel& p)
+  {
+    this->findby_parser_ = &p;
+  }
+
+  void usesport_pskel::
+  parsers (::xml_schema::string_pskel& usesidentifier,
+           ::dcd::componentinstantiationref_pskel& componentinstantiationref,
+           ::dcd::devicethatloadedthiscomponentref_pskel& devicethatloadedthiscomponentref,
+           ::dcd::deviceusedbythiscomponentref_pskel& deviceusedbythiscomponentref,
+           ::dcd::findby_pskel& findby)
+  {
+    this->usesidentifier_parser_ = &usesidentifier;
+    this->componentinstantiationref_parser_ = &componentinstantiationref;
+    this->devicethatloadedthiscomponentref_parser_ = &devicethatloadedthiscomponentref;
+    this->deviceusedbythiscomponentref_parser_ = &deviceusedbythiscomponentref;
+    this->findby_parser_ = &findby;
+  }
+
+  usesport_pskel::
+  usesport_pskel ()
+  : usesidentifier_parser_ (0),
+    componentinstantiationref_parser_ (0),
+    devicethatloadedthiscomponentref_parser_ (0),
+    deviceusedbythiscomponentref_parser_ (0),
+    findby_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // providesport_pskel
+  //
+
+  void providesport_pskel::
+  providesidentifier_parser (::xml_schema::string_pskel& p)
+  {
+    this->providesidentifier_parser_ = &p;
+  }
+
+  void providesport_pskel::
+  componentinstantiationref_parser (::dcd::componentinstantiationref_pskel& p)
+  {
+    this->componentinstantiationref_parser_ = &p;
+  }
+
+  void providesport_pskel::
+  devicethatloadedthiscomponentref_parser (::dcd::devicethatloadedthiscomponentref_pskel& p)
+  {
+    this->devicethatloadedthiscomponentref_parser_ = &p;
+  }
+
+  void providesport_pskel::
+  deviceusedbythiscomponentref_parser (::dcd::deviceusedbythiscomponentref_pskel& p)
+  {
+    this->deviceusedbythiscomponentref_parser_ = &p;
+  }
+
+  void providesport_pskel::
+  findby_parser (::dcd::findby_pskel& p)
+  {
+    this->findby_parser_ = &p;
+  }
+
+  void providesport_pskel::
+  parsers (::xml_schema::string_pskel& providesidentifier,
+           ::dcd::componentinstantiationref_pskel& componentinstantiationref,
+           ::dcd::devicethatloadedthiscomponentref_pskel& devicethatloadedthiscomponentref,
+           ::dcd::deviceusedbythiscomponentref_pskel& deviceusedbythiscomponentref,
+           ::dcd::findby_pskel& findby)
+  {
+    this->providesidentifier_parser_ = &providesidentifier;
+    this->componentinstantiationref_parser_ = &componentinstantiationref;
+    this->devicethatloadedthiscomponentref_parser_ = &devicethatloadedthiscomponentref;
+    this->deviceusedbythiscomponentref_parser_ = &deviceusedbythiscomponentref;
+    this->findby_parser_ = &findby;
+  }
+
+  providesport_pskel::
+  providesport_pskel ()
+  : providesidentifier_parser_ (0),
+    componentinstantiationref_parser_ (0),
+    devicethatloadedthiscomponentref_parser_ (0),
+    deviceusedbythiscomponentref_parser_ (0),
+    findby_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // componentsupportedinterface_pskel
+  //
+
+  void componentsupportedinterface_pskel::
+  supportedidentifier_parser (::xml_schema::string_pskel& p)
+  {
+    this->supportedidentifier_parser_ = &p;
+  }
+
+  void componentsupportedinterface_pskel::
+  componentinstantiationref_parser (::dcd::componentinstantiationref_pskel& p)
+  {
+    this->componentinstantiationref_parser_ = &p;
+  }
+
+  void componentsupportedinterface_pskel::
+  findby_parser (::dcd::findby_pskel& p)
+  {
+    this->findby_parser_ = &p;
+  }
+
+  void componentsupportedinterface_pskel::
+  parsers (::xml_schema::string_pskel& supportedidentifier,
+           ::dcd::componentinstantiationref_pskel& componentinstantiationref,
+           ::dcd::findby_pskel& findby)
+  {
+    this->supportedidentifier_parser_ = &supportedidentifier;
+    this->componentinstantiationref_parser_ = &componentinstantiationref;
+    this->findby_parser_ = &findby;
+  }
+
+  componentsupportedinterface_pskel::
+  componentsupportedinterface_pskel ()
+  : supportedidentifier_parser_ (0),
+    componentinstantiationref_parser_ (0),
+    findby_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+}
+
+namespace dcd
+{
+  // deviceconfiguration_pskel
+  //
+
+  void deviceconfiguration_pskel::
+  description (const ::std::string&)
+  {
+  }
+
+  void deviceconfiguration_pskel::
+  devicemanagersoftpkg (const ::std::string&)
+  {
+  }
+
+  void deviceconfiguration_pskel::
+  componentfiles (const ::std::vector<ossie::ComponentFile>&)
+  {
+  }
+
+  void deviceconfiguration_pskel::
+  partitioning (const ::std::vector<ossie::ComponentPlacement>&)
+  {
+  }
+
+  void deviceconfiguration_pskel::
+  connections (const ::std::vector<ossie::Connection>&)
+  {
+  }
+
+  void deviceconfiguration_pskel::
+  domainmanager (const ::std::string&)
+  {
+  }
+
+  void deviceconfiguration_pskel::
+  filesystemnames ()
+  {
+  }
+
+  void deviceconfiguration_pskel::
+  id (const ::std::string&)
+  {
+  }
+
+  void deviceconfiguration_pskel::
+  name (const ::std::string&)
+  {
+  }
+
+  // devicemanagersoftpkg_pskel
+  //
+
+  void devicemanagersoftpkg_pskel::
+  localfile (const ::std::string&)
+  {
+  }
+
+  // componentfiles_pskel
+  //
+
+  void componentfiles_pskel::
+  componentfile (const ::ossie::ComponentFile&)
+  {
+  }
+
+  // componentfile_pskel
+  //
+
+  void componentfile_pskel::
+  localfile (const ::std::string&)
+  {
+  }
+
+  void componentfile_pskel::
+  id (const ::std::string&)
+  {
+  }
+
+  void componentfile_pskel::
+  type (const ::std::string&)
+  {
+  }
+
+  // localfile_pskel
+  //
+
+  void localfile_pskel::
+  name (const ::std::string&)
+  {
+  }
+
+  // partitioning_pskel
+  //
+
+  void partitioning_pskel::
+  componentplacement (const ::ossie::ComponentPlacement&)
+  {
+  }
+
+  // componentplacement_pskel
+  //
+
+  void componentplacement_pskel::
+  componentfileref (const ::std::string&)
+  {
+  }
+
+  void componentplacement_pskel::
+  deployondevice (const ::std::string&)
+  {
+  }
+
+  void componentplacement_pskel::
+  compositepartofdevice (const ::std::string&)
+  {
+  }
+
+  void componentplacement_pskel::
+  devicepkgfile ()
+  {
+  }
+
+  void componentplacement_pskel::
+  componentinstantiation (const ::ossie::ComponentInstantiation&)
+  {
+  }
+
+  // componentfileref_pskel
+  //
+
+  void componentfileref_pskel::
+  refid (const ::std::string&)
+  {
+  }
+
+  // deployondevice_pskel
+  //
+
+  void deployondevice_pskel::
+  refid (const ::std::string&)
+  {
+  }
+
+  // compositepartofdevice_pskel
+  //
+
+  void compositepartofdevice_pskel::
+  refid (const ::std::string&)
+  {
+  }
+
+  // devicepkgfile_pskel
+  //
+
+  void devicepkgfile_pskel::
+  localfile (const ::std::string&)
+  {
+  }
+
+  void devicepkgfile_pskel::
+  type (const ::std::string&)
+  {
+  }
+
+  void devicepkgfile_pskel::
+  post_devicepkgfile ()
+  {
+  }
+
+  // componentinstantiation_pskel
+  //
+
+  void componentinstantiation_pskel::
+  usagename (const ::std::string&)
+  {
+  }
+
+  void componentinstantiation_pskel::
+  componentproperties (const ::std::vector<ossie::ComponentProperty*>&)
+  {
+  }
+
+  void componentinstantiation_pskel::
+  affinity (const  ossie::ComponentInstantiation::AffinityProperties &)
+  {
+  }
+
+  void componentinstantiation_pskel::
+  loggingconfig (const  ossie::ComponentInstantiation::LoggingConfig &)
+  {
+  }
+
+  void componentinstantiation_pskel::
+  id (const ::std::string&)
+  {
+  }
+
+  // loggingconfig_pskel
+  //
+
+  void loggingconfig_pskel::
+  level (const ::std::string&)
+  {
+  }
+
+  // affinity_pskel
+  //
+
+  void affinity_pskel::
+  simpleref (ossie::SimplePropertyRef*)
+  {
+  }
+
+  void affinity_pskel::
+  simplesequenceref (ossie::SimpleSequencePropertyRef*)
+  {
+  }
+
+  void affinity_pskel::
+  structref (ossie::StructPropertyRef*)
+  {
+  }
+
+  void affinity_pskel::
+  structsequenceref (ossie::StructSequencePropertyRef*)
+  {
+  }
+
+  // componentproperties_pskel
+  //
+
+  void componentproperties_pskel::
+  simpleref (ossie::SimplePropertyRef*)
+  {
+  }
+
+  void componentproperties_pskel::
+  simplesequenceref (ossie::SimpleSequencePropertyRef*)
+  {
+  }
+
+  void componentproperties_pskel::
+  structref (ossie::StructPropertyRef*)
+  {
+  }
+
+  void componentproperties_pskel::
+  structsequenceref (ossie::StructSequencePropertyRef*)
+  {
+  }
+
+  // devicethatloadedthiscomponentref_pskel
+  //
+
+  void devicethatloadedthiscomponentref_pskel::
+  refid (const ::std::string&)
+  {
+  }
+
+  // deviceusedbythiscomponentref_pskel
+  //
+
+  void deviceusedbythiscomponentref_pskel::
+  refid (const ::std::string&)
+  {
+  }
+
+  void deviceusedbythiscomponentref_pskel::
+  usesrefid (const ::std::string&)
+  {
+  }
+
+  // simpleref_pskel
+  //
+
+  void simpleref_pskel::
+  refid (const ::std::string&)
+  {
+  }
+
+  void simpleref_pskel::
+  value (const ::std::string&)
+  {
+  }
+
+  // simplesequenceref_pskel
+  //
+
+  void simplesequenceref_pskel::
+  values (const ::std::vector<std::string>&)
+  {
+  }
+
+  void simplesequenceref_pskel::
+  refid (const ::std::string&)
+  {
+  }
+
+  // structref_pskel
+  //
+
+  void structref_pskel::
+  simpleref (ossie::SimplePropertyRef*)
+  {
+  }
+
+  void structref_pskel::
+  simplesequenceref (ossie::SimpleSequencePropertyRef*)
+  {
+  }
+
+  void structref_pskel::
+  refid (const ::std::string&)
+  {
+  }
+
+  // structsequenceref_pskel
+  //
+
+  void structsequenceref_pskel::
+  structvalue (const ::std::map<std::string, ossie::ComponentProperty*>&)
+  {
+  }
+
+  void structsequenceref_pskel::
+  refid (const ::std::string&)
+  {
+  }
+
+  // structvalue_pskel
+  //
+
+  void structvalue_pskel::
+  simpleref (ossie::SimplePropertyRef*)
+  {
+  }
+
+  void structvalue_pskel::
+  simplesequenceref (ossie::SimpleSequencePropertyRef*)
+  {
+  }
+
+  // values_pskel
+  //
+
+  void values_pskel::
+  value (const ::std::string&)
+  {
+  }
+
+  // componentinstantiationref_pskel
+  //
+
+  void componentinstantiationref_pskel::
+  refid (const ::std::string&)
+  {
+  }
+
+  // domainmanager_pskel
+  //
+
+  void domainmanager_pskel::
+  namingservice (const ::std::string&)
+  {
+  }
+
+  void domainmanager_pskel::
+  stringifiedobjectref (const ::std::string&)
+  {
+  }
+
+  // findby_pskel
+  //
+
+  void findby_pskel::
+  namingservice (const ::std::string&)
+  {
+  }
+
+  void findby_pskel::
+  stringifiedobjectref (const ::std::string&)
+  {
+  }
+
+  void findby_pskel::
+  domainfinder (const ::std::pair<std::string, std::string>&)
+  {
+  }
+
+  // namingservice_pskel
+  //
+
+  void namingservice_pskel::
+  name (const ::std::string&)
+  {
+  }
+
+  // domainfinder_pskel
+  //
+
+  void domainfinder_pskel::
+  type (const ::std::string&)
+  {
+  }
+
+  void domainfinder_pskel::
+  name (const ::std::string&)
+  {
+  }
+
+  // filesystemnames_pskel
+  //
+
+  void filesystemnames_pskel::
+  filesystemname ()
+  {
+  }
+
+  void filesystemnames_pskel::
+  post_filesystemnames ()
+  {
+  }
+
+  // filesystemname_pskel
+  //
+
+  void filesystemname_pskel::
+  mountname (const ::std::string&)
+  {
+  }
+
+  void filesystemname_pskel::
+  deviceid (const ::std::string&)
+  {
+  }
+
+  void filesystemname_pskel::
+  post_filesystemname ()
+  {
+  }
+
+  // connections_pskel
+  //
+
+  void connections_pskel::
+  connectinterface (const ::ossie::Connection&)
+  {
+  }
+
+  // connectinterface_pskel
+  //
+
+  void connectinterface_pskel::
+  usesport (const ::ossie::UsesPort&)
+  {
+  }
+
+  void connectinterface_pskel::
+  providesport (const ::ossie::ProvidesPort&)
+  {
+  }
+
+  void connectinterface_pskel::
+  componentsupportedinterface (const ::ossie::ComponentSupportedInterface&)
+  {
+  }
+
+  void connectinterface_pskel::
+  findby (const ::ossie::FindBy&)
+  {
+  }
+
+  void connectinterface_pskel::
+  id (const ::std::string&)
+  {
+  }
+
+  // usesport_pskel
+  //
+
+  void usesport_pskel::
+  usesidentifier (const ::std::string&)
+  {
+  }
+
+  void usesport_pskel::
+  componentinstantiationref (const ::std::string&)
+  {
+  }
+
+  void usesport_pskel::
+  devicethatloadedthiscomponentref (const ::std::string&)
+  {
+  }
+
+  void usesport_pskel::
+  deviceusedbythiscomponentref (const ::std::pair<std::string, std::string>&)
+  {
+  }
+
+  void usesport_pskel::
+  findby (const ::ossie::FindBy&)
+  {
+  }
+
+  // providesport_pskel
+  //
+
+  void providesport_pskel::
+  providesidentifier (const ::std::string&)
+  {
+  }
+
+  void providesport_pskel::
+  componentinstantiationref (const ::std::string&)
+  {
+  }
+
+  void providesport_pskel::
+  devicethatloadedthiscomponentref (const ::std::string&)
+  {
+  }
+
+  void providesport_pskel::
+  deviceusedbythiscomponentref (const ::std::pair<std::string, std::string>&)
+  {
+  }
+
+  void providesport_pskel::
+  findby (const ::ossie::FindBy&)
+  {
+  }
+
+  // componentsupportedinterface_pskel
+  //
+
+  void componentsupportedinterface_pskel::
+  supportedidentifier (const ::std::string&)
+  {
+  }
+
+  void componentsupportedinterface_pskel::
+  componentinstantiationref (const ::std::string&)
+  {
+  }
+
+  void componentsupportedinterface_pskel::
+  findby (const ::ossie::FindBy&)
+  {
+  }
+}
+
+#include <cassert>
+
+namespace dcd
+{
+  // Element validation and dispatch functions for deviceconfiguration_pskel.
+  //
+  bool deviceconfiguration_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "description" &&
+            ns.empty())
+          s = 0UL;
+        else if (n == "devicemanagersoftpkg" &&
+                 ns.empty())
+          s = 1UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &deviceconfiguration_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "description",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool deviceconfiguration_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void deviceconfiguration_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void deviceconfiguration_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "description");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void deviceconfiguration_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "description" &&
+            ns.empty())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->description_parser_;
+
+            if (this->description_parser_)
+              this->description_parser_->pre ();
+          }
+          else
+          {
+            if (this->description_parser_)
+            {
+              const ::std::string& tmp (this->description_parser_->post_string ());
+              this->description (tmp);
+            }
+
+            count = 0;
+            state = 1UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 1UL;
+          // Fall through.
+        }
+      }
+      case 1UL:
+      {
+        if (n == "devicemanagersoftpkg" &&
+            ns.empty())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->devicemanagersoftpkg_parser_;
+
+            if (this->devicemanagersoftpkg_parser_)
+              this->devicemanagersoftpkg_parser_->pre ();
+          }
+          else
+          {
+            if (this->devicemanagersoftpkg_parser_)
+            {
+              const ::std::string& tmp (this->devicemanagersoftpkg_parser_->post_devicemanagersoftpkg ());
+              this->devicemanagersoftpkg (tmp);
+            }
+
+            count = 0;
+            state = 2UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "devicemanagersoftpkg",
+              ns, n);
+          count = 0;
+          state = 2UL;
+          // Fall through.
+        }
+      }
+      case 2UL:
+      {
+        if (n == "componentfiles" &&
+            ns.empty())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->componentfiles_parser_;
+
+            if (this->componentfiles_parser_)
+              this->componentfiles_parser_->pre ();
+          }
+          else
+          {
+            if (this->componentfiles_parser_)
+            {
+              const ::std::vector<ossie::ComponentFile>& tmp (this->componentfiles_parser_->post_componentfiles ());
+              this->componentfiles (tmp);
+            }
+
+            count = 0;
+            state = 3UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 3UL;
+          // Fall through.
+        }
+      }
+      case 3UL:
+      {
+        if (n == "partitioning" &&
+            ns.empty())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->partitioning_parser_;
+
+            if (this->partitioning_parser_)
+              this->partitioning_parser_->pre ();
+          }
+          else
+          {
+            if (this->partitioning_parser_)
+            {
+              const ::std::vector<ossie::ComponentPlacement>& tmp (this->partitioning_parser_->post_partitioning ());
+              this->partitioning (tmp);
+            }
+
+            count = 0;
+            state = 4UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 4UL;
+          // Fall through.
+        }
+      }
+      case 4UL:
+      {
+        if (n == "connections" &&
+            ns.empty())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->connections_parser_;
+
+            if (this->connections_parser_)
+              this->connections_parser_->pre ();
+          }
+          else
+          {
+            if (this->connections_parser_)
+            {
+              const ::std::vector<ossie::Connection>& tmp (this->connections_parser_->post_connections ());
+              this->connections (tmp);
+            }
+
+            count = 0;
+            state = 5UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 5UL;
+          // Fall through.
+        }
+      }
+      case 5UL:
+      {
+        if (n == "domainmanager" &&
+            ns.empty())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->domainmanager_parser_;
+
+            if (this->domainmanager_parser_)
+              this->domainmanager_parser_->pre ();
+          }
+          else
+          {
+            if (this->domainmanager_parser_)
+            {
+              const ::std::string& tmp (this->domainmanager_parser_->post_domainmanager ());
+              this->domainmanager (tmp);
+            }
+
+            count = 0;
+            state = 6UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "domainmanager",
+              ns, n);
+          count = 0;
+          state = 6UL;
+          // Fall through.
+        }
+      }
+      case 6UL:
+      {
+        if (n == "filesystemnames" &&
+            ns.empty())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->filesystemnames_parser_;
+
+            if (this->filesystemnames_parser_)
+              this->filesystemnames_parser_->pre ();
+          }
+          else
+          {
+            if (this->filesystemnames_parser_)
+            {
+              this->filesystemnames_parser_->post_filesystemnames ();
+              this->filesystemnames ();
+            }
+
+            count = 0;
+            state = ~0UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for devicemanagersoftpkg_pskel.
+  //
+  bool devicemanagersoftpkg_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "localfile" &&
+            ns.empty())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &devicemanagersoftpkg_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "localfile",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool devicemanagersoftpkg_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void devicemanagersoftpkg_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void devicemanagersoftpkg_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "localfile");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void devicemanagersoftpkg_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "localfile" &&
+            ns.empty())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->localfile_parser_;
+
+            if (this->localfile_parser_)
+              this->localfile_parser_->pre ();
+          }
+          else
+          {
+            if (this->localfile_parser_)
+            {
+              const ::std::string& tmp (this->localfile_parser_->post_localfile ());
+              this->localfile (tmp);
+            }
+
+            count = 0;
+            state = ~0UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "localfile",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for componentfiles_pskel.
+  //
+  bool componentfiles_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "componentfile" &&
+            ns.empty())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &componentfiles_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "componentfile",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool componentfiles_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void componentfiles_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void componentfiles_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "componentfile");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void componentfiles_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "componentfile" &&
+            ns.empty())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->componentfile_parser_;
+
+            if (this->componentfile_parser_)
+              this->componentfile_parser_->pre ();
+          }
+          else
+          {
+            if (this->componentfile_parser_)
+            {
+              const ::ossie::ComponentFile& tmp (this->componentfile_parser_->post_componentfile ());
+              this->componentfile (tmp);
+            }
+
+            count++;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "componentfile",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for componentfile_pskel.
+  //
+  bool componentfile_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "localfile" &&
+            ns.empty())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &componentfile_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "localfile",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool componentfile_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void componentfile_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void componentfile_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "localfile");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void componentfile_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "localfile" &&
+            ns.empty())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->localfile_parser_;
+
+            if (this->localfile_parser_)
+              this->localfile_parser_->pre ();
+          }
+          else
+          {
+            if (this->localfile_parser_)
+            {
+              const ::std::string& tmp (this->localfile_parser_->post_localfile ());
+              this->localfile (tmp);
+            }
+
+            count = 0;
+            state = ~0UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "localfile",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for partitioning_pskel.
+  //
+  bool partitioning_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "componentplacement" &&
+            ns.empty())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &partitioning_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool partitioning_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void partitioning_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void partitioning_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+
+    this->v_state_stack_.pop ();
+  }
+
+  void partitioning_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "componentplacement" &&
+            ns.empty())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->componentplacement_parser_;
+
+            if (this->componentplacement_parser_)
+              this->componentplacement_parser_->pre ();
+          }
+          else
+          {
+            if (this->componentplacement_parser_)
+            {
+              const ::ossie::ComponentPlacement& tmp (this->componentplacement_parser_->post_componentplacement ());
+              this->componentplacement (tmp);
+            }
+
+            count++;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for componentplacement_pskel.
+  //
+  bool componentplacement_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "componentfileref" &&
+            ns.empty())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &componentplacement_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "componentfileref",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool componentplacement_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void componentplacement_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void componentplacement_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "componentfileref");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void componentplacement_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "componentfileref" &&
+            ns.empty())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->componentfileref_parser_;
+
+            if (this->componentfileref_parser_)
+              this->componentfileref_parser_->pre ();
+          }
+          else
+          {
+            if (this->componentfileref_parser_)
+            {
+              const ::std::string& tmp (this->componentfileref_parser_->post_componentfileref ());
+              this->componentfileref (tmp);
+            }
+
+            count = 0;
+            state = 1UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "componentfileref",
+              ns, n);
+          count = 0;
+          state = 1UL;
+          // Fall through.
+        }
+      }
+      case 1UL:
+      {
+        if (n == "deployondevice" &&
+            ns.empty())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->deployondevice_parser_;
+
+            if (this->deployondevice_parser_)
+              this->deployondevice_parser_->pre ();
+          }
+          else
+          {
+            if (this->deployondevice_parser_)
+            {
+              const ::std::string& tmp (this->deployondevice_parser_->post_deployondevice ());
+              this->deployondevice (tmp);
+            }
+
+            count = 0;
+            state = 2UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 2UL;
+          // Fall through.
+        }
+      }
+      case 2UL:
+      {
+        if (n == "compositepartofdevice" &&
+            ns.empty())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->compositepartofdevice_parser_;
+
+            if (this->compositepartofdevice_parser_)
+              this->compositepartofdevice_parser_->pre ();
+          }
+          else
+          {
+            if (this->compositepartofdevice_parser_)
+            {
+              const ::std::string& tmp (this->compositepartofdevice_parser_->post_compositepartofdevice ());
+              this->compositepartofdevice (tmp);
+            }
+
+            count = 0;
+            state = 3UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 3UL;
+          // Fall through.
+        }
+      }
+      case 3UL:
+      {
+        if (n == "devicepkgfile" &&
+            ns.empty())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->devicepkgfile_parser_;
+
+            if (this->devicepkgfile_parser_)
+              this->devicepkgfile_parser_->pre ();
+          }
+          else
+          {
+            if (this->devicepkgfile_parser_)
+            {
+              this->devicepkgfile_parser_->post_devicepkgfile ();
+              this->devicepkgfile ();
+            }
+
+            count = 0;
+            state = 4UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 4UL;
+          // Fall through.
+        }
+      }
+      case 4UL:
+      {
+        if (n == "componentinstantiation" &&
+            ns.empty())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->componentinstantiation_parser_;
+
+            if (this->componentinstantiation_parser_)
+              this->componentinstantiation_parser_->pre ();
+          }
+          else
+          {
+            if (this->componentinstantiation_parser_)
+            {
+              const ::ossie::ComponentInstantiation& tmp (this->componentinstantiation_parser_->post_componentinstantiation ());
+              this->componentinstantiation (tmp);
+            }
+
+            count++;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "componentinstantiation",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for devicepkgfile_pskel.
+  //
+  bool devicepkgfile_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "localfile" &&
+            ns.empty())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &devicepkgfile_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "localfile",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool devicepkgfile_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void devicepkgfile_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void devicepkgfile_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "localfile");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void devicepkgfile_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "localfile" &&
+            ns.empty())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->localfile_parser_;
+
+            if (this->localfile_parser_)
+              this->localfile_parser_->pre ();
+          }
+          else
+          {
+            if (this->localfile_parser_)
+            {
+              const ::std::string& tmp (this->localfile_parser_->post_localfile ());
+              this->localfile (tmp);
+            }
+
+            count = 0;
+            state = ~0UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "localfile",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for componentinstantiation_pskel.
+  //
+  bool componentinstantiation_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "usagename" &&
+            ns.empty())
+          s = 0UL;
+        else if (n == "componentproperties" &&
+                 ns.empty())
+          s = 1UL;
+        else if (n == "affinity" && ns.empty ())
+          s = 2UL;
+        else if (n == "loggingconfig" && ns.empty ())
+          s = 3UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &componentinstantiation_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool componentinstantiation_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void componentinstantiation_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void componentinstantiation_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+
+    this->v_state_stack_.pop ();
+  }
+
+  void componentinstantiation_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "usagename" &&
+            ns.empty())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->usagename_parser_;
+
+            if (this->usagename_parser_)
+              this->usagename_parser_->pre ();
+          }
+          else
+          {
+            if (this->usagename_parser_)
+            {
+              const ::std::string& tmp (this->usagename_parser_->post_string ());
+              this->usagename (tmp);
+            }
+
+            count = 0;
+            state = 1UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 1UL;
+          // Fall through.
+        }
+      }
+      case 1UL:
+      {
+        if (n == "componentproperties" &&
+            ns.empty())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->componentproperties_parser_;
+
+            if (this->componentproperties_parser_)
+              this->componentproperties_parser_->pre ();
+          }
+          else
+          {
+            if (this->componentproperties_parser_)
+            {
+              const ::std::vector<ossie::ComponentProperty*>& tmp (this->componentproperties_parser_->post_componentproperties ());
+              this->componentproperties (tmp);
+            }
+
+            count = 0;
+            state = 2UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 2UL;
+          // Fall through.
+        }
+      }
+      case 2UL:
+      {
+        if (n == "affinity" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->affinity_parser_;
+
+            if (this->affinity_parser_)
+              this->affinity_parser_->pre ();
+          }
+          else
+          {
+            if (this->affinity_parser_)
+            {
+              const  ossie::ComponentInstantiation::AffinityProperties & tmp (this->affinity_parser_->post_affinity ());
+              this->affinity (tmp);
+            }
+
+            count = 0;
+            state = 3UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 3UL;
+          // Fall through.
+        }
+      }
+      case 3UL:
+      {
+        if (n == "loggingconfig" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->loggingconfig_parser_;
+
+            if (this->loggingconfig_parser_)
+              this->loggingconfig_parser_->pre ();
+          }
+          else
+          {
+            if (this->loggingconfig_parser_)
+            {
+              const  ossie::ComponentInstantiation::LoggingConfig & tmp (this->loggingconfig_parser_->post_loggingconfig ());
+              this->loggingconfig (tmp);
+            }
+
+            count = 0;
+            state = ~0UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for affinity_pskel.
+  //
+  bool affinity_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "simpleref" &&
+            ns.empty())
+          s = 0UL;
+        else if (n == "simplesequenceref" &&
+                 ns.empty())
+          s = 1UL;
+        else if (n == "structref" &&
+                 ns.empty())
+          s = 2UL;
+        else if (n == "structsequenceref" &&
+                 ns.empty())
+          s = 3UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+
+          vd = vs.data + vs.size++;
+          vd->func = &affinity_pskel::choice_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->choice_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "simpleref",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool affinity_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void affinity_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void affinity_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "simpleref");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void affinity_pskel::
+  choice_0 (unsigned long& state,
+            unsigned long& count,
+            const ::xml_schema::ro_string& ns,
+            const ::xml_schema::ro_string& n,
+            const ::xml_schema::ro_string* t,
+            bool start)
+  {
+    XSD_UNUSED (count);
+    XSD_UNUSED (ns);
+    XSD_UNUSED (n);
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->simpleref_parser_;
+
+          if (this->simpleref_parser_)
+            this->simpleref_parser_->pre ();
+        }
+        else
+        {
+          if (this->simpleref_parser_)
+          {
+            ossie::SimplePropertyRef* tmp (this->simpleref_parser_->post_simpleref ());
+            this->simpleref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 1UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->simplesequenceref_parser_;
+
+          if (this->simplesequenceref_parser_)
+            this->simplesequenceref_parser_->pre ();
+        }
+        else
+        {
+          if (this->simplesequenceref_parser_)
+          {
+            ossie::SimpleSequencePropertyRef* tmp (this->simplesequenceref_parser_->post_simplesequenceref ());
+            this->simplesequenceref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 2UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->structref_parser_;
+
+          if (this->structref_parser_)
+            this->structref_parser_->pre ();
+        }
+        else
+        {
+          if (this->structref_parser_)
+          {
+            ossie::StructPropertyRef* tmp (this->structref_parser_->post_structref ());
+            this->structref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 3UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->structsequenceref_parser_;
+
+          if (this->structsequenceref_parser_)
+            this->structsequenceref_parser_->pre ();
+        }
+        else
+        {
+          if (this->structsequenceref_parser_)
+          {
+            ossie::StructSequencePropertyRef* tmp (this->structsequenceref_parser_->post_structsequenceref ());
+            this->structsequenceref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+    }
+  }
+
+  // Element validation and dispatch functions for componentproperties_pskel.
+  //
+  bool componentproperties_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "simpleref" &&
+            ns.empty())
+          s = 0UL;
+        else if (n == "simplesequenceref" &&
+                 ns.empty())
+          s = 1UL;
+        else if (n == "structref" &&
+                 ns.empty())
+          s = 2UL;
+        else if (n == "structsequenceref" &&
+                 ns.empty())
+          s = 3UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+
+          vd = vs.data + vs.size++;
+          vd->func = &componentproperties_pskel::choice_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->choice_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "simpleref",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool componentproperties_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void componentproperties_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void componentproperties_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "simpleref");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void componentproperties_pskel::
+  choice_0 (unsigned long& state,
+            unsigned long& count,
+            const ::xml_schema::ro_string& ns,
+            const ::xml_schema::ro_string& n,
+            const ::xml_schema::ro_string* t,
+            bool start)
+  {
+    XSD_UNUSED (count);
+    XSD_UNUSED (ns);
+    XSD_UNUSED (n);
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->simpleref_parser_;
+
+          if (this->simpleref_parser_)
+            this->simpleref_parser_->pre ();
+        }
+        else
+        {
+          if (this->simpleref_parser_)
+          {
+            ossie::SimplePropertyRef* tmp (this->simpleref_parser_->post_simpleref ());
+            this->simpleref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 1UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->simplesequenceref_parser_;
+
+          if (this->simplesequenceref_parser_)
+            this->simplesequenceref_parser_->pre ();
+        }
+        else
+        {
+          if (this->simplesequenceref_parser_)
+          {
+            ossie::SimpleSequencePropertyRef* tmp (this->simplesequenceref_parser_->post_simplesequenceref ());
+            this->simplesequenceref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 2UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->structref_parser_;
+
+          if (this->structref_parser_)
+            this->structref_parser_->pre ();
+        }
+        else
+        {
+          if (this->structref_parser_)
+          {
+            ossie::StructPropertyRef* tmp (this->structref_parser_->post_structref ());
+            this->structref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 3UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->structsequenceref_parser_;
+
+          if (this->structsequenceref_parser_)
+            this->structsequenceref_parser_->pre ();
+        }
+        else
+        {
+          if (this->structsequenceref_parser_)
+          {
+            ossie::StructSequencePropertyRef* tmp (this->structsequenceref_parser_->post_structsequenceref ());
+            this->structsequenceref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+    }
+  }
+
+  // Element validation and dispatch functions for simplesequenceref_pskel.
+  //
+  bool simplesequenceref_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "values" &&
+            ns.empty())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &simplesequenceref_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "values",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool simplesequenceref_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void simplesequenceref_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void simplesequenceref_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "values");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void simplesequenceref_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "values" &&
+            ns.empty())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->values_parser_;
+
+            if (this->values_parser_)
+              this->values_parser_->pre ();
+          }
+          else
+          {
+            if (this->values_parser_)
+            {
+              const ::std::vector<std::string>& tmp (this->values_parser_->post_values ());
+              this->values (tmp);
+            }
+
+            count = 0;
+            state = ~0UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "values",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for structref_pskel.
+  //
+  bool structref_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if ((n == "simpleref" &&
+             ns.empty()) ||
+            (n == "simplesequenceref" &&
+             ns.empty()))
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &structref_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "simpleref",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool structref_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void structref_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void structref_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "simpleref");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void structref_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        unsigned long s (~0UL);
+
+        if (n == "simpleref" &&
+            ns.empty())
+          s = 0UL;
+        else if (n == "simplesequenceref" &&
+                 ns.empty())
+          s = 1UL;
+
+        if (s != ~0UL)
+        {
+          assert (start);
+          count++;
+
+          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+          v_state_descr_& vd = vs.data[vs.size++];
+
+          vd.func = &structref_pskel::choice_0;
+          vd.state = s;
+          vd.count = 0;
+
+          this->choice_0 (vd.state, vd.count, ns, n, t, true);
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "simpleref",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  void structref_pskel::
+  choice_0 (unsigned long& state,
+            unsigned long& count,
+            const ::xml_schema::ro_string& ns,
+            const ::xml_schema::ro_string& n,
+            const ::xml_schema::ro_string* t,
+            bool start)
+  {
+    XSD_UNUSED (count);
+    XSD_UNUSED (ns);
+    XSD_UNUSED (n);
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->simpleref_parser_;
+
+          if (this->simpleref_parser_)
+            this->simpleref_parser_->pre ();
+        }
+        else
+        {
+          if (this->simpleref_parser_)
+          {
+            ossie::SimplePropertyRef* tmp (this->simpleref_parser_->post_simpleref ());
+            this->simpleref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 1UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->simplesequenceref_parser_;
+
+          if (this->simplesequenceref_parser_)
+            this->simplesequenceref_parser_->pre ();
+        }
+        else
+        {
+          if (this->simplesequenceref_parser_)
+          {
+            ossie::SimpleSequencePropertyRef* tmp (this->simplesequenceref_parser_->post_simplesequenceref ());
+            this->simplesequenceref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+    }
+  }
+
+  // Element validation and dispatch functions for structsequenceref_pskel.
+  //
+  bool structsequenceref_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "structvalue" &&
+            ns.empty())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &structsequenceref_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "structvalue",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool structsequenceref_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void structsequenceref_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void structsequenceref_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "structvalue");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void structsequenceref_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "structvalue" &&
+            ns.empty())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->structvalue_parser_;
+
+            if (this->structvalue_parser_)
+              this->structvalue_parser_->pre ();
+          }
+          else
+          {
+            if (this->structvalue_parser_)
+            {
+              const ::std::map<std::string, ossie::ComponentProperty*>& tmp (this->structvalue_parser_->post_structvalue ());
+              this->structvalue (tmp);
+            }
+
+            count++;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "structvalue",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for structvalue_pskel.
+  //
+  bool structvalue_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if ((n == "simpleref" &&
+             ns.empty()) ||
+            (n == "simplesequenceref" &&
+             ns.empty()))
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &structvalue_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "simpleref",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool structvalue_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void structvalue_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void structvalue_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "simpleref");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void structvalue_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        unsigned long s (~0UL);
+
+        if (n == "simpleref" &&
+            ns.empty())
+          s = 0UL;
+        else if (n == "simplesequenceref" &&
+                 ns.empty())
+          s = 1UL;
+
+        if (s != ~0UL)
+        {
+          assert (start);
+          count++;
+
+          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+          v_state_descr_& vd = vs.data[vs.size++];
+
+          vd.func = &structvalue_pskel::choice_0;
+          vd.state = s;
+          vd.count = 0;
+
+          this->choice_0 (vd.state, vd.count, ns, n, t, true);
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "simpleref",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  void structvalue_pskel::
+  choice_0 (unsigned long& state,
+            unsigned long& count,
+            const ::xml_schema::ro_string& ns,
+            const ::xml_schema::ro_string& n,
+            const ::xml_schema::ro_string* t,
+            bool start)
+  {
+    XSD_UNUSED (count);
+    XSD_UNUSED (ns);
+    XSD_UNUSED (n);
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->simpleref_parser_;
+
+          if (this->simpleref_parser_)
+            this->simpleref_parser_->pre ();
+        }
+        else
+        {
+          if (this->simpleref_parser_)
+          {
+            ossie::SimplePropertyRef* tmp (this->simpleref_parser_->post_simpleref ());
+            this->simpleref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 1UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->simplesequenceref_parser_;
+
+          if (this->simplesequenceref_parser_)
+            this->simplesequenceref_parser_->pre ();
+        }
+        else
+        {
+          if (this->simplesequenceref_parser_)
+          {
+            ossie::SimpleSequencePropertyRef* tmp (this->simplesequenceref_parser_->post_simplesequenceref ());
+            this->simplesequenceref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+    }
+  }
+
+  // Element validation and dispatch functions for values_pskel.
+  //
+  bool values_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "value" &&
+            ns.empty())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &values_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "value",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool values_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void values_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void values_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "value");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void values_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "value" &&
+            ns.empty())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->value_parser_;
+
+            if (this->value_parser_)
+              this->value_parser_->pre ();
+          }
+          else
+          {
+            if (this->value_parser_)
+            {
+              const ::std::string& tmp (this->value_parser_->post_string ());
+              this->value (tmp);
+            }
+
+            count++;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "value",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for domainmanager_pskel.
+  //
+  bool domainmanager_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "namingservice" &&
+            ns.empty())
+          s = 0UL;
+        else if (n == "stringifiedobjectref" &&
+                 ns.empty())
+          s = 1UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &domainmanager_pskel::choice_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->choice_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "namingservice",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool domainmanager_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void domainmanager_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void domainmanager_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "namingservice");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void domainmanager_pskel::
+  choice_0 (unsigned long& state,
+            unsigned long& count,
+            const ::xml_schema::ro_string& ns,
+            const ::xml_schema::ro_string& n,
+            const ::xml_schema::ro_string* t,
+            bool start)
+  {
+    XSD_UNUSED (count);
+    XSD_UNUSED (ns);
+    XSD_UNUSED (n);
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->namingservice_parser_;
+
+          if (this->namingservice_parser_)
+            this->namingservice_parser_->pre ();
+        }
+        else
+        {
+          if (this->namingservice_parser_)
+          {
+            const ::std::string& tmp (this->namingservice_parser_->post_namingservice ());
+            this->namingservice (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 1UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->stringifiedobjectref_parser_;
+
+          if (this->stringifiedobjectref_parser_)
+            this->stringifiedobjectref_parser_->pre ();
+        }
+        else
+        {
+          if (this->stringifiedobjectref_parser_)
+          {
+            const ::std::string& tmp (this->stringifiedobjectref_parser_->post_string ());
+            this->stringifiedobjectref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+    }
+  }
+
+  // Element validation and dispatch functions for findby_pskel.
+  //
+  bool findby_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "namingservice" &&
+            ns.empty())
+          s = 0UL;
+        else if (n == "stringifiedobjectref" &&
+                 ns.empty())
+          s = 1UL;
+        else if (n == "domainfinder" &&
+                 ns.empty())
+          s = 2UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &findby_pskel::choice_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->choice_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "namingservice",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool findby_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void findby_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void findby_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "namingservice");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void findby_pskel::
+  choice_0 (unsigned long& state,
+            unsigned long& count,
+            const ::xml_schema::ro_string& ns,
+            const ::xml_schema::ro_string& n,
+            const ::xml_schema::ro_string* t,
+            bool start)
+  {
+    XSD_UNUSED (count);
+    XSD_UNUSED (ns);
+    XSD_UNUSED (n);
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->namingservice_parser_;
+
+          if (this->namingservice_parser_)
+            this->namingservice_parser_->pre ();
+        }
+        else
+        {
+          if (this->namingservice_parser_)
+          {
+            const ::std::string& tmp (this->namingservice_parser_->post_namingservice ());
+            this->namingservice (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 1UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->stringifiedobjectref_parser_;
+
+          if (this->stringifiedobjectref_parser_)
+            this->stringifiedobjectref_parser_->pre ();
+        }
+        else
+        {
+          if (this->stringifiedobjectref_parser_)
+          {
+            const ::std::string& tmp (this->stringifiedobjectref_parser_->post_string ());
+            this->stringifiedobjectref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 2UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->domainfinder_parser_;
+
+          if (this->domainfinder_parser_)
+            this->domainfinder_parser_->pre ();
+        }
+        else
+        {
+          if (this->domainfinder_parser_)
+          {
+            const ::std::pair<std::string, std::string>& tmp (this->domainfinder_parser_->post_domainfinder ());
+            this->domainfinder (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+    }
+  }
+
+  // Element validation and dispatch functions for filesystemnames_pskel.
+  //
+  bool filesystemnames_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "filesystemname" &&
+            ns.empty())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &filesystemnames_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "filesystemname",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool filesystemnames_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void filesystemnames_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void filesystemnames_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "filesystemname");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void filesystemnames_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "filesystemname" &&
+            ns.empty())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->filesystemname_parser_;
+
+            if (this->filesystemname_parser_)
+              this->filesystemname_parser_->pre ();
+          }
+          else
+          {
+            if (this->filesystemname_parser_)
+            {
+              this->filesystemname_parser_->post_filesystemname ();
+              this->filesystemname ();
+            }
+
+            count++;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "filesystemname",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for connections_pskel.
+  //
+  bool connections_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "connectinterface" &&
+            ns.empty())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &connections_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool connections_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void connections_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void connections_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+
+    this->v_state_stack_.pop ();
+  }
+
+  void connections_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "connectinterface" &&
+            ns.empty())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->connectinterface_parser_;
+
+            if (this->connectinterface_parser_)
+              this->connectinterface_parser_->pre ();
+          }
+          else
+          {
+            if (this->connectinterface_parser_)
+            {
+              const ::ossie::Connection& tmp (this->connectinterface_parser_->post_connectinterface ());
+              this->connectinterface (tmp);
+            }
+
+            count++;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for connectinterface_pskel.
+  //
+  bool connectinterface_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "usesport" &&
+            ns.empty())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &connectinterface_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "usesport",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool connectinterface_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void connectinterface_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void connectinterface_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "usesport");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void connectinterface_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "usesport" &&
+            ns.empty())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->usesport_parser_;
+
+            if (this->usesport_parser_)
+              this->usesport_parser_->pre ();
+          }
+          else
+          {
+            if (this->usesport_parser_)
+            {
+              const ::ossie::UsesPort& tmp (this->usesport_parser_->post_usesport ());
+              this->usesport (tmp);
+            }
+
+            count = 0;
+            state = 1UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "usesport",
+              ns, n);
+          count = 0;
+          state = 1UL;
+          // Fall through.
+        }
+      }
+      case 1UL:
+      {
+        unsigned long s (~0UL);
+
+        if (n == "providesport" &&
+            ns.empty())
+          s = 0UL;
+        else if (n == "componentsupportedinterface" &&
+                 ns.empty())
+          s = 1UL;
+        else if (n == "findby" &&
+                 ns.empty())
+          s = 2UL;
+
+        if (s != ~0UL)
+        {
+          assert (start);
+          count = 0;
+          state = ~0UL;
+
+          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+          v_state_descr_& vd = vs.data[vs.size++];
+
+          vd.func = &connectinterface_pskel::choice_0;
+          vd.state = s;
+          vd.count = 0;
+
+          this->choice_0 (vd.state, vd.count, ns, n, t, true);
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "providesport",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  void connectinterface_pskel::
+  choice_0 (unsigned long& state,
+            unsigned long& count,
+            const ::xml_schema::ro_string& ns,
+            const ::xml_schema::ro_string& n,
+            const ::xml_schema::ro_string* t,
+            bool start)
+  {
+    XSD_UNUSED (count);
+    XSD_UNUSED (ns);
+    XSD_UNUSED (n);
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->providesport_parser_;
+
+          if (this->providesport_parser_)
+            this->providesport_parser_->pre ();
+        }
+        else
+        {
+          if (this->providesport_parser_)
+          {
+            const ::ossie::ProvidesPort& tmp (this->providesport_parser_->post_providesport ());
+            this->providesport (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 1UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->componentsupportedinterface_parser_;
+
+          if (this->componentsupportedinterface_parser_)
+            this->componentsupportedinterface_parser_->pre ();
+        }
+        else
+        {
+          if (this->componentsupportedinterface_parser_)
+          {
+            const ::ossie::ComponentSupportedInterface& tmp (this->componentsupportedinterface_parser_->post_componentsupportedinterface ());
+            this->componentsupportedinterface (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 2UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->findby_parser_;
+
+          if (this->findby_parser_)
+            this->findby_parser_->pre ();
+        }
+        else
+        {
+          if (this->findby_parser_)
+          {
+            const ::ossie::FindBy& tmp (this->findby_parser_->post_findby ());
+            this->findby (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+    }
+  }
+
+  // Element validation and dispatch functions for usesport_pskel.
+  //
+  bool usesport_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "usesidentifier" &&
+            ns.empty())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &usesport_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "usesidentifier",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool usesport_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void usesport_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void usesport_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "usesidentifier");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void usesport_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "usesidentifier" &&
+            ns.empty())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->usesidentifier_parser_;
+
+            if (this->usesidentifier_parser_)
+              this->usesidentifier_parser_->pre ();
+          }
+          else
+          {
+            if (this->usesidentifier_parser_)
+            {
+              const ::std::string& tmp (this->usesidentifier_parser_->post_string ());
+              this->usesidentifier (tmp);
+            }
+
+            count = 0;
+            state = 1UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "usesidentifier",
+              ns, n);
+          count = 0;
+          state = 1UL;
+          // Fall through.
+        }
+      }
+      case 1UL:
+      {
+        unsigned long s (~0UL);
+
+        if (n == "componentinstantiationref" &&
+            ns.empty())
+          s = 0UL;
+        else if (n == "devicethatloadedthiscomponentref" &&
+                 ns.empty())
+          s = 1UL;
+        else if (n == "deviceusedbythiscomponentref" &&
+                 ns.empty())
+          s = 2UL;
+        else if (n == "findby" &&
+                 ns.empty())
+          s = 3UL;
+
+        if (s != ~0UL)
+        {
+          assert (start);
+          count = 0;
+          state = ~0UL;
+
+          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+          v_state_descr_& vd = vs.data[vs.size++];
+
+          vd.func = &usesport_pskel::choice_0;
+          vd.state = s;
+          vd.count = 0;
+
+          this->choice_0 (vd.state, vd.count, ns, n, t, true);
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "componentinstantiationref",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  void usesport_pskel::
+  choice_0 (unsigned long& state,
+            unsigned long& count,
+            const ::xml_schema::ro_string& ns,
+            const ::xml_schema::ro_string& n,
+            const ::xml_schema::ro_string* t,
+            bool start)
+  {
+    XSD_UNUSED (count);
+    XSD_UNUSED (ns);
+    XSD_UNUSED (n);
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->componentinstantiationref_parser_;
+
+          if (this->componentinstantiationref_parser_)
+            this->componentinstantiationref_parser_->pre ();
+        }
+        else
+        {
+          if (this->componentinstantiationref_parser_)
+          {
+            const ::std::string& tmp (this->componentinstantiationref_parser_->post_componentinstantiationref ());
+            this->componentinstantiationref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 1UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->devicethatloadedthiscomponentref_parser_;
+
+          if (this->devicethatloadedthiscomponentref_parser_)
+            this->devicethatloadedthiscomponentref_parser_->pre ();
+        }
+        else
+        {
+          if (this->devicethatloadedthiscomponentref_parser_)
+          {
+            const ::std::string& tmp (this->devicethatloadedthiscomponentref_parser_->post_devicethatloadedthiscomponentref ());
+            this->devicethatloadedthiscomponentref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 2UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->deviceusedbythiscomponentref_parser_;
+
+          if (this->deviceusedbythiscomponentref_parser_)
+            this->deviceusedbythiscomponentref_parser_->pre ();
+        }
+        else
+        {
+          if (this->deviceusedbythiscomponentref_parser_)
+          {
+            const ::std::pair<std::string, std::string>& tmp (this->deviceusedbythiscomponentref_parser_->post_deviceusedbythiscomponentref ());
+            this->deviceusedbythiscomponentref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 3UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->findby_parser_;
+
+          if (this->findby_parser_)
+            this->findby_parser_->pre ();
+        }
+        else
+        {
+          if (this->findby_parser_)
+          {
+            const ::ossie::FindBy& tmp (this->findby_parser_->post_findby ());
+            this->findby (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+    }
+  }
+
+  // Element validation and dispatch functions for providesport_pskel.
+  //
+  bool providesport_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "providesidentifier" &&
+            ns.empty())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &providesport_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "providesidentifier",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool providesport_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void providesport_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void providesport_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "providesidentifier");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void providesport_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "providesidentifier" &&
+            ns.empty())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->providesidentifier_parser_;
+
+            if (this->providesidentifier_parser_)
+              this->providesidentifier_parser_->pre ();
+          }
+          else
+          {
+            if (this->providesidentifier_parser_)
+            {
+              const ::std::string& tmp (this->providesidentifier_parser_->post_string ());
+              this->providesidentifier (tmp);
+            }
+
+            count = 0;
+            state = 1UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "providesidentifier",
+              ns, n);
+          count = 0;
+          state = 1UL;
+          // Fall through.
+        }
+      }
+      case 1UL:
+      {
+        unsigned long s (~0UL);
+
+        if (n == "componentinstantiationref" &&
+            ns.empty())
+          s = 0UL;
+        else if (n == "devicethatloadedthiscomponentref" &&
+                 ns.empty())
+          s = 1UL;
+        else if (n == "deviceusedbythiscomponentref" &&
+                 ns.empty())
+          s = 2UL;
+        else if (n == "findby" &&
+                 ns.empty())
+          s = 3UL;
+
+        if (s != ~0UL)
+        {
+          assert (start);
+          count = 0;
+          state = ~0UL;
+
+          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+          v_state_descr_& vd = vs.data[vs.size++];
+
+          vd.func = &providesport_pskel::choice_0;
+          vd.state = s;
+          vd.count = 0;
+
+          this->choice_0 (vd.state, vd.count, ns, n, t, true);
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "componentinstantiationref",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  void providesport_pskel::
+  choice_0 (unsigned long& state,
+            unsigned long& count,
+            const ::xml_schema::ro_string& ns,
+            const ::xml_schema::ro_string& n,
+            const ::xml_schema::ro_string* t,
+            bool start)
+  {
+    XSD_UNUSED (count);
+    XSD_UNUSED (ns);
+    XSD_UNUSED (n);
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->componentinstantiationref_parser_;
+
+          if (this->componentinstantiationref_parser_)
+            this->componentinstantiationref_parser_->pre ();
+        }
+        else
+        {
+          if (this->componentinstantiationref_parser_)
+          {
+            const ::std::string& tmp (this->componentinstantiationref_parser_->post_componentinstantiationref ());
+            this->componentinstantiationref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 1UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->devicethatloadedthiscomponentref_parser_;
+
+          if (this->devicethatloadedthiscomponentref_parser_)
+            this->devicethatloadedthiscomponentref_parser_->pre ();
+        }
+        else
+        {
+          if (this->devicethatloadedthiscomponentref_parser_)
+          {
+            const ::std::string& tmp (this->devicethatloadedthiscomponentref_parser_->post_devicethatloadedthiscomponentref ());
+            this->devicethatloadedthiscomponentref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 2UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->deviceusedbythiscomponentref_parser_;
+
+          if (this->deviceusedbythiscomponentref_parser_)
+            this->deviceusedbythiscomponentref_parser_->pre ();
+        }
+        else
+        {
+          if (this->deviceusedbythiscomponentref_parser_)
+          {
+            const ::std::pair<std::string, std::string>& tmp (this->deviceusedbythiscomponentref_parser_->post_deviceusedbythiscomponentref ());
+            this->deviceusedbythiscomponentref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 3UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->findby_parser_;
+
+          if (this->findby_parser_)
+            this->findby_parser_->pre ();
+        }
+        else
+        {
+          if (this->findby_parser_)
+          {
+            const ::ossie::FindBy& tmp (this->findby_parser_->post_findby ());
+            this->findby (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+    }
+  }
+
+  // Element validation and dispatch functions for componentsupportedinterface_pskel.
+  //
+  bool componentsupportedinterface_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "supportedidentifier" &&
+            ns.empty())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &componentsupportedinterface_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "supportedidentifier",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool componentsupportedinterface_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void componentsupportedinterface_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void componentsupportedinterface_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "supportedidentifier");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void componentsupportedinterface_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "supportedidentifier" &&
+            ns.empty())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->supportedidentifier_parser_;
+
+            if (this->supportedidentifier_parser_)
+              this->supportedidentifier_parser_->pre ();
+          }
+          else
+          {
+            if (this->supportedidentifier_parser_)
+            {
+              const ::std::string& tmp (this->supportedidentifier_parser_->post_string ());
+              this->supportedidentifier (tmp);
+            }
+
+            count = 0;
+            state = 1UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "supportedidentifier",
+              ns, n);
+          count = 0;
+          state = 1UL;
+          // Fall through.
+        }
+      }
+      case 1UL:
+      {
+        unsigned long s (~0UL);
+
+        if (n == "componentinstantiationref" &&
+            ns.empty())
+          s = 0UL;
+        else if (n == "findby" &&
+                 ns.empty())
+          s = 1UL;
+
+        if (s != ~0UL)
+        {
+          assert (start);
+          count = 0;
+          state = ~0UL;
+
+          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+          v_state_descr_& vd = vs.data[vs.size++];
+
+          vd.func = &componentsupportedinterface_pskel::choice_0;
+          vd.state = s;
+          vd.count = 0;
+
+          this->choice_0 (vd.state, vd.count, ns, n, t, true);
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "componentinstantiationref",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  void componentsupportedinterface_pskel::
+  choice_0 (unsigned long& state,
+            unsigned long& count,
+            const ::xml_schema::ro_string& ns,
+            const ::xml_schema::ro_string& n,
+            const ::xml_schema::ro_string* t,
+            bool start)
+  {
+    XSD_UNUSED (count);
+    XSD_UNUSED (ns);
+    XSD_UNUSED (n);
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->componentinstantiationref_parser_;
+
+          if (this->componentinstantiationref_parser_)
+            this->componentinstantiationref_parser_->pre ();
+        }
+        else
+        {
+          if (this->componentinstantiationref_parser_)
+          {
+            const ::std::string& tmp (this->componentinstantiationref_parser_->post_componentinstantiationref ());
+            this->componentinstantiationref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 1UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->findby_parser_;
+
+          if (this->findby_parser_)
+            this->findby_parser_->pre ();
+        }
+        else
+        {
+          if (this->findby_parser_)
+          {
+            const ::ossie::FindBy& tmp (this->findby_parser_->post_findby ());
+            this->findby (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+    }
+  }
+}
+
+namespace dcd
+{
+  // Attribute validation and dispatch functions for deviceconfiguration_pskel.
+  //
+  bool deviceconfiguration_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "id" && ns.empty ())
+    {
+      if (this->id_parser_)
+      {
+        this->id_parser_->pre ();
+        this->id_parser_->_pre_impl ();
+        this->id_parser_->_characters (s);
+        this->id_parser_->_post_impl ();
+        const ::std::string& tmp (this->id_parser_->post_string ());
+        this->id (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->id = true;
+      return true;
+    }
+
+    if (n == "name" && ns.empty ())
+    {
+      if (this->name_parser_)
+      {
+        this->name_parser_->pre ();
+        this->name_parser_->_pre_impl ();
+        this->name_parser_->_characters (s);
+        this->name_parser_->_post_impl ();
+        const ::std::string& tmp (this->name_parser_->post_string ());
+        this->name (tmp);
+      }
+
+      return true;
+    }
+
+    return false;
+  }
+
+  void deviceconfiguration_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.id = false;
+  }
+
+  void deviceconfiguration_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.id)
+      this->_expected_attribute (
+        "", "id");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for componentfile_pskel.
+  //
+  bool componentfile_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "id" && ns.empty ())
+    {
+      if (this->id_parser_)
+      {
+        this->id_parser_->pre ();
+        this->id_parser_->_pre_impl ();
+        this->id_parser_->_characters (s);
+        this->id_parser_->_post_impl ();
+        const ::std::string& tmp (this->id_parser_->post_string ());
+        this->id (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->id = true;
+      return true;
+    }
+
+    if (n == "type" && ns.empty ())
+    {
+      if (this->type_parser_)
+      {
+        this->type_parser_->pre ();
+        this->type_parser_->_pre_impl ();
+        this->type_parser_->_characters (s);
+        this->type_parser_->_post_impl ();
+        const ::std::string& tmp (this->type_parser_->post_string ());
+        this->type (tmp);
+      }
+
+      return true;
+    }
+
+    return false;
+  }
+
+  void componentfile_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.id = false;
+  }
+
+  void componentfile_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.id)
+      this->_expected_attribute (
+        "", "id");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for localfile_pskel.
+  //
+  bool localfile_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "name" && ns.empty ())
+    {
+      if (this->name_parser_)
+      {
+        this->name_parser_->pre ();
+        this->name_parser_->_pre_impl ();
+        this->name_parser_->_characters (s);
+        this->name_parser_->_post_impl ();
+        const ::std::string& tmp (this->name_parser_->post_string ());
+        this->name (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->name = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void localfile_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.name = false;
+  }
+
+  void localfile_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.name)
+      this->_expected_attribute (
+        "", "name");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for componentfileref_pskel.
+  //
+  bool componentfileref_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "refid" && ns.empty ())
+    {
+      if (this->refid_parser_)
+      {
+        this->refid_parser_->pre ();
+        this->refid_parser_->_pre_impl ();
+        this->refid_parser_->_characters (s);
+        this->refid_parser_->_post_impl ();
+        const ::std::string& tmp (this->refid_parser_->post_string ());
+        this->refid (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->refid = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void componentfileref_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.refid = false;
+  }
+
+  void componentfileref_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.refid)
+      this->_expected_attribute (
+        "", "refid");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for deployondevice_pskel.
+  //
+  bool deployondevice_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "refid" && ns.empty ())
+    {
+      if (this->refid_parser_)
+      {
+        this->refid_parser_->pre ();
+        this->refid_parser_->_pre_impl ();
+        this->refid_parser_->_characters (s);
+        this->refid_parser_->_post_impl ();
+        const ::std::string& tmp (this->refid_parser_->post_string ());
+        this->refid (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->refid = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void deployondevice_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.refid = false;
+  }
+
+  void deployondevice_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.refid)
+      this->_expected_attribute (
+        "", "refid");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for compositepartofdevice_pskel.
+  //
+  bool compositepartofdevice_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "refid" && ns.empty ())
+    {
+      if (this->refid_parser_)
+      {
+        this->refid_parser_->pre ();
+        this->refid_parser_->_pre_impl ();
+        this->refid_parser_->_characters (s);
+        this->refid_parser_->_post_impl ();
+        const ::std::string& tmp (this->refid_parser_->post_string ());
+        this->refid (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->refid = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void compositepartofdevice_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.refid = false;
+  }
+
+  void compositepartofdevice_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.refid)
+      this->_expected_attribute (
+        "", "refid");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for devicepkgfile_pskel.
+  //
+  bool devicepkgfile_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "type" && ns.empty ())
+    {
+      if (this->type_parser_)
+      {
+        this->type_parser_->pre ();
+        this->type_parser_->_pre_impl ();
+        this->type_parser_->_characters (s);
+        this->type_parser_->_post_impl ();
+        const ::std::string& tmp (this->type_parser_->post_string ());
+        this->type (tmp);
+      }
+
+      return true;
+    }
+
+    return false;
+  }
+
+  // Attribute validation and dispatch functions for componentinstantiation_pskel.
+  //
+  bool componentinstantiation_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "id" && ns.empty ())
+    {
+      if (this->id_parser_)
+      {
+        this->id_parser_->pre ();
+        this->id_parser_->_pre_impl ();
+        this->id_parser_->_characters (s);
+        this->id_parser_->_post_impl ();
+        const ::std::string& tmp (this->id_parser_->post_string ());
+        this->id (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->id = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void componentinstantiation_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.id = false;
+  }
+
+  void componentinstantiation_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.id)
+      this->_expected_attribute (
+        "", "id");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for loggingconfig_pskel.
+  //
+  bool loggingconfig_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "level" && ns.empty ())
+    {
+      if (this->level_parser_)
+      {
+        this->level_parser_->pre ();
+        this->level_parser_->_pre_impl ();
+        this->level_parser_->_characters (s);
+        this->level_parser_->_post_impl ();
+        const ::std::string& tmp (this->level_parser_->post_string ());
+        this->level (tmp);
+      }
+
+      return true;
+    }
+
+    return this->::xml_schema::string_pskel::_attribute_impl_phase_one (ns, n, s);
+  }
+
+  // Attribute validation and dispatch functions for devicethatloadedthiscomponentref_pskel.
+  //
+  bool devicethatloadedthiscomponentref_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "refid" && ns.empty ())
+    {
+      if (this->refid_parser_)
+      {
+        this->refid_parser_->pre ();
+        this->refid_parser_->_pre_impl ();
+        this->refid_parser_->_characters (s);
+        this->refid_parser_->_post_impl ();
+        const ::std::string& tmp (this->refid_parser_->post_string ());
+        this->refid (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->refid = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void devicethatloadedthiscomponentref_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.refid = false;
+  }
+
+  void devicethatloadedthiscomponentref_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.refid)
+      this->_expected_attribute (
+        "", "refid");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for deviceusedbythiscomponentref_pskel.
+  //
+  bool deviceusedbythiscomponentref_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "refid" && ns.empty ())
+    {
+      if (this->refid_parser_)
+      {
+        this->refid_parser_->pre ();
+        this->refid_parser_->_pre_impl ();
+        this->refid_parser_->_characters (s);
+        this->refid_parser_->_post_impl ();
+        const ::std::string& tmp (this->refid_parser_->post_string ());
+        this->refid (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->refid = true;
+      return true;
+    }
+
+    if (n == "usesrefid" && ns.empty ())
+    {
+      if (this->usesrefid_parser_)
+      {
+        this->usesrefid_parser_->pre ();
+        this->usesrefid_parser_->_pre_impl ();
+        this->usesrefid_parser_->_characters (s);
+        this->usesrefid_parser_->_post_impl ();
+        const ::std::string& tmp (this->usesrefid_parser_->post_string ());
+        this->usesrefid (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->usesrefid = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void deviceusedbythiscomponentref_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.refid = false;
+    as.usesrefid = false;
+  }
+
+  void deviceusedbythiscomponentref_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.refid)
+      this->_expected_attribute (
+        "", "refid");
+    if (!as.usesrefid)
+      this->_expected_attribute (
+        "", "usesrefid");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for simpleref_pskel.
+  //
+  bool simpleref_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "refid" && ns.empty ())
+    {
+      if (this->refid_parser_)
+      {
+        this->refid_parser_->pre ();
+        this->refid_parser_->_pre_impl ();
+        this->refid_parser_->_characters (s);
+        this->refid_parser_->_post_impl ();
+        const ::std::string& tmp (this->refid_parser_->post_string ());
+        this->refid (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->refid = true;
+      return true;
+    }
+
+    if (n == "value" && ns.empty ())
+    {
+      if (this->value_parser_)
+      {
+        this->value_parser_->pre ();
+        this->value_parser_->_pre_impl ();
+        this->value_parser_->_characters (s);
+        this->value_parser_->_post_impl ();
+        const ::std::string& tmp (this->value_parser_->post_string ());
+        this->value (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->value = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void simpleref_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.refid = false;
+    as.value = false;
+  }
+
+  void simpleref_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.refid)
+      this->_expected_attribute (
+        "", "refid");
+    if (!as.value)
+      this->_expected_attribute (
+        "", "value");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for simplesequenceref_pskel.
+  //
+  bool simplesequenceref_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "refid" && ns.empty ())
+    {
+      if (this->refid_parser_)
+      {
+        this->refid_parser_->pre ();
+        this->refid_parser_->_pre_impl ();
+        this->refid_parser_->_characters (s);
+        this->refid_parser_->_post_impl ();
+        const ::std::string& tmp (this->refid_parser_->post_string ());
+        this->refid (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->refid = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void simplesequenceref_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.refid = false;
+  }
+
+  void simplesequenceref_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.refid)
+      this->_expected_attribute (
+        "", "refid");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for structref_pskel.
+  //
+  bool structref_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "refid" && ns.empty ())
+    {
+      if (this->refid_parser_)
+      {
+        this->refid_parser_->pre ();
+        this->refid_parser_->_pre_impl ();
+        this->refid_parser_->_characters (s);
+        this->refid_parser_->_post_impl ();
+        const ::std::string& tmp (this->refid_parser_->post_string ());
+        this->refid (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->refid = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void structref_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.refid = false;
+  }
+
+  void structref_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.refid)
+      this->_expected_attribute (
+        "", "refid");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for structsequenceref_pskel.
+  //
+  bool structsequenceref_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "refid" && ns.empty ())
+    {
+      if (this->refid_parser_)
+      {
+        this->refid_parser_->pre ();
+        this->refid_parser_->_pre_impl ();
+        this->refid_parser_->_characters (s);
+        this->refid_parser_->_post_impl ();
+        const ::std::string& tmp (this->refid_parser_->post_string ());
+        this->refid (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->refid = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void structsequenceref_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.refid = false;
+  }
+
+  void structsequenceref_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.refid)
+      this->_expected_attribute (
+        "", "refid");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for componentinstantiationref_pskel.
+  //
+  bool componentinstantiationref_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "refid" && ns.empty ())
+    {
+      if (this->refid_parser_)
+      {
+        this->refid_parser_->pre ();
+        this->refid_parser_->_pre_impl ();
+        this->refid_parser_->_characters (s);
+        this->refid_parser_->_post_impl ();
+        const ::std::string& tmp (this->refid_parser_->post_string ());
+        this->refid (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->refid = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void componentinstantiationref_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.refid = false;
+  }
+
+  void componentinstantiationref_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.refid)
+      this->_expected_attribute (
+        "", "refid");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for namingservice_pskel.
+  //
+  bool namingservice_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "name" && ns.empty ())
+    {
+      if (this->name_parser_)
+      {
+        this->name_parser_->pre ();
+        this->name_parser_->_pre_impl ();
+        this->name_parser_->_characters (s);
+        this->name_parser_->_post_impl ();
+        const ::std::string& tmp (this->name_parser_->post_string ());
+        this->name (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->name = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void namingservice_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.name = false;
+  }
+
+  void namingservice_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.name)
+      this->_expected_attribute (
+        "", "name");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for domainfinder_pskel.
+  //
+  bool domainfinder_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "type" && ns.empty ())
+    {
+      if (this->type_parser_)
+      {
+        this->type_parser_->pre ();
+        this->type_parser_->_pre_impl ();
+        this->type_parser_->_characters (s);
+        this->type_parser_->_post_impl ();
+        const ::std::string& tmp (this->type_parser_->post_string ());
+        this->type (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->type = true;
+      return true;
+    }
+
+    if (n == "name" && ns.empty ())
+    {
+      if (this->name_parser_)
+      {
+        this->name_parser_->pre ();
+        this->name_parser_->_pre_impl ();
+        this->name_parser_->_characters (s);
+        this->name_parser_->_post_impl ();
+        const ::std::string& tmp (this->name_parser_->post_string ());
+        this->name (tmp);
+      }
+
+      return true;
+    }
+
+    return false;
+  }
+
+  void domainfinder_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.type = false;
+  }
+
+  void domainfinder_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.type)
+      this->_expected_attribute (
+        "", "type");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for filesystemname_pskel.
+  //
+  bool filesystemname_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "mountname" && ns.empty ())
+    {
+      if (this->mountname_parser_)
+      {
+        this->mountname_parser_->pre ();
+        this->mountname_parser_->_pre_impl ();
+        this->mountname_parser_->_characters (s);
+        this->mountname_parser_->_post_impl ();
+        const ::std::string& tmp (this->mountname_parser_->post_string ());
+        this->mountname (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->mountname = true;
+      return true;
+    }
+
+    if (n == "deviceid" && ns.empty ())
+    {
+      if (this->deviceid_parser_)
+      {
+        this->deviceid_parser_->pre ();
+        this->deviceid_parser_->_pre_impl ();
+        this->deviceid_parser_->_characters (s);
+        this->deviceid_parser_->_post_impl ();
+        const ::std::string& tmp (this->deviceid_parser_->post_string ());
+        this->deviceid (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->deviceid = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void filesystemname_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.mountname = false;
+    as.deviceid = false;
+  }
+
+  void filesystemname_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.mountname)
+      this->_expected_attribute (
+        "", "mountname");
+    if (!as.deviceid)
+      this->_expected_attribute (
+        "", "deviceid");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for connectinterface_pskel.
+  //
+  bool connectinterface_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "id" && ns.empty ())
+    {
+      if (this->id_parser_)
+      {
+        this->id_parser_->pre ();
+        this->id_parser_->_pre_impl ();
+        this->id_parser_->_characters (s);
+        this->id_parser_->_post_impl ();
+        const ::std::string& tmp (this->id_parser_->post_string ());
+        this->id (tmp);
+      }
+
+      return true;
+    }
+
+    return false;
+  }
+}
+
+namespace dcd
+{
+}
+
+// Begin epilogue.
+//
+//
+// End epilogue.
+
diff --git src/control/parser/internal/dcd-pskel.h src/control/parser/internal/dcd-pskel.h
new file mode 100644
index 0000000..88cfcb4
--- /dev/null
+++ src/control/parser/internal/dcd-pskel.h
@@ -0,0 +1,3354 @@
+// Copyright (C) 2005-2010 Code Synthesis Tools CC
+//
+// This program was generated by CodeSynthesis XSD, an XML Schema to
+// C++ data binding compiler.
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 2 as
+// published by the Free Software Foundation.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+//
+// In addition, as a special exception, Code Synthesis Tools CC gives
+// permission to link this program with the Xerces-C++ library (or with
+// modified versions of Xerces-C++ that use the same license as Xerces-C++),
+// and distribute linked combinations including the two. You must obey
+// the GNU General Public License version 2 in all respects for all of
+// the code used other than Xerces-C++. If you modify this copy of the
+// program, you may extend this exception to your version of the program,
+// but you are not obligated to do so. If you do not wish to do so, delete
+// this exception statement from your version.
+//
+// Furthermore, Code Synthesis Tools CC makes a special exception for
+// the Free/Libre and Open Source Software (FLOSS) which is described
+// in the accompanying FLOSSE file.
+//
+
+#ifndef CXX______XML_XSD_DCD_PSKEL_H
+#define CXX______XML_XSD_DCD_PSKEL_H
+
+// Begin prologue.
+//
+//
+// End prologue.
+
+#include <xsd/cxx/config.hxx>
+
+#if (XSD_INT_VERSION != 3030000L)
+#error XSD runtime version mismatch
+#endif
+
+#include <xsd/cxx/pre.hxx>
+
+// Forward declarations
+//
+namespace dcd
+{
+  class deviceconfiguration_pskel;
+  class devicemanagersoftpkg_pskel;
+  class componentfiles_pskel;
+  class componentfile_pskel;
+  class localfile_pskel;
+  class partitioning_pskel;
+  class componentplacement_pskel;
+  class componentfileref_pskel;
+  class deployondevice_pskel;
+  class compositepartofdevice_pskel;
+  class devicepkgfile_pskel;
+  class componentinstantiation_pskel;
+  class loggingconfig_pskel;
+  class affinity_pskel;
+  class componentproperties_pskel;
+  class devicethatloadedthiscomponentref_pskel;
+  class deviceusedbythiscomponentref_pskel;
+  class simpleref_pskel;
+  class simplesequenceref_pskel;
+  class structref_pskel;
+  class structsequenceref_pskel;
+  class structvalue_pskel;
+  class values_pskel;
+  class componentinstantiationref_pskel;
+  class domainmanager_pskel;
+  class findby_pskel;
+  class namingservice_pskel;
+  class domainfinder_pskel;
+  class filesystemnames_pskel;
+  class filesystemname_pskel;
+  class connections_pskel;
+  class connectinterface_pskel;
+  class usesport_pskel;
+  class providesport_pskel;
+  class componentsupportedinterface_pskel;
+}
+
+
+#ifndef XSD_USE_CHAR
+#define XSD_USE_CHAR
+#endif
+
+#ifndef XSD_CXX_PARSER_USE_CHAR
+#define XSD_CXX_PARSER_USE_CHAR
+#endif
+
+#include <xsd/cxx/xml/error-handler.hxx>
+#include <xsd/cxx/parser/exceptions.hxx>
+#include <xsd/cxx/parser/elements.hxx>
+#include <xsd/cxx/parser/xml-schema.hxx>
+#include <xsd/cxx/parser/validating/parser.hxx>
+#include <xsd/cxx/parser/validating/exceptions.hxx>
+#include <xsd/cxx/parser/validating/xml-schema-pskel.hxx>
+#include <xsd/cxx/parser/validating/xml-schema-pimpl.hxx>
+#include <xsd/cxx/parser/expat/elements.hxx>
+
+#include "memory"
+#include "map"
+#include "../include/ossie/DeviceManagerConfiguration.h"
+
+namespace xml_schema
+{
+  // Built-in XML Schema types mapping.
+  //
+  typedef ::xsd::cxx::parser::string_sequence< char > string_sequence;
+  typedef ::xsd::cxx::parser::qname< char > qname;
+  typedef ::xsd::cxx::parser::buffer buffer;
+  typedef ::xsd::cxx::parser::time_zone time_zone;
+  typedef ::xsd::cxx::parser::gday gday;
+  typedef ::xsd::cxx::parser::gmonth gmonth;
+  typedef ::xsd::cxx::parser::gyear gyear;
+  typedef ::xsd::cxx::parser::gmonth_day gmonth_day;
+  typedef ::xsd::cxx::parser::gyear_month gyear_month;
+  typedef ::xsd::cxx::parser::date date;
+  typedef ::xsd::cxx::parser::time time;
+  typedef ::xsd::cxx::parser::date_time date_time;
+  typedef ::xsd::cxx::parser::duration duration;
+
+  // Base parser skeletons.
+  //
+  typedef ::xsd::cxx::parser::parser_base< char > parser_base;
+  typedef ::xsd::cxx::parser::validating::empty_content< char > empty_content;
+  typedef ::xsd::cxx::parser::validating::simple_content< char > simple_content;
+  typedef ::xsd::cxx::parser::validating::complex_content< char > complex_content;
+  typedef ::xsd::cxx::parser::validating::list_base< char > list_base;
+
+  // Parser skeletons and implementations for the XML Schema
+  // built-in types.
+  //
+  typedef ::xsd::cxx::parser::validating::any_type_pskel< char > any_type_pskel;
+  typedef ::xsd::cxx::parser::validating::any_type_pimpl< char > any_type_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::any_simple_type_pskel< char > any_simple_type_pskel;
+  typedef ::xsd::cxx::parser::validating::any_simple_type_pimpl< char > any_simple_type_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::byte_pskel< char > byte_pskel;
+  typedef ::xsd::cxx::parser::validating::byte_pimpl< char > byte_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::unsigned_byte_pskel< char > unsigned_byte_pskel;
+  typedef ::xsd::cxx::parser::validating::unsigned_byte_pimpl< char > unsigned_byte_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::short_pskel< char > short_pskel;
+  typedef ::xsd::cxx::parser::validating::short_pimpl< char > short_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::unsigned_short_pskel< char > unsigned_short_pskel;
+  typedef ::xsd::cxx::parser::validating::unsigned_short_pimpl< char > unsigned_short_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::int_pskel< char > int_pskel;
+  typedef ::xsd::cxx::parser::validating::int_pimpl< char > int_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::unsigned_int_pskel< char > unsigned_int_pskel;
+  typedef ::xsd::cxx::parser::validating::unsigned_int_pimpl< char > unsigned_int_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::long_pskel< char > long_pskel;
+  typedef ::xsd::cxx::parser::validating::long_pimpl< char > long_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::unsigned_long_pskel< char > unsigned_long_pskel;
+  typedef ::xsd::cxx::parser::validating::unsigned_long_pimpl< char > unsigned_long_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::integer_pskel< char > integer_pskel;
+  typedef ::xsd::cxx::parser::validating::integer_pimpl< char > integer_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::non_positive_integer_pskel< char > non_positive_integer_pskel;
+  typedef ::xsd::cxx::parser::validating::non_positive_integer_pimpl< char > non_positive_integer_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::non_negative_integer_pskel< char > non_negative_integer_pskel;
+  typedef ::xsd::cxx::parser::validating::non_negative_integer_pimpl< char > non_negative_integer_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::positive_integer_pskel< char > positive_integer_pskel;
+  typedef ::xsd::cxx::parser::validating::positive_integer_pimpl< char > positive_integer_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::negative_integer_pskel< char > negative_integer_pskel;
+  typedef ::xsd::cxx::parser::validating::negative_integer_pimpl< char > negative_integer_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::boolean_pskel< char > boolean_pskel;
+  typedef ::xsd::cxx::parser::validating::boolean_pimpl< char > boolean_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::float_pskel< char > float_pskel;
+  typedef ::xsd::cxx::parser::validating::float_pimpl< char > float_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::double_pskel< char > double_pskel;
+  typedef ::xsd::cxx::parser::validating::double_pimpl< char > double_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::decimal_pskel< char > decimal_pskel;
+  typedef ::xsd::cxx::parser::validating::decimal_pimpl< char > decimal_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::string_pskel< char > string_pskel;
+  typedef ::xsd::cxx::parser::validating::string_pimpl< char > string_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::normalized_string_pskel< char > normalized_string_pskel;
+  typedef ::xsd::cxx::parser::validating::normalized_string_pimpl< char > normalized_string_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::token_pskel< char > token_pskel;
+  typedef ::xsd::cxx::parser::validating::token_pimpl< char > token_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::name_pskel< char > name_pskel;
+  typedef ::xsd::cxx::parser::validating::name_pimpl< char > name_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::nmtoken_pskel< char > nmtoken_pskel;
+  typedef ::xsd::cxx::parser::validating::nmtoken_pimpl< char > nmtoken_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::nmtokens_pskel< char > nmtokens_pskel;
+  typedef ::xsd::cxx::parser::validating::nmtokens_pimpl< char > nmtokens_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::ncname_pskel< char > ncname_pskel;
+  typedef ::xsd::cxx::parser::validating::ncname_pimpl< char > ncname_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::language_pskel< char > language_pskel;
+  typedef ::xsd::cxx::parser::validating::language_pimpl< char > language_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::id_pskel< char > id_pskel;
+  typedef ::xsd::cxx::parser::validating::id_pimpl< char > id_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::idref_pskel< char > idref_pskel;
+  typedef ::xsd::cxx::parser::validating::idref_pimpl< char > idref_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::idrefs_pskel< char > idrefs_pskel;
+  typedef ::xsd::cxx::parser::validating::idrefs_pimpl< char > idrefs_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::uri_pskel< char > uri_pskel;
+  typedef ::xsd::cxx::parser::validating::uri_pimpl< char > uri_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::qname_pskel< char > qname_pskel;
+  typedef ::xsd::cxx::parser::validating::qname_pimpl< char > qname_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::base64_binary_pskel< char > base64_binary_pskel;
+  typedef ::xsd::cxx::parser::validating::base64_binary_pimpl< char > base64_binary_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::hex_binary_pskel< char > hex_binary_pskel;
+  typedef ::xsd::cxx::parser::validating::hex_binary_pimpl< char > hex_binary_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::date_pskel< char > date_pskel;
+  typedef ::xsd::cxx::parser::validating::date_pimpl< char > date_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::date_time_pskel< char > date_time_pskel;
+  typedef ::xsd::cxx::parser::validating::date_time_pimpl< char > date_time_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::duration_pskel< char > duration_pskel;
+  typedef ::xsd::cxx::parser::validating::duration_pimpl< char > duration_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::gday_pskel< char > gday_pskel;
+  typedef ::xsd::cxx::parser::validating::gday_pimpl< char > gday_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::gmonth_pskel< char > gmonth_pskel;
+  typedef ::xsd::cxx::parser::validating::gmonth_pimpl< char > gmonth_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::gmonth_day_pskel< char > gmonth_day_pskel;
+  typedef ::xsd::cxx::parser::validating::gmonth_day_pimpl< char > gmonth_day_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::gyear_pskel< char > gyear_pskel;
+  typedef ::xsd::cxx::parser::validating::gyear_pimpl< char > gyear_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::gyear_month_pskel< char > gyear_month_pskel;
+  typedef ::xsd::cxx::parser::validating::gyear_month_pimpl< char > gyear_month_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::time_pskel< char > time_pskel;
+  typedef ::xsd::cxx::parser::validating::time_pimpl< char > time_pimpl;
+
+  // Exceptions. See libxsd/xsd/cxx/parser/exceptions.hxx for details.
+  //
+  typedef ::xsd::cxx::parser::exception< char > exception;
+
+  // Parsing diagnostics.
+  //
+  typedef ::xsd::cxx::parser::severity severity;
+  typedef ::xsd::cxx::parser::error< char > error;
+  typedef ::xsd::cxx::parser::diagnostics< char > diagnostics;
+  typedef ::xsd::cxx::parser::parsing< char > parsing;
+
+  // Error handler. See libxsd/xsd/cxx/xml/error-handler.hxx for details.
+  //
+  typedef ::xsd::cxx::xml::error_handler< char > error_handler;
+
+  // Read-only string.
+  //
+  typedef ::xsd::cxx::ro_string< char > ro_string;
+
+  // Document type. See libxsd/xsd/cxx/parser/expat/elements.hxx
+  // for details.
+  //
+  typedef ::xsd::cxx::parser::expat::document< char > document;
+}
+
+namespace dcd
+{
+  class deviceconfiguration_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    description (const ::std::string&);
+
+    virtual void
+    devicemanagersoftpkg (const ::std::string&);
+
+    virtual void
+    componentfiles (const ::std::vector<ossie::ComponentFile>&);
+
+    virtual void
+    partitioning (const ::std::vector<ossie::ComponentPlacement>&);
+
+    virtual void
+    connections (const ::std::vector<ossie::Connection>&);
+
+    virtual void
+    domainmanager (const ::std::string&);
+
+    virtual void
+    filesystemnames ();
+
+    virtual void
+    id (const ::std::string&);
+
+    virtual void
+    name (const ::std::string&);
+
+    virtual ::std::auto_ptr<ossie::DeviceManagerConfiguration::DCD>
+    post_deviceconfiguration () = 0;
+
+    // Parser construction API.
+    //
+    void
+    description_parser (::xml_schema::string_pskel&);
+
+    void
+    devicemanagersoftpkg_parser (::dcd::devicemanagersoftpkg_pskel&);
+
+    void
+    componentfiles_parser (::dcd::componentfiles_pskel&);
+
+    void
+    partitioning_parser (::dcd::partitioning_pskel&);
+
+    void
+    connections_parser (::dcd::connections_pskel&);
+
+    void
+    domainmanager_parser (::dcd::domainmanager_pskel&);
+
+    void
+    filesystemnames_parser (::dcd::filesystemnames_pskel&);
+
+    void
+    id_parser (::xml_schema::string_pskel&);
+
+    void
+    name_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* description */,
+             ::dcd::devicemanagersoftpkg_pskel& /* devicemanagersoftpkg */,
+             ::dcd::componentfiles_pskel& /* componentfiles */,
+             ::dcd::partitioning_pskel& /* partitioning */,
+             ::dcd::connections_pskel& /* connections */,
+             ::dcd::domainmanager_pskel& /* domainmanager */,
+             ::dcd::filesystemnames_pskel& /* filesystemnames */,
+             ::xml_schema::string_pskel& /* id */,
+             ::xml_schema::string_pskel& /* name */);
+
+    // Constructor.
+    //
+    deviceconfiguration_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* description_parser_;
+    ::dcd::devicemanagersoftpkg_pskel* devicemanagersoftpkg_parser_;
+    ::dcd::componentfiles_pskel* componentfiles_parser_;
+    ::dcd::partitioning_pskel* partitioning_parser_;
+    ::dcd::connections_pskel* connections_parser_;
+    ::dcd::domainmanager_pskel* domainmanager_parser_;
+    ::dcd::filesystemnames_pskel* filesystemnames_parser_;
+    ::xml_schema::string_pskel* id_parser_;
+    ::xml_schema::string_pskel* name_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::dcd::deviceconfiguration_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+
+    protected:
+    struct v_state_attr_
+    {
+      bool id;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class devicemanagersoftpkg_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    localfile (const ::std::string&);
+
+    virtual ::std::string
+    post_devicemanagersoftpkg () = 0;
+
+    // Parser construction API.
+    //
+    void
+    localfile_parser (::dcd::localfile_pskel&);
+
+    void
+    parsers (::dcd::localfile_pskel& /* localfile */);
+
+    // Constructor.
+    //
+    devicemanagersoftpkg_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::dcd::localfile_pskel* localfile_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::dcd::devicemanagersoftpkg_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+  };
+
+  class componentfiles_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    componentfile (const ::ossie::ComponentFile&);
+
+    virtual ::std::vector<ossie::ComponentFile>
+    post_componentfiles () = 0;
+
+    // Parser construction API.
+    //
+    void
+    componentfile_parser (::dcd::componentfile_pskel&);
+
+    void
+    parsers (::dcd::componentfile_pskel& /* componentfile */);
+
+    // Constructor.
+    //
+    componentfiles_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::dcd::componentfile_pskel* componentfile_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::dcd::componentfiles_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+  };
+
+  class componentfile_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    localfile (const ::std::string&);
+
+    virtual void
+    id (const ::std::string&);
+
+    virtual void
+    type (const ::std::string&);
+
+    virtual ::ossie::ComponentFile
+    post_componentfile () = 0;
+
+    // Parser construction API.
+    //
+    void
+    localfile_parser (::dcd::localfile_pskel&);
+
+    void
+    id_parser (::xml_schema::string_pskel&);
+
+    void
+    type_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::dcd::localfile_pskel& /* localfile */,
+             ::xml_schema::string_pskel& /* id */,
+             ::xml_schema::string_pskel& /* type */);
+
+    // Constructor.
+    //
+    componentfile_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::dcd::localfile_pskel* localfile_parser_;
+    ::xml_schema::string_pskel* id_parser_;
+    ::xml_schema::string_pskel* type_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::dcd::componentfile_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+
+    protected:
+    struct v_state_attr_
+    {
+      bool id;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class localfile_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    name (const ::std::string&);
+
+    virtual ::std::string
+    post_localfile () = 0;
+
+    // Parser construction API.
+    //
+    void
+    name_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* name */);
+
+    // Constructor.
+    //
+    localfile_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* name_parser_;
+
+    protected:
+    struct v_state_attr_
+    {
+      bool name;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class partitioning_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    componentplacement (const ::ossie::ComponentPlacement&);
+
+    virtual ::std::vector<ossie::ComponentPlacement>
+    post_partitioning () = 0;
+
+    // Parser construction API.
+    //
+    void
+    componentplacement_parser (::dcd::componentplacement_pskel&);
+
+    void
+    parsers (::dcd::componentplacement_pskel& /* componentplacement */);
+
+    // Constructor.
+    //
+    partitioning_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::dcd::componentplacement_pskel* componentplacement_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::dcd::partitioning_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+  };
+
+  class componentplacement_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    componentfileref (const ::std::string&);
+
+    virtual void
+    deployondevice (const ::std::string&);
+
+    virtual void
+    compositepartofdevice (const ::std::string&);
+
+    virtual void
+    devicepkgfile ();
+
+    virtual void
+    componentinstantiation (const ::ossie::ComponentInstantiation&);
+
+    virtual ::ossie::ComponentPlacement
+    post_componentplacement () = 0;
+
+    // Parser construction API.
+    //
+    void
+    componentfileref_parser (::dcd::componentfileref_pskel&);
+
+    void
+    deployondevice_parser (::dcd::deployondevice_pskel&);
+
+    void
+    compositepartofdevice_parser (::dcd::compositepartofdevice_pskel&);
+
+    void
+    devicepkgfile_parser (::dcd::devicepkgfile_pskel&);
+
+    void
+    componentinstantiation_parser (::dcd::componentinstantiation_pskel&);
+
+    void
+    parsers (::dcd::componentfileref_pskel& /* componentfileref */,
+             ::dcd::deployondevice_pskel& /* deployondevice */,
+             ::dcd::compositepartofdevice_pskel& /* compositepartofdevice */,
+             ::dcd::devicepkgfile_pskel& /* devicepkgfile */,
+             ::dcd::componentinstantiation_pskel& /* componentinstantiation */);
+
+    // Constructor.
+    //
+    componentplacement_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::dcd::componentfileref_pskel* componentfileref_parser_;
+    ::dcd::deployondevice_pskel* deployondevice_parser_;
+    ::dcd::compositepartofdevice_pskel* compositepartofdevice_parser_;
+    ::dcd::devicepkgfile_pskel* devicepkgfile_parser_;
+    ::dcd::componentinstantiation_pskel* componentinstantiation_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::dcd::componentplacement_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+  };
+
+  class componentfileref_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    refid (const ::std::string&);
+
+    virtual ::std::string
+    post_componentfileref () = 0;
+
+    // Parser construction API.
+    //
+    void
+    refid_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* refid */);
+
+    // Constructor.
+    //
+    componentfileref_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* refid_parser_;
+
+    protected:
+    struct v_state_attr_
+    {
+      bool refid;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class deployondevice_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    refid (const ::std::string&);
+
+    virtual ::std::string
+    post_deployondevice () = 0;
+
+    // Parser construction API.
+    //
+    void
+    refid_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* refid */);
+
+    // Constructor.
+    //
+    deployondevice_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* refid_parser_;
+
+    protected:
+    struct v_state_attr_
+    {
+      bool refid;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class compositepartofdevice_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    refid (const ::std::string&);
+
+    virtual ::std::string
+    post_compositepartofdevice () = 0;
+
+    // Parser construction API.
+    //
+    void
+    refid_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* refid */);
+
+    // Constructor.
+    //
+    compositepartofdevice_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* refid_parser_;
+
+    protected:
+    struct v_state_attr_
+    {
+      bool refid;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class devicepkgfile_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    localfile (const ::std::string&);
+
+    virtual void
+    type (const ::std::string&);
+
+    virtual void
+    post_devicepkgfile ();
+
+    // Parser construction API.
+    //
+    void
+    localfile_parser (::dcd::localfile_pskel&);
+
+    void
+    type_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::dcd::localfile_pskel& /* localfile */,
+             ::xml_schema::string_pskel& /* type */);
+
+    // Constructor.
+    //
+    devicepkgfile_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::dcd::localfile_pskel* localfile_parser_;
+    ::xml_schema::string_pskel* type_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::dcd::devicepkgfile_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+  };
+
+  class componentinstantiation_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    usagename (const ::std::string&);
+
+    virtual void
+    componentproperties (const ::std::vector<ossie::ComponentProperty*>&);
+
+    virtual void
+    affinity (const  ossie::ComponentInstantiation::AffinityProperties &);
+
+    virtual void
+    loggingconfig (const  ossie::ComponentInstantiation::LoggingConfig &);
+
+    virtual void
+    id (const ::std::string&);
+
+    virtual ::ossie::ComponentInstantiation
+    post_componentinstantiation () = 0;
+
+    // Parser construction API.
+    //
+    void
+    usagename_parser (::xml_schema::string_pskel&);
+
+    void
+    componentproperties_parser (::dcd::componentproperties_pskel&);
+
+    void
+    affinity_parser (::dcd::affinity_pskel&);
+
+    void
+    loggingconfig_parser (::dcd::loggingconfig_pskel&);
+
+    void
+    id_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* usagename */,
+             ::dcd::componentproperties_pskel& /* componentproperties */,
+             ::dcd::affinity_pskel& /* affinity */,
+             ::dcd::loggingconfig_pskel& /* loggingconfig */,
+             ::xml_schema::string_pskel& /* id */);
+
+    // Constructor.
+    //
+    componentinstantiation_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* usagename_parser_;
+    ::dcd::componentproperties_pskel* componentproperties_parser_;
+    ::dcd::affinity_pskel* affinity_parser_;
+    ::dcd::loggingconfig_pskel* loggingconfig_parser_;
+    ::xml_schema::string_pskel* id_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::dcd::componentinstantiation_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+
+    protected:
+    struct v_state_attr_
+    {
+      bool id;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class loggingconfig_pskel: public virtual ::xml_schema::string_pskel
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    level (const ::std::string&);
+
+    virtual  ossie::ComponentInstantiation::LoggingConfig 
+    post_loggingconfig () = 0;
+
+    // Parser construction API.
+    //
+    void
+    level_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* level */);
+
+    // Constructor.
+    //
+    loggingconfig_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* level_parser_;
+  };
+
+  class affinity_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    simpleref (ossie::SimplePropertyRef*);
+
+    virtual void
+    simplesequenceref (ossie::SimpleSequencePropertyRef*);
+
+    virtual void
+    structref (ossie::StructPropertyRef*);
+
+    virtual void
+    structsequenceref (ossie::StructSequencePropertyRef*);
+
+    virtual  ossie::ComponentInstantiation::AffinityProperties 
+    post_affinity () = 0;
+
+    // Parser construction API.
+    //
+    void
+    simpleref_parser (::dcd::simpleref_pskel&);
+
+    void
+    simplesequenceref_parser (::dcd::simplesequenceref_pskel&);
+
+    void
+    structref_parser (::dcd::structref_pskel&);
+
+    void
+    structsequenceref_parser (::dcd::structsequenceref_pskel&);
+
+    void
+    parsers (::dcd::simpleref_pskel& /* simpleref */,
+             ::dcd::simplesequenceref_pskel& /* simplesequenceref */,
+             ::dcd::structref_pskel& /* structref */,
+             ::dcd::structsequenceref_pskel& /* structsequenceref */);
+
+    // Constructor.
+    //
+    affinity_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::dcd::simpleref_pskel* simpleref_parser_;
+    ::dcd::simplesequenceref_pskel* simplesequenceref_parser_;
+    ::dcd::structref_pskel* structref_parser_;
+    ::dcd::structsequenceref_pskel* structsequenceref_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::dcd::affinity_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    choice_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start);
+  };
+
+  class componentproperties_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    simpleref (ossie::SimplePropertyRef*);
+
+    virtual void
+    simplesequenceref (ossie::SimpleSequencePropertyRef*);
+
+    virtual void
+    structref (ossie::StructPropertyRef*);
+
+    virtual void
+    structsequenceref (ossie::StructSequencePropertyRef*);
+
+    virtual ::std::vector<ossie::ComponentProperty*>
+    post_componentproperties () = 0;
+
+    // Parser construction API.
+    //
+    void
+    simpleref_parser (::dcd::simpleref_pskel&);
+
+    void
+    simplesequenceref_parser (::dcd::simplesequenceref_pskel&);
+
+    void
+    structref_parser (::dcd::structref_pskel&);
+
+    void
+    structsequenceref_parser (::dcd::structsequenceref_pskel&);
+
+    void
+    parsers (::dcd::simpleref_pskel& /* simpleref */,
+             ::dcd::simplesequenceref_pskel& /* simplesequenceref */,
+             ::dcd::structref_pskel& /* structref */,
+             ::dcd::structsequenceref_pskel& /* structsequenceref */);
+
+    // Constructor.
+    //
+    componentproperties_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::dcd::simpleref_pskel* simpleref_parser_;
+    ::dcd::simplesequenceref_pskel* simplesequenceref_parser_;
+    ::dcd::structref_pskel* structref_parser_;
+    ::dcd::structsequenceref_pskel* structsequenceref_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::dcd::componentproperties_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    choice_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start);
+  };
+
+  class devicethatloadedthiscomponentref_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    refid (const ::std::string&);
+
+    virtual ::std::string
+    post_devicethatloadedthiscomponentref () = 0;
+
+    // Parser construction API.
+    //
+    void
+    refid_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* refid */);
+
+    // Constructor.
+    //
+    devicethatloadedthiscomponentref_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* refid_parser_;
+
+    protected:
+    struct v_state_attr_
+    {
+      bool refid;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class deviceusedbythiscomponentref_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    refid (const ::std::string&);
+
+    virtual void
+    usesrefid (const ::std::string&);
+
+    virtual ::std::pair<std::string, std::string>
+    post_deviceusedbythiscomponentref () = 0;
+
+    // Parser construction API.
+    //
+    void
+    refid_parser (::xml_schema::string_pskel&);
+
+    void
+    usesrefid_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* refid */,
+             ::xml_schema::string_pskel& /* usesrefid */);
+
+    // Constructor.
+    //
+    deviceusedbythiscomponentref_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* refid_parser_;
+    ::xml_schema::string_pskel* usesrefid_parser_;
+
+    protected:
+    struct v_state_attr_
+    {
+      bool refid;
+      bool usesrefid;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class simpleref_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    refid (const ::std::string&);
+
+    virtual void
+    value (const ::std::string&);
+
+    virtual ossie::SimplePropertyRef*
+    post_simpleref () = 0;
+
+    // Parser construction API.
+    //
+    void
+    refid_parser (::xml_schema::string_pskel&);
+
+    void
+    value_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* refid */,
+             ::xml_schema::string_pskel& /* value */);
+
+    // Constructor.
+    //
+    simpleref_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* refid_parser_;
+    ::xml_schema::string_pskel* value_parser_;
+
+    protected:
+    struct v_state_attr_
+    {
+      bool refid;
+      bool value;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class simplesequenceref_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    values (const ::std::vector<std::string>&);
+
+    virtual void
+    refid (const ::std::string&);
+
+    virtual ossie::SimpleSequencePropertyRef*
+    post_simplesequenceref () = 0;
+
+    // Parser construction API.
+    //
+    void
+    values_parser (::dcd::values_pskel&);
+
+    void
+    refid_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::dcd::values_pskel& /* values */,
+             ::xml_schema::string_pskel& /* refid */);
+
+    // Constructor.
+    //
+    simplesequenceref_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::dcd::values_pskel* values_parser_;
+    ::xml_schema::string_pskel* refid_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::dcd::simplesequenceref_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+
+    protected:
+    struct v_state_attr_
+    {
+      bool refid;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class structref_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    simpleref (ossie::SimplePropertyRef*);
+
+    virtual void
+    simplesequenceref (ossie::SimpleSequencePropertyRef*);
+
+    virtual void
+    refid (const ::std::string&);
+
+    virtual ossie::StructPropertyRef*
+    post_structref () = 0;
+
+    // Parser construction API.
+    //
+    void
+    simpleref_parser (::dcd::simpleref_pskel&);
+
+    void
+    simplesequenceref_parser (::dcd::simplesequenceref_pskel&);
+
+    void
+    refid_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::dcd::simpleref_pskel& /* simpleref */,
+             ::dcd::simplesequenceref_pskel& /* simplesequenceref */,
+             ::xml_schema::string_pskel& /* refid */);
+
+    // Constructor.
+    //
+    structref_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::dcd::simpleref_pskel* simpleref_parser_;
+    ::dcd::simplesequenceref_pskel* simplesequenceref_parser_;
+    ::xml_schema::string_pskel* refid_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::dcd::structref_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[3UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+
+    void
+    choice_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start);
+
+    protected:
+    struct v_state_attr_
+    {
+      bool refid;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class structsequenceref_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    structvalue (const ::std::map<std::string, ossie::ComponentProperty*>&);
+
+    virtual void
+    refid (const ::std::string&);
+
+    virtual ossie::StructSequencePropertyRef*
+    post_structsequenceref () = 0;
+
+    // Parser construction API.
+    //
+    void
+    structvalue_parser (::dcd::structvalue_pskel&);
+
+    void
+    refid_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::dcd::structvalue_pskel& /* structvalue */,
+             ::xml_schema::string_pskel& /* refid */);
+
+    // Constructor.
+    //
+    structsequenceref_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::dcd::structvalue_pskel* structvalue_parser_;
+    ::xml_schema::string_pskel* refid_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::dcd::structsequenceref_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+
+    protected:
+    struct v_state_attr_
+    {
+      bool refid;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class structvalue_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    simpleref (ossie::SimplePropertyRef*);
+
+    virtual void
+    simplesequenceref (ossie::SimpleSequencePropertyRef*);
+
+    virtual ::std::map<std::string, ossie::ComponentProperty*>
+    post_structvalue () = 0;
+
+    // Parser construction API.
+    //
+    void
+    simpleref_parser (::dcd::simpleref_pskel&);
+
+    void
+    simplesequenceref_parser (::dcd::simplesequenceref_pskel&);
+
+    void
+    parsers (::dcd::simpleref_pskel& /* simpleref */,
+             ::dcd::simplesequenceref_pskel& /* simplesequenceref */);
+
+    // Constructor.
+    //
+    structvalue_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::dcd::simpleref_pskel* simpleref_parser_;
+    ::dcd::simplesequenceref_pskel* simplesequenceref_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::dcd::structvalue_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[3UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+
+    void
+    choice_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start);
+  };
+
+  class values_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    value (const ::std::string&);
+
+    virtual ::std::vector<std::string>
+    post_values () = 0;
+
+    // Parser construction API.
+    //
+    void
+    value_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* value */);
+
+    // Constructor.
+    //
+    values_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::xml_schema::string_pskel* value_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::dcd::values_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+  };
+
+  class componentinstantiationref_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    refid (const ::std::string&);
+
+    virtual ::std::string
+    post_componentinstantiationref () = 0;
+
+    // Parser construction API.
+    //
+    void
+    refid_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* refid */);
+
+    // Constructor.
+    //
+    componentinstantiationref_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* refid_parser_;
+
+    protected:
+    struct v_state_attr_
+    {
+      bool refid;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class domainmanager_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    namingservice (const ::std::string&);
+
+    virtual void
+    stringifiedobjectref (const ::std::string&);
+
+    virtual ::std::string
+    post_domainmanager () = 0;
+
+    // Parser construction API.
+    //
+    void
+    namingservice_parser (::dcd::namingservice_pskel&);
+
+    void
+    stringifiedobjectref_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::dcd::namingservice_pskel& /* namingservice */,
+             ::xml_schema::string_pskel& /* stringifiedobjectref */);
+
+    // Constructor.
+    //
+    domainmanager_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::dcd::namingservice_pskel* namingservice_parser_;
+    ::xml_schema::string_pskel* stringifiedobjectref_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::dcd::domainmanager_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    choice_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start);
+  };
+
+  class findby_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    namingservice (const ::std::string&);
+
+    virtual void
+    stringifiedobjectref (const ::std::string&);
+
+    virtual void
+    domainfinder (const ::std::pair<std::string, std::string>&);
+
+    virtual ::ossie::FindBy
+    post_findby () = 0;
+
+    // Parser construction API.
+    //
+    void
+    namingservice_parser (::dcd::namingservice_pskel&);
+
+    void
+    stringifiedobjectref_parser (::xml_schema::string_pskel&);
+
+    void
+    domainfinder_parser (::dcd::domainfinder_pskel&);
+
+    void
+    parsers (::dcd::namingservice_pskel& /* namingservice */,
+             ::xml_schema::string_pskel& /* stringifiedobjectref */,
+             ::dcd::domainfinder_pskel& /* domainfinder */);
+
+    // Constructor.
+    //
+    findby_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::dcd::namingservice_pskel* namingservice_parser_;
+    ::xml_schema::string_pskel* stringifiedobjectref_parser_;
+    ::dcd::domainfinder_pskel* domainfinder_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::dcd::findby_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    choice_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start);
+  };
+
+  class namingservice_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    name (const ::std::string&);
+
+    virtual ::std::string
+    post_namingservice () = 0;
+
+    // Parser construction API.
+    //
+    void
+    name_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* name */);
+
+    // Constructor.
+    //
+    namingservice_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* name_parser_;
+
+    protected:
+    struct v_state_attr_
+    {
+      bool name;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class domainfinder_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    type (const ::std::string&);
+
+    virtual void
+    name (const ::std::string&);
+
+    virtual ::std::pair<std::string, std::string>
+    post_domainfinder () = 0;
+
+    // Parser construction API.
+    //
+    void
+    type_parser (::xml_schema::string_pskel&);
+
+    void
+    name_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* type */,
+             ::xml_schema::string_pskel& /* name */);
+
+    // Constructor.
+    //
+    domainfinder_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* type_parser_;
+    ::xml_schema::string_pskel* name_parser_;
+
+    protected:
+    struct v_state_attr_
+    {
+      bool type;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class filesystemnames_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    filesystemname ();
+
+    virtual void
+    post_filesystemnames ();
+
+    // Parser construction API.
+    //
+    void
+    filesystemname_parser (::dcd::filesystemname_pskel&);
+
+    void
+    parsers (::dcd::filesystemname_pskel& /* filesystemname */);
+
+    // Constructor.
+    //
+    filesystemnames_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::dcd::filesystemname_pskel* filesystemname_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::dcd::filesystemnames_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+  };
+
+  class filesystemname_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    mountname (const ::std::string&);
+
+    virtual void
+    deviceid (const ::std::string&);
+
+    virtual void
+    post_filesystemname ();
+
+    // Parser construction API.
+    //
+    void
+    mountname_parser (::xml_schema::string_pskel&);
+
+    void
+    deviceid_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* mountname */,
+             ::xml_schema::string_pskel& /* deviceid */);
+
+    // Constructor.
+    //
+    filesystemname_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* mountname_parser_;
+    ::xml_schema::string_pskel* deviceid_parser_;
+
+    protected:
+    struct v_state_attr_
+    {
+      bool mountname;
+      bool deviceid;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class connections_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    connectinterface (const ::ossie::Connection&);
+
+    virtual ::std::vector<ossie::Connection>
+    post_connections () = 0;
+
+    // Parser construction API.
+    //
+    void
+    connectinterface_parser (::dcd::connectinterface_pskel&);
+
+    void
+    parsers (::dcd::connectinterface_pskel& /* connectinterface */);
+
+    // Constructor.
+    //
+    connections_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::dcd::connectinterface_pskel* connectinterface_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::dcd::connections_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+  };
+
+  class connectinterface_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    usesport (const ::ossie::UsesPort&);
+
+    virtual void
+    providesport (const ::ossie::ProvidesPort&);
+
+    virtual void
+    componentsupportedinterface (const ::ossie::ComponentSupportedInterface&);
+
+    virtual void
+    findby (const ::ossie::FindBy&);
+
+    virtual void
+    id (const ::std::string&);
+
+    virtual ::ossie::Connection
+    post_connectinterface () = 0;
+
+    // Parser construction API.
+    //
+    void
+    usesport_parser (::dcd::usesport_pskel&);
+
+    void
+    providesport_parser (::dcd::providesport_pskel&);
+
+    void
+    componentsupportedinterface_parser (::dcd::componentsupportedinterface_pskel&);
+
+    void
+    findby_parser (::dcd::findby_pskel&);
+
+    void
+    id_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::dcd::usesport_pskel& /* usesport */,
+             ::dcd::providesport_pskel& /* providesport */,
+             ::dcd::componentsupportedinterface_pskel& /* componentsupportedinterface */,
+             ::dcd::findby_pskel& /* findby */,
+             ::xml_schema::string_pskel& /* id */);
+
+    // Constructor.
+    //
+    connectinterface_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::dcd::usesport_pskel* usesport_parser_;
+    ::dcd::providesport_pskel* providesport_parser_;
+    ::dcd::componentsupportedinterface_pskel* componentsupportedinterface_parser_;
+    ::dcd::findby_pskel* findby_parser_;
+    ::xml_schema::string_pskel* id_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::dcd::connectinterface_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[3UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+
+    void
+    choice_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start);
+  };
+
+  class usesport_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    usesidentifier (const ::std::string&);
+
+    virtual void
+    componentinstantiationref (const ::std::string&);
+
+    virtual void
+    devicethatloadedthiscomponentref (const ::std::string&);
+
+    virtual void
+    deviceusedbythiscomponentref (const ::std::pair<std::string, std::string>&);
+
+    virtual void
+    findby (const ::ossie::FindBy&);
+
+    virtual ::ossie::UsesPort
+    post_usesport () = 0;
+
+    // Parser construction API.
+    //
+    void
+    usesidentifier_parser (::xml_schema::string_pskel&);
+
+    void
+    componentinstantiationref_parser (::dcd::componentinstantiationref_pskel&);
+
+    void
+    devicethatloadedthiscomponentref_parser (::dcd::devicethatloadedthiscomponentref_pskel&);
+
+    void
+    deviceusedbythiscomponentref_parser (::dcd::deviceusedbythiscomponentref_pskel&);
+
+    void
+    findby_parser (::dcd::findby_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* usesidentifier */,
+             ::dcd::componentinstantiationref_pskel& /* componentinstantiationref */,
+             ::dcd::devicethatloadedthiscomponentref_pskel& /* devicethatloadedthiscomponentref */,
+             ::dcd::deviceusedbythiscomponentref_pskel& /* deviceusedbythiscomponentref */,
+             ::dcd::findby_pskel& /* findby */);
+
+    // Constructor.
+    //
+    usesport_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::xml_schema::string_pskel* usesidentifier_parser_;
+    ::dcd::componentinstantiationref_pskel* componentinstantiationref_parser_;
+    ::dcd::devicethatloadedthiscomponentref_pskel* devicethatloadedthiscomponentref_parser_;
+    ::dcd::deviceusedbythiscomponentref_pskel* deviceusedbythiscomponentref_parser_;
+    ::dcd::findby_pskel* findby_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::dcd::usesport_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[3UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+
+    void
+    choice_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start);
+  };
+
+  class providesport_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    providesidentifier (const ::std::string&);
+
+    virtual void
+    componentinstantiationref (const ::std::string&);
+
+    virtual void
+    devicethatloadedthiscomponentref (const ::std::string&);
+
+    virtual void
+    deviceusedbythiscomponentref (const ::std::pair<std::string, std::string>&);
+
+    virtual void
+    findby (const ::ossie::FindBy&);
+
+    virtual ::ossie::ProvidesPort
+    post_providesport () = 0;
+
+    // Parser construction API.
+    //
+    void
+    providesidentifier_parser (::xml_schema::string_pskel&);
+
+    void
+    componentinstantiationref_parser (::dcd::componentinstantiationref_pskel&);
+
+    void
+    devicethatloadedthiscomponentref_parser (::dcd::devicethatloadedthiscomponentref_pskel&);
+
+    void
+    deviceusedbythiscomponentref_parser (::dcd::deviceusedbythiscomponentref_pskel&);
+
+    void
+    findby_parser (::dcd::findby_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* providesidentifier */,
+             ::dcd::componentinstantiationref_pskel& /* componentinstantiationref */,
+             ::dcd::devicethatloadedthiscomponentref_pskel& /* devicethatloadedthiscomponentref */,
+             ::dcd::deviceusedbythiscomponentref_pskel& /* deviceusedbythiscomponentref */,
+             ::dcd::findby_pskel& /* findby */);
+
+    // Constructor.
+    //
+    providesport_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::xml_schema::string_pskel* providesidentifier_parser_;
+    ::dcd::componentinstantiationref_pskel* componentinstantiationref_parser_;
+    ::dcd::devicethatloadedthiscomponentref_pskel* devicethatloadedthiscomponentref_parser_;
+    ::dcd::deviceusedbythiscomponentref_pskel* deviceusedbythiscomponentref_parser_;
+    ::dcd::findby_pskel* findby_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::dcd::providesport_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[3UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+
+    void
+    choice_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start);
+  };
+
+  class componentsupportedinterface_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    supportedidentifier (const ::std::string&);
+
+    virtual void
+    componentinstantiationref (const ::std::string&);
+
+    virtual void
+    findby (const ::ossie::FindBy&);
+
+    virtual ::ossie::ComponentSupportedInterface
+    post_componentsupportedinterface () = 0;
+
+    // Parser construction API.
+    //
+    void
+    supportedidentifier_parser (::xml_schema::string_pskel&);
+
+    void
+    componentinstantiationref_parser (::dcd::componentinstantiationref_pskel&);
+
+    void
+    findby_parser (::dcd::findby_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* supportedidentifier */,
+             ::dcd::componentinstantiationref_pskel& /* componentinstantiationref */,
+             ::dcd::findby_pskel& /* findby */);
+
+    // Constructor.
+    //
+    componentsupportedinterface_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::xml_schema::string_pskel* supportedidentifier_parser_;
+    ::dcd::componentinstantiationref_pskel* componentinstantiationref_parser_;
+    ::dcd::findby_pskel* findby_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::dcd::componentsupportedinterface_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[3UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+
+    void
+    choice_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start);
+  };
+}
+
+#include <xsd/cxx/post.hxx>
+
+// Begin epilogue.
+//
+//
+// End epilogue.
+
+#endif // CXX______XML_XSD_DCD_PSKEL_H
diff --git src/control/parser/internal/dmd-pskel.cpp src/control/parser/internal/dmd-pskel.cpp
new file mode 100644
index 0000000..12e1bc2
--- /dev/null
+++ src/control/parser/internal/dmd-pskel.cpp
@@ -0,0 +1,1722 @@
+// Copyright (C) 2005-2010 Code Synthesis Tools CC
+//
+// This program was generated by CodeSynthesis XSD, an XML Schema to
+// C++ data binding compiler.
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 2 as
+// published by the Free Software Foundation.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+//
+// In addition, as a special exception, Code Synthesis Tools CC gives
+// permission to link this program with the Xerces-C++ library (or with
+// modified versions of Xerces-C++ that use the same license as Xerces-C++),
+// and distribute linked combinations including the two. You must obey
+// the GNU General Public License version 2 in all respects for all of
+// the code used other than Xerces-C++. If you modify this copy of the
+// program, you may extend this exception to your version of the program,
+// but you are not obligated to do so. If you do not wish to do so, delete
+// this exception statement from your version.
+//
+// Furthermore, Code Synthesis Tools CC makes a special exception for
+// the Free/Libre and Open Source Software (FLOSS) which is described
+// in the accompanying FLOSSE file.
+//
+
+// Begin prologue.
+//
+//
+// End prologue.
+
+#include "dmd-pskel.h"
+
+namespace dmd
+{
+  // domainmanagerconfiguration_pskel
+  //
+
+  void domainmanagerconfiguration_pskel::
+  description_parser (::xml_schema::string_pskel& p)
+  {
+    this->description_parser_ = &p;
+  }
+
+  void domainmanagerconfiguration_pskel::
+  domainmanagersoftpkg_parser (::dmd::domainmanagersoftpkg_pskel& p)
+  {
+    this->domainmanagersoftpkg_parser_ = &p;
+  }
+
+  void domainmanagerconfiguration_pskel::
+  services_parser (::dmd::services_pskel& p)
+  {
+    this->services_parser_ = &p;
+  }
+
+  void domainmanagerconfiguration_pskel::
+  id_parser (::xml_schema::string_pskel& p)
+  {
+    this->id_parser_ = &p;
+  }
+
+  void domainmanagerconfiguration_pskel::
+  name_parser (::xml_schema::string_pskel& p)
+  {
+    this->name_parser_ = &p;
+  }
+
+  void domainmanagerconfiguration_pskel::
+  parsers (::xml_schema::string_pskel& description,
+           ::dmd::domainmanagersoftpkg_pskel& domainmanagersoftpkg,
+           ::dmd::services_pskel& services,
+           ::xml_schema::string_pskel& id,
+           ::xml_schema::string_pskel& name)
+  {
+    this->description_parser_ = &description;
+    this->domainmanagersoftpkg_parser_ = &domainmanagersoftpkg;
+    this->services_parser_ = &services;
+    this->id_parser_ = &id;
+    this->name_parser_ = &name;
+  }
+
+  domainmanagerconfiguration_pskel::
+  domainmanagerconfiguration_pskel ()
+  : description_parser_ (0),
+    domainmanagersoftpkg_parser_ (0),
+    services_parser_ (0),
+    id_parser_ (0),
+    name_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // domainmanagersoftpkg_pskel
+  //
+
+  void domainmanagersoftpkg_pskel::
+  localfile_parser (::dmd::localfile_pskel& p)
+  {
+    this->localfile_parser_ = &p;
+  }
+
+  void domainmanagersoftpkg_pskel::
+  parsers (::dmd::localfile_pskel& localfile)
+  {
+    this->localfile_parser_ = &localfile;
+  }
+
+  domainmanagersoftpkg_pskel::
+  domainmanagersoftpkg_pskel ()
+  : localfile_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // localfile_pskel
+  //
+
+  void localfile_pskel::
+  name_parser (::xml_schema::string_pskel& p)
+  {
+    this->name_parser_ = &p;
+  }
+
+  void localfile_pskel::
+  parsers (::xml_schema::string_pskel& name)
+  {
+    this->name_parser_ = &name;
+  }
+
+  localfile_pskel::
+  localfile_pskel ()
+  : name_parser_ (0),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // services_pskel
+  //
+
+  void services_pskel::
+  service_parser (::dmd::service_pskel& p)
+  {
+    this->service_parser_ = &p;
+  }
+
+  void services_pskel::
+  parsers (::dmd::service_pskel& service)
+  {
+    this->service_parser_ = &service;
+  }
+
+  services_pskel::
+  services_pskel ()
+  : service_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // service_pskel
+  //
+
+  void service_pskel::
+  usesidentifier_parser (::xml_schema::string_pskel& p)
+  {
+    this->usesidentifier_parser_ = &p;
+  }
+
+  void service_pskel::
+  findby_parser (::dmd::findby_pskel& p)
+  {
+    this->findby_parser_ = &p;
+  }
+
+  void service_pskel::
+  parsers (::xml_schema::string_pskel& usesidentifier,
+           ::dmd::findby_pskel& findby)
+  {
+    this->usesidentifier_parser_ = &usesidentifier;
+    this->findby_parser_ = &findby;
+  }
+
+  service_pskel::
+  service_pskel ()
+  : usesidentifier_parser_ (0),
+    findby_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // findby_pskel
+  //
+
+  void findby_pskel::
+  namingservice_parser (::dmd::namingservice_pskel& p)
+  {
+    this->namingservice_parser_ = &p;
+  }
+
+  void findby_pskel::
+  stringifiedobjectref_parser (::xml_schema::string_pskel& p)
+  {
+    this->stringifiedobjectref_parser_ = &p;
+  }
+
+  void findby_pskel::
+  domainfinder_parser (::dmd::domainfinder_pskel& p)
+  {
+    this->domainfinder_parser_ = &p;
+  }
+
+  void findby_pskel::
+  parsers (::dmd::namingservice_pskel& namingservice,
+           ::xml_schema::string_pskel& stringifiedobjectref,
+           ::dmd::domainfinder_pskel& domainfinder)
+  {
+    this->namingservice_parser_ = &namingservice;
+    this->stringifiedobjectref_parser_ = &stringifiedobjectref;
+    this->domainfinder_parser_ = &domainfinder;
+  }
+
+  findby_pskel::
+  findby_pskel ()
+  : namingservice_parser_ (0),
+    stringifiedobjectref_parser_ (0),
+    domainfinder_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // namingservice_pskel
+  //
+
+  void namingservice_pskel::
+  name_parser (::xml_schema::any_simple_type_pskel& p)
+  {
+    this->name_parser_ = &p;
+  }
+
+  void namingservice_pskel::
+  parsers (::xml_schema::any_simple_type_pskel& name)
+  {
+    this->name_parser_ = &name;
+  }
+
+  namingservice_pskel::
+  namingservice_pskel ()
+  : name_parser_ (0),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // domainfinder_pskel
+  //
+
+  void domainfinder_pskel::
+  type_parser (::xml_schema::string_pskel& p)
+  {
+    this->type_parser_ = &p;
+  }
+
+  void domainfinder_pskel::
+  name_parser (::xml_schema::string_pskel& p)
+  {
+    this->name_parser_ = &p;
+  }
+
+  void domainfinder_pskel::
+  parsers (::xml_schema::string_pskel& type,
+           ::xml_schema::string_pskel& name)
+  {
+    this->type_parser_ = &type;
+    this->name_parser_ = &name;
+  }
+
+  domainfinder_pskel::
+  domainfinder_pskel ()
+  : type_parser_ (0),
+    name_parser_ (0),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+}
+
+namespace dmd
+{
+  // domainmanagerconfiguration_pskel
+  //
+
+  void domainmanagerconfiguration_pskel::
+  description (const ::std::string&)
+  {
+  }
+
+  void domainmanagerconfiguration_pskel::
+  domainmanagersoftpkg (const ::std::string&)
+  {
+  }
+
+  void domainmanagerconfiguration_pskel::
+  services ()
+  {
+  }
+
+  void domainmanagerconfiguration_pskel::
+  id (const ::std::string&)
+  {
+  }
+
+  void domainmanagerconfiguration_pskel::
+  name (const ::std::string&)
+  {
+  }
+
+  // domainmanagersoftpkg_pskel
+  //
+
+  void domainmanagersoftpkg_pskel::
+  localfile (const ::std::string&)
+  {
+  }
+
+  // localfile_pskel
+  //
+
+  void localfile_pskel::
+  name (const ::std::string&)
+  {
+  }
+
+  // services_pskel
+  //
+
+  void services_pskel::
+  service ()
+  {
+  }
+
+  void services_pskel::
+  post_services ()
+  {
+  }
+
+  // service_pskel
+  //
+
+  void service_pskel::
+  usesidentifier (const ::std::string&)
+  {
+  }
+
+  void service_pskel::
+  findby ()
+  {
+  }
+
+  void service_pskel::
+  post_service ()
+  {
+  }
+
+  // findby_pskel
+  //
+
+  void findby_pskel::
+  namingservice ()
+  {
+  }
+
+  void findby_pskel::
+  stringifiedobjectref (const ::std::string&)
+  {
+  }
+
+  void findby_pskel::
+  domainfinder ()
+  {
+  }
+
+  void findby_pskel::
+  post_findby ()
+  {
+  }
+
+  // namingservice_pskel
+  //
+
+  void namingservice_pskel::
+  name ()
+  {
+  }
+
+  void namingservice_pskel::
+  post_namingservice ()
+  {
+  }
+
+  // domainfinder_pskel
+  //
+
+  void domainfinder_pskel::
+  type (const ::std::string&)
+  {
+  }
+
+  void domainfinder_pskel::
+  name (const ::std::string&)
+  {
+  }
+
+  void domainfinder_pskel::
+  post_domainfinder ()
+  {
+  }
+}
+
+#include <cassert>
+
+namespace dmd
+{
+  // Element validation and dispatch functions for domainmanagerconfiguration_pskel.
+  //
+  bool domainmanagerconfiguration_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "description" &&
+            ns.empty())
+          s = 0UL;
+        else if (n == "domainmanagersoftpkg" &&
+                 ns.empty())
+          s = 1UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &domainmanagerconfiguration_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "description",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool domainmanagerconfiguration_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void domainmanagerconfiguration_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void domainmanagerconfiguration_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "description");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void domainmanagerconfiguration_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "description" &&
+            ns.empty())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->description_parser_;
+
+            if (this->description_parser_)
+              this->description_parser_->pre ();
+          }
+          else
+          {
+            if (this->description_parser_)
+            {
+              const ::std::string& tmp (this->description_parser_->post_string ());
+              this->description (tmp);
+            }
+
+            count = 0;
+            state = 1UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 1UL;
+          // Fall through.
+        }
+      }
+      case 1UL:
+      {
+        if (n == "domainmanagersoftpkg" &&
+            ns.empty())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->domainmanagersoftpkg_parser_;
+
+            if (this->domainmanagersoftpkg_parser_)
+              this->domainmanagersoftpkg_parser_->pre ();
+          }
+          else
+          {
+            if (this->domainmanagersoftpkg_parser_)
+            {
+              const ::std::string& tmp (this->domainmanagersoftpkg_parser_->post_domainmanagersoftpkg ());
+              this->domainmanagersoftpkg (tmp);
+            }
+
+            count = 0;
+            state = 2UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "domainmanagersoftpkg",
+              ns, n);
+          count = 0;
+          state = 2UL;
+          // Fall through.
+        }
+      }
+      case 2UL:
+      {
+        if (n == "services" &&
+            ns.empty())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->services_parser_;
+
+            if (this->services_parser_)
+              this->services_parser_->pre ();
+          }
+          else
+          {
+            if (this->services_parser_)
+            {
+              this->services_parser_->post_services ();
+              this->services ();
+            }
+
+            count = 0;
+            state = ~0UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for domainmanagersoftpkg_pskel.
+  //
+  bool domainmanagersoftpkg_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "localfile" &&
+            ns.empty())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &domainmanagersoftpkg_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "localfile",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool domainmanagersoftpkg_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void domainmanagersoftpkg_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void domainmanagersoftpkg_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "localfile");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void domainmanagersoftpkg_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "localfile" &&
+            ns.empty())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->localfile_parser_;
+
+            if (this->localfile_parser_)
+              this->localfile_parser_->pre ();
+          }
+          else
+          {
+            if (this->localfile_parser_)
+            {
+              const ::std::string& tmp (this->localfile_parser_->post_localfile ());
+              this->localfile (tmp);
+            }
+
+            count = 0;
+            state = ~0UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "localfile",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for services_pskel.
+  //
+  bool services_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "service" &&
+            ns.empty())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &services_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "service",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool services_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void services_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void services_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "service");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void services_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "service" &&
+            ns.empty())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->service_parser_;
+
+            if (this->service_parser_)
+              this->service_parser_->pre ();
+          }
+          else
+          {
+            if (this->service_parser_)
+            {
+              this->service_parser_->post_service ();
+              this->service ();
+            }
+
+            count++;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "service",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for service_pskel.
+  //
+  bool service_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "usesidentifier" &&
+            ns.empty())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &service_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "usesidentifier",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool service_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void service_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void service_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "usesidentifier");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void service_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "usesidentifier" &&
+            ns.empty())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->usesidentifier_parser_;
+
+            if (this->usesidentifier_parser_)
+              this->usesidentifier_parser_->pre ();
+          }
+          else
+          {
+            if (this->usesidentifier_parser_)
+            {
+              const ::std::string& tmp (this->usesidentifier_parser_->post_string ());
+              this->usesidentifier (tmp);
+            }
+
+            count = 0;
+            state = 1UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "usesidentifier",
+              ns, n);
+          count = 0;
+          state = 1UL;
+          // Fall through.
+        }
+      }
+      case 1UL:
+      {
+        if (n == "findby" &&
+            ns.empty())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->findby_parser_;
+
+            if (this->findby_parser_)
+              this->findby_parser_->pre ();
+          }
+          else
+          {
+            if (this->findby_parser_)
+            {
+              this->findby_parser_->post_findby ();
+              this->findby ();
+            }
+
+            count = 0;
+            state = ~0UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "findby",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for findby_pskel.
+  //
+  bool findby_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "namingservice" &&
+            ns.empty())
+          s = 0UL;
+        else if (n == "stringifiedobjectref" &&
+                 ns.empty())
+          s = 1UL;
+        else if (n == "domainfinder" &&
+                 ns.empty())
+          s = 2UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &findby_pskel::choice_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->choice_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "namingservice",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool findby_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void findby_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void findby_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "namingservice");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void findby_pskel::
+  choice_0 (unsigned long& state,
+            unsigned long& count,
+            const ::xml_schema::ro_string& ns,
+            const ::xml_schema::ro_string& n,
+            const ::xml_schema::ro_string* t,
+            bool start)
+  {
+    XSD_UNUSED (count);
+    XSD_UNUSED (ns);
+    XSD_UNUSED (n);
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->namingservice_parser_;
+
+          if (this->namingservice_parser_)
+            this->namingservice_parser_->pre ();
+        }
+        else
+        {
+          if (this->namingservice_parser_)
+          {
+            this->namingservice_parser_->post_namingservice ();
+            this->namingservice ();
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 1UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->stringifiedobjectref_parser_;
+
+          if (this->stringifiedobjectref_parser_)
+            this->stringifiedobjectref_parser_->pre ();
+        }
+        else
+        {
+          if (this->stringifiedobjectref_parser_)
+          {
+            const ::std::string& tmp (this->stringifiedobjectref_parser_->post_string ());
+            this->stringifiedobjectref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 2UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->domainfinder_parser_;
+
+          if (this->domainfinder_parser_)
+            this->domainfinder_parser_->pre ();
+        }
+        else
+        {
+          if (this->domainfinder_parser_)
+          {
+            this->domainfinder_parser_->post_domainfinder ();
+            this->domainfinder ();
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+    }
+  }
+}
+
+namespace dmd
+{
+  // Attribute validation and dispatch functions for domainmanagerconfiguration_pskel.
+  //
+  bool domainmanagerconfiguration_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "id" && ns.empty ())
+    {
+      if (this->id_parser_)
+      {
+        this->id_parser_->pre ();
+        this->id_parser_->_pre_impl ();
+        this->id_parser_->_characters (s);
+        this->id_parser_->_post_impl ();
+        const ::std::string& tmp (this->id_parser_->post_string ());
+        this->id (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->id = true;
+      return true;
+    }
+
+    if (n == "name" && ns.empty ())
+    {
+      if (this->name_parser_)
+      {
+        this->name_parser_->pre ();
+        this->name_parser_->_pre_impl ();
+        this->name_parser_->_characters (s);
+        this->name_parser_->_post_impl ();
+        const ::std::string& tmp (this->name_parser_->post_string ());
+        this->name (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->name = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void domainmanagerconfiguration_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.id = false;
+    as.name = false;
+  }
+
+  void domainmanagerconfiguration_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.id)
+      this->_expected_attribute (
+        "", "id");
+    if (!as.name)
+      this->_expected_attribute (
+        "", "name");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for localfile_pskel.
+  //
+  bool localfile_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "name" && ns.empty ())
+    {
+      if (this->name_parser_)
+      {
+        this->name_parser_->pre ();
+        this->name_parser_->_pre_impl ();
+        this->name_parser_->_characters (s);
+        this->name_parser_->_post_impl ();
+        const ::std::string& tmp (this->name_parser_->post_string ());
+        this->name (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->name = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void localfile_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.name = false;
+  }
+
+  void localfile_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.name)
+      this->_expected_attribute (
+        "", "name");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for namingservice_pskel.
+  //
+  bool namingservice_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "name" && ns.empty ())
+    {
+      if (this->name_parser_)
+      {
+        this->name_parser_->pre ();
+        this->name_parser_->_pre_impl ();
+        this->name_parser_->_characters (s);
+        this->name_parser_->_post_impl ();
+        this->name_parser_->post_any_simple_type ();
+        this->name ();
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->name = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void namingservice_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.name = false;
+  }
+
+  void namingservice_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.name)
+      this->_expected_attribute (
+        "", "name");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for domainfinder_pskel.
+  //
+  bool domainfinder_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "type" && ns.empty ())
+    {
+      if (this->type_parser_)
+      {
+        this->type_parser_->pre ();
+        this->type_parser_->_pre_impl ();
+        this->type_parser_->_characters (s);
+        this->type_parser_->_post_impl ();
+        const ::std::string& tmp (this->type_parser_->post_string ());
+        this->type (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->type = true;
+      return true;
+    }
+
+    if (n == "name" && ns.empty ())
+    {
+      if (this->name_parser_)
+      {
+        this->name_parser_->pre ();
+        this->name_parser_->_pre_impl ();
+        this->name_parser_->_characters (s);
+        this->name_parser_->_post_impl ();
+        const ::std::string& tmp (this->name_parser_->post_string ());
+        this->name (tmp);
+      }
+
+      return true;
+    }
+
+    return false;
+  }
+
+  void domainfinder_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.type = false;
+  }
+
+  void domainfinder_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.type)
+      this->_expected_attribute (
+        "", "type");
+
+    this->v_state_attr_stack_.pop ();
+  }
+}
+
+namespace dmd
+{
+}
+
+// Begin epilogue.
+//
+//
+// End epilogue.
+
diff --git src/control/parser/internal/dmd-pskel.h src/control/parser/internal/dmd-pskel.h
new file mode 100644
index 0000000..99b9fdf
--- /dev/null
+++ src/control/parser/internal/dmd-pskel.h
@@ -0,0 +1,922 @@
+// Copyright (C) 2005-2010 Code Synthesis Tools CC
+//
+// This program was generated by CodeSynthesis XSD, an XML Schema to
+// C++ data binding compiler.
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 2 as
+// published by the Free Software Foundation.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+//
+// In addition, as a special exception, Code Synthesis Tools CC gives
+// permission to link this program with the Xerces-C++ library (or with
+// modified versions of Xerces-C++ that use the same license as Xerces-C++),
+// and distribute linked combinations including the two. You must obey
+// the GNU General Public License version 2 in all respects for all of
+// the code used other than Xerces-C++. If you modify this copy of the
+// program, you may extend this exception to your version of the program,
+// but you are not obligated to do so. If you do not wish to do so, delete
+// this exception statement from your version.
+//
+// Furthermore, Code Synthesis Tools CC makes a special exception for
+// the Free/Libre and Open Source Software (FLOSS) which is described
+// in the accompanying FLOSSE file.
+//
+
+#ifndef CXX______XML_XSD_DMD_PSKEL_H
+#define CXX______XML_XSD_DMD_PSKEL_H
+
+// Begin prologue.
+//
+//
+// End prologue.
+
+#include <xsd/cxx/config.hxx>
+
+#if (XSD_INT_VERSION != 3030000L)
+#error XSD runtime version mismatch
+#endif
+
+#include <xsd/cxx/pre.hxx>
+
+// Forward declarations
+//
+namespace dmd
+{
+  class domainmanagerconfiguration_pskel;
+  class domainmanagersoftpkg_pskel;
+  class localfile_pskel;
+  class services_pskel;
+  class service_pskel;
+  class findby_pskel;
+  class namingservice_pskel;
+  class domainfinder_pskel;
+}
+
+
+#ifndef XSD_USE_CHAR
+#define XSD_USE_CHAR
+#endif
+
+#ifndef XSD_CXX_PARSER_USE_CHAR
+#define XSD_CXX_PARSER_USE_CHAR
+#endif
+
+#include <xsd/cxx/xml/error-handler.hxx>
+#include <xsd/cxx/parser/exceptions.hxx>
+#include <xsd/cxx/parser/elements.hxx>
+#include <xsd/cxx/parser/xml-schema.hxx>
+#include <xsd/cxx/parser/validating/parser.hxx>
+#include <xsd/cxx/parser/validating/exceptions.hxx>
+#include <xsd/cxx/parser/validating/xml-schema-pskel.hxx>
+#include <xsd/cxx/parser/validating/xml-schema-pimpl.hxx>
+#include <xsd/cxx/parser/expat/elements.hxx>
+
+#include "memory"
+#include "../include/ossie/DomainManagerConfiguration.h"
+
+namespace xml_schema
+{
+  // Built-in XML Schema types mapping.
+  //
+  typedef ::xsd::cxx::parser::string_sequence< char > string_sequence;
+  typedef ::xsd::cxx::parser::qname< char > qname;
+  typedef ::xsd::cxx::parser::buffer buffer;
+  typedef ::xsd::cxx::parser::time_zone time_zone;
+  typedef ::xsd::cxx::parser::gday gday;
+  typedef ::xsd::cxx::parser::gmonth gmonth;
+  typedef ::xsd::cxx::parser::gyear gyear;
+  typedef ::xsd::cxx::parser::gmonth_day gmonth_day;
+  typedef ::xsd::cxx::parser::gyear_month gyear_month;
+  typedef ::xsd::cxx::parser::date date;
+  typedef ::xsd::cxx::parser::time time;
+  typedef ::xsd::cxx::parser::date_time date_time;
+  typedef ::xsd::cxx::parser::duration duration;
+
+  // Base parser skeletons.
+  //
+  typedef ::xsd::cxx::parser::parser_base< char > parser_base;
+  typedef ::xsd::cxx::parser::validating::empty_content< char > empty_content;
+  typedef ::xsd::cxx::parser::validating::simple_content< char > simple_content;
+  typedef ::xsd::cxx::parser::validating::complex_content< char > complex_content;
+  typedef ::xsd::cxx::parser::validating::list_base< char > list_base;
+
+  // Parser skeletons and implementations for the XML Schema
+  // built-in types.
+  //
+  typedef ::xsd::cxx::parser::validating::any_type_pskel< char > any_type_pskel;
+  typedef ::xsd::cxx::parser::validating::any_type_pimpl< char > any_type_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::any_simple_type_pskel< char > any_simple_type_pskel;
+  typedef ::xsd::cxx::parser::validating::any_simple_type_pimpl< char > any_simple_type_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::byte_pskel< char > byte_pskel;
+  typedef ::xsd::cxx::parser::validating::byte_pimpl< char > byte_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::unsigned_byte_pskel< char > unsigned_byte_pskel;
+  typedef ::xsd::cxx::parser::validating::unsigned_byte_pimpl< char > unsigned_byte_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::short_pskel< char > short_pskel;
+  typedef ::xsd::cxx::parser::validating::short_pimpl< char > short_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::unsigned_short_pskel< char > unsigned_short_pskel;
+  typedef ::xsd::cxx::parser::validating::unsigned_short_pimpl< char > unsigned_short_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::int_pskel< char > int_pskel;
+  typedef ::xsd::cxx::parser::validating::int_pimpl< char > int_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::unsigned_int_pskel< char > unsigned_int_pskel;
+  typedef ::xsd::cxx::parser::validating::unsigned_int_pimpl< char > unsigned_int_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::long_pskel< char > long_pskel;
+  typedef ::xsd::cxx::parser::validating::long_pimpl< char > long_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::unsigned_long_pskel< char > unsigned_long_pskel;
+  typedef ::xsd::cxx::parser::validating::unsigned_long_pimpl< char > unsigned_long_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::integer_pskel< char > integer_pskel;
+  typedef ::xsd::cxx::parser::validating::integer_pimpl< char > integer_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::non_positive_integer_pskel< char > non_positive_integer_pskel;
+  typedef ::xsd::cxx::parser::validating::non_positive_integer_pimpl< char > non_positive_integer_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::non_negative_integer_pskel< char > non_negative_integer_pskel;
+  typedef ::xsd::cxx::parser::validating::non_negative_integer_pimpl< char > non_negative_integer_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::positive_integer_pskel< char > positive_integer_pskel;
+  typedef ::xsd::cxx::parser::validating::positive_integer_pimpl< char > positive_integer_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::negative_integer_pskel< char > negative_integer_pskel;
+  typedef ::xsd::cxx::parser::validating::negative_integer_pimpl< char > negative_integer_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::boolean_pskel< char > boolean_pskel;
+  typedef ::xsd::cxx::parser::validating::boolean_pimpl< char > boolean_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::float_pskel< char > float_pskel;
+  typedef ::xsd::cxx::parser::validating::float_pimpl< char > float_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::double_pskel< char > double_pskel;
+  typedef ::xsd::cxx::parser::validating::double_pimpl< char > double_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::decimal_pskel< char > decimal_pskel;
+  typedef ::xsd::cxx::parser::validating::decimal_pimpl< char > decimal_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::string_pskel< char > string_pskel;
+  typedef ::xsd::cxx::parser::validating::string_pimpl< char > string_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::normalized_string_pskel< char > normalized_string_pskel;
+  typedef ::xsd::cxx::parser::validating::normalized_string_pimpl< char > normalized_string_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::token_pskel< char > token_pskel;
+  typedef ::xsd::cxx::parser::validating::token_pimpl< char > token_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::name_pskel< char > name_pskel;
+  typedef ::xsd::cxx::parser::validating::name_pimpl< char > name_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::nmtoken_pskel< char > nmtoken_pskel;
+  typedef ::xsd::cxx::parser::validating::nmtoken_pimpl< char > nmtoken_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::nmtokens_pskel< char > nmtokens_pskel;
+  typedef ::xsd::cxx::parser::validating::nmtokens_pimpl< char > nmtokens_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::ncname_pskel< char > ncname_pskel;
+  typedef ::xsd::cxx::parser::validating::ncname_pimpl< char > ncname_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::language_pskel< char > language_pskel;
+  typedef ::xsd::cxx::parser::validating::language_pimpl< char > language_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::id_pskel< char > id_pskel;
+  typedef ::xsd::cxx::parser::validating::id_pimpl< char > id_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::idref_pskel< char > idref_pskel;
+  typedef ::xsd::cxx::parser::validating::idref_pimpl< char > idref_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::idrefs_pskel< char > idrefs_pskel;
+  typedef ::xsd::cxx::parser::validating::idrefs_pimpl< char > idrefs_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::uri_pskel< char > uri_pskel;
+  typedef ::xsd::cxx::parser::validating::uri_pimpl< char > uri_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::qname_pskel< char > qname_pskel;
+  typedef ::xsd::cxx::parser::validating::qname_pimpl< char > qname_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::base64_binary_pskel< char > base64_binary_pskel;
+  typedef ::xsd::cxx::parser::validating::base64_binary_pimpl< char > base64_binary_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::hex_binary_pskel< char > hex_binary_pskel;
+  typedef ::xsd::cxx::parser::validating::hex_binary_pimpl< char > hex_binary_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::date_pskel< char > date_pskel;
+  typedef ::xsd::cxx::parser::validating::date_pimpl< char > date_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::date_time_pskel< char > date_time_pskel;
+  typedef ::xsd::cxx::parser::validating::date_time_pimpl< char > date_time_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::duration_pskel< char > duration_pskel;
+  typedef ::xsd::cxx::parser::validating::duration_pimpl< char > duration_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::gday_pskel< char > gday_pskel;
+  typedef ::xsd::cxx::parser::validating::gday_pimpl< char > gday_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::gmonth_pskel< char > gmonth_pskel;
+  typedef ::xsd::cxx::parser::validating::gmonth_pimpl< char > gmonth_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::gmonth_day_pskel< char > gmonth_day_pskel;
+  typedef ::xsd::cxx::parser::validating::gmonth_day_pimpl< char > gmonth_day_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::gyear_pskel< char > gyear_pskel;
+  typedef ::xsd::cxx::parser::validating::gyear_pimpl< char > gyear_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::gyear_month_pskel< char > gyear_month_pskel;
+  typedef ::xsd::cxx::parser::validating::gyear_month_pimpl< char > gyear_month_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::time_pskel< char > time_pskel;
+  typedef ::xsd::cxx::parser::validating::time_pimpl< char > time_pimpl;
+
+  // Exceptions. See libxsd/xsd/cxx/parser/exceptions.hxx for details.
+  //
+  typedef ::xsd::cxx::parser::exception< char > exception;
+
+  // Parsing diagnostics.
+  //
+  typedef ::xsd::cxx::parser::severity severity;
+  typedef ::xsd::cxx::parser::error< char > error;
+  typedef ::xsd::cxx::parser::diagnostics< char > diagnostics;
+  typedef ::xsd::cxx::parser::parsing< char > parsing;
+
+  // Error handler. See libxsd/xsd/cxx/xml/error-handler.hxx for details.
+  //
+  typedef ::xsd::cxx::xml::error_handler< char > error_handler;
+
+  // Read-only string.
+  //
+  typedef ::xsd::cxx::ro_string< char > ro_string;
+
+  // Document type. See libxsd/xsd/cxx/parser/expat/elements.hxx
+  // for details.
+  //
+  typedef ::xsd::cxx::parser::expat::document< char > document;
+}
+
+namespace dmd
+{
+  class domainmanagerconfiguration_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    description (const ::std::string&);
+
+    virtual void
+    domainmanagersoftpkg (const ::std::string&);
+
+    virtual void
+    services ();
+
+    virtual void
+    id (const ::std::string&);
+
+    virtual void
+    name (const ::std::string&);
+
+    virtual ::std::auto_ptr<ossie::DomainManagerConfiguration::DMD>
+    post_domainmanagerconfiguration () = 0;
+
+    // Parser construction API.
+    //
+    void
+    description_parser (::xml_schema::string_pskel&);
+
+    void
+    domainmanagersoftpkg_parser (::dmd::domainmanagersoftpkg_pskel&);
+
+    void
+    services_parser (::dmd::services_pskel&);
+
+    void
+    id_parser (::xml_schema::string_pskel&);
+
+    void
+    name_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* description */,
+             ::dmd::domainmanagersoftpkg_pskel& /* domainmanagersoftpkg */,
+             ::dmd::services_pskel& /* services */,
+             ::xml_schema::string_pskel& /* id */,
+             ::xml_schema::string_pskel& /* name */);
+
+    // Constructor.
+    //
+    domainmanagerconfiguration_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* description_parser_;
+    ::dmd::domainmanagersoftpkg_pskel* domainmanagersoftpkg_parser_;
+    ::dmd::services_pskel* services_parser_;
+    ::xml_schema::string_pskel* id_parser_;
+    ::xml_schema::string_pskel* name_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::dmd::domainmanagerconfiguration_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+
+    protected:
+    struct v_state_attr_
+    {
+      bool id;
+      bool name;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class domainmanagersoftpkg_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    localfile (const ::std::string&);
+
+    virtual ::std::string
+    post_domainmanagersoftpkg () = 0;
+
+    // Parser construction API.
+    //
+    void
+    localfile_parser (::dmd::localfile_pskel&);
+
+    void
+    parsers (::dmd::localfile_pskel& /* localfile */);
+
+    // Constructor.
+    //
+    domainmanagersoftpkg_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::dmd::localfile_pskel* localfile_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::dmd::domainmanagersoftpkg_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+  };
+
+  class localfile_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    name (const ::std::string&);
+
+    virtual ::std::string
+    post_localfile () = 0;
+
+    // Parser construction API.
+    //
+    void
+    name_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* name */);
+
+    // Constructor.
+    //
+    localfile_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* name_parser_;
+
+    protected:
+    struct v_state_attr_
+    {
+      bool name;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class services_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    service ();
+
+    virtual void
+    post_services ();
+
+    // Parser construction API.
+    //
+    void
+    service_parser (::dmd::service_pskel&);
+
+    void
+    parsers (::dmd::service_pskel& /* service */);
+
+    // Constructor.
+    //
+    services_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::dmd::service_pskel* service_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::dmd::services_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+  };
+
+  class service_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    usesidentifier (const ::std::string&);
+
+    virtual void
+    findby ();
+
+    virtual void
+    post_service ();
+
+    // Parser construction API.
+    //
+    void
+    usesidentifier_parser (::xml_schema::string_pskel&);
+
+    void
+    findby_parser (::dmd::findby_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* usesidentifier */,
+             ::dmd::findby_pskel& /* findby */);
+
+    // Constructor.
+    //
+    service_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::xml_schema::string_pskel* usesidentifier_parser_;
+    ::dmd::findby_pskel* findby_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::dmd::service_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+  };
+
+  class findby_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    namingservice ();
+
+    virtual void
+    stringifiedobjectref (const ::std::string&);
+
+    virtual void
+    domainfinder ();
+
+    virtual void
+    post_findby ();
+
+    // Parser construction API.
+    //
+    void
+    namingservice_parser (::dmd::namingservice_pskel&);
+
+    void
+    stringifiedobjectref_parser (::xml_schema::string_pskel&);
+
+    void
+    domainfinder_parser (::dmd::domainfinder_pskel&);
+
+    void
+    parsers (::dmd::namingservice_pskel& /* namingservice */,
+             ::xml_schema::string_pskel& /* stringifiedobjectref */,
+             ::dmd::domainfinder_pskel& /* domainfinder */);
+
+    // Constructor.
+    //
+    findby_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::dmd::namingservice_pskel* namingservice_parser_;
+    ::xml_schema::string_pskel* stringifiedobjectref_parser_;
+    ::dmd::domainfinder_pskel* domainfinder_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::dmd::findby_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    choice_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start);
+  };
+
+  class namingservice_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    name ();
+
+    virtual void
+    post_namingservice ();
+
+    // Parser construction API.
+    //
+    void
+    name_parser (::xml_schema::any_simple_type_pskel&);
+
+    void
+    parsers (::xml_schema::any_simple_type_pskel& /* name */);
+
+    // Constructor.
+    //
+    namingservice_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::any_simple_type_pskel* name_parser_;
+
+    protected:
+    struct v_state_attr_
+    {
+      bool name;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class domainfinder_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    type (const ::std::string&);
+
+    virtual void
+    name (const ::std::string&);
+
+    virtual void
+    post_domainfinder ();
+
+    // Parser construction API.
+    //
+    void
+    type_parser (::xml_schema::string_pskel&);
+
+    void
+    name_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* type */,
+             ::xml_schema::string_pskel& /* name */);
+
+    // Constructor.
+    //
+    domainfinder_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* type_parser_;
+    ::xml_schema::string_pskel* name_parser_;
+
+    protected:
+    struct v_state_attr_
+    {
+      bool type;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+}
+
+#include <xsd/cxx/post.hxx>
+
+// Begin epilogue.
+//
+//
+// End epilogue.
+
+#endif // CXX______XML_XSD_DMD_PSKEL_H
diff --git src/control/parser/internal/dpd-pskel.cpp src/control/parser/internal/dpd-pskel.cpp
new file mode 100644
index 0000000..e752994
--- /dev/null
+++ src/control/parser/internal/dpd-pskel.cpp
@@ -0,0 +1,2491 @@
+// Copyright (C) 2005-2010 Code Synthesis Tools CC
+//
+// This program was generated by CodeSynthesis XSD, an XML Schema to
+// C++ data binding compiler.
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 2 as
+// published by the Free Software Foundation.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+//
+// In addition, as a special exception, Code Synthesis Tools CC gives
+// permission to link this program with the Xerces-C++ library (or with
+// modified versions of Xerces-C++ that use the same license as Xerces-C++),
+// and distribute linked combinations including the two. You must obey
+// the GNU General Public License version 2 in all respects for all of
+// the code used other than Xerces-C++. If you modify this copy of the
+// program, you may extend this exception to your version of the program,
+// but you are not obligated to do so. If you do not wish to do so, delete
+// this exception statement from your version.
+//
+// Furthermore, Code Synthesis Tools CC makes a special exception for
+// the Free/Libre and Open Source Software (FLOSS) which is described
+// in the accompanying FLOSSE file.
+//
+
+// Begin prologue.
+//
+//
+// End prologue.
+
+#include "dpd-pskel.h"
+
+namespace dpd
+{
+  // devicepkg_pskel
+  //
+
+  void devicepkg_pskel::
+  title_parser (::xml_schema::string_pskel& p)
+  {
+    this->title_parser_ = &p;
+  }
+
+  void devicepkg_pskel::
+  author_parser (::dpd::author_pskel& p)
+  {
+    this->author_parser_ = &p;
+  }
+
+  void devicepkg_pskel::
+  description_parser (::xml_schema::string_pskel& p)
+  {
+    this->description_parser_ = &p;
+  }
+
+  void devicepkg_pskel::
+  hwdeviceregistration_parser (::dpd::hwdeviceregistration_pskel& p)
+  {
+    this->hwdeviceregistration_parser_ = &p;
+  }
+
+  void devicepkg_pskel::
+  id_parser (::xml_schema::string_pskel& p)
+  {
+    this->id_parser_ = &p;
+  }
+
+  void devicepkg_pskel::
+  name_parser (::xml_schema::string_pskel& p)
+  {
+    this->name_parser_ = &p;
+  }
+
+  void devicepkg_pskel::
+  version_parser (::xml_schema::string_pskel& p)
+  {
+    this->version_parser_ = &p;
+  }
+
+  void devicepkg_pskel::
+  parsers (::xml_schema::string_pskel& title,
+           ::dpd::author_pskel& author,
+           ::xml_schema::string_pskel& description,
+           ::dpd::hwdeviceregistration_pskel& hwdeviceregistration,
+           ::xml_schema::string_pskel& id,
+           ::xml_schema::string_pskel& name,
+           ::xml_schema::string_pskel& version)
+  {
+    this->title_parser_ = &title;
+    this->author_parser_ = &author;
+    this->description_parser_ = &description;
+    this->hwdeviceregistration_parser_ = &hwdeviceregistration;
+    this->id_parser_ = &id;
+    this->name_parser_ = &name;
+    this->version_parser_ = &version;
+  }
+
+  devicepkg_pskel::
+  devicepkg_pskel ()
+  : title_parser_ (0),
+    author_parser_ (0),
+    description_parser_ (0),
+    hwdeviceregistration_parser_ (0),
+    id_parser_ (0),
+    name_parser_ (0),
+    version_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // author_pskel
+  //
+
+  void author_pskel::
+  name_parser (::xml_schema::string_pskel& p)
+  {
+    this->name_parser_ = &p;
+  }
+
+  void author_pskel::
+  company_parser (::xml_schema::string_pskel& p)
+  {
+    this->company_parser_ = &p;
+  }
+
+  void author_pskel::
+  webpage_parser (::xml_schema::uri_pskel& p)
+  {
+    this->webpage_parser_ = &p;
+  }
+
+  void author_pskel::
+  parsers (::xml_schema::string_pskel& name,
+           ::xml_schema::string_pskel& company,
+           ::xml_schema::uri_pskel& webpage)
+  {
+    this->name_parser_ = &name;
+    this->company_parser_ = &company;
+    this->webpage_parser_ = &webpage;
+  }
+
+  author_pskel::
+  author_pskel ()
+  : name_parser_ (0),
+    company_parser_ (0),
+    webpage_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // hwdeviceregistration_pskel
+  //
+
+  void hwdeviceregistration_pskel::
+  propertyfile_parser (::dpd::propertyfile_pskel& p)
+  {
+    this->propertyfile_parser_ = &p;
+  }
+
+  void hwdeviceregistration_pskel::
+  description_parser (::xml_schema::string_pskel& p)
+  {
+    this->description_parser_ = &p;
+  }
+
+  void hwdeviceregistration_pskel::
+  manufacturer_parser (::xml_schema::string_pskel& p)
+  {
+    this->manufacturer_parser_ = &p;
+  }
+
+  void hwdeviceregistration_pskel::
+  modelnumber_parser (::xml_schema::string_pskel& p)
+  {
+    this->modelnumber_parser_ = &p;
+  }
+
+  void hwdeviceregistration_pskel::
+  deviceclass_parser (::dpd::deviceclass_pskel& p)
+  {
+    this->deviceclass_parser_ = &p;
+  }
+
+  void hwdeviceregistration_pskel::
+  childhwdevice_parser (::dpd::childhwdevice_pskel& p)
+  {
+    this->childhwdevice_parser_ = &p;
+  }
+
+  void hwdeviceregistration_pskel::
+  id_parser (::xml_schema::string_pskel& p)
+  {
+    this->id_parser_ = &p;
+  }
+
+  void hwdeviceregistration_pskel::
+  name_parser (::xml_schema::string_pskel& p)
+  {
+    this->name_parser_ = &p;
+  }
+
+  void hwdeviceregistration_pskel::
+  version_parser (::xml_schema::string_pskel& p)
+  {
+    this->version_parser_ = &p;
+  }
+
+  void hwdeviceregistration_pskel::
+  parsers (::dpd::propertyfile_pskel& propertyfile,
+           ::xml_schema::string_pskel& description,
+           ::xml_schema::string_pskel& manufacturer,
+           ::xml_schema::string_pskel& modelnumber,
+           ::dpd::deviceclass_pskel& deviceclass,
+           ::dpd::childhwdevice_pskel& childhwdevice,
+           ::xml_schema::string_pskel& id,
+           ::xml_schema::string_pskel& name,
+           ::xml_schema::string_pskel& version)
+  {
+    this->propertyfile_parser_ = &propertyfile;
+    this->description_parser_ = &description;
+    this->manufacturer_parser_ = &manufacturer;
+    this->modelnumber_parser_ = &modelnumber;
+    this->deviceclass_parser_ = &deviceclass;
+    this->childhwdevice_parser_ = &childhwdevice;
+    this->id_parser_ = &id;
+    this->name_parser_ = &name;
+    this->version_parser_ = &version;
+  }
+
+  hwdeviceregistration_pskel::
+  hwdeviceregistration_pskel ()
+  : propertyfile_parser_ (0),
+    description_parser_ (0),
+    manufacturer_parser_ (0),
+    modelnumber_parser_ (0),
+    deviceclass_parser_ (0),
+    childhwdevice_parser_ (0),
+    id_parser_ (0),
+    name_parser_ (0),
+    version_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // propertyfile_pskel
+  //
+
+  void propertyfile_pskel::
+  localfile_parser (::dpd::localfile_pskel& p)
+  {
+    this->localfile_parser_ = &p;
+  }
+
+  void propertyfile_pskel::
+  type_parser (::xml_schema::string_pskel& p)
+  {
+    this->type_parser_ = &p;
+  }
+
+  void propertyfile_pskel::
+  parsers (::dpd::localfile_pskel& localfile,
+           ::xml_schema::string_pskel& type)
+  {
+    this->localfile_parser_ = &localfile;
+    this->type_parser_ = &type;
+  }
+
+  propertyfile_pskel::
+  propertyfile_pskel ()
+  : localfile_parser_ (0),
+    type_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // localfile_pskel
+  //
+
+  void localfile_pskel::
+  name_parser (::xml_schema::string_pskel& p)
+  {
+    this->name_parser_ = &p;
+  }
+
+  void localfile_pskel::
+  parsers (::xml_schema::string_pskel& name)
+  {
+    this->name_parser_ = &name;
+  }
+
+  localfile_pskel::
+  localfile_pskel ()
+  : name_parser_ (0),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // deviceclass_pskel
+  //
+
+  void deviceclass_pskel::
+  class_parser (::xml_schema::string_pskel& p)
+  {
+    this->class__parser_ = &p;
+  }
+
+  void deviceclass_pskel::
+  parsers (::xml_schema::string_pskel& class_)
+  {
+    this->class__parser_ = &class_;
+  }
+
+  deviceclass_pskel::
+  deviceclass_pskel ()
+  : class__parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // childhwdevice_pskel
+  //
+
+  void childhwdevice_pskel::
+  hwdeviceregistration_parser (::dpd::hwdeviceregistration_pskel& p)
+  {
+    this->hwdeviceregistration_parser_ = &p;
+  }
+
+  void childhwdevice_pskel::
+  devicepkgref_parser (::dpd::devicepkgref_pskel& p)
+  {
+    this->devicepkgref_parser_ = &p;
+  }
+
+  void childhwdevice_pskel::
+  parsers (::dpd::hwdeviceregistration_pskel& hwdeviceregistration,
+           ::dpd::devicepkgref_pskel& devicepkgref)
+  {
+    this->hwdeviceregistration_parser_ = &hwdeviceregistration;
+    this->devicepkgref_parser_ = &devicepkgref;
+  }
+
+  childhwdevice_pskel::
+  childhwdevice_pskel ()
+  : hwdeviceregistration_parser_ (0),
+    devicepkgref_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // devicepkgref_pskel
+  //
+
+  void devicepkgref_pskel::
+  localfile_parser (::dpd::localfile_pskel& p)
+  {
+    this->localfile_parser_ = &p;
+  }
+
+  void devicepkgref_pskel::
+  type_parser (::xml_schema::string_pskel& p)
+  {
+    this->type_parser_ = &p;
+  }
+
+  void devicepkgref_pskel::
+  parsers (::dpd::localfile_pskel& localfile,
+           ::xml_schema::string_pskel& type)
+  {
+    this->localfile_parser_ = &localfile;
+    this->type_parser_ = &type;
+  }
+
+  devicepkgref_pskel::
+  devicepkgref_pskel ()
+  : localfile_parser_ (0),
+    type_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+}
+
+namespace dpd
+{
+  // devicepkg_pskel
+  //
+
+  void devicepkg_pskel::
+  title (const ::std::string&)
+  {
+  }
+
+  void devicepkg_pskel::
+  author ()
+  {
+  }
+
+  void devicepkg_pskel::
+  description (const ::std::string&)
+  {
+  }
+
+  void devicepkg_pskel::
+  hwdeviceregistration ()
+  {
+  }
+
+  void devicepkg_pskel::
+  id (const ::std::string&)
+  {
+  }
+
+  void devicepkg_pskel::
+  name (const ::std::string&)
+  {
+  }
+
+  void devicepkg_pskel::
+  version (const ::std::string&)
+  {
+  }
+
+  void devicepkg_pskel::
+  post_devicepkg ()
+  {
+  }
+
+  // author_pskel
+  //
+
+  void author_pskel::
+  name (const ::std::string&)
+  {
+  }
+
+  void author_pskel::
+  company (const ::std::string&)
+  {
+  }
+
+  void author_pskel::
+  webpage (const ::std::string&)
+  {
+  }
+
+  void author_pskel::
+  post_author ()
+  {
+  }
+
+  // hwdeviceregistration_pskel
+  //
+
+  void hwdeviceregistration_pskel::
+  propertyfile ()
+  {
+  }
+
+  void hwdeviceregistration_pskel::
+  description (const ::std::string&)
+  {
+  }
+
+  void hwdeviceregistration_pskel::
+  manufacturer (const ::std::string&)
+  {
+  }
+
+  void hwdeviceregistration_pskel::
+  modelnumber (const ::std::string&)
+  {
+  }
+
+  void hwdeviceregistration_pskel::
+  deviceclass ()
+  {
+  }
+
+  void hwdeviceregistration_pskel::
+  childhwdevice ()
+  {
+  }
+
+  void hwdeviceregistration_pskel::
+  id (const ::std::string&)
+  {
+  }
+
+  void hwdeviceregistration_pskel::
+  name (const ::std::string&)
+  {
+  }
+
+  void hwdeviceregistration_pskel::
+  version (const ::std::string&)
+  {
+  }
+
+  void hwdeviceregistration_pskel::
+  post_hwdeviceregistration ()
+  {
+  }
+
+  // propertyfile_pskel
+  //
+
+  void propertyfile_pskel::
+  localfile ()
+  {
+  }
+
+  void propertyfile_pskel::
+  type (const ::std::string&)
+  {
+  }
+
+  void propertyfile_pskel::
+  post_propertyfile ()
+  {
+  }
+
+  // localfile_pskel
+  //
+
+  void localfile_pskel::
+  name (const ::std::string&)
+  {
+  }
+
+  void localfile_pskel::
+  post_localfile ()
+  {
+  }
+
+  // deviceclass_pskel
+  //
+
+  void deviceclass_pskel::
+  class_ (const ::std::string&)
+  {
+  }
+
+  void deviceclass_pskel::
+  post_deviceclass ()
+  {
+  }
+
+  // childhwdevice_pskel
+  //
+
+  void childhwdevice_pskel::
+  hwdeviceregistration ()
+  {
+  }
+
+  void childhwdevice_pskel::
+  devicepkgref ()
+  {
+  }
+
+  void childhwdevice_pskel::
+  post_childhwdevice ()
+  {
+  }
+
+  // devicepkgref_pskel
+  //
+
+  void devicepkgref_pskel::
+  localfile ()
+  {
+  }
+
+  void devicepkgref_pskel::
+  type (const ::std::string&)
+  {
+  }
+
+  void devicepkgref_pskel::
+  post_devicepkgref ()
+  {
+  }
+}
+
+#include <cassert>
+
+namespace dpd
+{
+  // Element validation and dispatch functions for devicepkg_pskel.
+  //
+  bool devicepkg_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "title" &&
+            ns == "urn:mil:jpeojtrs:sca:dpd")
+          s = 0UL;
+        else if (n == "author" &&
+                 ns == "urn:mil:jpeojtrs:sca:dpd")
+          s = 1UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &devicepkg_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "urn:mil:jpeojtrs:sca:dpd", "title",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool devicepkg_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void devicepkg_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void devicepkg_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "urn:mil:jpeojtrs:sca:dpd", "title");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void devicepkg_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "title" &&
+            ns == "urn:mil:jpeojtrs:sca:dpd")
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->title_parser_;
+
+            if (this->title_parser_)
+              this->title_parser_->pre ();
+          }
+          else
+          {
+            if (this->title_parser_)
+            {
+              const ::std::string& tmp (this->title_parser_->post_string ());
+              this->title (tmp);
+            }
+
+            count = 0;
+            state = 1UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 1UL;
+          // Fall through.
+        }
+      }
+      case 1UL:
+      {
+        if (n == "author" &&
+            ns == "urn:mil:jpeojtrs:sca:dpd")
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->author_parser_;
+
+            if (this->author_parser_)
+              this->author_parser_->pre ();
+          }
+          else
+          {
+            if (this->author_parser_)
+            {
+              this->author_parser_->post_author ();
+              this->author ();
+            }
+
+            count++;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "urn:mil:jpeojtrs:sca:dpd", "author",
+              ns, n);
+          count = 0;
+          state = 2UL;
+          // Fall through.
+        }
+      }
+      case 2UL:
+      {
+        if (n == "description" &&
+            ns == "urn:mil:jpeojtrs:sca:dpd")
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->description_parser_;
+
+            if (this->description_parser_)
+              this->description_parser_->pre ();
+          }
+          else
+          {
+            if (this->description_parser_)
+            {
+              const ::std::string& tmp (this->description_parser_->post_string ());
+              this->description (tmp);
+            }
+
+            count = 0;
+            state = 3UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 3UL;
+          // Fall through.
+        }
+      }
+      case 3UL:
+      {
+        if (n == "hwdeviceregistration" &&
+            ns == "urn:mil:jpeojtrs:sca:dpd")
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->hwdeviceregistration_parser_;
+
+            if (this->hwdeviceregistration_parser_)
+              this->hwdeviceregistration_parser_->pre ();
+          }
+          else
+          {
+            if (this->hwdeviceregistration_parser_)
+            {
+              this->hwdeviceregistration_parser_->post_hwdeviceregistration ();
+              this->hwdeviceregistration ();
+            }
+
+            count = 0;
+            state = ~0UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "urn:mil:jpeojtrs:sca:dpd", "hwdeviceregistration",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for author_pskel.
+  //
+  bool author_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "name" &&
+            ns == "urn:mil:jpeojtrs:sca:dpd")
+          s = 0UL;
+        else if (n == "company" &&
+                 ns == "urn:mil:jpeojtrs:sca:dpd")
+          s = 1UL;
+        else if (n == "webpage" &&
+                 ns == "urn:mil:jpeojtrs:sca:dpd")
+          s = 2UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &author_pskel::choice_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->choice_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool author_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void author_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void author_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+
+    this->v_state_stack_.pop ();
+  }
+
+  void author_pskel::
+  choice_0 (unsigned long& state,
+            unsigned long& count,
+            const ::xml_schema::ro_string& ns,
+            const ::xml_schema::ro_string& n,
+            const ::xml_schema::ro_string* t,
+            bool start)
+  {
+    XSD_UNUSED (count);
+    XSD_UNUSED (ns);
+    XSD_UNUSED (n);
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "name" &&
+            ns == "urn:mil:jpeojtrs:sca:dpd")
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->name_parser_;
+
+            if (this->name_parser_)
+              this->name_parser_->pre ();
+          }
+          else
+          {
+            if (this->name_parser_)
+            {
+              const ::std::string& tmp (this->name_parser_->post_string ());
+              this->name (tmp);
+            }
+
+            count++;
+          }
+        }
+        else
+        {
+          assert (start);
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 1UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->company_parser_;
+
+          if (this->company_parser_)
+            this->company_parser_->pre ();
+        }
+        else
+        {
+          if (this->company_parser_)
+          {
+            const ::std::string& tmp (this->company_parser_->post_string ());
+            this->company (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 2UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->webpage_parser_;
+
+          if (this->webpage_parser_)
+            this->webpage_parser_->pre ();
+        }
+        else
+        {
+          if (this->webpage_parser_)
+          {
+            const ::std::string& tmp (this->webpage_parser_->post_uri ());
+            this->webpage (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+    }
+  }
+
+  // Element validation and dispatch functions for hwdeviceregistration_pskel.
+  //
+  bool hwdeviceregistration_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "propertyfile" &&
+            ns == "urn:mil:jpeojtrs:sca:dpd")
+          s = 0UL;
+        else if (n == "description" &&
+                 ns == "urn:mil:jpeojtrs:sca:dpd")
+          s = 1UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &hwdeviceregistration_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "urn:mil:jpeojtrs:sca:dpd", "propertyfile",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool hwdeviceregistration_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void hwdeviceregistration_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void hwdeviceregistration_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "urn:mil:jpeojtrs:sca:dpd", "propertyfile");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void hwdeviceregistration_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "propertyfile" &&
+            ns == "urn:mil:jpeojtrs:sca:dpd")
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->propertyfile_parser_;
+
+            if (this->propertyfile_parser_)
+              this->propertyfile_parser_->pre ();
+          }
+          else
+          {
+            if (this->propertyfile_parser_)
+            {
+              this->propertyfile_parser_->post_propertyfile ();
+              this->propertyfile ();
+            }
+
+            count = 0;
+            state = 1UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 1UL;
+          // Fall through.
+        }
+      }
+      case 1UL:
+      {
+        if (n == "description" &&
+            ns == "urn:mil:jpeojtrs:sca:dpd")
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->description_parser_;
+
+            if (this->description_parser_)
+              this->description_parser_->pre ();
+          }
+          else
+          {
+            if (this->description_parser_)
+            {
+              const ::std::string& tmp (this->description_parser_->post_string ());
+              this->description (tmp);
+            }
+
+            count = 0;
+            state = 2UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "urn:mil:jpeojtrs:sca:dpd", "description",
+              ns, n);
+          count = 0;
+          state = 2UL;
+          // Fall through.
+        }
+      }
+      case 2UL:
+      {
+        if (n == "manufacturer" &&
+            ns == "urn:mil:jpeojtrs:sca:dpd")
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->manufacturer_parser_;
+
+            if (this->manufacturer_parser_)
+              this->manufacturer_parser_->pre ();
+          }
+          else
+          {
+            if (this->manufacturer_parser_)
+            {
+              const ::std::string& tmp (this->manufacturer_parser_->post_string ());
+              this->manufacturer (tmp);
+            }
+
+            count = 0;
+            state = 3UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "urn:mil:jpeojtrs:sca:dpd", "manufacturer",
+              ns, n);
+          count = 0;
+          state = 3UL;
+          // Fall through.
+        }
+      }
+      case 3UL:
+      {
+        if (n == "modelnumber" &&
+            ns == "urn:mil:jpeojtrs:sca:dpd")
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->modelnumber_parser_;
+
+            if (this->modelnumber_parser_)
+              this->modelnumber_parser_->pre ();
+          }
+          else
+          {
+            if (this->modelnumber_parser_)
+            {
+              const ::std::string& tmp (this->modelnumber_parser_->post_string ());
+              this->modelnumber (tmp);
+            }
+
+            count = 0;
+            state = 4UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "urn:mil:jpeojtrs:sca:dpd", "modelnumber",
+              ns, n);
+          count = 0;
+          state = 4UL;
+          // Fall through.
+        }
+      }
+      case 4UL:
+      {
+        if (n == "deviceclass" &&
+            ns == "urn:mil:jpeojtrs:sca:dpd")
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->deviceclass_parser_;
+
+            if (this->deviceclass_parser_)
+              this->deviceclass_parser_->pre ();
+          }
+          else
+          {
+            if (this->deviceclass_parser_)
+            {
+              this->deviceclass_parser_->post_deviceclass ();
+              this->deviceclass ();
+            }
+
+            count = 0;
+            state = 5UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "urn:mil:jpeojtrs:sca:dpd", "deviceclass",
+              ns, n);
+          count = 0;
+          state = 5UL;
+          // Fall through.
+        }
+      }
+      case 5UL:
+      {
+        if (n == "childhwdevice" &&
+            ns == "urn:mil:jpeojtrs:sca:dpd")
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->childhwdevice_parser_;
+
+            if (this->childhwdevice_parser_)
+              this->childhwdevice_parser_->pre ();
+          }
+          else
+          {
+            if (this->childhwdevice_parser_)
+            {
+              this->childhwdevice_parser_->post_childhwdevice ();
+              this->childhwdevice ();
+            }
+
+            count++;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for propertyfile_pskel.
+  //
+  bool propertyfile_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "localfile" &&
+            ns == "urn:mil:jpeojtrs:sca:dpd")
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &propertyfile_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "urn:mil:jpeojtrs:sca:dpd", "localfile",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool propertyfile_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void propertyfile_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void propertyfile_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "urn:mil:jpeojtrs:sca:dpd", "localfile");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void propertyfile_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "localfile" &&
+            ns == "urn:mil:jpeojtrs:sca:dpd")
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->localfile_parser_;
+
+            if (this->localfile_parser_)
+              this->localfile_parser_->pre ();
+          }
+          else
+          {
+            if (this->localfile_parser_)
+            {
+              this->localfile_parser_->post_localfile ();
+              this->localfile ();
+            }
+
+            count = 0;
+            state = ~0UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "urn:mil:jpeojtrs:sca:dpd", "localfile",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for deviceclass_pskel.
+  //
+  bool deviceclass_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "class" &&
+            ns == "urn:mil:jpeojtrs:sca:dpd")
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &deviceclass_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "urn:mil:jpeojtrs:sca:dpd", "class",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool deviceclass_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void deviceclass_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void deviceclass_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "urn:mil:jpeojtrs:sca:dpd", "class");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void deviceclass_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "class" &&
+            ns == "urn:mil:jpeojtrs:sca:dpd")
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->class__parser_;
+
+            if (this->class__parser_)
+              this->class__parser_->pre ();
+          }
+          else
+          {
+            if (this->class__parser_)
+            {
+              const ::std::string& tmp (this->class__parser_->post_string ());
+              this->class_ (tmp);
+            }
+
+            count++;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "urn:mil:jpeojtrs:sca:dpd", "class",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for childhwdevice_pskel.
+  //
+  bool childhwdevice_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "hwdeviceregistration" &&
+            ns == "urn:mil:jpeojtrs:sca:dpd")
+          s = 0UL;
+        else if (n == "devicepkgref" &&
+                 ns == "urn:mil:jpeojtrs:sca:dpd")
+          s = 1UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &childhwdevice_pskel::choice_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->choice_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "urn:mil:jpeojtrs:sca:dpd", "hwdeviceregistration",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool childhwdevice_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void childhwdevice_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void childhwdevice_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "urn:mil:jpeojtrs:sca:dpd", "hwdeviceregistration");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void childhwdevice_pskel::
+  choice_0 (unsigned long& state,
+            unsigned long& count,
+            const ::xml_schema::ro_string& ns,
+            const ::xml_schema::ro_string& n,
+            const ::xml_schema::ro_string* t,
+            bool start)
+  {
+    XSD_UNUSED (count);
+    XSD_UNUSED (ns);
+    XSD_UNUSED (n);
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->hwdeviceregistration_parser_;
+
+          if (this->hwdeviceregistration_parser_)
+            this->hwdeviceregistration_parser_->pre ();
+        }
+        else
+        {
+          if (this->hwdeviceregistration_parser_)
+          {
+            this->hwdeviceregistration_parser_->post_hwdeviceregistration ();
+            this->hwdeviceregistration ();
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 1UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->devicepkgref_parser_;
+
+          if (this->devicepkgref_parser_)
+            this->devicepkgref_parser_->pre ();
+        }
+        else
+        {
+          if (this->devicepkgref_parser_)
+          {
+            this->devicepkgref_parser_->post_devicepkgref ();
+            this->devicepkgref ();
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+    }
+  }
+
+  // Element validation and dispatch functions for devicepkgref_pskel.
+  //
+  bool devicepkgref_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "localfile" &&
+            ns == "urn:mil:jpeojtrs:sca:dpd")
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &devicepkgref_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "urn:mil:jpeojtrs:sca:dpd", "localfile",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool devicepkgref_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void devicepkgref_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void devicepkgref_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "urn:mil:jpeojtrs:sca:dpd", "localfile");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void devicepkgref_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "localfile" &&
+            ns == "urn:mil:jpeojtrs:sca:dpd")
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->localfile_parser_;
+
+            if (this->localfile_parser_)
+              this->localfile_parser_->pre ();
+          }
+          else
+          {
+            if (this->localfile_parser_)
+            {
+              this->localfile_parser_->post_localfile ();
+              this->localfile ();
+            }
+
+            count = 0;
+            state = ~0UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "urn:mil:jpeojtrs:sca:dpd", "localfile",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+}
+
+namespace dpd
+{
+  // Attribute validation and dispatch functions for devicepkg_pskel.
+  //
+  bool devicepkg_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "id" && ns.empty ())
+    {
+      if (this->id_parser_)
+      {
+        this->id_parser_->pre ();
+        this->id_parser_->_pre_impl ();
+        this->id_parser_->_characters (s);
+        this->id_parser_->_post_impl ();
+        const ::std::string& tmp (this->id_parser_->post_string ());
+        this->id (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->id = true;
+      return true;
+    }
+
+    if (n == "name" && ns.empty ())
+    {
+      if (this->name_parser_)
+      {
+        this->name_parser_->pre ();
+        this->name_parser_->_pre_impl ();
+        this->name_parser_->_characters (s);
+        this->name_parser_->_post_impl ();
+        const ::std::string& tmp (this->name_parser_->post_string ());
+        this->name (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->name = true;
+      return true;
+    }
+
+    if (n == "version" && ns.empty ())
+    {
+      if (this->version_parser_)
+      {
+        this->version_parser_->pre ();
+        this->version_parser_->_pre_impl ();
+        this->version_parser_->_characters (s);
+        this->version_parser_->_post_impl ();
+        const ::std::string& tmp (this->version_parser_->post_string ());
+        this->version (tmp);
+      }
+
+      return true;
+    }
+
+    return false;
+  }
+
+  void devicepkg_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.id = false;
+    as.name = false;
+  }
+
+  void devicepkg_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.id)
+      this->_expected_attribute (
+        "", "id");
+    if (!as.name)
+      this->_expected_attribute (
+        "", "name");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for hwdeviceregistration_pskel.
+  //
+  bool hwdeviceregistration_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "id" && ns.empty ())
+    {
+      if (this->id_parser_)
+      {
+        this->id_parser_->pre ();
+        this->id_parser_->_pre_impl ();
+        this->id_parser_->_characters (s);
+        this->id_parser_->_post_impl ();
+        const ::std::string& tmp (this->id_parser_->post_string ());
+        this->id (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->id = true;
+      return true;
+    }
+
+    if (n == "name" && ns.empty ())
+    {
+      if (this->name_parser_)
+      {
+        this->name_parser_->pre ();
+        this->name_parser_->_pre_impl ();
+        this->name_parser_->_characters (s);
+        this->name_parser_->_post_impl ();
+        const ::std::string& tmp (this->name_parser_->post_string ());
+        this->name (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->name = true;
+      return true;
+    }
+
+    if (n == "version" && ns.empty ())
+    {
+      if (this->version_parser_)
+      {
+        this->version_parser_->pre ();
+        this->version_parser_->_pre_impl ();
+        this->version_parser_->_characters (s);
+        this->version_parser_->_post_impl ();
+        const ::std::string& tmp (this->version_parser_->post_string ());
+        this->version (tmp);
+      }
+
+      return true;
+    }
+
+    return false;
+  }
+
+  void hwdeviceregistration_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.id = false;
+    as.name = false;
+  }
+
+  void hwdeviceregistration_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.id)
+      this->_expected_attribute (
+        "", "id");
+    if (!as.name)
+      this->_expected_attribute (
+        "", "name");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for propertyfile_pskel.
+  //
+  bool propertyfile_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "type" && ns.empty ())
+    {
+      if (this->type_parser_)
+      {
+        this->type_parser_->pre ();
+        this->type_parser_->_pre_impl ();
+        this->type_parser_->_characters (s);
+        this->type_parser_->_post_impl ();
+        const ::std::string& tmp (this->type_parser_->post_string ());
+        this->type (tmp);
+      }
+
+      return true;
+    }
+
+    return false;
+  }
+
+  // Attribute validation and dispatch functions for localfile_pskel.
+  //
+  bool localfile_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "name" && ns.empty ())
+    {
+      if (this->name_parser_)
+      {
+        this->name_parser_->pre ();
+        this->name_parser_->_pre_impl ();
+        this->name_parser_->_characters (s);
+        this->name_parser_->_post_impl ();
+        const ::std::string& tmp (this->name_parser_->post_string ());
+        this->name (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->name = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void localfile_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.name = false;
+  }
+
+  void localfile_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.name)
+      this->_expected_attribute (
+        "", "name");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for devicepkgref_pskel.
+  //
+  bool devicepkgref_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "type" && ns.empty ())
+    {
+      if (this->type_parser_)
+      {
+        this->type_parser_->pre ();
+        this->type_parser_->_pre_impl ();
+        this->type_parser_->_characters (s);
+        this->type_parser_->_post_impl ();
+        const ::std::string& tmp (this->type_parser_->post_string ());
+        this->type (tmp);
+      }
+
+      return true;
+    }
+
+    return false;
+  }
+}
+
+namespace dpd
+{
+}
+
+// Begin epilogue.
+//
+//
+// End epilogue.
+
diff --git src/control/parser/internal/dpd-pskel.h src/control/parser/internal/dpd-pskel.h
new file mode 100644
index 0000000..650c2ba
--- /dev/null
+++ src/control/parser/internal/dpd-pskel.h
@@ -0,0 +1,1091 @@
+// Copyright (C) 2005-2010 Code Synthesis Tools CC
+//
+// This program was generated by CodeSynthesis XSD, an XML Schema to
+// C++ data binding compiler.
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 2 as
+// published by the Free Software Foundation.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+//
+// In addition, as a special exception, Code Synthesis Tools CC gives
+// permission to link this program with the Xerces-C++ library (or with
+// modified versions of Xerces-C++ that use the same license as Xerces-C++),
+// and distribute linked combinations including the two. You must obey
+// the GNU General Public License version 2 in all respects for all of
+// the code used other than Xerces-C++. If you modify this copy of the
+// program, you may extend this exception to your version of the program,
+// but you are not obligated to do so. If you do not wish to do so, delete
+// this exception statement from your version.
+//
+// Furthermore, Code Synthesis Tools CC makes a special exception for
+// the Free/Libre and Open Source Software (FLOSS) which is described
+// in the accompanying FLOSSE file.
+//
+
+#ifndef CXX______XML_XSD_DPD_PSKEL_H
+#define CXX______XML_XSD_DPD_PSKEL_H
+
+// Begin prologue.
+//
+//
+// End prologue.
+
+#include <xsd/cxx/config.hxx>
+
+#if (XSD_INT_VERSION != 3030000L)
+#error XSD runtime version mismatch
+#endif
+
+#include <xsd/cxx/pre.hxx>
+
+// Forward declarations
+//
+namespace dpd
+{
+  class devicepkg_pskel;
+  class author_pskel;
+  class hwdeviceregistration_pskel;
+  class propertyfile_pskel;
+  class localfile_pskel;
+  class deviceclass_pskel;
+  class childhwdevice_pskel;
+  class devicepkgref_pskel;
+}
+
+
+#ifndef XSD_USE_CHAR
+#define XSD_USE_CHAR
+#endif
+
+#ifndef XSD_CXX_PARSER_USE_CHAR
+#define XSD_CXX_PARSER_USE_CHAR
+#endif
+
+#include <xsd/cxx/xml/error-handler.hxx>
+#include <xsd/cxx/parser/exceptions.hxx>
+#include <xsd/cxx/parser/elements.hxx>
+#include <xsd/cxx/parser/xml-schema.hxx>
+#include <xsd/cxx/parser/validating/parser.hxx>
+#include <xsd/cxx/parser/validating/exceptions.hxx>
+#include <xsd/cxx/parser/validating/xml-schema-pskel.hxx>
+#include <xsd/cxx/parser/validating/xml-schema-pimpl.hxx>
+#include <xsd/cxx/parser/expat/elements.hxx>
+
+namespace xml_schema
+{
+  // Built-in XML Schema types mapping.
+  //
+  typedef ::xsd::cxx::parser::string_sequence< char > string_sequence;
+  typedef ::xsd::cxx::parser::qname< char > qname;
+  typedef ::xsd::cxx::parser::buffer buffer;
+  typedef ::xsd::cxx::parser::time_zone time_zone;
+  typedef ::xsd::cxx::parser::gday gday;
+  typedef ::xsd::cxx::parser::gmonth gmonth;
+  typedef ::xsd::cxx::parser::gyear gyear;
+  typedef ::xsd::cxx::parser::gmonth_day gmonth_day;
+  typedef ::xsd::cxx::parser::gyear_month gyear_month;
+  typedef ::xsd::cxx::parser::date date;
+  typedef ::xsd::cxx::parser::time time;
+  typedef ::xsd::cxx::parser::date_time date_time;
+  typedef ::xsd::cxx::parser::duration duration;
+
+  // Base parser skeletons.
+  //
+  typedef ::xsd::cxx::parser::parser_base< char > parser_base;
+  typedef ::xsd::cxx::parser::validating::empty_content< char > empty_content;
+  typedef ::xsd::cxx::parser::validating::simple_content< char > simple_content;
+  typedef ::xsd::cxx::parser::validating::complex_content< char > complex_content;
+  typedef ::xsd::cxx::parser::validating::list_base< char > list_base;
+
+  // Parser skeletons and implementations for the XML Schema
+  // built-in types.
+  //
+  typedef ::xsd::cxx::parser::validating::any_type_pskel< char > any_type_pskel;
+  typedef ::xsd::cxx::parser::validating::any_type_pimpl< char > any_type_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::any_simple_type_pskel< char > any_simple_type_pskel;
+  typedef ::xsd::cxx::parser::validating::any_simple_type_pimpl< char > any_simple_type_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::byte_pskel< char > byte_pskel;
+  typedef ::xsd::cxx::parser::validating::byte_pimpl< char > byte_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::unsigned_byte_pskel< char > unsigned_byte_pskel;
+  typedef ::xsd::cxx::parser::validating::unsigned_byte_pimpl< char > unsigned_byte_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::short_pskel< char > short_pskel;
+  typedef ::xsd::cxx::parser::validating::short_pimpl< char > short_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::unsigned_short_pskel< char > unsigned_short_pskel;
+  typedef ::xsd::cxx::parser::validating::unsigned_short_pimpl< char > unsigned_short_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::int_pskel< char > int_pskel;
+  typedef ::xsd::cxx::parser::validating::int_pimpl< char > int_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::unsigned_int_pskel< char > unsigned_int_pskel;
+  typedef ::xsd::cxx::parser::validating::unsigned_int_pimpl< char > unsigned_int_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::long_pskel< char > long_pskel;
+  typedef ::xsd::cxx::parser::validating::long_pimpl< char > long_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::unsigned_long_pskel< char > unsigned_long_pskel;
+  typedef ::xsd::cxx::parser::validating::unsigned_long_pimpl< char > unsigned_long_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::integer_pskel< char > integer_pskel;
+  typedef ::xsd::cxx::parser::validating::integer_pimpl< char > integer_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::non_positive_integer_pskel< char > non_positive_integer_pskel;
+  typedef ::xsd::cxx::parser::validating::non_positive_integer_pimpl< char > non_positive_integer_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::non_negative_integer_pskel< char > non_negative_integer_pskel;
+  typedef ::xsd::cxx::parser::validating::non_negative_integer_pimpl< char > non_negative_integer_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::positive_integer_pskel< char > positive_integer_pskel;
+  typedef ::xsd::cxx::parser::validating::positive_integer_pimpl< char > positive_integer_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::negative_integer_pskel< char > negative_integer_pskel;
+  typedef ::xsd::cxx::parser::validating::negative_integer_pimpl< char > negative_integer_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::boolean_pskel< char > boolean_pskel;
+  typedef ::xsd::cxx::parser::validating::boolean_pimpl< char > boolean_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::float_pskel< char > float_pskel;
+  typedef ::xsd::cxx::parser::validating::float_pimpl< char > float_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::double_pskel< char > double_pskel;
+  typedef ::xsd::cxx::parser::validating::double_pimpl< char > double_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::decimal_pskel< char > decimal_pskel;
+  typedef ::xsd::cxx::parser::validating::decimal_pimpl< char > decimal_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::string_pskel< char > string_pskel;
+  typedef ::xsd::cxx::parser::validating::string_pimpl< char > string_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::normalized_string_pskel< char > normalized_string_pskel;
+  typedef ::xsd::cxx::parser::validating::normalized_string_pimpl< char > normalized_string_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::token_pskel< char > token_pskel;
+  typedef ::xsd::cxx::parser::validating::token_pimpl< char > token_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::name_pskel< char > name_pskel;
+  typedef ::xsd::cxx::parser::validating::name_pimpl< char > name_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::nmtoken_pskel< char > nmtoken_pskel;
+  typedef ::xsd::cxx::parser::validating::nmtoken_pimpl< char > nmtoken_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::nmtokens_pskel< char > nmtokens_pskel;
+  typedef ::xsd::cxx::parser::validating::nmtokens_pimpl< char > nmtokens_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::ncname_pskel< char > ncname_pskel;
+  typedef ::xsd::cxx::parser::validating::ncname_pimpl< char > ncname_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::language_pskel< char > language_pskel;
+  typedef ::xsd::cxx::parser::validating::language_pimpl< char > language_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::id_pskel< char > id_pskel;
+  typedef ::xsd::cxx::parser::validating::id_pimpl< char > id_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::idref_pskel< char > idref_pskel;
+  typedef ::xsd::cxx::parser::validating::idref_pimpl< char > idref_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::idrefs_pskel< char > idrefs_pskel;
+  typedef ::xsd::cxx::parser::validating::idrefs_pimpl< char > idrefs_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::uri_pskel< char > uri_pskel;
+  typedef ::xsd::cxx::parser::validating::uri_pimpl< char > uri_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::qname_pskel< char > qname_pskel;
+  typedef ::xsd::cxx::parser::validating::qname_pimpl< char > qname_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::base64_binary_pskel< char > base64_binary_pskel;
+  typedef ::xsd::cxx::parser::validating::base64_binary_pimpl< char > base64_binary_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::hex_binary_pskel< char > hex_binary_pskel;
+  typedef ::xsd::cxx::parser::validating::hex_binary_pimpl< char > hex_binary_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::date_pskel< char > date_pskel;
+  typedef ::xsd::cxx::parser::validating::date_pimpl< char > date_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::date_time_pskel< char > date_time_pskel;
+  typedef ::xsd::cxx::parser::validating::date_time_pimpl< char > date_time_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::duration_pskel< char > duration_pskel;
+  typedef ::xsd::cxx::parser::validating::duration_pimpl< char > duration_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::gday_pskel< char > gday_pskel;
+  typedef ::xsd::cxx::parser::validating::gday_pimpl< char > gday_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::gmonth_pskel< char > gmonth_pskel;
+  typedef ::xsd::cxx::parser::validating::gmonth_pimpl< char > gmonth_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::gmonth_day_pskel< char > gmonth_day_pskel;
+  typedef ::xsd::cxx::parser::validating::gmonth_day_pimpl< char > gmonth_day_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::gyear_pskel< char > gyear_pskel;
+  typedef ::xsd::cxx::parser::validating::gyear_pimpl< char > gyear_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::gyear_month_pskel< char > gyear_month_pskel;
+  typedef ::xsd::cxx::parser::validating::gyear_month_pimpl< char > gyear_month_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::time_pskel< char > time_pskel;
+  typedef ::xsd::cxx::parser::validating::time_pimpl< char > time_pimpl;
+
+  // Exceptions. See libxsd/xsd/cxx/parser/exceptions.hxx for details.
+  //
+  typedef ::xsd::cxx::parser::exception< char > exception;
+
+  // Parsing diagnostics.
+  //
+  typedef ::xsd::cxx::parser::severity severity;
+  typedef ::xsd::cxx::parser::error< char > error;
+  typedef ::xsd::cxx::parser::diagnostics< char > diagnostics;
+  typedef ::xsd::cxx::parser::parsing< char > parsing;
+
+  // Error handler. See libxsd/xsd/cxx/xml/error-handler.hxx for details.
+  //
+  typedef ::xsd::cxx::xml::error_handler< char > error_handler;
+
+  // Read-only string.
+  //
+  typedef ::xsd::cxx::ro_string< char > ro_string;
+
+  // Document type. See libxsd/xsd/cxx/parser/expat/elements.hxx
+  // for details.
+  //
+  typedef ::xsd::cxx::parser::expat::document< char > document;
+}
+
+namespace dpd
+{
+  class devicepkg_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    title (const ::std::string&);
+
+    virtual void
+    author ();
+
+    virtual void
+    description (const ::std::string&);
+
+    virtual void
+    hwdeviceregistration ();
+
+    virtual void
+    id (const ::std::string&);
+
+    virtual void
+    name (const ::std::string&);
+
+    virtual void
+    version (const ::std::string&);
+
+    virtual void
+    post_devicepkg ();
+
+    // Parser construction API.
+    //
+    void
+    title_parser (::xml_schema::string_pskel&);
+
+    void
+    author_parser (::dpd::author_pskel&);
+
+    void
+    description_parser (::xml_schema::string_pskel&);
+
+    void
+    hwdeviceregistration_parser (::dpd::hwdeviceregistration_pskel&);
+
+    void
+    id_parser (::xml_schema::string_pskel&);
+
+    void
+    name_parser (::xml_schema::string_pskel&);
+
+    void
+    version_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* title */,
+             ::dpd::author_pskel& /* author */,
+             ::xml_schema::string_pskel& /* description */,
+             ::dpd::hwdeviceregistration_pskel& /* hwdeviceregistration */,
+             ::xml_schema::string_pskel& /* id */,
+             ::xml_schema::string_pskel& /* name */,
+             ::xml_schema::string_pskel& /* version */);
+
+    // Constructor.
+    //
+    devicepkg_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* title_parser_;
+    ::dpd::author_pskel* author_parser_;
+    ::xml_schema::string_pskel* description_parser_;
+    ::dpd::hwdeviceregistration_pskel* hwdeviceregistration_parser_;
+    ::xml_schema::string_pskel* id_parser_;
+    ::xml_schema::string_pskel* name_parser_;
+    ::xml_schema::string_pskel* version_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::dpd::devicepkg_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+
+    protected:
+    struct v_state_attr_
+    {
+      bool id;
+      bool name;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class author_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    name (const ::std::string&);
+
+    virtual void
+    company (const ::std::string&);
+
+    virtual void
+    webpage (const ::std::string&);
+
+    virtual void
+    post_author ();
+
+    // Parser construction API.
+    //
+    void
+    name_parser (::xml_schema::string_pskel&);
+
+    void
+    company_parser (::xml_schema::string_pskel&);
+
+    void
+    webpage_parser (::xml_schema::uri_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* name */,
+             ::xml_schema::string_pskel& /* company */,
+             ::xml_schema::uri_pskel& /* webpage */);
+
+    // Constructor.
+    //
+    author_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::xml_schema::string_pskel* name_parser_;
+    ::xml_schema::string_pskel* company_parser_;
+    ::xml_schema::uri_pskel* webpage_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::dpd::author_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    choice_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start);
+  };
+
+  class hwdeviceregistration_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    propertyfile ();
+
+    virtual void
+    description (const ::std::string&);
+
+    virtual void
+    manufacturer (const ::std::string&);
+
+    virtual void
+    modelnumber (const ::std::string&);
+
+    virtual void
+    deviceclass ();
+
+    virtual void
+    childhwdevice ();
+
+    virtual void
+    id (const ::std::string&);
+
+    virtual void
+    name (const ::std::string&);
+
+    virtual void
+    version (const ::std::string&);
+
+    virtual void
+    post_hwdeviceregistration ();
+
+    // Parser construction API.
+    //
+    void
+    propertyfile_parser (::dpd::propertyfile_pskel&);
+
+    void
+    description_parser (::xml_schema::string_pskel&);
+
+    void
+    manufacturer_parser (::xml_schema::string_pskel&);
+
+    void
+    modelnumber_parser (::xml_schema::string_pskel&);
+
+    void
+    deviceclass_parser (::dpd::deviceclass_pskel&);
+
+    void
+    childhwdevice_parser (::dpd::childhwdevice_pskel&);
+
+    void
+    id_parser (::xml_schema::string_pskel&);
+
+    void
+    name_parser (::xml_schema::string_pskel&);
+
+    void
+    version_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::dpd::propertyfile_pskel& /* propertyfile */,
+             ::xml_schema::string_pskel& /* description */,
+             ::xml_schema::string_pskel& /* manufacturer */,
+             ::xml_schema::string_pskel& /* modelnumber */,
+             ::dpd::deviceclass_pskel& /* deviceclass */,
+             ::dpd::childhwdevice_pskel& /* childhwdevice */,
+             ::xml_schema::string_pskel& /* id */,
+             ::xml_schema::string_pskel& /* name */,
+             ::xml_schema::string_pskel& /* version */);
+
+    // Constructor.
+    //
+    hwdeviceregistration_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::dpd::propertyfile_pskel* propertyfile_parser_;
+    ::xml_schema::string_pskel* description_parser_;
+    ::xml_schema::string_pskel* manufacturer_parser_;
+    ::xml_schema::string_pskel* modelnumber_parser_;
+    ::dpd::deviceclass_pskel* deviceclass_parser_;
+    ::dpd::childhwdevice_pskel* childhwdevice_parser_;
+    ::xml_schema::string_pskel* id_parser_;
+    ::xml_schema::string_pskel* name_parser_;
+    ::xml_schema::string_pskel* version_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::dpd::hwdeviceregistration_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+
+    protected:
+    struct v_state_attr_
+    {
+      bool id;
+      bool name;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class propertyfile_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    localfile ();
+
+    virtual void
+    type (const ::std::string&);
+
+    virtual void
+    post_propertyfile ();
+
+    // Parser construction API.
+    //
+    void
+    localfile_parser (::dpd::localfile_pskel&);
+
+    void
+    type_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::dpd::localfile_pskel& /* localfile */,
+             ::xml_schema::string_pskel& /* type */);
+
+    // Constructor.
+    //
+    propertyfile_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::dpd::localfile_pskel* localfile_parser_;
+    ::xml_schema::string_pskel* type_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::dpd::propertyfile_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+  };
+
+  class localfile_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    name (const ::std::string&);
+
+    virtual void
+    post_localfile ();
+
+    // Parser construction API.
+    //
+    void
+    name_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* name */);
+
+    // Constructor.
+    //
+    localfile_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* name_parser_;
+
+    protected:
+    struct v_state_attr_
+    {
+      bool name;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class deviceclass_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    class_ (const ::std::string&);
+
+    virtual void
+    post_deviceclass ();
+
+    // Parser construction API.
+    //
+    void
+    class_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* class */);
+
+    // Constructor.
+    //
+    deviceclass_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::xml_schema::string_pskel* class__parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::dpd::deviceclass_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+  };
+
+  class childhwdevice_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    hwdeviceregistration ();
+
+    virtual void
+    devicepkgref ();
+
+    virtual void
+    post_childhwdevice ();
+
+    // Parser construction API.
+    //
+    void
+    hwdeviceregistration_parser (::dpd::hwdeviceregistration_pskel&);
+
+    void
+    devicepkgref_parser (::dpd::devicepkgref_pskel&);
+
+    void
+    parsers (::dpd::hwdeviceregistration_pskel& /* hwdeviceregistration */,
+             ::dpd::devicepkgref_pskel& /* devicepkgref */);
+
+    // Constructor.
+    //
+    childhwdevice_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::dpd::hwdeviceregistration_pskel* hwdeviceregistration_parser_;
+    ::dpd::devicepkgref_pskel* devicepkgref_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::dpd::childhwdevice_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    choice_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start);
+  };
+
+  class devicepkgref_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    localfile ();
+
+    virtual void
+    type (const ::std::string&);
+
+    virtual void
+    post_devicepkgref ();
+
+    // Parser construction API.
+    //
+    void
+    localfile_parser (::dpd::localfile_pskel&);
+
+    void
+    type_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::dpd::localfile_pskel& /* localfile */,
+             ::xml_schema::string_pskel& /* type */);
+
+    // Constructor.
+    //
+    devicepkgref_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::dpd::localfile_pskel* localfile_parser_;
+    ::xml_schema::string_pskel* type_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::dpd::devicepkgref_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+  };
+}
+
+#include <xsd/cxx/post.hxx>
+
+// Begin epilogue.
+//
+//
+// End epilogue.
+
+#endif // CXX______XML_XSD_DPD_PSKEL_H
diff --git src/control/parser/internal/prf-pskel.cpp src/control/parser/internal/prf-pskel.cpp
new file mode 100644
index 0000000..a573409
--- /dev/null
+++ src/control/parser/internal/prf-pskel.cpp
@@ -0,0 +1,5226 @@
+// Copyright (C) 2005-2010 Code Synthesis Tools CC
+//
+// This program was generated by CodeSynthesis XSD, an XML Schema to
+// C++ data binding compiler.
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 2 as
+// published by the Free Software Foundation.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+//
+// In addition, as a special exception, Code Synthesis Tools CC gives
+// permission to link this program with the Xerces-C++ library (or with
+// modified versions of Xerces-C++ that use the same license as Xerces-C++),
+// and distribute linked combinations including the two. You must obey
+// the GNU General Public License version 2 in all respects for all of
+// the code used other than Xerces-C++. If you modify this copy of the
+// program, you may extend this exception to your version of the program,
+// but you are not obligated to do so. If you do not wish to do so, delete
+// this exception statement from your version.
+//
+// Furthermore, Code Synthesis Tools CC makes a special exception for
+// the Free/Libre and Open Source Software (FLOSS) which is described
+// in the accompanying FLOSSE file.
+//
+
+// Begin prologue.
+//
+//
+// End prologue.
+
+#include "prf-pskel.h"
+
+namespace prf
+{
+  // action_pskel
+  //
+
+  void action_pskel::
+  type_parser (::prf::ActionType_pskel& p)
+  {
+    this->type_parser_ = &p;
+  }
+
+  void action_pskel::
+  parsers (::prf::ActionType_pskel& type)
+  {
+    this->type_parser_ = &type;
+  }
+
+  action_pskel::
+  action_pskel ()
+  : type_parser_ (0)
+  {
+  }
+
+  // configurationKind_pskel
+  //
+
+  void configurationKind_pskel::
+  kindtype_parser (::prf::StructPropertyConfigurationType_pskel& p)
+  {
+    this->kindtype_parser_ = &p;
+  }
+
+  void configurationKind_pskel::
+  parsers (::prf::StructPropertyConfigurationType_pskel& kindtype)
+  {
+    this->kindtype_parser_ = &kindtype;
+  }
+
+  configurationKind_pskel::
+  configurationKind_pskel ()
+  : kindtype_parser_ (0)
+  {
+  }
+
+  // enumeration_pskel
+  //
+
+  void enumeration_pskel::
+  label_parser (::xml_schema::string_pskel& p)
+  {
+    this->label_parser_ = &p;
+  }
+
+  void enumeration_pskel::
+  value_parser (::xml_schema::string_pskel& p)
+  {
+    this->value_parser_ = &p;
+  }
+
+  void enumeration_pskel::
+  parsers (::xml_schema::string_pskel& label,
+           ::xml_schema::string_pskel& value)
+  {
+    this->label_parser_ = &label;
+    this->value_parser_ = &value;
+  }
+
+  enumeration_pskel::
+  enumeration_pskel ()
+  : label_parser_ (0),
+    value_parser_ (0),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // enumerations_pskel
+  //
+
+  void enumerations_pskel::
+  enumeration_parser (::prf::enumeration_pskel& p)
+  {
+    this->enumeration_parser_ = &p;
+  }
+
+  void enumerations_pskel::
+  parsers (::prf::enumeration_pskel& enumeration)
+  {
+    this->enumeration_parser_ = &enumeration;
+  }
+
+  enumerations_pskel::
+  enumerations_pskel ()
+  : enumeration_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // inputValue_pskel
+  //
+
+  void inputValue_pskel::
+  simple_parser (::prf::simple_pskel& p)
+  {
+    this->simple_parser_ = &p;
+  }
+
+  void inputValue_pskel::
+  parsers (::prf::simple_pskel& simple)
+  {
+    this->simple_parser_ = &simple;
+  }
+
+  inputValue_pskel::
+  inputValue_pskel ()
+  : simple_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // kind_pskel
+  //
+
+  void kind_pskel::
+  kindtype_parser (::prf::PropertyConfigurationType_pskel& p)
+  {
+    this->kindtype_parser_ = &p;
+  }
+
+  void kind_pskel::
+  parsers (::prf::PropertyConfigurationType_pskel& kindtype)
+  {
+    this->kindtype_parser_ = &kindtype;
+  }
+
+  kind_pskel::
+  kind_pskel ()
+  : kindtype_parser_ (0)
+  {
+  }
+
+  // properties_pskel
+  //
+
+  void properties_pskel::
+  description_parser (::xml_schema::string_pskel& p)
+  {
+    this->description_parser_ = &p;
+  }
+
+  void properties_pskel::
+  simple_parser (::prf::simple_pskel& p)
+  {
+    this->simple_parser_ = &p;
+  }
+
+  void properties_pskel::
+  simplesequence_parser (::prf::simpleSequence_pskel& p)
+  {
+    this->simplesequence_parser_ = &p;
+  }
+
+  void properties_pskel::
+  test_parser (::prf::test_pskel& p)
+  {
+    this->test_parser_ = &p;
+  }
+
+  void properties_pskel::
+  struct_parser (::prf::struct_pskel& p)
+  {
+    this->struct__parser_ = &p;
+  }
+
+  void properties_pskel::
+  structsequence_parser (::prf::structSequence_pskel& p)
+  {
+    this->structsequence_parser_ = &p;
+  }
+
+  void properties_pskel::
+  parsers (::xml_schema::string_pskel& description,
+           ::prf::simple_pskel& simple,
+           ::prf::simpleSequence_pskel& simplesequence,
+           ::prf::test_pskel& test,
+           ::prf::struct_pskel& struct_,
+           ::prf::structSequence_pskel& structsequence)
+  {
+    this->description_parser_ = &description;
+    this->simple_parser_ = &simple;
+    this->simplesequence_parser_ = &simplesequence;
+    this->test_parser_ = &test;
+    this->struct__parser_ = &struct_;
+    this->structsequence_parser_ = &structsequence;
+  }
+
+  properties_pskel::
+  properties_pskel ()
+  : description_parser_ (0),
+    simple_parser_ (0),
+    simplesequence_parser_ (0),
+    test_parser_ (0),
+    struct__parser_ (0),
+    structsequence_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // range_pskel
+  //
+
+  void range_pskel::
+  max_parser (::xml_schema::string_pskel& p)
+  {
+    this->max_parser_ = &p;
+  }
+
+  void range_pskel::
+  min_parser (::xml_schema::string_pskel& p)
+  {
+    this->min_parser_ = &p;
+  }
+
+  void range_pskel::
+  parsers (::xml_schema::string_pskel& max,
+           ::xml_schema::string_pskel& min)
+  {
+    this->max_parser_ = &max;
+    this->min_parser_ = &min;
+  }
+
+  range_pskel::
+  range_pskel ()
+  : max_parser_ (0),
+    min_parser_ (0),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // resultValue_pskel
+  //
+
+  void resultValue_pskel::
+  simple_parser (::prf::simple_pskel& p)
+  {
+    this->simple_parser_ = &p;
+  }
+
+  void resultValue_pskel::
+  parsers (::prf::simple_pskel& simple)
+  {
+    this->simple_parser_ = &simple;
+  }
+
+  resultValue_pskel::
+  resultValue_pskel ()
+  : simple_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // simple_pskel
+  //
+
+  void simple_pskel::
+  description_parser (::xml_schema::string_pskel& p)
+  {
+    this->description_parser_ = &p;
+  }
+
+  void simple_pskel::
+  value_parser (::xml_schema::string_pskel& p)
+  {
+    this->value_parser_ = &p;
+  }
+
+  void simple_pskel::
+  units_parser (::prf::Unit_pskel& p)
+  {
+    this->units_parser_ = &p;
+  }
+
+  void simple_pskel::
+  range_parser (::prf::range_pskel& p)
+  {
+    this->range_parser_ = &p;
+  }
+
+  void simple_pskel::
+  enumerations_parser (::prf::enumerations_pskel& p)
+  {
+    this->enumerations_parser_ = &p;
+  }
+
+  void simple_pskel::
+  kind_parser (::prf::kind_pskel& p)
+  {
+    this->kind_parser_ = &p;
+  }
+
+  void simple_pskel::
+  action_parser (::prf::action_pskel& p)
+  {
+    this->action_parser_ = &p;
+  }
+
+  void simple_pskel::
+  id_parser (::xml_schema::string_pskel& p)
+  {
+    this->id_parser_ = &p;
+  }
+
+  void simple_pskel::
+  mode_parser (::prf::AccessType_pskel& p)
+  {
+    this->mode_parser_ = &p;
+  }
+
+  void simple_pskel::
+  name_parser (::xml_schema::string_pskel& p)
+  {
+    this->name_parser_ = &p;
+  }
+
+  void simple_pskel::
+  complex_parser (::prf::IsComplex_pskel& p)
+  {
+    this->complex_parser_ = &p;
+  }
+
+  void simple_pskel::
+  commandline_parser (::prf::IsCommandLine_pskel& p)
+  {
+    this->commandline_parser_ = &p;
+  }
+
+  void simple_pskel::
+  optional_parser (::prf::IsOptional_pskel& p)
+  {
+    this->optional_parser_ = &p;
+  }
+
+  void simple_pskel::
+  type_parser (::prf::PropertyValueType_pskel& p)
+  {
+    this->type_parser_ = &p;
+  }
+
+  void simple_pskel::
+  parsers (::xml_schema::string_pskel& description,
+           ::xml_schema::string_pskel& value,
+           ::prf::Unit_pskel& units,
+           ::prf::range_pskel& range,
+           ::prf::enumerations_pskel& enumerations,
+           ::prf::kind_pskel& kind,
+           ::prf::action_pskel& action,
+           ::xml_schema::string_pskel& id,
+           ::prf::AccessType_pskel& mode,
+           ::xml_schema::string_pskel& name,
+           ::prf::IsComplex_pskel& complex,
+           ::prf::IsCommandLine_pskel& commandline,
+           ::prf::IsOptional_pskel& optional,
+           ::prf::PropertyValueType_pskel& type)
+  {
+    this->description_parser_ = &description;
+    this->value_parser_ = &value;
+    this->units_parser_ = &units;
+    this->range_parser_ = &range;
+    this->enumerations_parser_ = &enumerations;
+    this->kind_parser_ = &kind;
+    this->action_parser_ = &action;
+    this->id_parser_ = &id;
+    this->mode_parser_ = &mode;
+    this->name_parser_ = &name;
+    this->complex_parser_ = &complex;
+    this->commandline_parser_ = &commandline;
+    this->optional_parser_ = &optional;
+    this->type_parser_ = &type;
+  }
+
+  simple_pskel::
+  simple_pskel ()
+  : description_parser_ (0),
+    value_parser_ (0),
+    units_parser_ (0),
+    range_parser_ (0),
+    enumerations_parser_ (0),
+    kind_parser_ (0),
+    action_parser_ (0),
+    id_parser_ (0),
+    mode_parser_ (0),
+    name_parser_ (0),
+    complex_parser_ (0),
+    commandline_parser_ (0),
+    optional_parser_ (0),
+    type_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // simpleRef_pskel
+  //
+
+  void simpleRef_pskel::
+  refid_parser (::xml_schema::string_pskel& p)
+  {
+    this->refid_parser_ = &p;
+  }
+
+  void simpleRef_pskel::
+  value_parser (::xml_schema::string_pskel& p)
+  {
+    this->value_parser_ = &p;
+  }
+
+  void simpleRef_pskel::
+  parsers (::xml_schema::string_pskel& refid,
+           ::xml_schema::string_pskel& value)
+  {
+    this->refid_parser_ = &refid;
+    this->value_parser_ = &value;
+  }
+
+  simpleRef_pskel::
+  simpleRef_pskel ()
+  : refid_parser_ (0),
+    value_parser_ (0),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // simpleSequenceRef_pskel
+  //
+
+  void simpleSequenceRef_pskel::
+  values_parser (::prf::values_pskel& p)
+  {
+    this->values_parser_ = &p;
+  }
+
+  void simpleSequenceRef_pskel::
+  refid_parser (::xml_schema::string_pskel& p)
+  {
+    this->refid_parser_ = &p;
+  }
+
+  void simpleSequenceRef_pskel::
+  parsers (::prf::values_pskel& values,
+           ::xml_schema::string_pskel& refid)
+  {
+    this->values_parser_ = &values;
+    this->refid_parser_ = &refid;
+  }
+
+  simpleSequenceRef_pskel::
+  simpleSequenceRef_pskel ()
+  : values_parser_ (0),
+    refid_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // simpleSequence_pskel
+  //
+
+  void simpleSequence_pskel::
+  description_parser (::xml_schema::string_pskel& p)
+  {
+    this->description_parser_ = &p;
+  }
+
+  void simpleSequence_pskel::
+  values_parser (::prf::values_pskel& p)
+  {
+    this->values_parser_ = &p;
+  }
+
+  void simpleSequence_pskel::
+  units_parser (::prf::Unit_pskel& p)
+  {
+    this->units_parser_ = &p;
+  }
+
+  void simpleSequence_pskel::
+  range_parser (::prf::range_pskel& p)
+  {
+    this->range_parser_ = &p;
+  }
+
+  void simpleSequence_pskel::
+  kind_parser (::prf::kind_pskel& p)
+  {
+    this->kind_parser_ = &p;
+  }
+
+  void simpleSequence_pskel::
+  action_parser (::prf::action_pskel& p)
+  {
+    this->action_parser_ = &p;
+  }
+
+  void simpleSequence_pskel::
+  id_parser (::xml_schema::string_pskel& p)
+  {
+    this->id_parser_ = &p;
+  }
+
+  void simpleSequence_pskel::
+  mode_parser (::prf::AccessType_pskel& p)
+  {
+    this->mode_parser_ = &p;
+  }
+
+  void simpleSequence_pskel::
+  name_parser (::xml_schema::string_pskel& p)
+  {
+    this->name_parser_ = &p;
+  }
+
+  void simpleSequence_pskel::
+  type_parser (::prf::PropertyValueType_pskel& p)
+  {
+    this->type_parser_ = &p;
+  }
+
+  void simpleSequence_pskel::
+  complex_parser (::prf::IsComplex_pskel& p)
+  {
+    this->complex_parser_ = &p;
+  }
+
+  void simpleSequence_pskel::
+  optional_parser (::prf::IsOptional_pskel& p)
+  {
+    this->optional_parser_ = &p;
+  }
+
+  void simpleSequence_pskel::
+  parsers (::xml_schema::string_pskel& description,
+           ::prf::values_pskel& values,
+           ::prf::Unit_pskel& units,
+           ::prf::range_pskel& range,
+           ::prf::kind_pskel& kind,
+           ::prf::action_pskel& action,
+           ::xml_schema::string_pskel& id,
+           ::prf::AccessType_pskel& mode,
+           ::xml_schema::string_pskel& name,
+           ::prf::PropertyValueType_pskel& type,
+           ::prf::IsComplex_pskel& complex,
+           ::prf::IsOptional_pskel& optional)
+  {
+    this->description_parser_ = &description;
+    this->values_parser_ = &values;
+    this->units_parser_ = &units;
+    this->range_parser_ = &range;
+    this->kind_parser_ = &kind;
+    this->action_parser_ = &action;
+    this->id_parser_ = &id;
+    this->mode_parser_ = &mode;
+    this->name_parser_ = &name;
+    this->type_parser_ = &type;
+    this->complex_parser_ = &complex;
+    this->optional_parser_ = &optional;
+  }
+
+  simpleSequence_pskel::
+  simpleSequence_pskel ()
+  : description_parser_ (0),
+    values_parser_ (0),
+    units_parser_ (0),
+    range_parser_ (0),
+    kind_parser_ (0),
+    action_parser_ (0),
+    id_parser_ (0),
+    mode_parser_ (0),
+    name_parser_ (0),
+    type_parser_ (0),
+    complex_parser_ (0),
+    optional_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // struct_pskel
+  //
+
+  void struct_pskel::
+  description_parser (::xml_schema::string_pskel& p)
+  {
+    this->description_parser_ = &p;
+  }
+
+  void struct_pskel::
+  simple_parser (::prf::simple_pskel& p)
+  {
+    this->simple_parser_ = &p;
+  }
+
+  void struct_pskel::
+  simplesequence_parser (::prf::simpleSequence_pskel& p)
+  {
+    this->simplesequence_parser_ = &p;
+  }
+
+  void struct_pskel::
+  configurationkind_parser (::prf::configurationKind_pskel& p)
+  {
+    this->configurationkind_parser_ = &p;
+  }
+
+  void struct_pskel::
+  id_parser (::xml_schema::string_pskel& p)
+  {
+    this->id_parser_ = &p;
+  }
+
+  void struct_pskel::
+  mode_parser (::prf::AccessType_pskel& p)
+  {
+    this->mode_parser_ = &p;
+  }
+
+  void struct_pskel::
+  name_parser (::xml_schema::string_pskel& p)
+  {
+    this->name_parser_ = &p;
+  }
+
+  void struct_pskel::
+  parsers (::xml_schema::string_pskel& description,
+           ::prf::simple_pskel& simple,
+           ::prf::simpleSequence_pskel& simplesequence,
+           ::prf::configurationKind_pskel& configurationkind,
+           ::xml_schema::string_pskel& id,
+           ::prf::AccessType_pskel& mode,
+           ::xml_schema::string_pskel& name)
+  {
+    this->description_parser_ = &description;
+    this->simple_parser_ = &simple;
+    this->simplesequence_parser_ = &simplesequence;
+    this->configurationkind_parser_ = &configurationkind;
+    this->id_parser_ = &id;
+    this->mode_parser_ = &mode;
+    this->name_parser_ = &name;
+  }
+
+  struct_pskel::
+  struct_pskel ()
+  : description_parser_ (0),
+    simple_parser_ (0),
+    simplesequence_parser_ (0),
+    configurationkind_parser_ (0),
+    id_parser_ (0),
+    mode_parser_ (0),
+    name_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // structSequence_pskel
+  //
+
+  void structSequence_pskel::
+  description_parser (::xml_schema::string_pskel& p)
+  {
+    this->description_parser_ = &p;
+  }
+
+  void structSequence_pskel::
+  struct_parser (::prf::struct_pskel& p)
+  {
+    this->struct__parser_ = &p;
+  }
+
+  void structSequence_pskel::
+  structvalue_parser (::prf::structValue_pskel& p)
+  {
+    this->structvalue_parser_ = &p;
+  }
+
+  void structSequence_pskel::
+  configurationkind_parser (::prf::configurationKind_pskel& p)
+  {
+    this->configurationkind_parser_ = &p;
+  }
+
+  void structSequence_pskel::
+  id_parser (::xml_schema::string_pskel& p)
+  {
+    this->id_parser_ = &p;
+  }
+
+  void structSequence_pskel::
+  mode_parser (::prf::AccessType_pskel& p)
+  {
+    this->mode_parser_ = &p;
+  }
+
+  void structSequence_pskel::
+  name_parser (::xml_schema::string_pskel& p)
+  {
+    this->name_parser_ = &p;
+  }
+
+  void structSequence_pskel::
+  parsers (::xml_schema::string_pskel& description,
+           ::prf::struct_pskel& struct_,
+           ::prf::structValue_pskel& structvalue,
+           ::prf::configurationKind_pskel& configurationkind,
+           ::xml_schema::string_pskel& id,
+           ::prf::AccessType_pskel& mode,
+           ::xml_schema::string_pskel& name)
+  {
+    this->description_parser_ = &description;
+    this->struct__parser_ = &struct_;
+    this->structvalue_parser_ = &structvalue;
+    this->configurationkind_parser_ = &configurationkind;
+    this->id_parser_ = &id;
+    this->mode_parser_ = &mode;
+    this->name_parser_ = &name;
+  }
+
+  structSequence_pskel::
+  structSequence_pskel ()
+  : description_parser_ (0),
+    struct__parser_ (0),
+    structvalue_parser_ (0),
+    configurationkind_parser_ (0),
+    id_parser_ (0),
+    mode_parser_ (0),
+    name_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // structValue_pskel
+  //
+
+  void structValue_pskel::
+  simpleref_parser (::prf::simpleRef_pskel& p)
+  {
+    this->simpleref_parser_ = &p;
+  }
+
+  void structValue_pskel::
+  simplesequenceref_parser (::prf::simpleSequenceRef_pskel& p)
+  {
+    this->simplesequenceref_parser_ = &p;
+  }
+
+  void structValue_pskel::
+  parsers (::prf::simpleRef_pskel& simpleref,
+           ::prf::simpleSequenceRef_pskel& simplesequenceref)
+  {
+    this->simpleref_parser_ = &simpleref;
+    this->simplesequenceref_parser_ = &simplesequenceref;
+  }
+
+  structValue_pskel::
+  structValue_pskel ()
+  : simpleref_parser_ (0),
+    simplesequenceref_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // test_pskel
+  //
+
+  void test_pskel::
+  description_parser (::xml_schema::string_pskel& p)
+  {
+    this->description_parser_ = &p;
+  }
+
+  void test_pskel::
+  inputvalue_parser (::prf::inputValue_pskel& p)
+  {
+    this->inputvalue_parser_ = &p;
+  }
+
+  void test_pskel::
+  resultvalue_parser (::prf::resultValue_pskel& p)
+  {
+    this->resultvalue_parser_ = &p;
+  }
+
+  void test_pskel::
+  id_parser (::xml_schema::string_pskel& p)
+  {
+    this->id_parser_ = &p;
+  }
+
+  void test_pskel::
+  parsers (::xml_schema::string_pskel& description,
+           ::prf::inputValue_pskel& inputvalue,
+           ::prf::resultValue_pskel& resultvalue,
+           ::xml_schema::string_pskel& id)
+  {
+    this->description_parser_ = &description;
+    this->inputvalue_parser_ = &inputvalue;
+    this->resultvalue_parser_ = &resultvalue;
+    this->id_parser_ = &id;
+  }
+
+  test_pskel::
+  test_pskel ()
+  : description_parser_ (0),
+    inputvalue_parser_ (0),
+    resultvalue_parser_ (0),
+    id_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // values_pskel
+  //
+
+  void values_pskel::
+  value_parser (::xml_schema::string_pskel& p)
+  {
+    this->value_parser_ = &p;
+  }
+
+  void values_pskel::
+  parsers (::xml_schema::string_pskel& value)
+  {
+    this->value_parser_ = &value;
+  }
+
+  values_pskel::
+  values_pskel ()
+  : value_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+}
+
+namespace prf
+{
+  // Unit_pskel
+  //
+
+  ::std::string Unit_pskel::
+  post_Unit ()
+  {
+    return post_string ();
+  }
+
+  // IsComplex_pskel
+  //
+
+  ::std::string IsComplex_pskel::
+  post_IsComplex ()
+  {
+    return post_string ();
+  }
+
+  // IsCommandLine_pskel
+  //
+
+  ::std::string IsCommandLine_pskel::
+  post_IsCommandLine ()
+  {
+    return post_string ();
+  }
+
+  // IsOptional_pskel
+  //
+
+  ::std::string IsOptional_pskel::
+  post_IsOptional ()
+  {
+    return post_string ();
+  }
+
+  // AccessType_pskel
+  //
+
+  ::std::string AccessType_pskel::
+  post_AccessType ()
+  {
+    return post_string ();
+  }
+
+  // action_pskel
+  //
+
+  void action_pskel::
+  type (const ::std::string&)
+  {
+  }
+
+  // ActionType_pskel
+  //
+
+  ::std::string ActionType_pskel::
+  post_ActionType ()
+  {
+    return post_string ();
+  }
+
+  // configurationKind_pskel
+  //
+
+  void configurationKind_pskel::
+  kindtype (const ::std::string&)
+  {
+  }
+
+  // enumeration_pskel
+  //
+
+  void enumeration_pskel::
+  label (const ::std::string&)
+  {
+  }
+
+  void enumeration_pskel::
+  value (const ::std::string&)
+  {
+  }
+
+  // enumerations_pskel
+  //
+
+  void enumerations_pskel::
+  enumeration (const ::std::map<std::string, std::string>::value_type&)
+  {
+  }
+
+  // inputValue_pskel
+  //
+
+  void inputValue_pskel::
+  simple (ossie::SimpleProperty*)
+  {
+  }
+
+  void inputValue_pskel::
+  post_inputValue ()
+  {
+  }
+
+  // kind_pskel
+  //
+
+  void kind_pskel::
+  kindtype (const ::std::string&)
+  {
+  }
+
+  // PropertyConfigurationType_pskel
+  //
+
+  ::std::string PropertyConfigurationType_pskel::
+  post_PropertyConfigurationType ()
+  {
+    return post_string ();
+  }
+
+  // StructPropertyConfigurationType_pskel
+  //
+
+  ::std::string StructPropertyConfigurationType_pskel::
+  post_StructPropertyConfigurationType ()
+  {
+    return post_PropertyConfigurationType ();
+  }
+
+  // properties_pskel
+  //
+
+  void properties_pskel::
+  description (const ::std::string&)
+  {
+  }
+
+  void properties_pskel::
+  simple (ossie::SimpleProperty*)
+  {
+  }
+
+  void properties_pskel::
+  simplesequence (ossie::SimpleSequenceProperty*)
+  {
+  }
+
+  void properties_pskel::
+  test ()
+  {
+  }
+
+  void properties_pskel::
+  struct_ (ossie::StructProperty*)
+  {
+  }
+
+  void properties_pskel::
+  structsequence (ossie::StructSequenceProperty*)
+  {
+  }
+
+  // PropertyValueType_pskel
+  //
+
+  ::std::string PropertyValueType_pskel::
+  post_PropertyValueType ()
+  {
+    return post_string ();
+  }
+
+  // range_pskel
+  //
+
+  void range_pskel::
+  max (const ::std::string&)
+  {
+  }
+
+  void range_pskel::
+  min (const ::std::string&)
+  {
+  }
+
+  // resultValue_pskel
+  //
+
+  void resultValue_pskel::
+  simple (ossie::SimpleProperty*)
+  {
+  }
+
+  void resultValue_pskel::
+  post_resultValue ()
+  {
+  }
+
+  // simple_pskel
+  //
+
+  void simple_pskel::
+  description (const ::std::string&)
+  {
+  }
+
+  void simple_pskel::
+  value (const ::std::string&)
+  {
+  }
+
+  void simple_pskel::
+  units (const ::std::string&)
+  {
+  }
+
+  void simple_pskel::
+  range (const ::std::pair<std::string, std::string>&)
+  {
+  }
+
+  void simple_pskel::
+  enumerations (const ::std::map<std::string, std::string>&)
+  {
+  }
+
+  void simple_pskel::
+  kind (const ::std::string&)
+  {
+  }
+
+  void simple_pskel::
+  action (const ::std::string&)
+  {
+  }
+
+  void simple_pskel::
+  id (const ::std::string&)
+  {
+  }
+
+  void simple_pskel::
+  mode (const ::std::string&)
+  {
+  }
+
+  void simple_pskel::
+  name (const ::std::string&)
+  {
+  }
+
+  void simple_pskel::
+  complex (const ::std::string&)
+  {
+  }
+
+  void simple_pskel::
+  commandline (const ::std::string&)
+  {
+  }
+
+  void simple_pskel::
+  optional (const ::std::string&)
+  {
+  }
+
+  void simple_pskel::
+  type (const ::std::string&)
+  {
+  }
+
+  // simpleRef_pskel
+  //
+
+  void simpleRef_pskel::
+  refid (const ::std::string&)
+  {
+  }
+
+  void simpleRef_pskel::
+  value (const ::std::string&)
+  {
+  }
+
+  // simpleSequenceRef_pskel
+  //
+
+  void simpleSequenceRef_pskel::
+  values (const ::std::vector<std::string>&)
+  {
+  }
+
+  void simpleSequenceRef_pskel::
+  refid (const ::std::string&)
+  {
+  }
+
+  // simpleSequence_pskel
+  //
+
+  void simpleSequence_pskel::
+  description (const ::std::string&)
+  {
+  }
+
+  void simpleSequence_pskel::
+  values (const ::std::vector<std::string>&)
+  {
+  }
+
+  void simpleSequence_pskel::
+  units (const ::std::string&)
+  {
+  }
+
+  void simpleSequence_pskel::
+  range (const ::std::pair<std::string, std::string>&)
+  {
+  }
+
+  void simpleSequence_pskel::
+  kind (const ::std::string&)
+  {
+  }
+
+  void simpleSequence_pskel::
+  action (const ::std::string&)
+  {
+  }
+
+  void simpleSequence_pskel::
+  id (const ::std::string&)
+  {
+  }
+
+  void simpleSequence_pskel::
+  mode (const ::std::string&)
+  {
+  }
+
+  void simpleSequence_pskel::
+  name (const ::std::string&)
+  {
+  }
+
+  void simpleSequence_pskel::
+  type (const ::std::string&)
+  {
+  }
+
+  void simpleSequence_pskel::
+  complex (const ::std::string&)
+  {
+  }
+
+  void simpleSequence_pskel::
+  optional (const ::std::string&)
+  {
+  }
+
+  // struct_pskel
+  //
+
+  void struct_pskel::
+  description (const ::std::string&)
+  {
+  }
+
+  void struct_pskel::
+  simple (ossie::SimpleProperty*)
+  {
+  }
+
+  void struct_pskel::
+  simplesequence (ossie::SimpleSequenceProperty*)
+  {
+  }
+
+  void struct_pskel::
+  configurationkind (const ::std::string&)
+  {
+  }
+
+  void struct_pskel::
+  id (const ::std::string&)
+  {
+  }
+
+  void struct_pskel::
+  mode (const ::std::string&)
+  {
+  }
+
+  void struct_pskel::
+  name (const ::std::string&)
+  {
+  }
+
+  // structSequence_pskel
+  //
+
+  void structSequence_pskel::
+  description (const ::std::string&)
+  {
+  }
+
+  void structSequence_pskel::
+  struct_ (ossie::StructProperty*)
+  {
+  }
+
+  void structSequence_pskel::
+  structvalue (const ::std::map<std::string, ossie::ComponentProperty*>&)
+  {
+  }
+
+  void structSequence_pskel::
+  configurationkind (const ::std::string&)
+  {
+  }
+
+  void structSequence_pskel::
+  id (const ::std::string&)
+  {
+  }
+
+  void structSequence_pskel::
+  mode (const ::std::string&)
+  {
+  }
+
+  void structSequence_pskel::
+  name (const ::std::string&)
+  {
+  }
+
+  // structValue_pskel
+  //
+
+  void structValue_pskel::
+  simpleref (ossie::SimplePropertyRef*)
+  {
+  }
+
+  void structValue_pskel::
+  simplesequenceref (ossie::SimpleSequencePropertyRef*)
+  {
+  }
+
+  // test_pskel
+  //
+
+  void test_pskel::
+  description (const ::std::string&)
+  {
+  }
+
+  void test_pskel::
+  inputvalue ()
+  {
+  }
+
+  void test_pskel::
+  resultvalue ()
+  {
+  }
+
+  void test_pskel::
+  id (const ::std::string&)
+  {
+  }
+
+  void test_pskel::
+  post_test ()
+  {
+  }
+
+  // values_pskel
+  //
+
+  void values_pskel::
+  value (const ::std::string&)
+  {
+  }
+}
+
+#include <cassert>
+
+namespace prf
+{
+  // Element validation and dispatch functions for enumerations_pskel.
+  //
+  bool enumerations_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "enumeration" && ns.empty ())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &enumerations_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "enumeration",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool enumerations_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void enumerations_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void enumerations_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "enumeration");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void enumerations_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "enumeration" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->enumeration_parser_;
+
+            if (this->enumeration_parser_)
+              this->enumeration_parser_->pre ();
+          }
+          else
+          {
+            if (this->enumeration_parser_)
+            {
+              const ::std::map<std::string, std::string>::value_type& tmp (this->enumeration_parser_->post_enumeration ());
+              this->enumeration (tmp);
+            }
+
+            count++;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "enumeration",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for inputValue_pskel.
+  //
+  bool inputValue_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "simple" && ns.empty ())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &inputValue_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "simple",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool inputValue_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void inputValue_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void inputValue_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "simple");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void inputValue_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "simple" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->simple_parser_;
+
+            if (this->simple_parser_)
+              this->simple_parser_->pre ();
+          }
+          else
+          {
+            if (this->simple_parser_)
+            {
+              ossie::SimpleProperty* tmp (this->simple_parser_->post_simple ());
+              this->simple (tmp);
+            }
+
+            count++;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "simple",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for properties_pskel.
+  //
+  bool properties_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "description" && ns.empty ())
+          s = 0UL;
+        else if ((n == "simple" && ns.empty ()) ||
+                 (n == "simplesequence" && ns.empty ()) ||
+                 (n == "test" && ns.empty ()) ||
+                 (n == "struct" && ns.empty ()) ||
+                 (n == "structsequence" && ns.empty ()))
+          s = 1UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &properties_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool properties_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void properties_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void properties_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+
+    this->v_state_stack_.pop ();
+  }
+
+  void properties_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "description" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->description_parser_;
+
+            if (this->description_parser_)
+              this->description_parser_->pre ();
+          }
+          else
+          {
+            if (this->description_parser_)
+            {
+              const ::std::string& tmp (this->description_parser_->post_string ());
+              this->description (tmp);
+            }
+
+            count = 0;
+            state = 1UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 1UL;
+          // Fall through.
+        }
+      }
+      case 1UL:
+      {
+        unsigned long s (~0UL);
+
+        if (n == "simple" && ns.empty ())
+          s = 0UL;
+        else if (n == "simplesequence" && ns.empty ())
+          s = 1UL;
+        else if (n == "test" && ns.empty ())
+          s = 2UL;
+        else if (n == "struct" && ns.empty ())
+          s = 3UL;
+        else if (n == "structsequence" && ns.empty ())
+          s = 4UL;
+
+        if (s != ~0UL)
+        {
+          assert (start);
+          count++;
+
+          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+          v_state_descr_& vd = vs.data[vs.size++];
+
+          vd.func = &properties_pskel::choice_0;
+          vd.state = s;
+          vd.count = 0;
+
+          this->choice_0 (vd.state, vd.count, ns, n, t, true);
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  void properties_pskel::
+  choice_0 (unsigned long& state,
+            unsigned long& count,
+            const ::xml_schema::ro_string& ns,
+            const ::xml_schema::ro_string& n,
+            const ::xml_schema::ro_string* t,
+            bool start)
+  {
+    XSD_UNUSED (count);
+    XSD_UNUSED (ns);
+    XSD_UNUSED (n);
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->simple_parser_;
+
+          if (this->simple_parser_)
+            this->simple_parser_->pre ();
+        }
+        else
+        {
+          if (this->simple_parser_)
+          {
+            ossie::SimpleProperty* tmp (this->simple_parser_->post_simple ());
+            this->simple (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 1UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->simplesequence_parser_;
+
+          if (this->simplesequence_parser_)
+            this->simplesequence_parser_->pre ();
+        }
+        else
+        {
+          if (this->simplesequence_parser_)
+          {
+            ossie::SimpleSequenceProperty* tmp (this->simplesequence_parser_->post_simpleSequence ());
+            this->simplesequence (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 2UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->test_parser_;
+
+          if (this->test_parser_)
+            this->test_parser_->pre ();
+        }
+        else
+        {
+          if (this->test_parser_)
+          {
+            this->test_parser_->post_test ();
+            this->test ();
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 3UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->struct__parser_;
+
+          if (this->struct__parser_)
+            this->struct__parser_->pre ();
+        }
+        else
+        {
+          if (this->struct__parser_)
+          {
+            ossie::StructProperty* tmp (this->struct__parser_->post_struct ());
+            this->struct_ (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 4UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->structsequence_parser_;
+
+          if (this->structsequence_parser_)
+            this->structsequence_parser_->pre ();
+        }
+        else
+        {
+          if (this->structsequence_parser_)
+          {
+            ossie::StructSequenceProperty* tmp (this->structsequence_parser_->post_structSequence ());
+            this->structsequence (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+    }
+  }
+
+  // Element validation and dispatch functions for resultValue_pskel.
+  //
+  bool resultValue_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "simple" && ns.empty ())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &resultValue_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "simple",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool resultValue_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void resultValue_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void resultValue_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "simple");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void resultValue_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "simple" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->simple_parser_;
+
+            if (this->simple_parser_)
+              this->simple_parser_->pre ();
+          }
+          else
+          {
+            if (this->simple_parser_)
+            {
+              ossie::SimpleProperty* tmp (this->simple_parser_->post_simple ());
+              this->simple (tmp);
+            }
+
+            count++;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "simple",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for simple_pskel.
+  //
+  bool simple_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "description" && ns.empty ())
+          s = 0UL;
+        else if (n == "value" && ns.empty ())
+          s = 1UL;
+        else if (n == "units" && ns.empty ())
+          s = 2UL;
+        else if (n == "range" && ns.empty ())
+          s = 3UL;
+        else if (n == "enumerations" && ns.empty ())
+          s = 4UL;
+        else if (n == "kind" && ns.empty ())
+          s = 5UL;
+        else if (n == "action" && ns.empty ())
+          s = 6UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &simple_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool simple_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void simple_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void simple_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+
+    this->v_state_stack_.pop ();
+  }
+
+  void simple_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "description" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->description_parser_;
+
+            if (this->description_parser_)
+              this->description_parser_->pre ();
+          }
+          else
+          {
+            if (this->description_parser_)
+            {
+              const ::std::string& tmp (this->description_parser_->post_string ());
+              this->description (tmp);
+            }
+
+            count = 0;
+            state = 1UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 1UL;
+          // Fall through.
+        }
+      }
+      case 1UL:
+      {
+        if (n == "value" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->value_parser_;
+
+            if (this->value_parser_)
+              this->value_parser_->pre ();
+          }
+          else
+          {
+            if (this->value_parser_)
+            {
+              const ::std::string& tmp (this->value_parser_->post_string ());
+              this->value (tmp);
+            }
+
+            count = 0;
+            state = 2UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 2UL;
+          // Fall through.
+        }
+      }
+      case 2UL:
+      {
+        if (n == "units" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->units_parser_;
+
+            if (this->units_parser_)
+              this->units_parser_->pre ();
+          }
+          else
+          {
+            if (this->units_parser_)
+            {
+              const ::std::string& tmp (this->units_parser_->post_Unit ());
+              this->units (tmp);
+            }
+
+            count = 0;
+            state = 3UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 3UL;
+          // Fall through.
+        }
+      }
+      case 3UL:
+      {
+        if (n == "range" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->range_parser_;
+
+            if (this->range_parser_)
+              this->range_parser_->pre ();
+          }
+          else
+          {
+            if (this->range_parser_)
+            {
+              const ::std::pair<std::string, std::string>& tmp (this->range_parser_->post_range ());
+              this->range (tmp);
+            }
+
+            count = 0;
+            state = 4UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 4UL;
+          // Fall through.
+        }
+      }
+      case 4UL:
+      {
+        if (n == "enumerations" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->enumerations_parser_;
+
+            if (this->enumerations_parser_)
+              this->enumerations_parser_->pre ();
+          }
+          else
+          {
+            if (this->enumerations_parser_)
+            {
+              const ::std::map<std::string, std::string>& tmp (this->enumerations_parser_->post_enumerations ());
+              this->enumerations (tmp);
+            }
+
+            count = 0;
+            state = 5UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 5UL;
+          // Fall through.
+        }
+      }
+      case 5UL:
+      {
+        if (n == "kind" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->kind_parser_;
+
+            if (this->kind_parser_)
+              this->kind_parser_->pre ();
+          }
+          else
+          {
+            if (this->kind_parser_)
+            {
+              const ::std::string& tmp (this->kind_parser_->post_kind ());
+              this->kind (tmp);
+            }
+
+            count++;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 6UL;
+          // Fall through.
+        }
+      }
+      case 6UL:
+      {
+        if (n == "action" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->action_parser_;
+
+            if (this->action_parser_)
+              this->action_parser_->pre ();
+          }
+          else
+          {
+            if (this->action_parser_)
+            {
+              const ::std::string& tmp (this->action_parser_->post_action ());
+              this->action (tmp);
+            }
+
+            count = 0;
+            state = ~0UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for simpleSequenceRef_pskel.
+  //
+  bool simpleSequenceRef_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "values" && ns.empty ())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &simpleSequenceRef_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "values",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool simpleSequenceRef_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void simpleSequenceRef_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void simpleSequenceRef_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "values");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void simpleSequenceRef_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "values" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->values_parser_;
+
+            if (this->values_parser_)
+              this->values_parser_->pre ();
+          }
+          else
+          {
+            if (this->values_parser_)
+            {
+              const ::std::vector<std::string>& tmp (this->values_parser_->post_values ());
+              this->values (tmp);
+            }
+
+            count = 0;
+            state = ~0UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "values",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for simpleSequence_pskel.
+  //
+  bool simpleSequence_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "description" && ns.empty ())
+          s = 0UL;
+        else if (n == "values" && ns.empty ())
+          s = 1UL;
+        else if (n == "units" && ns.empty ())
+          s = 2UL;
+        else if (n == "range" && ns.empty ())
+          s = 3UL;
+        else if (n == "kind" && ns.empty ())
+          s = 4UL;
+        else if (n == "action" && ns.empty ())
+          s = 5UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &simpleSequence_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool simpleSequence_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void simpleSequence_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void simpleSequence_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+
+    this->v_state_stack_.pop ();
+  }
+
+  void simpleSequence_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "description" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->description_parser_;
+
+            if (this->description_parser_)
+              this->description_parser_->pre ();
+          }
+          else
+          {
+            if (this->description_parser_)
+            {
+              const ::std::string& tmp (this->description_parser_->post_string ());
+              this->description (tmp);
+            }
+
+            count = 0;
+            state = 1UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 1UL;
+          // Fall through.
+        }
+      }
+      case 1UL:
+      {
+        if (n == "values" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->values_parser_;
+
+            if (this->values_parser_)
+              this->values_parser_->pre ();
+          }
+          else
+          {
+            if (this->values_parser_)
+            {
+              const ::std::vector<std::string>& tmp (this->values_parser_->post_values ());
+              this->values (tmp);
+            }
+
+            count = 0;
+            state = 2UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 2UL;
+          // Fall through.
+        }
+      }
+      case 2UL:
+      {
+        if (n == "units" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->units_parser_;
+
+            if (this->units_parser_)
+              this->units_parser_->pre ();
+          }
+          else
+          {
+            if (this->units_parser_)
+            {
+              const ::std::string& tmp (this->units_parser_->post_Unit ());
+              this->units (tmp);
+            }
+
+            count = 0;
+            state = 3UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 3UL;
+          // Fall through.
+        }
+      }
+      case 3UL:
+      {
+        if (n == "range" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->range_parser_;
+
+            if (this->range_parser_)
+              this->range_parser_->pre ();
+          }
+          else
+          {
+            if (this->range_parser_)
+            {
+              const ::std::pair<std::string, std::string>& tmp (this->range_parser_->post_range ());
+              this->range (tmp);
+            }
+
+            count = 0;
+            state = 4UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 4UL;
+          // Fall through.
+        }
+      }
+      case 4UL:
+      {
+        if (n == "kind" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->kind_parser_;
+
+            if (this->kind_parser_)
+              this->kind_parser_->pre ();
+          }
+          else
+          {
+            if (this->kind_parser_)
+            {
+              const ::std::string& tmp (this->kind_parser_->post_kind ());
+              this->kind (tmp);
+            }
+
+            count++;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 5UL;
+          // Fall through.
+        }
+      }
+      case 5UL:
+      {
+        if (n == "action" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->action_parser_;
+
+            if (this->action_parser_)
+              this->action_parser_->pre ();
+          }
+          else
+          {
+            if (this->action_parser_)
+            {
+              const ::std::string& tmp (this->action_parser_->post_action ());
+              this->action (tmp);
+            }
+
+            count = 0;
+            state = ~0UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for struct_pskel.
+  //
+  bool struct_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "description" && ns.empty ())
+          s = 0UL;
+        else if ((n == "simple" && ns.empty ()) ||
+                 (n == "simplesequence" && ns.empty ()))
+          s = 1UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &struct_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "description",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool struct_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void struct_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void struct_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "description");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void struct_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "description" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->description_parser_;
+
+            if (this->description_parser_)
+              this->description_parser_->pre ();
+          }
+          else
+          {
+            if (this->description_parser_)
+            {
+              const ::std::string& tmp (this->description_parser_->post_string ());
+              this->description (tmp);
+            }
+
+            count = 0;
+            state = 1UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 1UL;
+          // Fall through.
+        }
+      }
+      case 1UL:
+      {
+        unsigned long s (~0UL);
+
+        if (n == "simple" && ns.empty ())
+          s = 0UL;
+        else if (n == "simplesequence" && ns.empty ())
+          s = 1UL;
+
+        if (s != ~0UL)
+        {
+          assert (start);
+          count++;
+
+          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+          v_state_descr_& vd = vs.data[vs.size++];
+
+          vd.func = &struct_pskel::choice_0;
+          vd.state = s;
+          vd.count = 0;
+
+          this->choice_0 (vd.state, vd.count, ns, n, t, true);
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "simple",
+              ns, n);
+          count = 0;
+          state = 2UL;
+          // Fall through.
+        }
+      }
+      case 2UL:
+      {
+        if (n == "configurationkind" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->configurationkind_parser_;
+
+            if (this->configurationkind_parser_)
+              this->configurationkind_parser_->pre ();
+          }
+          else
+          {
+            if (this->configurationkind_parser_)
+            {
+              const ::std::string& tmp (this->configurationkind_parser_->post_configurationKind ());
+              this->configurationkind (tmp);
+            }
+
+            count++;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  void struct_pskel::
+  choice_0 (unsigned long& state,
+            unsigned long& count,
+            const ::xml_schema::ro_string& ns,
+            const ::xml_schema::ro_string& n,
+            const ::xml_schema::ro_string* t,
+            bool start)
+  {
+    XSD_UNUSED (count);
+    XSD_UNUSED (ns);
+    XSD_UNUSED (n);
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->simple_parser_;
+
+          if (this->simple_parser_)
+            this->simple_parser_->pre ();
+        }
+        else
+        {
+          if (this->simple_parser_)
+          {
+            ossie::SimpleProperty* tmp (this->simple_parser_->post_simple ());
+            this->simple (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 1UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->simplesequence_parser_;
+
+          if (this->simplesequence_parser_)
+            this->simplesequence_parser_->pre ();
+        }
+        else
+        {
+          if (this->simplesequence_parser_)
+          {
+            ossie::SimpleSequenceProperty* tmp (this->simplesequence_parser_->post_simpleSequence ());
+            this->simplesequence (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+    }
+  }
+
+  // Element validation and dispatch functions for structSequence_pskel.
+  //
+  bool structSequence_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "description" && ns.empty ())
+          s = 0UL;
+        else if (n == "struct" && ns.empty ())
+          s = 1UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &structSequence_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "description",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool structSequence_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void structSequence_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void structSequence_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "description");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void structSequence_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "description" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->description_parser_;
+
+            if (this->description_parser_)
+              this->description_parser_->pre ();
+          }
+          else
+          {
+            if (this->description_parser_)
+            {
+              const ::std::string& tmp (this->description_parser_->post_string ());
+              this->description (tmp);
+            }
+
+            count = 0;
+            state = 1UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 1UL;
+          // Fall through.
+        }
+      }
+      case 1UL:
+      {
+        if (n == "struct" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->struct__parser_;
+
+            if (this->struct__parser_)
+              this->struct__parser_->pre ();
+          }
+          else
+          {
+            if (this->struct__parser_)
+            {
+              ossie::StructProperty* tmp (this->struct__parser_->post_struct ());
+              this->struct_ (tmp);
+            }
+
+            count = 0;
+            state = 2UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "struct",
+              ns, n);
+          count = 0;
+          state = 2UL;
+          // Fall through.
+        }
+      }
+      case 2UL:
+      {
+        if (n == "structvalue" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->structvalue_parser_;
+
+            if (this->structvalue_parser_)
+              this->structvalue_parser_->pre ();
+          }
+          else
+          {
+            if (this->structvalue_parser_)
+            {
+              const ::std::map<std::string, ossie::ComponentProperty*>& tmp (this->structvalue_parser_->post_structValue ());
+              this->structvalue (tmp);
+            }
+
+            count++;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 3UL;
+          // Fall through.
+        }
+      }
+      case 3UL:
+      {
+        if (n == "configurationkind" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->configurationkind_parser_;
+
+            if (this->configurationkind_parser_)
+              this->configurationkind_parser_->pre ();
+          }
+          else
+          {
+            if (this->configurationkind_parser_)
+            {
+              const ::std::string& tmp (this->configurationkind_parser_->post_configurationKind ());
+              this->configurationkind (tmp);
+            }
+
+            count++;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for structValue_pskel.
+  //
+  bool structValue_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if ((n == "simpleref" && ns.empty ()) ||
+            (n == "simplesequenceref" && ns.empty ()))
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &structValue_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "simpleref",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool structValue_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void structValue_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void structValue_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "simpleref");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void structValue_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        unsigned long s (~0UL);
+
+        if (n == "simpleref" && ns.empty ())
+          s = 0UL;
+        else if (n == "simplesequenceref" && ns.empty ())
+          s = 1UL;
+
+        if (s != ~0UL)
+        {
+          assert (start);
+          count++;
+
+          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+          v_state_descr_& vd = vs.data[vs.size++];
+
+          vd.func = &structValue_pskel::choice_0;
+          vd.state = s;
+          vd.count = 0;
+
+          this->choice_0 (vd.state, vd.count, ns, n, t, true);
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "simpleref",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  void structValue_pskel::
+  choice_0 (unsigned long& state,
+            unsigned long& count,
+            const ::xml_schema::ro_string& ns,
+            const ::xml_schema::ro_string& n,
+            const ::xml_schema::ro_string* t,
+            bool start)
+  {
+    XSD_UNUSED (count);
+    XSD_UNUSED (ns);
+    XSD_UNUSED (n);
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->simpleref_parser_;
+
+          if (this->simpleref_parser_)
+            this->simpleref_parser_->pre ();
+        }
+        else
+        {
+          if (this->simpleref_parser_)
+          {
+            ossie::SimplePropertyRef* tmp (this->simpleref_parser_->post_simpleRef ());
+            this->simpleref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 1UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->simplesequenceref_parser_;
+
+          if (this->simplesequenceref_parser_)
+            this->simplesequenceref_parser_->pre ();
+        }
+        else
+        {
+          if (this->simplesequenceref_parser_)
+          {
+            ossie::SimpleSequencePropertyRef* tmp (this->simplesequenceref_parser_->post_simpleSequenceRef ());
+            this->simplesequenceref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+    }
+  }
+
+  // Element validation and dispatch functions for test_pskel.
+  //
+  bool test_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "description" && ns.empty ())
+          s = 0UL;
+        else if (n == "inputvalue" && ns.empty ())
+          s = 1UL;
+        else if (n == "resultvalue" && ns.empty ())
+          s = 2UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &test_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "description",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool test_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void test_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void test_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "description");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void test_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "description" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->description_parser_;
+
+            if (this->description_parser_)
+              this->description_parser_->pre ();
+          }
+          else
+          {
+            if (this->description_parser_)
+            {
+              const ::std::string& tmp (this->description_parser_->post_string ());
+              this->description (tmp);
+            }
+
+            count = 0;
+            state = 1UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 1UL;
+          // Fall through.
+        }
+      }
+      case 1UL:
+      {
+        if (n == "inputvalue" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->inputvalue_parser_;
+
+            if (this->inputvalue_parser_)
+              this->inputvalue_parser_->pre ();
+          }
+          else
+          {
+            if (this->inputvalue_parser_)
+            {
+              this->inputvalue_parser_->post_inputValue ();
+              this->inputvalue ();
+            }
+
+            count = 0;
+            state = 2UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 2UL;
+          // Fall through.
+        }
+      }
+      case 2UL:
+      {
+        if (n == "resultvalue" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->resultvalue_parser_;
+
+            if (this->resultvalue_parser_)
+              this->resultvalue_parser_->pre ();
+          }
+          else
+          {
+            if (this->resultvalue_parser_)
+            {
+              this->resultvalue_parser_->post_resultValue ();
+              this->resultvalue ();
+            }
+
+            count = 0;
+            state = ~0UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "resultvalue",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for values_pskel.
+  //
+  bool values_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "value" && ns.empty ())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &values_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "value",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool values_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void values_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void values_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "value");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void values_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "value" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->value_parser_;
+
+            if (this->value_parser_)
+              this->value_parser_->pre ();
+          }
+          else
+          {
+            if (this->value_parser_)
+            {
+              const ::std::string& tmp (this->value_parser_->post_string ());
+              this->value (tmp);
+            }
+
+            count++;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "value",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+}
+
+namespace prf
+{
+  // Attribute validation and dispatch functions for action_pskel.
+  //
+  bool action_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "type" && ns.empty ())
+    {
+      if (this->type_parser_)
+      {
+        this->type_parser_->pre ();
+        this->type_parser_->_pre_impl ();
+        this->type_parser_->_characters (s);
+        this->type_parser_->_post_impl ();
+        const ::std::string& tmp (this->type_parser_->post_ActionType ());
+        this->type (tmp);
+      }
+
+      return true;
+    }
+
+    return false;
+  }
+
+  // Attribute validation and dispatch functions for configurationKind_pskel.
+  //
+  bool configurationKind_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "kindtype" && ns.empty ())
+    {
+      if (this->kindtype_parser_)
+      {
+        this->kindtype_parser_->pre ();
+        this->kindtype_parser_->_pre_impl ();
+        this->kindtype_parser_->_characters (s);
+        this->kindtype_parser_->_post_impl ();
+        const ::std::string& tmp (this->kindtype_parser_->post_StructPropertyConfigurationType ());
+        this->kindtype (tmp);
+      }
+
+      return true;
+    }
+
+    return false;
+  }
+
+  // Attribute validation and dispatch functions for enumeration_pskel.
+  //
+  bool enumeration_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "label" && ns.empty ())
+    {
+      if (this->label_parser_)
+      {
+        this->label_parser_->pre ();
+        this->label_parser_->_pre_impl ();
+        this->label_parser_->_characters (s);
+        this->label_parser_->_post_impl ();
+        const ::std::string& tmp (this->label_parser_->post_string ());
+        this->label (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->label = true;
+      return true;
+    }
+
+    if (n == "value" && ns.empty ())
+    {
+      if (this->value_parser_)
+      {
+        this->value_parser_->pre ();
+        this->value_parser_->_pre_impl ();
+        this->value_parser_->_characters (s);
+        this->value_parser_->_post_impl ();
+        const ::std::string& tmp (this->value_parser_->post_string ());
+        this->value (tmp);
+      }
+
+      return true;
+    }
+
+    return false;
+  }
+
+  void enumeration_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.label = false;
+  }
+
+  void enumeration_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.label)
+      this->_expected_attribute (
+        "", "label");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for kind_pskel.
+  //
+  bool kind_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "kindtype" && ns.empty ())
+    {
+      if (this->kindtype_parser_)
+      {
+        this->kindtype_parser_->pre ();
+        this->kindtype_parser_->_pre_impl ();
+        this->kindtype_parser_->_characters (s);
+        this->kindtype_parser_->_post_impl ();
+        const ::std::string& tmp (this->kindtype_parser_->post_PropertyConfigurationType ());
+        this->kindtype (tmp);
+      }
+
+      return true;
+    }
+
+    return false;
+  }
+
+  // Attribute validation and dispatch functions for range_pskel.
+  //
+  bool range_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "max" && ns.empty ())
+    {
+      if (this->max_parser_)
+      {
+        this->max_parser_->pre ();
+        this->max_parser_->_pre_impl ();
+        this->max_parser_->_characters (s);
+        this->max_parser_->_post_impl ();
+        const ::std::string& tmp (this->max_parser_->post_string ());
+        this->max (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->max = true;
+      return true;
+    }
+
+    if (n == "min" && ns.empty ())
+    {
+      if (this->min_parser_)
+      {
+        this->min_parser_->pre ();
+        this->min_parser_->_pre_impl ();
+        this->min_parser_->_characters (s);
+        this->min_parser_->_post_impl ();
+        const ::std::string& tmp (this->min_parser_->post_string ());
+        this->min (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->min = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void range_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.max = false;
+    as.min = false;
+  }
+
+  void range_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.max)
+      this->_expected_attribute (
+        "", "max");
+    if (!as.min)
+      this->_expected_attribute (
+        "", "min");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for simple_pskel.
+  //
+  bool simple_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "id" && ns.empty ())
+    {
+      if (this->id_parser_)
+      {
+        this->id_parser_->pre ();
+        this->id_parser_->_pre_impl ();
+        this->id_parser_->_characters (s);
+        this->id_parser_->_post_impl ();
+        const ::std::string& tmp (this->id_parser_->post_string ());
+        this->id (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->id = true;
+      return true;
+    }
+
+    if (n == "mode" && ns.empty ())
+    {
+      if (this->mode_parser_)
+      {
+        this->mode_parser_->pre ();
+        this->mode_parser_->_pre_impl ();
+        this->mode_parser_->_characters (s);
+        this->mode_parser_->_post_impl ();
+        const ::std::string& tmp (this->mode_parser_->post_AccessType ());
+        this->mode (tmp);
+      }
+
+      return true;
+    }
+
+    if (n == "name" && ns.empty ())
+    {
+      if (this->name_parser_)
+      {
+        this->name_parser_->pre ();
+        this->name_parser_->_pre_impl ();
+        this->name_parser_->_characters (s);
+        this->name_parser_->_post_impl ();
+        const ::std::string& tmp (this->name_parser_->post_string ());
+        this->name (tmp);
+      }
+
+      return true;
+    }
+
+    if (n == "complex" && ns.empty ())
+    {
+      if (this->complex_parser_)
+      {
+        this->complex_parser_->pre ();
+        this->complex_parser_->_pre_impl ();
+        this->complex_parser_->_characters (s);
+        this->complex_parser_->_post_impl ();
+        const ::std::string& tmp (this->complex_parser_->post_IsComplex ());
+        this->complex (tmp);
+      }
+
+      return true;
+    }
+
+    if (n == "commandline" && ns.empty ())
+    {
+      if (this->commandline_parser_)
+      {
+        this->commandline_parser_->pre ();
+        this->commandline_parser_->_pre_impl ();
+        this->commandline_parser_->_characters (s);
+        this->commandline_parser_->_post_impl ();
+        const ::std::string& tmp (this->commandline_parser_->post_IsCommandLine ());
+        this->commandline (tmp);
+      }
+
+      return true;
+    }
+
+    if (n == "optional" && ns.empty ())
+    {
+      if (this->optional_parser_)
+      {
+        this->optional_parser_->pre ();
+        this->optional_parser_->_pre_impl ();
+        this->optional_parser_->_characters (s);
+        this->optional_parser_->_post_impl ();
+        const ::std::string& tmp (this->optional_parser_->post_IsOptional ());
+        this->optional (tmp);
+      }
+
+      return true;
+    }
+
+    if (n == "type" && ns.empty ())
+    {
+      if (this->type_parser_)
+      {
+        this->type_parser_->pre ();
+        this->type_parser_->_pre_impl ();
+        this->type_parser_->_characters (s);
+        this->type_parser_->_post_impl ();
+        const ::std::string& tmp (this->type_parser_->post_PropertyValueType ());
+        this->type (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->type = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void simple_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.id = false;
+    as.type = false;
+  }
+
+  void simple_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.id)
+      this->_expected_attribute (
+        "", "id");
+    if (!as.type)
+      this->_expected_attribute (
+        "", "type");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for simpleRef_pskel.
+  //
+  bool simpleRef_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "refid" && ns.empty ())
+    {
+      if (this->refid_parser_)
+      {
+        this->refid_parser_->pre ();
+        this->refid_parser_->_pre_impl ();
+        this->refid_parser_->_characters (s);
+        this->refid_parser_->_post_impl ();
+        const ::std::string& tmp (this->refid_parser_->post_string ());
+        this->refid (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->refid = true;
+      return true;
+    }
+
+    if (n == "value" && ns.empty ())
+    {
+      if (this->value_parser_)
+      {
+        this->value_parser_->pre ();
+        this->value_parser_->_pre_impl ();
+        this->value_parser_->_characters (s);
+        this->value_parser_->_post_impl ();
+        const ::std::string& tmp (this->value_parser_->post_string ());
+        this->value (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->value = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void simpleRef_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.refid = false;
+    as.value = false;
+  }
+
+  void simpleRef_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.refid)
+      this->_expected_attribute (
+        "", "refid");
+    if (!as.value)
+      this->_expected_attribute (
+        "", "value");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for simpleSequenceRef_pskel.
+  //
+  bool simpleSequenceRef_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "refid" && ns.empty ())
+    {
+      if (this->refid_parser_)
+      {
+        this->refid_parser_->pre ();
+        this->refid_parser_->_pre_impl ();
+        this->refid_parser_->_characters (s);
+        this->refid_parser_->_post_impl ();
+        const ::std::string& tmp (this->refid_parser_->post_string ());
+        this->refid (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->refid = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void simpleSequenceRef_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.refid = false;
+  }
+
+  void simpleSequenceRef_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.refid)
+      this->_expected_attribute (
+        "", "refid");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for simpleSequence_pskel.
+  //
+  bool simpleSequence_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "id" && ns.empty ())
+    {
+      if (this->id_parser_)
+      {
+        this->id_parser_->pre ();
+        this->id_parser_->_pre_impl ();
+        this->id_parser_->_characters (s);
+        this->id_parser_->_post_impl ();
+        const ::std::string& tmp (this->id_parser_->post_string ());
+        this->id (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->id = true;
+      return true;
+    }
+
+    if (n == "mode" && ns.empty ())
+    {
+      if (this->mode_parser_)
+      {
+        this->mode_parser_->pre ();
+        this->mode_parser_->_pre_impl ();
+        this->mode_parser_->_characters (s);
+        this->mode_parser_->_post_impl ();
+        const ::std::string& tmp (this->mode_parser_->post_AccessType ());
+        this->mode (tmp);
+      }
+
+      return true;
+    }
+
+    if (n == "name" && ns.empty ())
+    {
+      if (this->name_parser_)
+      {
+        this->name_parser_->pre ();
+        this->name_parser_->_pre_impl ();
+        this->name_parser_->_characters (s);
+        this->name_parser_->_post_impl ();
+        const ::std::string& tmp (this->name_parser_->post_string ());
+        this->name (tmp);
+      }
+
+      return true;
+    }
+
+    if (n == "type" && ns.empty ())
+    {
+      if (this->type_parser_)
+      {
+        this->type_parser_->pre ();
+        this->type_parser_->_pre_impl ();
+        this->type_parser_->_characters (s);
+        this->type_parser_->_post_impl ();
+        const ::std::string& tmp (this->type_parser_->post_PropertyValueType ());
+        this->type (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->type = true;
+      return true;
+    }
+
+    if (n == "complex" && ns.empty ())
+    {
+      if (this->complex_parser_)
+      {
+        this->complex_parser_->pre ();
+        this->complex_parser_->_pre_impl ();
+        this->complex_parser_->_characters (s);
+        this->complex_parser_->_post_impl ();
+        const ::std::string& tmp (this->complex_parser_->post_IsComplex ());
+        this->complex (tmp);
+      }
+
+      return true;
+    }
+
+    if (n == "optional" && ns.empty ())
+    {
+      if (this->optional_parser_)
+      {
+        this->optional_parser_->pre ();
+        this->optional_parser_->_pre_impl ();
+        this->optional_parser_->_characters (s);
+        this->optional_parser_->_post_impl ();
+        const ::std::string& tmp (this->optional_parser_->post_IsOptional ());
+        this->optional (tmp);
+      }
+
+      return true;
+    }
+
+    return false;
+  }
+
+  void simpleSequence_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.id = false;
+    as.type = false;
+  }
+
+  void simpleSequence_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.id)
+      this->_expected_attribute (
+        "", "id");
+    if (!as.type)
+      this->_expected_attribute (
+        "", "type");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for struct_pskel.
+  //
+  bool struct_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "id" && ns.empty ())
+    {
+      if (this->id_parser_)
+      {
+        this->id_parser_->pre ();
+        this->id_parser_->_pre_impl ();
+        this->id_parser_->_characters (s);
+        this->id_parser_->_post_impl ();
+        const ::std::string& tmp (this->id_parser_->post_string ());
+        this->id (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->id = true;
+      return true;
+    }
+
+    if (n == "mode" && ns.empty ())
+    {
+      if (this->mode_parser_)
+      {
+        this->mode_parser_->pre ();
+        this->mode_parser_->_pre_impl ();
+        this->mode_parser_->_characters (s);
+        this->mode_parser_->_post_impl ();
+        const ::std::string& tmp (this->mode_parser_->post_AccessType ());
+        this->mode (tmp);
+      }
+
+      return true;
+    }
+
+    if (n == "name" && ns.empty ())
+    {
+      if (this->name_parser_)
+      {
+        this->name_parser_->pre ();
+        this->name_parser_->_pre_impl ();
+        this->name_parser_->_characters (s);
+        this->name_parser_->_post_impl ();
+        const ::std::string& tmp (this->name_parser_->post_string ());
+        this->name (tmp);
+      }
+
+      return true;
+    }
+
+    return false;
+  }
+
+  void struct_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.id = false;
+  }
+
+  void struct_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.id)
+      this->_expected_attribute (
+        "", "id");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for structSequence_pskel.
+  //
+  bool structSequence_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "id" && ns.empty ())
+    {
+      if (this->id_parser_)
+      {
+        this->id_parser_->pre ();
+        this->id_parser_->_pre_impl ();
+        this->id_parser_->_characters (s);
+        this->id_parser_->_post_impl ();
+        const ::std::string& tmp (this->id_parser_->post_string ());
+        this->id (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->id = true;
+      return true;
+    }
+
+    if (n == "mode" && ns.empty ())
+    {
+      if (this->mode_parser_)
+      {
+        this->mode_parser_->pre ();
+        this->mode_parser_->_pre_impl ();
+        this->mode_parser_->_characters (s);
+        this->mode_parser_->_post_impl ();
+        const ::std::string& tmp (this->mode_parser_->post_AccessType ());
+        this->mode (tmp);
+      }
+
+      return true;
+    }
+
+    if (n == "name" && ns.empty ())
+    {
+      if (this->name_parser_)
+      {
+        this->name_parser_->pre ();
+        this->name_parser_->_pre_impl ();
+        this->name_parser_->_characters (s);
+        this->name_parser_->_post_impl ();
+        const ::std::string& tmp (this->name_parser_->post_string ());
+        this->name (tmp);
+      }
+
+      return true;
+    }
+
+    return false;
+  }
+
+  void structSequence_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.id = false;
+  }
+
+  void structSequence_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.id)
+      this->_expected_attribute (
+        "", "id");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for test_pskel.
+  //
+  bool test_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "id" && ns.empty ())
+    {
+      if (this->id_parser_)
+      {
+        this->id_parser_->pre ();
+        this->id_parser_->_pre_impl ();
+        this->id_parser_->_characters (s);
+        this->id_parser_->_post_impl ();
+        const ::std::string& tmp (this->id_parser_->post_string ());
+        this->id (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->id = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void test_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.id = false;
+  }
+
+  void test_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.id)
+      this->_expected_attribute (
+        "", "id");
+
+    this->v_state_attr_stack_.pop ();
+  }
+}
+
+namespace prf
+{
+}
+
+// Begin epilogue.
+//
+//
+// End epilogue.
+
diff --git src/control/parser/internal/prf-pskel.h src/control/parser/internal/prf-pskel.h
new file mode 100644
index 0000000..b432d83
--- /dev/null
+++ src/control/parser/internal/prf-pskel.h
@@ -0,0 +1,2182 @@
+// Copyright (C) 2005-2010 Code Synthesis Tools CC
+//
+// This program was generated by CodeSynthesis XSD, an XML Schema to
+// C++ data binding compiler.
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 2 as
+// published by the Free Software Foundation.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+//
+// In addition, as a special exception, Code Synthesis Tools CC gives
+// permission to link this program with the Xerces-C++ library (or with
+// modified versions of Xerces-C++ that use the same license as Xerces-C++),
+// and distribute linked combinations including the two. You must obey
+// the GNU General Public License version 2 in all respects for all of
+// the code used other than Xerces-C++. If you modify this copy of the
+// program, you may extend this exception to your version of the program,
+// but you are not obligated to do so. If you do not wish to do so, delete
+// this exception statement from your version.
+//
+// Furthermore, Code Synthesis Tools CC makes a special exception for
+// the Free/Libre and Open Source Software (FLOSS) which is described
+// in the accompanying FLOSSE file.
+//
+
+#ifndef CXX______XML_XSD_PRF_PSKEL_H
+#define CXX______XML_XSD_PRF_PSKEL_H
+
+// Begin prologue.
+//
+//
+// End prologue.
+
+#include <xsd/cxx/config.hxx>
+
+#if (XSD_INT_VERSION != 3030000L)
+#error XSD runtime version mismatch
+#endif
+
+#include <xsd/cxx/pre.hxx>
+
+// Forward declarations
+//
+namespace prf
+{
+  class Unit_pskel;
+  class IsComplex_pskel;
+  class IsCommandLine_pskel;
+  class IsOptional_pskel;
+  class AccessType_pskel;
+  class action_pskel;
+  class ActionType_pskel;
+  class configurationKind_pskel;
+  class enumeration_pskel;
+  class enumerations_pskel;
+  class inputValue_pskel;
+  class kind_pskel;
+  class PropertyConfigurationType_pskel;
+  class StructPropertyConfigurationType_pskel;
+  class properties_pskel;
+  class PropertyValueType_pskel;
+  class range_pskel;
+  class resultValue_pskel;
+  class simple_pskel;
+  class simpleRef_pskel;
+  class simpleSequenceRef_pskel;
+  class simpleSequence_pskel;
+  class struct_pskel;
+  class structSequence_pskel;
+  class structValue_pskel;
+  class test_pskel;
+  class values_pskel;
+}
+
+
+#ifndef XSD_USE_CHAR
+#define XSD_USE_CHAR
+#endif
+
+#ifndef XSD_CXX_PARSER_USE_CHAR
+#define XSD_CXX_PARSER_USE_CHAR
+#endif
+
+#include <xsd/cxx/xml/error-handler.hxx>
+#include <xsd/cxx/parser/exceptions.hxx>
+#include <xsd/cxx/parser/elements.hxx>
+#include <xsd/cxx/parser/xml-schema.hxx>
+#include <xsd/cxx/parser/validating/parser.hxx>
+#include <xsd/cxx/parser/validating/exceptions.hxx>
+#include <xsd/cxx/parser/validating/xml-schema-pskel.hxx>
+#include <xsd/cxx/parser/validating/xml-schema-pimpl.hxx>
+#include <xsd/cxx/parser/expat/elements.hxx>
+
+#include "vector"
+#include "utility"
+#include "map"
+#include "../../include/ossie/componentProfile.h"
+#include "../../include/ossie/Properties.h"
+
+namespace xml_schema
+{
+  // Built-in XML Schema types mapping.
+  //
+  typedef ::xsd::cxx::parser::string_sequence< char > string_sequence;
+  typedef ::xsd::cxx::parser::qname< char > qname;
+  typedef ::xsd::cxx::parser::buffer buffer;
+  typedef ::xsd::cxx::parser::time_zone time_zone;
+  typedef ::xsd::cxx::parser::gday gday;
+  typedef ::xsd::cxx::parser::gmonth gmonth;
+  typedef ::xsd::cxx::parser::gyear gyear;
+  typedef ::xsd::cxx::parser::gmonth_day gmonth_day;
+  typedef ::xsd::cxx::parser::gyear_month gyear_month;
+  typedef ::xsd::cxx::parser::date date;
+  typedef ::xsd::cxx::parser::time time;
+  typedef ::xsd::cxx::parser::date_time date_time;
+  typedef ::xsd::cxx::parser::duration duration;
+
+  // Base parser skeletons.
+  //
+  typedef ::xsd::cxx::parser::parser_base< char > parser_base;
+  typedef ::xsd::cxx::parser::validating::empty_content< char > empty_content;
+  typedef ::xsd::cxx::parser::validating::simple_content< char > simple_content;
+  typedef ::xsd::cxx::parser::validating::complex_content< char > complex_content;
+  typedef ::xsd::cxx::parser::validating::list_base< char > list_base;
+
+  // Parser skeletons and implementations for the XML Schema
+  // built-in types.
+  //
+  typedef ::xsd::cxx::parser::validating::any_type_pskel< char > any_type_pskel;
+  typedef ::xsd::cxx::parser::validating::any_type_pimpl< char > any_type_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::any_simple_type_pskel< char > any_simple_type_pskel;
+  typedef ::xsd::cxx::parser::validating::any_simple_type_pimpl< char > any_simple_type_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::byte_pskel< char > byte_pskel;
+  typedef ::xsd::cxx::parser::validating::byte_pimpl< char > byte_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::unsigned_byte_pskel< char > unsigned_byte_pskel;
+  typedef ::xsd::cxx::parser::validating::unsigned_byte_pimpl< char > unsigned_byte_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::short_pskel< char > short_pskel;
+  typedef ::xsd::cxx::parser::validating::short_pimpl< char > short_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::unsigned_short_pskel< char > unsigned_short_pskel;
+  typedef ::xsd::cxx::parser::validating::unsigned_short_pimpl< char > unsigned_short_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::int_pskel< char > int_pskel;
+  typedef ::xsd::cxx::parser::validating::int_pimpl< char > int_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::unsigned_int_pskel< char > unsigned_int_pskel;
+  typedef ::xsd::cxx::parser::validating::unsigned_int_pimpl< char > unsigned_int_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::long_pskel< char > long_pskel;
+  typedef ::xsd::cxx::parser::validating::long_pimpl< char > long_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::unsigned_long_pskel< char > unsigned_long_pskel;
+  typedef ::xsd::cxx::parser::validating::unsigned_long_pimpl< char > unsigned_long_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::integer_pskel< char > integer_pskel;
+  typedef ::xsd::cxx::parser::validating::integer_pimpl< char > integer_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::non_positive_integer_pskel< char > non_positive_integer_pskel;
+  typedef ::xsd::cxx::parser::validating::non_positive_integer_pimpl< char > non_positive_integer_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::non_negative_integer_pskel< char > non_negative_integer_pskel;
+  typedef ::xsd::cxx::parser::validating::non_negative_integer_pimpl< char > non_negative_integer_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::positive_integer_pskel< char > positive_integer_pskel;
+  typedef ::xsd::cxx::parser::validating::positive_integer_pimpl< char > positive_integer_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::negative_integer_pskel< char > negative_integer_pskel;
+  typedef ::xsd::cxx::parser::validating::negative_integer_pimpl< char > negative_integer_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::boolean_pskel< char > boolean_pskel;
+  typedef ::xsd::cxx::parser::validating::boolean_pimpl< char > boolean_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::float_pskel< char > float_pskel;
+  typedef ::xsd::cxx::parser::validating::float_pimpl< char > float_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::double_pskel< char > double_pskel;
+  typedef ::xsd::cxx::parser::validating::double_pimpl< char > double_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::decimal_pskel< char > decimal_pskel;
+  typedef ::xsd::cxx::parser::validating::decimal_pimpl< char > decimal_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::string_pskel< char > string_pskel;
+  typedef ::xsd::cxx::parser::validating::string_pimpl< char > string_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::normalized_string_pskel< char > normalized_string_pskel;
+  typedef ::xsd::cxx::parser::validating::normalized_string_pimpl< char > normalized_string_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::token_pskel< char > token_pskel;
+  typedef ::xsd::cxx::parser::validating::token_pimpl< char > token_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::name_pskel< char > name_pskel;
+  typedef ::xsd::cxx::parser::validating::name_pimpl< char > name_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::nmtoken_pskel< char > nmtoken_pskel;
+  typedef ::xsd::cxx::parser::validating::nmtoken_pimpl< char > nmtoken_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::nmtokens_pskel< char > nmtokens_pskel;
+  typedef ::xsd::cxx::parser::validating::nmtokens_pimpl< char > nmtokens_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::ncname_pskel< char > ncname_pskel;
+  typedef ::xsd::cxx::parser::validating::ncname_pimpl< char > ncname_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::language_pskel< char > language_pskel;
+  typedef ::xsd::cxx::parser::validating::language_pimpl< char > language_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::id_pskel< char > id_pskel;
+  typedef ::xsd::cxx::parser::validating::id_pimpl< char > id_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::idref_pskel< char > idref_pskel;
+  typedef ::xsd::cxx::parser::validating::idref_pimpl< char > idref_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::idrefs_pskel< char > idrefs_pskel;
+  typedef ::xsd::cxx::parser::validating::idrefs_pimpl< char > idrefs_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::uri_pskel< char > uri_pskel;
+  typedef ::xsd::cxx::parser::validating::uri_pimpl< char > uri_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::qname_pskel< char > qname_pskel;
+  typedef ::xsd::cxx::parser::validating::qname_pimpl< char > qname_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::base64_binary_pskel< char > base64_binary_pskel;
+  typedef ::xsd::cxx::parser::validating::base64_binary_pimpl< char > base64_binary_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::hex_binary_pskel< char > hex_binary_pskel;
+  typedef ::xsd::cxx::parser::validating::hex_binary_pimpl< char > hex_binary_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::date_pskel< char > date_pskel;
+  typedef ::xsd::cxx::parser::validating::date_pimpl< char > date_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::date_time_pskel< char > date_time_pskel;
+  typedef ::xsd::cxx::parser::validating::date_time_pimpl< char > date_time_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::duration_pskel< char > duration_pskel;
+  typedef ::xsd::cxx::parser::validating::duration_pimpl< char > duration_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::gday_pskel< char > gday_pskel;
+  typedef ::xsd::cxx::parser::validating::gday_pimpl< char > gday_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::gmonth_pskel< char > gmonth_pskel;
+  typedef ::xsd::cxx::parser::validating::gmonth_pimpl< char > gmonth_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::gmonth_day_pskel< char > gmonth_day_pskel;
+  typedef ::xsd::cxx::parser::validating::gmonth_day_pimpl< char > gmonth_day_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::gyear_pskel< char > gyear_pskel;
+  typedef ::xsd::cxx::parser::validating::gyear_pimpl< char > gyear_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::gyear_month_pskel< char > gyear_month_pskel;
+  typedef ::xsd::cxx::parser::validating::gyear_month_pimpl< char > gyear_month_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::time_pskel< char > time_pskel;
+  typedef ::xsd::cxx::parser::validating::time_pimpl< char > time_pimpl;
+
+  // Exceptions. See libxsd/xsd/cxx/parser/exceptions.hxx for details.
+  //
+  typedef ::xsd::cxx::parser::exception< char > exception;
+
+  // Parsing diagnostics.
+  //
+  typedef ::xsd::cxx::parser::severity severity;
+  typedef ::xsd::cxx::parser::error< char > error;
+  typedef ::xsd::cxx::parser::diagnostics< char > diagnostics;
+  typedef ::xsd::cxx::parser::parsing< char > parsing;
+
+  // Error handler. See libxsd/xsd/cxx/xml/error-handler.hxx for details.
+  //
+  typedef ::xsd::cxx::xml::error_handler< char > error_handler;
+
+  // Read-only string.
+  //
+  typedef ::xsd::cxx::ro_string< char > ro_string;
+
+  // Document type. See libxsd/xsd/cxx/parser/expat/elements.hxx
+  // for details.
+  //
+  typedef ::xsd::cxx::parser::expat::document< char > document;
+}
+
+namespace prf
+{
+  class Unit_pskel: public virtual ::xml_schema::string_pskel
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual ::std::string
+    post_Unit ();
+  };
+
+  class IsComplex_pskel: public virtual ::xml_schema::string_pskel
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual ::std::string
+    post_IsComplex ();
+  };
+
+  class IsCommandLine_pskel: public virtual ::xml_schema::string_pskel
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual ::std::string
+    post_IsCommandLine ();
+  };
+
+  class IsOptional_pskel: public virtual ::xml_schema::string_pskel
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual ::std::string
+    post_IsOptional ();
+  };
+
+  class AccessType_pskel: public virtual ::xml_schema::string_pskel
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual ::std::string
+    post_AccessType ();
+  };
+
+  class action_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    type (const ::std::string&);
+
+    virtual ::std::string
+    post_action () = 0;
+
+    // Parser construction API.
+    //
+    void
+    type_parser (::prf::ActionType_pskel&);
+
+    void
+    parsers (::prf::ActionType_pskel& /* type */);
+
+    // Constructor.
+    //
+    action_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::prf::ActionType_pskel* type_parser_;
+  };
+
+  class ActionType_pskel: public virtual ::xml_schema::string_pskel
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual ::std::string
+    post_ActionType ();
+  };
+
+  class configurationKind_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    kindtype (const ::std::string&);
+
+    virtual ::std::string
+    post_configurationKind () = 0;
+
+    // Parser construction API.
+    //
+    void
+    kindtype_parser (::prf::StructPropertyConfigurationType_pskel&);
+
+    void
+    parsers (::prf::StructPropertyConfigurationType_pskel& /* kindtype */);
+
+    // Constructor.
+    //
+    configurationKind_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::prf::StructPropertyConfigurationType_pskel* kindtype_parser_;
+  };
+
+  class enumeration_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    label (const ::std::string&);
+
+    virtual void
+    value (const ::std::string&);
+
+    virtual ::std::map<std::string, std::string>::value_type
+    post_enumeration () = 0;
+
+    // Parser construction API.
+    //
+    void
+    label_parser (::xml_schema::string_pskel&);
+
+    void
+    value_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* label */,
+             ::xml_schema::string_pskel& /* value */);
+
+    // Constructor.
+    //
+    enumeration_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* label_parser_;
+    ::xml_schema::string_pskel* value_parser_;
+
+    protected:
+    struct v_state_attr_
+    {
+      bool label;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class enumerations_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    enumeration (const ::std::map<std::string, std::string>::value_type&);
+
+    virtual ::std::map<std::string, std::string>
+    post_enumerations () = 0;
+
+    // Parser construction API.
+    //
+    void
+    enumeration_parser (::prf::enumeration_pskel&);
+
+    void
+    parsers (::prf::enumeration_pskel& /* enumeration */);
+
+    // Constructor.
+    //
+    enumerations_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::prf::enumeration_pskel* enumeration_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::prf::enumerations_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+  };
+
+  class inputValue_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    simple (ossie::SimpleProperty*);
+
+    virtual void
+    post_inputValue ();
+
+    // Parser construction API.
+    //
+    void
+    simple_parser (::prf::simple_pskel&);
+
+    void
+    parsers (::prf::simple_pskel& /* simple */);
+
+    // Constructor.
+    //
+    inputValue_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::prf::simple_pskel* simple_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::prf::inputValue_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+  };
+
+  class kind_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    kindtype (const ::std::string&);
+
+    virtual ::std::string
+    post_kind () = 0;
+
+    // Parser construction API.
+    //
+    void
+    kindtype_parser (::prf::PropertyConfigurationType_pskel&);
+
+    void
+    parsers (::prf::PropertyConfigurationType_pskel& /* kindtype */);
+
+    // Constructor.
+    //
+    kind_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::prf::PropertyConfigurationType_pskel* kindtype_parser_;
+  };
+
+  class PropertyConfigurationType_pskel: public virtual ::xml_schema::string_pskel
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual ::std::string
+    post_PropertyConfigurationType ();
+  };
+
+  class StructPropertyConfigurationType_pskel: public virtual ::prf::PropertyConfigurationType_pskel
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual ::std::string
+    post_StructPropertyConfigurationType ();
+  };
+
+  class properties_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    description (const ::std::string&);
+
+    virtual void
+    simple (ossie::SimpleProperty*);
+
+    virtual void
+    simplesequence (ossie::SimpleSequenceProperty*);
+
+    virtual void
+    test ();
+
+    virtual void
+    struct_ (ossie::StructProperty*);
+
+    virtual void
+    structsequence (ossie::StructSequenceProperty*);
+
+    virtual std::auto_ptr<ossie::PRF>
+    post_properties () = 0;
+
+    // Parser construction API.
+    //
+    void
+    description_parser (::xml_schema::string_pskel&);
+
+    void
+    simple_parser (::prf::simple_pskel&);
+
+    void
+    simplesequence_parser (::prf::simpleSequence_pskel&);
+
+    void
+    test_parser (::prf::test_pskel&);
+
+    void
+    struct_parser (::prf::struct_pskel&);
+
+    void
+    structsequence_parser (::prf::structSequence_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* description */,
+             ::prf::simple_pskel& /* simple */,
+             ::prf::simpleSequence_pskel& /* simplesequence */,
+             ::prf::test_pskel& /* test */,
+             ::prf::struct_pskel& /* struct */,
+             ::prf::structSequence_pskel& /* structsequence */);
+
+    // Constructor.
+    //
+    properties_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::xml_schema::string_pskel* description_parser_;
+    ::prf::simple_pskel* simple_parser_;
+    ::prf::simpleSequence_pskel* simplesequence_parser_;
+    ::prf::test_pskel* test_parser_;
+    ::prf::struct_pskel* struct__parser_;
+    ::prf::structSequence_pskel* structsequence_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::prf::properties_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[3UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+
+    void
+    choice_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start);
+  };
+
+  class PropertyValueType_pskel: public virtual ::xml_schema::string_pskel
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual ::std::string
+    post_PropertyValueType ();
+  };
+
+  class range_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    max (const ::std::string&);
+
+    virtual void
+    min (const ::std::string&);
+
+    virtual ::std::pair<std::string, std::string>
+    post_range () = 0;
+
+    // Parser construction API.
+    //
+    void
+    max_parser (::xml_schema::string_pskel&);
+
+    void
+    min_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* max */,
+             ::xml_schema::string_pskel& /* min */);
+
+    // Constructor.
+    //
+    range_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* max_parser_;
+    ::xml_schema::string_pskel* min_parser_;
+
+    protected:
+    struct v_state_attr_
+    {
+      bool max;
+      bool min;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class resultValue_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    simple (ossie::SimpleProperty*);
+
+    virtual void
+    post_resultValue ();
+
+    // Parser construction API.
+    //
+    void
+    simple_parser (::prf::simple_pskel&);
+
+    void
+    parsers (::prf::simple_pskel& /* simple */);
+
+    // Constructor.
+    //
+    resultValue_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::prf::simple_pskel* simple_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::prf::resultValue_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+  };
+
+  class simple_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    description (const ::std::string&);
+
+    virtual void
+    value (const ::std::string&);
+
+    virtual void
+    units (const ::std::string&);
+
+    virtual void
+    range (const ::std::pair<std::string, std::string>&);
+
+    virtual void
+    enumerations (const ::std::map<std::string, std::string>&);
+
+    virtual void
+    kind (const ::std::string&);
+
+    virtual void
+    action (const ::std::string&);
+
+    virtual void
+    id (const ::std::string&);
+
+    virtual void
+    mode (const ::std::string&);
+
+    virtual void
+    name (const ::std::string&);
+
+    virtual void
+    complex (const ::std::string&);
+
+    virtual void
+    commandline (const ::std::string&);
+
+    virtual void
+    optional (const ::std::string&);
+
+    virtual void
+    type (const ::std::string&);
+
+    virtual ossie::SimpleProperty*
+    post_simple () = 0;
+
+    // Parser construction API.
+    //
+    void
+    description_parser (::xml_schema::string_pskel&);
+
+    void
+    value_parser (::xml_schema::string_pskel&);
+
+    void
+    units_parser (::prf::Unit_pskel&);
+
+    void
+    range_parser (::prf::range_pskel&);
+
+    void
+    enumerations_parser (::prf::enumerations_pskel&);
+
+    void
+    kind_parser (::prf::kind_pskel&);
+
+    void
+    action_parser (::prf::action_pskel&);
+
+    void
+    id_parser (::xml_schema::string_pskel&);
+
+    void
+    mode_parser (::prf::AccessType_pskel&);
+
+    void
+    name_parser (::xml_schema::string_pskel&);
+
+    void
+    complex_parser (::prf::IsComplex_pskel&);
+
+    void
+    commandline_parser (::prf::IsCommandLine_pskel&);
+
+    void
+    optional_parser (::prf::IsOptional_pskel&);
+
+    void
+    type_parser (::prf::PropertyValueType_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* description */,
+             ::xml_schema::string_pskel& /* value */,
+             ::prf::Unit_pskel& /* units */,
+             ::prf::range_pskel& /* range */,
+             ::prf::enumerations_pskel& /* enumerations */,
+             ::prf::kind_pskel& /* kind */,
+             ::prf::action_pskel& /* action */,
+             ::xml_schema::string_pskel& /* id */,
+             ::prf::AccessType_pskel& /* mode */,
+             ::xml_schema::string_pskel& /* name */,
+             ::prf::IsComplex_pskel& /* complex */,
+             ::prf::IsCommandLine_pskel& /* commandline */,
+             ::prf::IsOptional_pskel& /* optional */,
+             ::prf::PropertyValueType_pskel& /* type */);
+
+    // Constructor.
+    //
+    simple_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* description_parser_;
+    ::xml_schema::string_pskel* value_parser_;
+    ::prf::Unit_pskel* units_parser_;
+    ::prf::range_pskel* range_parser_;
+    ::prf::enumerations_pskel* enumerations_parser_;
+    ::prf::kind_pskel* kind_parser_;
+    ::prf::action_pskel* action_parser_;
+    ::xml_schema::string_pskel* id_parser_;
+    ::prf::AccessType_pskel* mode_parser_;
+    ::xml_schema::string_pskel* name_parser_;
+    ::prf::IsComplex_pskel* complex_parser_;
+    ::prf::IsCommandLine_pskel* commandline_parser_;
+    ::prf::IsOptional_pskel* optional_parser_;
+    ::prf::PropertyValueType_pskel* type_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::prf::simple_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+
+    protected:
+    struct v_state_attr_
+    {
+      bool id;
+      bool type;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class simpleRef_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    refid (const ::std::string&);
+
+    virtual void
+    value (const ::std::string&);
+
+    virtual ossie::SimplePropertyRef*
+    post_simpleRef () = 0;
+
+    // Parser construction API.
+    //
+    void
+    refid_parser (::xml_schema::string_pskel&);
+
+    void
+    value_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* refid */,
+             ::xml_schema::string_pskel& /* value */);
+
+    // Constructor.
+    //
+    simpleRef_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* refid_parser_;
+    ::xml_schema::string_pskel* value_parser_;
+
+    protected:
+    struct v_state_attr_
+    {
+      bool refid;
+      bool value;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class simpleSequenceRef_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    values (const ::std::vector<std::string>&);
+
+    virtual void
+    refid (const ::std::string&);
+
+    virtual ossie::SimpleSequencePropertyRef*
+    post_simpleSequenceRef () = 0;
+
+    // Parser construction API.
+    //
+    void
+    values_parser (::prf::values_pskel&);
+
+    void
+    refid_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::prf::values_pskel& /* values */,
+             ::xml_schema::string_pskel& /* refid */);
+
+    // Constructor.
+    //
+    simpleSequenceRef_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::prf::values_pskel* values_parser_;
+    ::xml_schema::string_pskel* refid_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::prf::simpleSequenceRef_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+
+    protected:
+    struct v_state_attr_
+    {
+      bool refid;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class simpleSequence_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    description (const ::std::string&);
+
+    virtual void
+    values (const ::std::vector<std::string>&);
+
+    virtual void
+    units (const ::std::string&);
+
+    virtual void
+    range (const ::std::pair<std::string, std::string>&);
+
+    virtual void
+    kind (const ::std::string&);
+
+    virtual void
+    action (const ::std::string&);
+
+    virtual void
+    id (const ::std::string&);
+
+    virtual void
+    mode (const ::std::string&);
+
+    virtual void
+    name (const ::std::string&);
+
+    virtual void
+    type (const ::std::string&);
+
+    virtual void
+    complex (const ::std::string&);
+
+    virtual void
+    optional (const ::std::string&);
+
+    virtual ossie::SimpleSequenceProperty*
+    post_simpleSequence () = 0;
+
+    // Parser construction API.
+    //
+    void
+    description_parser (::xml_schema::string_pskel&);
+
+    void
+    values_parser (::prf::values_pskel&);
+
+    void
+    units_parser (::prf::Unit_pskel&);
+
+    void
+    range_parser (::prf::range_pskel&);
+
+    void
+    kind_parser (::prf::kind_pskel&);
+
+    void
+    action_parser (::prf::action_pskel&);
+
+    void
+    id_parser (::xml_schema::string_pskel&);
+
+    void
+    mode_parser (::prf::AccessType_pskel&);
+
+    void
+    name_parser (::xml_schema::string_pskel&);
+
+    void
+    type_parser (::prf::PropertyValueType_pskel&);
+
+    void
+    complex_parser (::prf::IsComplex_pskel&);
+
+    void
+    optional_parser (::prf::IsOptional_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* description */,
+             ::prf::values_pskel& /* values */,
+             ::prf::Unit_pskel& /* units */,
+             ::prf::range_pskel& /* range */,
+             ::prf::kind_pskel& /* kind */,
+             ::prf::action_pskel& /* action */,
+             ::xml_schema::string_pskel& /* id */,
+             ::prf::AccessType_pskel& /* mode */,
+             ::xml_schema::string_pskel& /* name */,
+             ::prf::PropertyValueType_pskel& /* type */,
+             ::prf::IsComplex_pskel& /* complex */,
+             ::prf::IsOptional_pskel& /* optional */);
+
+    // Constructor.
+    //
+    simpleSequence_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* description_parser_;
+    ::prf::values_pskel* values_parser_;
+    ::prf::Unit_pskel* units_parser_;
+    ::prf::range_pskel* range_parser_;
+    ::prf::kind_pskel* kind_parser_;
+    ::prf::action_pskel* action_parser_;
+    ::xml_schema::string_pskel* id_parser_;
+    ::prf::AccessType_pskel* mode_parser_;
+    ::xml_schema::string_pskel* name_parser_;
+    ::prf::PropertyValueType_pskel* type_parser_;
+    ::prf::IsComplex_pskel* complex_parser_;
+    ::prf::IsOptional_pskel* optional_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::prf::simpleSequence_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+
+    protected:
+    struct v_state_attr_
+    {
+      bool id;
+      bool type;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class struct_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    description (const ::std::string&);
+
+    virtual void
+    simple (ossie::SimpleProperty*);
+
+    virtual void
+    simplesequence (ossie::SimpleSequenceProperty*);
+
+    virtual void
+    configurationkind (const ::std::string&);
+
+    virtual void
+    id (const ::std::string&);
+
+    virtual void
+    mode (const ::std::string&);
+
+    virtual void
+    name (const ::std::string&);
+
+    virtual ossie::StructProperty*
+    post_struct () = 0;
+
+    // Parser construction API.
+    //
+    void
+    description_parser (::xml_schema::string_pskel&);
+
+    void
+    simple_parser (::prf::simple_pskel&);
+
+    void
+    simplesequence_parser (::prf::simpleSequence_pskel&);
+
+    void
+    configurationkind_parser (::prf::configurationKind_pskel&);
+
+    void
+    id_parser (::xml_schema::string_pskel&);
+
+    void
+    mode_parser (::prf::AccessType_pskel&);
+
+    void
+    name_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* description */,
+             ::prf::simple_pskel& /* simple */,
+             ::prf::simpleSequence_pskel& /* simplesequence */,
+             ::prf::configurationKind_pskel& /* configurationkind */,
+             ::xml_schema::string_pskel& /* id */,
+             ::prf::AccessType_pskel& /* mode */,
+             ::xml_schema::string_pskel& /* name */);
+
+    // Constructor.
+    //
+    struct_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* description_parser_;
+    ::prf::simple_pskel* simple_parser_;
+    ::prf::simpleSequence_pskel* simplesequence_parser_;
+    ::prf::configurationKind_pskel* configurationkind_parser_;
+    ::xml_schema::string_pskel* id_parser_;
+    ::prf::AccessType_pskel* mode_parser_;
+    ::xml_schema::string_pskel* name_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::prf::struct_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[3UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+
+    void
+    choice_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start);
+
+    protected:
+    struct v_state_attr_
+    {
+      bool id;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class structSequence_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    description (const ::std::string&);
+
+    virtual void
+    struct_ (ossie::StructProperty*);
+
+    virtual void
+    structvalue (const ::std::map<std::string, ossie::ComponentProperty*>&);
+
+    virtual void
+    configurationkind (const ::std::string&);
+
+    virtual void
+    id (const ::std::string&);
+
+    virtual void
+    mode (const ::std::string&);
+
+    virtual void
+    name (const ::std::string&);
+
+    virtual ossie::StructSequenceProperty*
+    post_structSequence () = 0;
+
+    // Parser construction API.
+    //
+    void
+    description_parser (::xml_schema::string_pskel&);
+
+    void
+    struct_parser (::prf::struct_pskel&);
+
+    void
+    structvalue_parser (::prf::structValue_pskel&);
+
+    void
+    configurationkind_parser (::prf::configurationKind_pskel&);
+
+    void
+    id_parser (::xml_schema::string_pskel&);
+
+    void
+    mode_parser (::prf::AccessType_pskel&);
+
+    void
+    name_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* description */,
+             ::prf::struct_pskel& /* struct */,
+             ::prf::structValue_pskel& /* structvalue */,
+             ::prf::configurationKind_pskel& /* configurationkind */,
+             ::xml_schema::string_pskel& /* id */,
+             ::prf::AccessType_pskel& /* mode */,
+             ::xml_schema::string_pskel& /* name */);
+
+    // Constructor.
+    //
+    structSequence_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* description_parser_;
+    ::prf::struct_pskel* struct__parser_;
+    ::prf::structValue_pskel* structvalue_parser_;
+    ::prf::configurationKind_pskel* configurationkind_parser_;
+    ::xml_schema::string_pskel* id_parser_;
+    ::prf::AccessType_pskel* mode_parser_;
+    ::xml_schema::string_pskel* name_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::prf::structSequence_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+
+    protected:
+    struct v_state_attr_
+    {
+      bool id;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class structValue_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    simpleref (ossie::SimplePropertyRef*);
+
+    virtual void
+    simplesequenceref (ossie::SimpleSequencePropertyRef*);
+
+    virtual ::std::map<std::string, ossie::ComponentProperty*>
+    post_structValue () = 0;
+
+    // Parser construction API.
+    //
+    void
+    simpleref_parser (::prf::simpleRef_pskel&);
+
+    void
+    simplesequenceref_parser (::prf::simpleSequenceRef_pskel&);
+
+    void
+    parsers (::prf::simpleRef_pskel& /* simpleref */,
+             ::prf::simpleSequenceRef_pskel& /* simplesequenceref */);
+
+    // Constructor.
+    //
+    structValue_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::prf::simpleRef_pskel* simpleref_parser_;
+    ::prf::simpleSequenceRef_pskel* simplesequenceref_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::prf::structValue_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[3UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+
+    void
+    choice_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start);
+  };
+
+  class test_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    description (const ::std::string&);
+
+    virtual void
+    inputvalue ();
+
+    virtual void
+    resultvalue ();
+
+    virtual void
+    id (const ::std::string&);
+
+    virtual void
+    post_test ();
+
+    // Parser construction API.
+    //
+    void
+    description_parser (::xml_schema::string_pskel&);
+
+    void
+    inputvalue_parser (::prf::inputValue_pskel&);
+
+    void
+    resultvalue_parser (::prf::resultValue_pskel&);
+
+    void
+    id_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* description */,
+             ::prf::inputValue_pskel& /* inputvalue */,
+             ::prf::resultValue_pskel& /* resultvalue */,
+             ::xml_schema::string_pskel& /* id */);
+
+    // Constructor.
+    //
+    test_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* description_parser_;
+    ::prf::inputValue_pskel* inputvalue_parser_;
+    ::prf::resultValue_pskel* resultvalue_parser_;
+    ::xml_schema::string_pskel* id_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::prf::test_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+
+    protected:
+    struct v_state_attr_
+    {
+      bool id;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class values_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    value (const ::std::string&);
+
+    virtual ::std::vector<std::string>
+    post_values () = 0;
+
+    // Parser construction API.
+    //
+    void
+    value_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* value */);
+
+    // Constructor.
+    //
+    values_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::xml_schema::string_pskel* value_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::prf::values_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+  };
+}
+
+#include <xsd/cxx/post.hxx>
+
+// Begin epilogue.
+//
+//
+// End epilogue.
+
+#endif // CXX______XML_XSD_PRF_PSKEL_H
diff --git src/control/parser/internal/profile-pskel.cpp src/control/parser/internal/profile-pskel.cpp
new file mode 100644
index 0000000..707b8b8
--- /dev/null
+++ src/control/parser/internal/profile-pskel.cpp
@@ -0,0 +1,175 @@
+// Copyright (C) 2005-2010 Code Synthesis Tools CC
+//
+// This program was generated by CodeSynthesis XSD, an XML Schema to
+// C++ data binding compiler.
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 2 as
+// published by the Free Software Foundation.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+//
+// In addition, as a special exception, Code Synthesis Tools CC gives
+// permission to link this program with the Xerces-C++ library (or with
+// modified versions of Xerces-C++ that use the same license as Xerces-C++),
+// and distribute linked combinations including the two. You must obey
+// the GNU General Public License version 2 in all respects for all of
+// the code used other than Xerces-C++. If you modify this copy of the
+// program, you may extend this exception to your version of the program,
+// but you are not obligated to do so. If you do not wish to do so, delete
+// this exception statement from your version.
+//
+// Furthermore, Code Synthesis Tools CC makes a special exception for
+// the Free/Libre and Open Source Software (FLOSS) which is described
+// in the accompanying FLOSSE file.
+//
+
+// Begin prologue.
+//
+//
+// End prologue.
+
+#include "profile-pskel.h"
+
+namespace profile
+{
+  // profile_pskel
+  //
+
+  void profile_pskel::
+  filename_parser (::xml_schema::string_pskel& p)
+  {
+    this->filename_parser_ = &p;
+  }
+
+  void profile_pskel::
+  type_parser (::xml_schema::string_pskel& p)
+  {
+    this->type_parser_ = &p;
+  }
+
+  void profile_pskel::
+  parsers (::xml_schema::string_pskel& filename,
+           ::xml_schema::string_pskel& type)
+  {
+    this->filename_parser_ = &filename;
+    this->type_parser_ = &type;
+  }
+
+  profile_pskel::
+  profile_pskel ()
+  : filename_parser_ (0),
+    type_parser_ (0),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+}
+
+namespace profile
+{
+  // profile_pskel
+  //
+
+  void profile_pskel::
+  filename (const ::std::string&)
+  {
+  }
+
+  void profile_pskel::
+  type (const ::std::string&)
+  {
+  }
+
+  void profile_pskel::
+  post_profile ()
+  {
+  }
+}
+
+#include <cassert>
+
+namespace profile
+{
+}
+
+namespace profile
+{
+  // Attribute validation and dispatch functions for profile_pskel.
+  //
+  bool profile_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "filename" && ns.empty ())
+    {
+      if (this->filename_parser_)
+      {
+        this->filename_parser_->pre ();
+        this->filename_parser_->_pre_impl ();
+        this->filename_parser_->_characters (s);
+        this->filename_parser_->_post_impl ();
+        const ::std::string& tmp (this->filename_parser_->post_string ());
+        this->filename (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->filename = true;
+      return true;
+    }
+
+    if (n == "type" && ns.empty ())
+    {
+      if (this->type_parser_)
+      {
+        this->type_parser_->pre ();
+        this->type_parser_->_pre_impl ();
+        this->type_parser_->_characters (s);
+        this->type_parser_->_post_impl ();
+        const ::std::string& tmp (this->type_parser_->post_string ());
+        this->type (tmp);
+      }
+
+      return true;
+    }
+
+    return false;
+  }
+
+  void profile_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.filename = false;
+  }
+
+  void profile_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.filename)
+      this->_expected_attribute (
+        "", "filename");
+
+    this->v_state_attr_stack_.pop ();
+  }
+}
+
+namespace profile
+{
+}
+
+// Begin epilogue.
+//
+//
+// End epilogue.
+
diff --git src/control/parser/internal/profile-pskel.h src/control/parser/internal/profile-pskel.h
new file mode 100644
index 0000000..c1a6d5c
--- /dev/null
+++ src/control/parser/internal/profile-pskel.h
@@ -0,0 +1,331 @@
+// Copyright (C) 2005-2010 Code Synthesis Tools CC
+//
+// This program was generated by CodeSynthesis XSD, an XML Schema to
+// C++ data binding compiler.
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 2 as
+// published by the Free Software Foundation.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+//
+// In addition, as a special exception, Code Synthesis Tools CC gives
+// permission to link this program with the Xerces-C++ library (or with
+// modified versions of Xerces-C++ that use the same license as Xerces-C++),
+// and distribute linked combinations including the two. You must obey
+// the GNU General Public License version 2 in all respects for all of
+// the code used other than Xerces-C++. If you modify this copy of the
+// program, you may extend this exception to your version of the program,
+// but you are not obligated to do so. If you do not wish to do so, delete
+// this exception statement from your version.
+//
+// Furthermore, Code Synthesis Tools CC makes a special exception for
+// the Free/Libre and Open Source Software (FLOSS) which is described
+// in the accompanying FLOSSE file.
+//
+
+#ifndef CXX______XML_XSD_PROFILE_PSKEL_H
+#define CXX______XML_XSD_PROFILE_PSKEL_H
+
+// Begin prologue.
+//
+//
+// End prologue.
+
+#include <xsd/cxx/config.hxx>
+
+#if (XSD_INT_VERSION != 3030000L)
+#error XSD runtime version mismatch
+#endif
+
+#include <xsd/cxx/pre.hxx>
+
+// Forward declarations
+//
+namespace profile
+{
+  class profile_pskel;
+}
+
+
+#ifndef XSD_USE_CHAR
+#define XSD_USE_CHAR
+#endif
+
+#ifndef XSD_CXX_PARSER_USE_CHAR
+#define XSD_CXX_PARSER_USE_CHAR
+#endif
+
+#include <xsd/cxx/xml/error-handler.hxx>
+#include <xsd/cxx/parser/exceptions.hxx>
+#include <xsd/cxx/parser/elements.hxx>
+#include <xsd/cxx/parser/xml-schema.hxx>
+#include <xsd/cxx/parser/validating/parser.hxx>
+#include <xsd/cxx/parser/validating/exceptions.hxx>
+#include <xsd/cxx/parser/validating/xml-schema-pskel.hxx>
+#include <xsd/cxx/parser/validating/xml-schema-pimpl.hxx>
+#include <xsd/cxx/parser/expat/elements.hxx>
+
+namespace xml_schema
+{
+  // Built-in XML Schema types mapping.
+  //
+  typedef ::xsd::cxx::parser::string_sequence< char > string_sequence;
+  typedef ::xsd::cxx::parser::qname< char > qname;
+  typedef ::xsd::cxx::parser::buffer buffer;
+  typedef ::xsd::cxx::parser::time_zone time_zone;
+  typedef ::xsd::cxx::parser::gday gday;
+  typedef ::xsd::cxx::parser::gmonth gmonth;
+  typedef ::xsd::cxx::parser::gyear gyear;
+  typedef ::xsd::cxx::parser::gmonth_day gmonth_day;
+  typedef ::xsd::cxx::parser::gyear_month gyear_month;
+  typedef ::xsd::cxx::parser::date date;
+  typedef ::xsd::cxx::parser::time time;
+  typedef ::xsd::cxx::parser::date_time date_time;
+  typedef ::xsd::cxx::parser::duration duration;
+
+  // Base parser skeletons.
+  //
+  typedef ::xsd::cxx::parser::parser_base< char > parser_base;
+  typedef ::xsd::cxx::parser::validating::empty_content< char > empty_content;
+  typedef ::xsd::cxx::parser::validating::simple_content< char > simple_content;
+  typedef ::xsd::cxx::parser::validating::complex_content< char > complex_content;
+  typedef ::xsd::cxx::parser::validating::list_base< char > list_base;
+
+  // Parser skeletons and implementations for the XML Schema
+  // built-in types.
+  //
+  typedef ::xsd::cxx::parser::validating::any_type_pskel< char > any_type_pskel;
+  typedef ::xsd::cxx::parser::validating::any_type_pimpl< char > any_type_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::any_simple_type_pskel< char > any_simple_type_pskel;
+  typedef ::xsd::cxx::parser::validating::any_simple_type_pimpl< char > any_simple_type_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::byte_pskel< char > byte_pskel;
+  typedef ::xsd::cxx::parser::validating::byte_pimpl< char > byte_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::unsigned_byte_pskel< char > unsigned_byte_pskel;
+  typedef ::xsd::cxx::parser::validating::unsigned_byte_pimpl< char > unsigned_byte_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::short_pskel< char > short_pskel;
+  typedef ::xsd::cxx::parser::validating::short_pimpl< char > short_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::unsigned_short_pskel< char > unsigned_short_pskel;
+  typedef ::xsd::cxx::parser::validating::unsigned_short_pimpl< char > unsigned_short_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::int_pskel< char > int_pskel;
+  typedef ::xsd::cxx::parser::validating::int_pimpl< char > int_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::unsigned_int_pskel< char > unsigned_int_pskel;
+  typedef ::xsd::cxx::parser::validating::unsigned_int_pimpl< char > unsigned_int_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::long_pskel< char > long_pskel;
+  typedef ::xsd::cxx::parser::validating::long_pimpl< char > long_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::unsigned_long_pskel< char > unsigned_long_pskel;
+  typedef ::xsd::cxx::parser::validating::unsigned_long_pimpl< char > unsigned_long_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::integer_pskel< char > integer_pskel;
+  typedef ::xsd::cxx::parser::validating::integer_pimpl< char > integer_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::non_positive_integer_pskel< char > non_positive_integer_pskel;
+  typedef ::xsd::cxx::parser::validating::non_positive_integer_pimpl< char > non_positive_integer_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::non_negative_integer_pskel< char > non_negative_integer_pskel;
+  typedef ::xsd::cxx::parser::validating::non_negative_integer_pimpl< char > non_negative_integer_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::positive_integer_pskel< char > positive_integer_pskel;
+  typedef ::xsd::cxx::parser::validating::positive_integer_pimpl< char > positive_integer_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::negative_integer_pskel< char > negative_integer_pskel;
+  typedef ::xsd::cxx::parser::validating::negative_integer_pimpl< char > negative_integer_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::boolean_pskel< char > boolean_pskel;
+  typedef ::xsd::cxx::parser::validating::boolean_pimpl< char > boolean_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::float_pskel< char > float_pskel;
+  typedef ::xsd::cxx::parser::validating::float_pimpl< char > float_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::double_pskel< char > double_pskel;
+  typedef ::xsd::cxx::parser::validating::double_pimpl< char > double_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::decimal_pskel< char > decimal_pskel;
+  typedef ::xsd::cxx::parser::validating::decimal_pimpl< char > decimal_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::string_pskel< char > string_pskel;
+  typedef ::xsd::cxx::parser::validating::string_pimpl< char > string_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::normalized_string_pskel< char > normalized_string_pskel;
+  typedef ::xsd::cxx::parser::validating::normalized_string_pimpl< char > normalized_string_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::token_pskel< char > token_pskel;
+  typedef ::xsd::cxx::parser::validating::token_pimpl< char > token_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::name_pskel< char > name_pskel;
+  typedef ::xsd::cxx::parser::validating::name_pimpl< char > name_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::nmtoken_pskel< char > nmtoken_pskel;
+  typedef ::xsd::cxx::parser::validating::nmtoken_pimpl< char > nmtoken_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::nmtokens_pskel< char > nmtokens_pskel;
+  typedef ::xsd::cxx::parser::validating::nmtokens_pimpl< char > nmtokens_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::ncname_pskel< char > ncname_pskel;
+  typedef ::xsd::cxx::parser::validating::ncname_pimpl< char > ncname_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::language_pskel< char > language_pskel;
+  typedef ::xsd::cxx::parser::validating::language_pimpl< char > language_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::id_pskel< char > id_pskel;
+  typedef ::xsd::cxx::parser::validating::id_pimpl< char > id_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::idref_pskel< char > idref_pskel;
+  typedef ::xsd::cxx::parser::validating::idref_pimpl< char > idref_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::idrefs_pskel< char > idrefs_pskel;
+  typedef ::xsd::cxx::parser::validating::idrefs_pimpl< char > idrefs_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::uri_pskel< char > uri_pskel;
+  typedef ::xsd::cxx::parser::validating::uri_pimpl< char > uri_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::qname_pskel< char > qname_pskel;
+  typedef ::xsd::cxx::parser::validating::qname_pimpl< char > qname_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::base64_binary_pskel< char > base64_binary_pskel;
+  typedef ::xsd::cxx::parser::validating::base64_binary_pimpl< char > base64_binary_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::hex_binary_pskel< char > hex_binary_pskel;
+  typedef ::xsd::cxx::parser::validating::hex_binary_pimpl< char > hex_binary_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::date_pskel< char > date_pskel;
+  typedef ::xsd::cxx::parser::validating::date_pimpl< char > date_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::date_time_pskel< char > date_time_pskel;
+  typedef ::xsd::cxx::parser::validating::date_time_pimpl< char > date_time_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::duration_pskel< char > duration_pskel;
+  typedef ::xsd::cxx::parser::validating::duration_pimpl< char > duration_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::gday_pskel< char > gday_pskel;
+  typedef ::xsd::cxx::parser::validating::gday_pimpl< char > gday_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::gmonth_pskel< char > gmonth_pskel;
+  typedef ::xsd::cxx::parser::validating::gmonth_pimpl< char > gmonth_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::gmonth_day_pskel< char > gmonth_day_pskel;
+  typedef ::xsd::cxx::parser::validating::gmonth_day_pimpl< char > gmonth_day_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::gyear_pskel< char > gyear_pskel;
+  typedef ::xsd::cxx::parser::validating::gyear_pimpl< char > gyear_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::gyear_month_pskel< char > gyear_month_pskel;
+  typedef ::xsd::cxx::parser::validating::gyear_month_pimpl< char > gyear_month_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::time_pskel< char > time_pskel;
+  typedef ::xsd::cxx::parser::validating::time_pimpl< char > time_pimpl;
+
+  // Exceptions. See libxsd/xsd/cxx/parser/exceptions.hxx for details.
+  //
+  typedef ::xsd::cxx::parser::exception< char > exception;
+
+  // Parsing diagnostics.
+  //
+  typedef ::xsd::cxx::parser::severity severity;
+  typedef ::xsd::cxx::parser::error< char > error;
+  typedef ::xsd::cxx::parser::diagnostics< char > diagnostics;
+  typedef ::xsd::cxx::parser::parsing< char > parsing;
+
+  // Error handler. See libxsd/xsd/cxx/xml/error-handler.hxx for details.
+  //
+  typedef ::xsd::cxx::xml::error_handler< char > error_handler;
+
+  // Read-only string.
+  //
+  typedef ::xsd::cxx::ro_string< char > ro_string;
+
+  // Document type. See libxsd/xsd/cxx/parser/expat/elements.hxx
+  // for details.
+  //
+  typedef ::xsd::cxx::parser::expat::document< char > document;
+}
+
+namespace profile
+{
+  class profile_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    filename (const ::std::string&);
+
+    virtual void
+    type (const ::std::string&);
+
+    virtual void
+    post_profile ();
+
+    // Parser construction API.
+    //
+    void
+    filename_parser (::xml_schema::string_pskel&);
+
+    void
+    type_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* filename */,
+             ::xml_schema::string_pskel& /* type */);
+
+    // Constructor.
+    //
+    profile_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* filename_parser_;
+    ::xml_schema::string_pskel* type_parser_;
+
+    protected:
+    struct v_state_attr_
+    {
+      bool filename;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+}
+
+#include <xsd/cxx/post.hxx>
+
+// Begin epilogue.
+//
+//
+// End epilogue.
+
+#endif // CXX______XML_XSD_PROFILE_PSKEL_H
diff --git src/control/parser/internal/sad-pskel.cpp src/control/parser/internal/sad-pskel.cpp
new file mode 100644
index 0000000..bac6946
--- /dev/null
+++ src/control/parser/internal/sad-pskel.cpp
@@ -0,0 +1,10409 @@
+// Copyright (C) 2005-2010 Code Synthesis Tools CC
+//
+// This program was generated by CodeSynthesis XSD, an XML Schema to
+// C++ data binding compiler.
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 2 as
+// published by the Free Software Foundation.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+//
+// In addition, as a special exception, Code Synthesis Tools CC gives
+// permission to link this program with the Xerces-C++ library (or with
+// modified versions of Xerces-C++ that use the same license as Xerces-C++),
+// and distribute linked combinations including the two. You must obey
+// the GNU General Public License version 2 in all respects for all of
+// the code used other than Xerces-C++. If you modify this copy of the
+// program, you may extend this exception to your version of the program,
+// but you are not obligated to do so. If you do not wish to do so, delete
+// this exception statement from your version.
+//
+// Furthermore, Code Synthesis Tools CC makes a special exception for
+// the Free/Libre and Open Source Software (FLOSS) which is described
+// in the accompanying FLOSSE file.
+//
+
+// Begin prologue.
+//
+//
+// End prologue.
+
+#include "sad-pskel.h"
+
+namespace sad
+{
+  // softwareassembly_pskel
+  //
+
+  void softwareassembly_pskel::
+  description_parser (::xml_schema::string_pskel& p)
+  {
+    this->description_parser_ = &p;
+  }
+
+  void softwareassembly_pskel::
+  componentfiles_parser (::sad::componentfiles_pskel& p)
+  {
+    this->componentfiles_parser_ = &p;
+  }
+
+  void softwareassembly_pskel::
+  partitioning_parser (::sad::partitioning_pskel& p)
+  {
+    this->partitioning_parser_ = &p;
+  }
+
+  void softwareassembly_pskel::
+  assemblycontroller_parser (::sad::assemblycontroller_pskel& p)
+  {
+    this->assemblycontroller_parser_ = &p;
+  }
+
+  void softwareassembly_pskel::
+  connections_parser (::sad::connections_pskel& p)
+  {
+    this->connections_parser_ = &p;
+  }
+
+  void softwareassembly_pskel::
+  externalports_parser (::sad::externalports_pskel& p)
+  {
+    this->externalports_parser_ = &p;
+  }
+
+  void softwareassembly_pskel::
+  externalproperties_parser (::sad::externalproperties_pskel& p)
+  {
+    this->externalproperties_parser_ = &p;
+  }
+
+  void softwareassembly_pskel::
+  usesdevicedependencies_parser (::sad::usesdevicedependencies_pskel& p)
+  {
+    this->usesdevicedependencies_parser_ = &p;
+  }
+
+  void softwareassembly_pskel::
+  id_parser (::xml_schema::string_pskel& p)
+  {
+    this->id_parser_ = &p;
+  }
+
+  void softwareassembly_pskel::
+  name_parser (::xml_schema::string_pskel& p)
+  {
+    this->name_parser_ = &p;
+  }
+
+  void softwareassembly_pskel::
+  version_parser (::xml_schema::string_pskel& p)
+  {
+    this->version_parser_ = &p;
+  }
+
+  void softwareassembly_pskel::
+  parsers (::xml_schema::string_pskel& description,
+           ::sad::componentfiles_pskel& componentfiles,
+           ::sad::partitioning_pskel& partitioning,
+           ::sad::assemblycontroller_pskel& assemblycontroller,
+           ::sad::connections_pskel& connections,
+           ::sad::externalports_pskel& externalports,
+           ::sad::externalproperties_pskel& externalproperties,
+           ::sad::usesdevicedependencies_pskel& usesdevicedependencies,
+           ::xml_schema::string_pskel& id,
+           ::xml_schema::string_pskel& name,
+           ::xml_schema::string_pskel& version)
+  {
+    this->description_parser_ = &description;
+    this->componentfiles_parser_ = &componentfiles;
+    this->partitioning_parser_ = &partitioning;
+    this->assemblycontroller_parser_ = &assemblycontroller;
+    this->connections_parser_ = &connections;
+    this->externalports_parser_ = &externalports;
+    this->externalproperties_parser_ = &externalproperties;
+    this->usesdevicedependencies_parser_ = &usesdevicedependencies;
+    this->id_parser_ = &id;
+    this->name_parser_ = &name;
+    this->version_parser_ = &version;
+  }
+
+  softwareassembly_pskel::
+  softwareassembly_pskel ()
+  : description_parser_ (0),
+    componentfiles_parser_ (0),
+    partitioning_parser_ (0),
+    assemblycontroller_parser_ (0),
+    connections_parser_ (0),
+    externalports_parser_ (0),
+    externalproperties_parser_ (0),
+    usesdevicedependencies_parser_ (0),
+    id_parser_ (0),
+    name_parser_ (0),
+    version_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // componentfiles_pskel
+  //
+
+  void componentfiles_pskel::
+  componentfile_parser (::sad::componentfile_pskel& p)
+  {
+    this->componentfile_parser_ = &p;
+  }
+
+  void componentfiles_pskel::
+  parsers (::sad::componentfile_pskel& componentfile)
+  {
+    this->componentfile_parser_ = &componentfile;
+  }
+
+  componentfiles_pskel::
+  componentfiles_pskel ()
+  : componentfile_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // componentfile_pskel
+  //
+
+  void componentfile_pskel::
+  localfile_parser (::sad::localfile_pskel& p)
+  {
+    this->localfile_parser_ = &p;
+  }
+
+  void componentfile_pskel::
+  id_parser (::xml_schema::string_pskel& p)
+  {
+    this->id_parser_ = &p;
+  }
+
+  void componentfile_pskel::
+  type_parser (::xml_schema::string_pskel& p)
+  {
+    this->type_parser_ = &p;
+  }
+
+  void componentfile_pskel::
+  parsers (::sad::localfile_pskel& localfile,
+           ::xml_schema::string_pskel& id,
+           ::xml_schema::string_pskel& type)
+  {
+    this->localfile_parser_ = &localfile;
+    this->id_parser_ = &id;
+    this->type_parser_ = &type;
+  }
+
+  componentfile_pskel::
+  componentfile_pskel ()
+  : localfile_parser_ (0),
+    id_parser_ (0),
+    type_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // localfile_pskel
+  //
+
+  void localfile_pskel::
+  name_parser (::xml_schema::string_pskel& p)
+  {
+    this->name_parser_ = &p;
+  }
+
+  void localfile_pskel::
+  parsers (::xml_schema::string_pskel& name)
+  {
+    this->name_parser_ = &name;
+  }
+
+  localfile_pskel::
+  localfile_pskel ()
+  : name_parser_ (0),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // partitioning_pskel
+  //
+
+  void partitioning_pskel::
+  componentplacement_parser (::sad::componentplacement_pskel& p)
+  {
+    this->componentplacement_parser_ = &p;
+  }
+
+  void partitioning_pskel::
+  hostcollocation_parser (::sad::hostcollocation_pskel& p)
+  {
+    this->hostcollocation_parser_ = &p;
+  }
+
+  void partitioning_pskel::
+  parsers (::sad::componentplacement_pskel& componentplacement,
+           ::sad::hostcollocation_pskel& hostcollocation)
+  {
+    this->componentplacement_parser_ = &componentplacement;
+    this->hostcollocation_parser_ = &hostcollocation;
+  }
+
+  partitioning_pskel::
+  partitioning_pskel ()
+  : componentplacement_parser_ (0),
+    hostcollocation_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // componentplacement_pskel
+  //
+
+  void componentplacement_pskel::
+  componentfileref_parser (::sad::componentfileref_pskel& p)
+  {
+    this->componentfileref_parser_ = &p;
+  }
+
+  void componentplacement_pskel::
+  componentinstantiation_parser (::sad::componentinstantiation_pskel& p)
+  {
+    this->componentinstantiation_parser_ = &p;
+  }
+
+  void componentplacement_pskel::
+  parsers (::sad::componentfileref_pskel& componentfileref,
+           ::sad::componentinstantiation_pskel& componentinstantiation)
+  {
+    this->componentfileref_parser_ = &componentfileref;
+    this->componentinstantiation_parser_ = &componentinstantiation;
+  }
+
+  componentplacement_pskel::
+  componentplacement_pskel ()
+  : componentfileref_parser_ (0),
+    componentinstantiation_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // componentfileref_pskel
+  //
+
+  void componentfileref_pskel::
+  refid_parser (::xml_schema::string_pskel& p)
+  {
+    this->refid_parser_ = &p;
+  }
+
+  void componentfileref_pskel::
+  parsers (::xml_schema::string_pskel& refid)
+  {
+    this->refid_parser_ = &refid;
+  }
+
+  componentfileref_pskel::
+  componentfileref_pskel ()
+  : refid_parser_ (0),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // componentinstantiation_pskel
+  //
+
+  void componentinstantiation_pskel::
+  usagename_parser (::xml_schema::string_pskel& p)
+  {
+    this->usagename_parser_ = &p;
+  }
+
+  void componentinstantiation_pskel::
+  componentproperties_parser (::sad::componentproperties_pskel& p)
+  {
+    this->componentproperties_parser_ = &p;
+  }
+
+  void componentinstantiation_pskel::
+  affinity_parser (::sad::affinity_pskel& p)
+  {
+    this->affinity_parser_ = &p;
+  }
+
+  void componentinstantiation_pskel::
+  loggingconfig_parser (::sad::loggingconfig_pskel& p)
+  {
+    this->loggingconfig_parser_ = &p;
+  }
+
+  void componentinstantiation_pskel::
+  findcomponent_parser (::sad::findcomponent_pskel& p)
+  {
+    this->findcomponent_parser_ = &p;
+  }
+
+  void componentinstantiation_pskel::
+  id_parser (::xml_schema::string_pskel& p)
+  {
+    this->id_parser_ = &p;
+  }
+
+  void componentinstantiation_pskel::
+  startorder_parser (::xml_schema::string_pskel& p)
+  {
+    this->startorder_parser_ = &p;
+  }
+
+  void componentinstantiation_pskel::
+  parsers (::xml_schema::string_pskel& usagename,
+           ::sad::componentproperties_pskel& componentproperties,
+           ::sad::affinity_pskel& affinity,
+           ::sad::loggingconfig_pskel& loggingconfig,
+           ::sad::findcomponent_pskel& findcomponent,
+           ::xml_schema::string_pskel& id,
+           ::xml_schema::string_pskel& startorder)
+  {
+    this->usagename_parser_ = &usagename;
+    this->componentproperties_parser_ = &componentproperties;
+    this->affinity_parser_ = &affinity;
+    this->loggingconfig_parser_ = &loggingconfig;
+    this->findcomponent_parser_ = &findcomponent;
+    this->id_parser_ = &id;
+    this->startorder_parser_ = &startorder;
+  }
+
+  componentinstantiation_pskel::
+  componentinstantiation_pskel ()
+  : usagename_parser_ (0),
+    componentproperties_parser_ (0),
+    affinity_parser_ (0),
+    loggingconfig_parser_ (0),
+    findcomponent_parser_ (0),
+    id_parser_ (0),
+    startorder_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // loggingconfig_pskel
+  //
+
+  void loggingconfig_pskel::
+  level_parser (::xml_schema::string_pskel& p)
+  {
+    this->level_parser_ = &p;
+  }
+
+  void loggingconfig_pskel::
+  parsers (::xml_schema::string_pskel& level)
+  {
+    this->level_parser_ = &level;
+  }
+
+  loggingconfig_pskel::
+  loggingconfig_pskel ()
+  : level_parser_ (0)
+  {
+  }
+
+  // affinity_pskel
+  //
+
+  void affinity_pskel::
+  simpleref_parser (::sad::simpleref_pskel& p)
+  {
+    this->simpleref_parser_ = &p;
+  }
+
+  void affinity_pskel::
+  simplesequenceref_parser (::sad::simplesequenceref_pskel& p)
+  {
+    this->simplesequenceref_parser_ = &p;
+  }
+
+  void affinity_pskel::
+  structref_parser (::sad::structref_pskel& p)
+  {
+    this->structref_parser_ = &p;
+  }
+
+  void affinity_pskel::
+  structsequenceref_parser (::sad::structsequenceref_pskel& p)
+  {
+    this->structsequenceref_parser_ = &p;
+  }
+
+  void affinity_pskel::
+  parsers (::sad::simpleref_pskel& simpleref,
+           ::sad::simplesequenceref_pskel& simplesequenceref,
+           ::sad::structref_pskel& structref,
+           ::sad::structsequenceref_pskel& structsequenceref)
+  {
+    this->simpleref_parser_ = &simpleref;
+    this->simplesequenceref_parser_ = &simplesequenceref;
+    this->structref_parser_ = &structref;
+    this->structsequenceref_parser_ = &structsequenceref;
+  }
+
+  affinity_pskel::
+  affinity_pskel ()
+  : simpleref_parser_ (0),
+    simplesequenceref_parser_ (0),
+    structref_parser_ (0),
+    structsequenceref_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // componentproperties_pskel
+  //
+
+  void componentproperties_pskel::
+  simpleref_parser (::sad::simpleref_pskel& p)
+  {
+    this->simpleref_parser_ = &p;
+  }
+
+  void componentproperties_pskel::
+  simplesequenceref_parser (::sad::simplesequenceref_pskel& p)
+  {
+    this->simplesequenceref_parser_ = &p;
+  }
+
+  void componentproperties_pskel::
+  structref_parser (::sad::structref_pskel& p)
+  {
+    this->structref_parser_ = &p;
+  }
+
+  void componentproperties_pskel::
+  structsequenceref_parser (::sad::structsequenceref_pskel& p)
+  {
+    this->structsequenceref_parser_ = &p;
+  }
+
+  void componentproperties_pskel::
+  parsers (::sad::simpleref_pskel& simpleref,
+           ::sad::simplesequenceref_pskel& simplesequenceref,
+           ::sad::structref_pskel& structref,
+           ::sad::structsequenceref_pskel& structsequenceref)
+  {
+    this->simpleref_parser_ = &simpleref;
+    this->simplesequenceref_parser_ = &simplesequenceref;
+    this->structref_parser_ = &structref;
+    this->structsequenceref_parser_ = &structsequenceref;
+  }
+
+  componentproperties_pskel::
+  componentproperties_pskel ()
+  : simpleref_parser_ (0),
+    simplesequenceref_parser_ (0),
+    structref_parser_ (0),
+    structsequenceref_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // findcomponent_pskel
+  //
+
+  void findcomponent_pskel::
+  componentresourcefactoryref_parser (::sad::componentresourcefactoryref_pskel& p)
+  {
+    this->componentresourcefactoryref_parser_ = &p;
+  }
+
+  void findcomponent_pskel::
+  namingservice_parser (::sad::namingservice_pskel& p)
+  {
+    this->namingservice_parser_ = &p;
+  }
+
+  void findcomponent_pskel::
+  parsers (::sad::componentresourcefactoryref_pskel& componentresourcefactoryref,
+           ::sad::namingservice_pskel& namingservice)
+  {
+    this->componentresourcefactoryref_parser_ = &componentresourcefactoryref;
+    this->namingservice_parser_ = &namingservice;
+  }
+
+  findcomponent_pskel::
+  findcomponent_pskel ()
+  : componentresourcefactoryref_parser_ (0),
+    namingservice_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // componentresourcefactoryref_pskel
+  //
+
+  void componentresourcefactoryref_pskel::
+  resourcefactoryproperties_parser (::sad::resourcefactoryproperties_pskel& p)
+  {
+    this->resourcefactoryproperties_parser_ = &p;
+  }
+
+  void componentresourcefactoryref_pskel::
+  refid_parser (::xml_schema::string_pskel& p)
+  {
+    this->refid_parser_ = &p;
+  }
+
+  void componentresourcefactoryref_pskel::
+  parsers (::sad::resourcefactoryproperties_pskel& resourcefactoryproperties,
+           ::xml_schema::string_pskel& refid)
+  {
+    this->resourcefactoryproperties_parser_ = &resourcefactoryproperties;
+    this->refid_parser_ = &refid;
+  }
+
+  componentresourcefactoryref_pskel::
+  componentresourcefactoryref_pskel ()
+  : resourcefactoryproperties_parser_ (0),
+    refid_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // devicethatloadedthiscomponentref_pskel
+  //
+
+  void devicethatloadedthiscomponentref_pskel::
+  refid_parser (::xml_schema::string_pskel& p)
+  {
+    this->refid_parser_ = &p;
+  }
+
+  void devicethatloadedthiscomponentref_pskel::
+  parsers (::xml_schema::string_pskel& refid)
+  {
+    this->refid_parser_ = &refid;
+  }
+
+  devicethatloadedthiscomponentref_pskel::
+  devicethatloadedthiscomponentref_pskel ()
+  : refid_parser_ (0),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // deviceusedbythiscomponentref_pskel
+  //
+
+  void deviceusedbythiscomponentref_pskel::
+  refid_parser (::xml_schema::string_pskel& p)
+  {
+    this->refid_parser_ = &p;
+  }
+
+  void deviceusedbythiscomponentref_pskel::
+  usesrefid_parser (::xml_schema::string_pskel& p)
+  {
+    this->usesrefid_parser_ = &p;
+  }
+
+  void deviceusedbythiscomponentref_pskel::
+  parsers (::xml_schema::string_pskel& refid,
+           ::xml_schema::string_pskel& usesrefid)
+  {
+    this->refid_parser_ = &refid;
+    this->usesrefid_parser_ = &usesrefid;
+  }
+
+  deviceusedbythiscomponentref_pskel::
+  deviceusedbythiscomponentref_pskel ()
+  : refid_parser_ (0),
+    usesrefid_parser_ (0),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // deviceusedbyapplication_pskel
+  //
+
+  void deviceusedbyapplication_pskel::
+  usesrefid_parser (::xml_schema::string_pskel& p)
+  {
+    this->usesrefid_parser_ = &p;
+  }
+
+  void deviceusedbyapplication_pskel::
+  parsers (::xml_schema::string_pskel& usesrefid)
+  {
+    this->usesrefid_parser_ = &usesrefid;
+  }
+
+  deviceusedbyapplication_pskel::
+  deviceusedbyapplication_pskel ()
+  : usesrefid_parser_ (0),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // resourcefactoryproperties_pskel
+  //
+
+  void resourcefactoryproperties_pskel::
+  simpleref_parser (::sad::simpleref_pskel& p)
+  {
+    this->simpleref_parser_ = &p;
+  }
+
+  void resourcefactoryproperties_pskel::
+  simplesequenceref_parser (::sad::simplesequenceref_pskel& p)
+  {
+    this->simplesequenceref_parser_ = &p;
+  }
+
+  void resourcefactoryproperties_pskel::
+  structref_parser (::sad::structref_pskel& p)
+  {
+    this->structref_parser_ = &p;
+  }
+
+  void resourcefactoryproperties_pskel::
+  structsequenceref_parser (::sad::structsequenceref_pskel& p)
+  {
+    this->structsequenceref_parser_ = &p;
+  }
+
+  void resourcefactoryproperties_pskel::
+  parsers (::sad::simpleref_pskel& simpleref,
+           ::sad::simplesequenceref_pskel& simplesequenceref,
+           ::sad::structref_pskel& structref,
+           ::sad::structsequenceref_pskel& structsequenceref)
+  {
+    this->simpleref_parser_ = &simpleref;
+    this->simplesequenceref_parser_ = &simplesequenceref;
+    this->structref_parser_ = &structref;
+    this->structsequenceref_parser_ = &structsequenceref;
+  }
+
+  resourcefactoryproperties_pskel::
+  resourcefactoryproperties_pskel ()
+  : simpleref_parser_ (0),
+    simplesequenceref_parser_ (0),
+    structref_parser_ (0),
+    structsequenceref_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // simpleref_pskel
+  //
+
+  void simpleref_pskel::
+  refid_parser (::xml_schema::string_pskel& p)
+  {
+    this->refid_parser_ = &p;
+  }
+
+  void simpleref_pskel::
+  value_parser (::xml_schema::string_pskel& p)
+  {
+    this->value_parser_ = &p;
+  }
+
+  void simpleref_pskel::
+  parsers (::xml_schema::string_pskel& refid,
+           ::xml_schema::string_pskel& value)
+  {
+    this->refid_parser_ = &refid;
+    this->value_parser_ = &value;
+  }
+
+  simpleref_pskel::
+  simpleref_pskel ()
+  : refid_parser_ (0),
+    value_parser_ (0),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // simplesequenceref_pskel
+  //
+
+  void simplesequenceref_pskel::
+  values_parser (::sad::values_pskel& p)
+  {
+    this->values_parser_ = &p;
+  }
+
+  void simplesequenceref_pskel::
+  refid_parser (::xml_schema::string_pskel& p)
+  {
+    this->refid_parser_ = &p;
+  }
+
+  void simplesequenceref_pskel::
+  parsers (::sad::values_pskel& values,
+           ::xml_schema::string_pskel& refid)
+  {
+    this->values_parser_ = &values;
+    this->refid_parser_ = &refid;
+  }
+
+  simplesequenceref_pskel::
+  simplesequenceref_pskel ()
+  : values_parser_ (0),
+    refid_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // structref_pskel
+  //
+
+  void structref_pskel::
+  simpleref_parser (::sad::simpleref_pskel& p)
+  {
+    this->simpleref_parser_ = &p;
+  }
+
+  void structref_pskel::
+  simplesequenceref_parser (::sad::simplesequenceref_pskel& p)
+  {
+    this->simplesequenceref_parser_ = &p;
+  }
+
+  void structref_pskel::
+  refid_parser (::xml_schema::string_pskel& p)
+  {
+    this->refid_parser_ = &p;
+  }
+
+  void structref_pskel::
+  parsers (::sad::simpleref_pskel& simpleref,
+           ::sad::simplesequenceref_pskel& simplesequenceref,
+           ::xml_schema::string_pskel& refid)
+  {
+    this->simpleref_parser_ = &simpleref;
+    this->simplesequenceref_parser_ = &simplesequenceref;
+    this->refid_parser_ = &refid;
+  }
+
+  structref_pskel::
+  structref_pskel ()
+  : simpleref_parser_ (0),
+    simplesequenceref_parser_ (0),
+    refid_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // structsequenceref_pskel
+  //
+
+  void structsequenceref_pskel::
+  structvalue_parser (::sad::structvalue_pskel& p)
+  {
+    this->structvalue_parser_ = &p;
+  }
+
+  void structsequenceref_pskel::
+  refid_parser (::xml_schema::string_pskel& p)
+  {
+    this->refid_parser_ = &p;
+  }
+
+  void structsequenceref_pskel::
+  parsers (::sad::structvalue_pskel& structvalue,
+           ::xml_schema::string_pskel& refid)
+  {
+    this->structvalue_parser_ = &structvalue;
+    this->refid_parser_ = &refid;
+  }
+
+  structsequenceref_pskel::
+  structsequenceref_pskel ()
+  : structvalue_parser_ (0),
+    refid_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // structvalue_pskel
+  //
+
+  void structvalue_pskel::
+  simpleref_parser (::sad::simpleref_pskel& p)
+  {
+    this->simpleref_parser_ = &p;
+  }
+
+  void structvalue_pskel::
+  simplesequenceref_parser (::sad::simplesequenceref_pskel& p)
+  {
+    this->simplesequenceref_parser_ = &p;
+  }
+
+  void structvalue_pskel::
+  parsers (::sad::simpleref_pskel& simpleref,
+           ::sad::simplesequenceref_pskel& simplesequenceref)
+  {
+    this->simpleref_parser_ = &simpleref;
+    this->simplesequenceref_parser_ = &simplesequenceref;
+  }
+
+  structvalue_pskel::
+  structvalue_pskel ()
+  : simpleref_parser_ (0),
+    simplesequenceref_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // values_pskel
+  //
+
+  void values_pskel::
+  value_parser (::xml_schema::string_pskel& p)
+  {
+    this->value_parser_ = &p;
+  }
+
+  void values_pskel::
+  parsers (::xml_schema::string_pskel& value)
+  {
+    this->value_parser_ = &value;
+  }
+
+  values_pskel::
+  values_pskel ()
+  : value_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // componentinstantiationref_pskel
+  //
+
+  void componentinstantiationref_pskel::
+  refid_parser (::xml_schema::string_pskel& p)
+  {
+    this->refid_parser_ = &p;
+  }
+
+  void componentinstantiationref_pskel::
+  parsers (::xml_schema::string_pskel& refid)
+  {
+    this->refid_parser_ = &refid;
+  }
+
+  componentinstantiationref_pskel::
+  componentinstantiationref_pskel ()
+  : refid_parser_ (0),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // findby_pskel
+  //
+
+  void findby_pskel::
+  namingservice_parser (::sad::namingservice_pskel& p)
+  {
+    this->namingservice_parser_ = &p;
+  }
+
+  void findby_pskel::
+  stringifiedobjectref_parser (::xml_schema::string_pskel& p)
+  {
+    this->stringifiedobjectref_parser_ = &p;
+  }
+
+  void findby_pskel::
+  domainfinder_parser (::sad::domainfinder_pskel& p)
+  {
+    this->domainfinder_parser_ = &p;
+  }
+
+  void findby_pskel::
+  parsers (::sad::namingservice_pskel& namingservice,
+           ::xml_schema::string_pskel& stringifiedobjectref,
+           ::sad::domainfinder_pskel& domainfinder)
+  {
+    this->namingservice_parser_ = &namingservice;
+    this->stringifiedobjectref_parser_ = &stringifiedobjectref;
+    this->domainfinder_parser_ = &domainfinder;
+  }
+
+  findby_pskel::
+  findby_pskel ()
+  : namingservice_parser_ (0),
+    stringifiedobjectref_parser_ (0),
+    domainfinder_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // namingservice_pskel
+  //
+
+  void namingservice_pskel::
+  name_parser (::xml_schema::string_pskel& p)
+  {
+    this->name_parser_ = &p;
+  }
+
+  void namingservice_pskel::
+  parsers (::xml_schema::string_pskel& name)
+  {
+    this->name_parser_ = &name;
+  }
+
+  namingservice_pskel::
+  namingservice_pskel ()
+  : name_parser_ (0),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // domainfinder_pskel
+  //
+
+  void domainfinder_pskel::
+  type_parser (::xml_schema::string_pskel& p)
+  {
+    this->type_parser_ = &p;
+  }
+
+  void domainfinder_pskel::
+  name_parser (::xml_schema::string_pskel& p)
+  {
+    this->name_parser_ = &p;
+  }
+
+  void domainfinder_pskel::
+  parsers (::xml_schema::string_pskel& type,
+           ::xml_schema::string_pskel& name)
+  {
+    this->type_parser_ = &type;
+    this->name_parser_ = &name;
+  }
+
+  domainfinder_pskel::
+  domainfinder_pskel ()
+  : type_parser_ (0),
+    name_parser_ (0),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // hostcollocation_pskel
+  //
+
+  void hostcollocation_pskel::
+  componentplacement_parser (::sad::componentplacement_pskel& p)
+  {
+    this->componentplacement_parser_ = &p;
+  }
+
+  void hostcollocation_pskel::
+  id_parser (::xml_schema::string_pskel& p)
+  {
+    this->id_parser_ = &p;
+  }
+
+  void hostcollocation_pskel::
+  name_parser (::xml_schema::string_pskel& p)
+  {
+    this->name_parser_ = &p;
+  }
+
+  void hostcollocation_pskel::
+  parsers (::sad::componentplacement_pskel& componentplacement,
+           ::xml_schema::string_pskel& id,
+           ::xml_schema::string_pskel& name)
+  {
+    this->componentplacement_parser_ = &componentplacement;
+    this->id_parser_ = &id;
+    this->name_parser_ = &name;
+  }
+
+  hostcollocation_pskel::
+  hostcollocation_pskel ()
+  : componentplacement_parser_ (0),
+    id_parser_ (0),
+    name_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // assemblycontroller_pskel
+  //
+
+  void assemblycontroller_pskel::
+  componentinstantiationref_parser (::sad::componentinstantiationref_pskel& p)
+  {
+    this->componentinstantiationref_parser_ = &p;
+  }
+
+  void assemblycontroller_pskel::
+  parsers (::sad::componentinstantiationref_pskel& componentinstantiationref)
+  {
+    this->componentinstantiationref_parser_ = &componentinstantiationref;
+  }
+
+  assemblycontroller_pskel::
+  assemblycontroller_pskel ()
+  : componentinstantiationref_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // connections_pskel
+  //
+
+  void connections_pskel::
+  connectinterface_parser (::sad::connectinterface_pskel& p)
+  {
+    this->connectinterface_parser_ = &p;
+  }
+
+  void connections_pskel::
+  parsers (::sad::connectinterface_pskel& connectinterface)
+  {
+    this->connectinterface_parser_ = &connectinterface;
+  }
+
+  connections_pskel::
+  connections_pskel ()
+  : connectinterface_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // connectinterface_pskel
+  //
+
+  void connectinterface_pskel::
+  usesport_parser (::sad::usesport_pskel& p)
+  {
+    this->usesport_parser_ = &p;
+  }
+
+  void connectinterface_pskel::
+  providesport_parser (::sad::providesport_pskel& p)
+  {
+    this->providesport_parser_ = &p;
+  }
+
+  void connectinterface_pskel::
+  componentsupportedinterface_parser (::sad::componentsupportedinterface_pskel& p)
+  {
+    this->componentsupportedinterface_parser_ = &p;
+  }
+
+  void connectinterface_pskel::
+  findby_parser (::sad::findby_pskel& p)
+  {
+    this->findby_parser_ = &p;
+  }
+
+  void connectinterface_pskel::
+  id_parser (::xml_schema::string_pskel& p)
+  {
+    this->id_parser_ = &p;
+  }
+
+  void connectinterface_pskel::
+  parsers (::sad::usesport_pskel& usesport,
+           ::sad::providesport_pskel& providesport,
+           ::sad::componentsupportedinterface_pskel& componentsupportedinterface,
+           ::sad::findby_pskel& findby,
+           ::xml_schema::string_pskel& id)
+  {
+    this->usesport_parser_ = &usesport;
+    this->providesport_parser_ = &providesport;
+    this->componentsupportedinterface_parser_ = &componentsupportedinterface;
+    this->findby_parser_ = &findby;
+    this->id_parser_ = &id;
+  }
+
+  connectinterface_pskel::
+  connectinterface_pskel ()
+  : usesport_parser_ (0),
+    providesport_parser_ (0),
+    componentsupportedinterface_parser_ (0),
+    findby_parser_ (0),
+    id_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // usesport_pskel
+  //
+
+  void usesport_pskel::
+  usesidentifier_parser (::xml_schema::string_pskel& p)
+  {
+    this->usesidentifier_parser_ = &p;
+  }
+
+  void usesport_pskel::
+  componentinstantiationref_parser (::sad::componentinstantiationref_pskel& p)
+  {
+    this->componentinstantiationref_parser_ = &p;
+  }
+
+  void usesport_pskel::
+  devicethatloadedthiscomponentref_parser (::sad::devicethatloadedthiscomponentref_pskel& p)
+  {
+    this->devicethatloadedthiscomponentref_parser_ = &p;
+  }
+
+  void usesport_pskel::
+  deviceusedbythiscomponentref_parser (::sad::deviceusedbythiscomponentref_pskel& p)
+  {
+    this->deviceusedbythiscomponentref_parser_ = &p;
+  }
+
+  void usesport_pskel::
+  deviceusedbyapplication_parser (::sad::deviceusedbyapplication_pskel& p)
+  {
+    this->deviceusedbyapplication_parser_ = &p;
+  }
+
+  void usesport_pskel::
+  findby_parser (::sad::findby_pskel& p)
+  {
+    this->findby_parser_ = &p;
+  }
+
+  void usesport_pskel::
+  parsers (::xml_schema::string_pskel& usesidentifier,
+           ::sad::componentinstantiationref_pskel& componentinstantiationref,
+           ::sad::devicethatloadedthiscomponentref_pskel& devicethatloadedthiscomponentref,
+           ::sad::deviceusedbythiscomponentref_pskel& deviceusedbythiscomponentref,
+           ::sad::deviceusedbyapplication_pskel& deviceusedbyapplication,
+           ::sad::findby_pskel& findby)
+  {
+    this->usesidentifier_parser_ = &usesidentifier;
+    this->componentinstantiationref_parser_ = &componentinstantiationref;
+    this->devicethatloadedthiscomponentref_parser_ = &devicethatloadedthiscomponentref;
+    this->deviceusedbythiscomponentref_parser_ = &deviceusedbythiscomponentref;
+    this->deviceusedbyapplication_parser_ = &deviceusedbyapplication;
+    this->findby_parser_ = &findby;
+  }
+
+  usesport_pskel::
+  usesport_pskel ()
+  : usesidentifier_parser_ (0),
+    componentinstantiationref_parser_ (0),
+    devicethatloadedthiscomponentref_parser_ (0),
+    deviceusedbythiscomponentref_parser_ (0),
+    deviceusedbyapplication_parser_ (0),
+    findby_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // providesport_pskel
+  //
+
+  void providesport_pskel::
+  providesidentifier_parser (::xml_schema::string_pskel& p)
+  {
+    this->providesidentifier_parser_ = &p;
+  }
+
+  void providesport_pskel::
+  componentinstantiationref_parser (::sad::componentinstantiationref_pskel& p)
+  {
+    this->componentinstantiationref_parser_ = &p;
+  }
+
+  void providesport_pskel::
+  devicethatloadedthiscomponentref_parser (::sad::devicethatloadedthiscomponentref_pskel& p)
+  {
+    this->devicethatloadedthiscomponentref_parser_ = &p;
+  }
+
+  void providesport_pskel::
+  deviceusedbythiscomponentref_parser (::sad::deviceusedbythiscomponentref_pskel& p)
+  {
+    this->deviceusedbythiscomponentref_parser_ = &p;
+  }
+
+  void providesport_pskel::
+  deviceusedbyapplication_parser (::sad::deviceusedbyapplication_pskel& p)
+  {
+    this->deviceusedbyapplication_parser_ = &p;
+  }
+
+  void providesport_pskel::
+  findby_parser (::sad::findby_pskel& p)
+  {
+    this->findby_parser_ = &p;
+  }
+
+  void providesport_pskel::
+  parsers (::xml_schema::string_pskel& providesidentifier,
+           ::sad::componentinstantiationref_pskel& componentinstantiationref,
+           ::sad::devicethatloadedthiscomponentref_pskel& devicethatloadedthiscomponentref,
+           ::sad::deviceusedbythiscomponentref_pskel& deviceusedbythiscomponentref,
+           ::sad::deviceusedbyapplication_pskel& deviceusedbyapplication,
+           ::sad::findby_pskel& findby)
+  {
+    this->providesidentifier_parser_ = &providesidentifier;
+    this->componentinstantiationref_parser_ = &componentinstantiationref;
+    this->devicethatloadedthiscomponentref_parser_ = &devicethatloadedthiscomponentref;
+    this->deviceusedbythiscomponentref_parser_ = &deviceusedbythiscomponentref;
+    this->deviceusedbyapplication_parser_ = &deviceusedbyapplication;
+    this->findby_parser_ = &findby;
+  }
+
+  providesport_pskel::
+  providesport_pskel ()
+  : providesidentifier_parser_ (0),
+    componentinstantiationref_parser_ (0),
+    devicethatloadedthiscomponentref_parser_ (0),
+    deviceusedbythiscomponentref_parser_ (0),
+    deviceusedbyapplication_parser_ (0),
+    findby_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // componentsupportedinterface_pskel
+  //
+
+  void componentsupportedinterface_pskel::
+  supportedidentifier_parser (::xml_schema::string_pskel& p)
+  {
+    this->supportedidentifier_parser_ = &p;
+  }
+
+  void componentsupportedinterface_pskel::
+  componentinstantiationref_parser (::sad::componentinstantiationref_pskel& p)
+  {
+    this->componentinstantiationref_parser_ = &p;
+  }
+
+  void componentsupportedinterface_pskel::
+  devicethatloadedthiscomponentref_parser (::sad::devicethatloadedthiscomponentref_pskel& p)
+  {
+    this->devicethatloadedthiscomponentref_parser_ = &p;
+  }
+
+  void componentsupportedinterface_pskel::
+  deviceusedbythiscomponentref_parser (::sad::deviceusedbythiscomponentref_pskel& p)
+  {
+    this->deviceusedbythiscomponentref_parser_ = &p;
+  }
+
+  void componentsupportedinterface_pskel::
+  deviceusedbyapplication_parser (::sad::deviceusedbyapplication_pskel& p)
+  {
+    this->deviceusedbyapplication_parser_ = &p;
+  }
+
+  void componentsupportedinterface_pskel::
+  findby_parser (::sad::findby_pskel& p)
+  {
+    this->findby_parser_ = &p;
+  }
+
+  void componentsupportedinterface_pskel::
+  parsers (::xml_schema::string_pskel& supportedidentifier,
+           ::sad::componentinstantiationref_pskel& componentinstantiationref,
+           ::sad::devicethatloadedthiscomponentref_pskel& devicethatloadedthiscomponentref,
+           ::sad::deviceusedbythiscomponentref_pskel& deviceusedbythiscomponentref,
+           ::sad::deviceusedbyapplication_pskel& deviceusedbyapplication,
+           ::sad::findby_pskel& findby)
+  {
+    this->supportedidentifier_parser_ = &supportedidentifier;
+    this->componentinstantiationref_parser_ = &componentinstantiationref;
+    this->devicethatloadedthiscomponentref_parser_ = &devicethatloadedthiscomponentref;
+    this->deviceusedbythiscomponentref_parser_ = &deviceusedbythiscomponentref;
+    this->deviceusedbyapplication_parser_ = &deviceusedbyapplication;
+    this->findby_parser_ = &findby;
+  }
+
+  componentsupportedinterface_pskel::
+  componentsupportedinterface_pskel ()
+  : supportedidentifier_parser_ (0),
+    componentinstantiationref_parser_ (0),
+    devicethatloadedthiscomponentref_parser_ (0),
+    deviceusedbythiscomponentref_parser_ (0),
+    deviceusedbyapplication_parser_ (0),
+    findby_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // externalports_pskel
+  //
+
+  void externalports_pskel::
+  port_parser (::sad::port_pskel& p)
+  {
+    this->port_parser_ = &p;
+  }
+
+  void externalports_pskel::
+  parsers (::sad::port_pskel& port)
+  {
+    this->port_parser_ = &port;
+  }
+
+  externalports_pskel::
+  externalports_pskel ()
+  : port_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // port_pskel
+  //
+
+  void port_pskel::
+  description_parser (::xml_schema::string_pskel& p)
+  {
+    this->description_parser_ = &p;
+  }
+
+  void port_pskel::
+  usesidentifier_parser (::xml_schema::string_pskel& p)
+  {
+    this->usesidentifier_parser_ = &p;
+  }
+
+  void port_pskel::
+  providesidentifier_parser (::xml_schema::string_pskel& p)
+  {
+    this->providesidentifier_parser_ = &p;
+  }
+
+  void port_pskel::
+  supportedidentifier_parser (::xml_schema::string_pskel& p)
+  {
+    this->supportedidentifier_parser_ = &p;
+  }
+
+  void port_pskel::
+  componentinstantiationref_parser (::sad::componentinstantiationref_pskel& p)
+  {
+    this->componentinstantiationref_parser_ = &p;
+  }
+
+  void port_pskel::
+  externalname_parser (::xml_schema::string_pskel& p)
+  {
+    this->externalname_parser_ = &p;
+  }
+
+  void port_pskel::
+  parsers (::xml_schema::string_pskel& description,
+           ::xml_schema::string_pskel& usesidentifier,
+           ::xml_schema::string_pskel& providesidentifier,
+           ::xml_schema::string_pskel& supportedidentifier,
+           ::sad::componentinstantiationref_pskel& componentinstantiationref,
+           ::xml_schema::string_pskel& externalname)
+  {
+    this->description_parser_ = &description;
+    this->usesidentifier_parser_ = &usesidentifier;
+    this->providesidentifier_parser_ = &providesidentifier;
+    this->supportedidentifier_parser_ = &supportedidentifier;
+    this->componentinstantiationref_parser_ = &componentinstantiationref;
+    this->externalname_parser_ = &externalname;
+  }
+
+  port_pskel::
+  port_pskel ()
+  : description_parser_ (0),
+    usesidentifier_parser_ (0),
+    providesidentifier_parser_ (0),
+    supportedidentifier_parser_ (0),
+    componentinstantiationref_parser_ (0),
+    externalname_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // externalproperties_pskel
+  //
+
+  void externalproperties_pskel::
+  property_parser (::sad::property_pskel& p)
+  {
+    this->property_parser_ = &p;
+  }
+
+  void externalproperties_pskel::
+  parsers (::sad::property_pskel& property)
+  {
+    this->property_parser_ = &property;
+  }
+
+  externalproperties_pskel::
+  externalproperties_pskel ()
+  : property_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // property_pskel
+  //
+
+  void property_pskel::
+  comprefid_parser (::xml_schema::string_pskel& p)
+  {
+    this->comprefid_parser_ = &p;
+  }
+
+  void property_pskel::
+  propid_parser (::xml_schema::string_pskel& p)
+  {
+    this->propid_parser_ = &p;
+  }
+
+  void property_pskel::
+  externalpropid_parser (::xml_schema::string_pskel& p)
+  {
+    this->externalpropid_parser_ = &p;
+  }
+
+  void property_pskel::
+  parsers (::xml_schema::string_pskel& comprefid,
+           ::xml_schema::string_pskel& propid,
+           ::xml_schema::string_pskel& externalpropid)
+  {
+    this->comprefid_parser_ = &comprefid;
+    this->propid_parser_ = &propid;
+    this->externalpropid_parser_ = &externalpropid;
+  }
+
+  property_pskel::
+  property_pskel ()
+  : comprefid_parser_ (0),
+    propid_parser_ (0),
+    externalpropid_parser_ (0),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // usesdevicedependencies_pskel
+  //
+
+  void usesdevicedependencies_pskel::
+  usesdevice_parser (::sad::usesdevice_pskel& p)
+  {
+    this->usesdevice_parser_ = &p;
+  }
+
+  void usesdevicedependencies_pskel::
+  parsers (::sad::usesdevice_pskel& usesdevice)
+  {
+    this->usesdevice_parser_ = &usesdevice;
+  }
+
+  usesdevicedependencies_pskel::
+  usesdevicedependencies_pskel ()
+  : usesdevice_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // usesdevice_pskel
+  //
+
+  void usesdevice_pskel::
+  propertyref_parser (::sad::propertyref_pskel& p)
+  {
+    this->propertyref_parser_ = &p;
+  }
+
+  void usesdevice_pskel::
+  simpleref_parser (::sad::simpleref_pskel& p)
+  {
+    this->simpleref_parser_ = &p;
+  }
+
+  void usesdevice_pskel::
+  simplesequenceref_parser (::sad::simplesequenceref_pskel& p)
+  {
+    this->simplesequenceref_parser_ = &p;
+  }
+
+  void usesdevice_pskel::
+  structref_parser (::sad::structref_pskel& p)
+  {
+    this->structref_parser_ = &p;
+  }
+
+  void usesdevice_pskel::
+  structsequenceref_parser (::sad::structsequenceref_pskel& p)
+  {
+    this->structsequenceref_parser_ = &p;
+  }
+
+  void usesdevice_pskel::
+  id_parser (::xml_schema::string_pskel& p)
+  {
+    this->id_parser_ = &p;
+  }
+
+  void usesdevice_pskel::
+  type_parser (::xml_schema::string_pskel& p)
+  {
+    this->type_parser_ = &p;
+  }
+
+  void usesdevice_pskel::
+  parsers (::sad::propertyref_pskel& propertyref,
+           ::sad::simpleref_pskel& simpleref,
+           ::sad::simplesequenceref_pskel& simplesequenceref,
+           ::sad::structref_pskel& structref,
+           ::sad::structsequenceref_pskel& structsequenceref,
+           ::xml_schema::string_pskel& id,
+           ::xml_schema::string_pskel& type)
+  {
+    this->propertyref_parser_ = &propertyref;
+    this->simpleref_parser_ = &simpleref;
+    this->simplesequenceref_parser_ = &simplesequenceref;
+    this->structref_parser_ = &structref;
+    this->structsequenceref_parser_ = &structsequenceref;
+    this->id_parser_ = &id;
+    this->type_parser_ = &type;
+  }
+
+  usesdevice_pskel::
+  usesdevice_pskel ()
+  : propertyref_parser_ (0),
+    simpleref_parser_ (0),
+    simplesequenceref_parser_ (0),
+    structref_parser_ (0),
+    structsequenceref_parser_ (0),
+    id_parser_ (0),
+    type_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // propertyref_pskel
+  //
+
+  void propertyref_pskel::
+  refid_parser (::xml_schema::string_pskel& p)
+  {
+    this->refid_parser_ = &p;
+  }
+
+  void propertyref_pskel::
+  value_parser (::xml_schema::string_pskel& p)
+  {
+    this->value_parser_ = &p;
+  }
+
+  void propertyref_pskel::
+  parsers (::xml_schema::string_pskel& refid,
+           ::xml_schema::string_pskel& value)
+  {
+    this->refid_parser_ = &refid;
+    this->value_parser_ = &value;
+  }
+
+  propertyref_pskel::
+  propertyref_pskel ()
+  : refid_parser_ (0),
+    value_parser_ (0),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+}
+
+namespace sad
+{
+  // softwareassembly_pskel
+  //
+
+  void softwareassembly_pskel::
+  description (const ::std::string&)
+  {
+  }
+
+  void softwareassembly_pskel::
+  componentfiles (const ::std::vector<ossie::ComponentFile>&)
+  {
+  }
+
+  void softwareassembly_pskel::
+  partitioning (const ossie::SoftwareAssembly::Partitioning&)
+  {
+  }
+
+  void softwareassembly_pskel::
+  assemblycontroller (const ::std::string&)
+  {
+  }
+
+  void softwareassembly_pskel::
+  connections (const ::std::vector<ossie::Connection>&)
+  {
+  }
+
+  void softwareassembly_pskel::
+  externalports (const ::std::vector<ossie::SoftwareAssembly::Port>&)
+  {
+  }
+
+  void softwareassembly_pskel::
+  externalproperties (const ::std::vector<ossie::SoftwareAssembly::Property>&)
+  {
+  }
+
+  void softwareassembly_pskel::
+  usesdevicedependencies (const ::std::vector<ossie::SoftwareAssembly::UsesDevice>&)
+  {
+  }
+
+  void softwareassembly_pskel::
+  id (const ::std::string&)
+  {
+  }
+
+  void softwareassembly_pskel::
+  name (const ::std::string&)
+  {
+  }
+
+  void softwareassembly_pskel::
+  version (const ::std::string&)
+  {
+  }
+
+  // componentfiles_pskel
+  //
+
+  void componentfiles_pskel::
+  componentfile (const ::ossie::ComponentFile&)
+  {
+  }
+
+  // componentfile_pskel
+  //
+
+  void componentfile_pskel::
+  localfile (const ::std::string&)
+  {
+  }
+
+  void componentfile_pskel::
+  id (const ::std::string&)
+  {
+  }
+
+  void componentfile_pskel::
+  type (const ::std::string&)
+  {
+  }
+
+  // localfile_pskel
+  //
+
+  void localfile_pskel::
+  name (const ::std::string&)
+  {
+  }
+
+  // partitioning_pskel
+  //
+
+  void partitioning_pskel::
+  componentplacement (const ::ossie::ComponentPlacement&)
+  {
+  }
+
+  void partitioning_pskel::
+  hostcollocation (const ::ossie::SoftwareAssembly::HostCollocation&)
+  {
+  }
+
+  // componentplacement_pskel
+  //
+
+  void componentplacement_pskel::
+  componentfileref (const ::std::string&)
+  {
+  }
+
+  void componentplacement_pskel::
+  componentinstantiation (const ::ossie::ComponentInstantiation&)
+  {
+  }
+
+  // componentfileref_pskel
+  //
+
+  void componentfileref_pskel::
+  refid (const ::std::string&)
+  {
+  }
+
+  // componentinstantiation_pskel
+  //
+
+  void componentinstantiation_pskel::
+  usagename (const ::std::string&)
+  {
+  }
+
+  void componentinstantiation_pskel::
+  componentproperties (const ::std::vector<ossie::ComponentProperty*>&)
+  {
+  }
+
+  void componentinstantiation_pskel::
+  affinity (const  ossie::ComponentInstantiation::AffinityProperties &)
+  {
+  }
+
+  void componentinstantiation_pskel::
+  loggingconfig (const  ossie::ComponentInstantiation::LoggingConfig &)
+  {
+  }
+
+  void componentinstantiation_pskel::
+  findcomponent (const ::std::string&)
+  {
+  }
+
+  void componentinstantiation_pskel::
+  id (const ::std::string&)
+  {
+  }
+
+  void componentinstantiation_pskel::
+  startorder (const ::std::string&)
+  {
+  }
+
+  // loggingconfig_pskel
+  //
+
+  void loggingconfig_pskel::
+  level (const ::std::string&)
+  {
+  }
+
+  // affinity_pskel
+  //
+
+  void affinity_pskel::
+  simpleref (ossie::SimplePropertyRef*)
+  {
+  }
+
+  void affinity_pskel::
+  simplesequenceref (ossie::SimpleSequencePropertyRef*)
+  {
+  }
+
+  void affinity_pskel::
+  structref (ossie::StructPropertyRef*)
+  {
+  }
+
+  void affinity_pskel::
+  structsequenceref (ossie::StructSequencePropertyRef*)
+  {
+  }
+
+  // componentproperties_pskel
+  //
+
+  void componentproperties_pskel::
+  simpleref (ossie::SimplePropertyRef*)
+  {
+  }
+
+  void componentproperties_pskel::
+  simplesequenceref (ossie::SimpleSequencePropertyRef*)
+  {
+  }
+
+  void componentproperties_pskel::
+  structref (ossie::StructPropertyRef*)
+  {
+  }
+
+  void componentproperties_pskel::
+  structsequenceref (ossie::StructSequencePropertyRef*)
+  {
+  }
+
+  // findcomponent_pskel
+  //
+
+  void findcomponent_pskel::
+  componentresourcefactoryref ()
+  {
+  }
+
+  void findcomponent_pskel::
+  namingservice (const ::std::string&)
+  {
+  }
+
+  // componentresourcefactoryref_pskel
+  //
+
+  void componentresourcefactoryref_pskel::
+  resourcefactoryproperties ()
+  {
+  }
+
+  void componentresourcefactoryref_pskel::
+  refid (const ::std::string&)
+  {
+  }
+
+  void componentresourcefactoryref_pskel::
+  post_componentresourcefactoryref ()
+  {
+  }
+
+  // devicethatloadedthiscomponentref_pskel
+  //
+
+  void devicethatloadedthiscomponentref_pskel::
+  refid (const ::std::string&)
+  {
+  }
+
+  // deviceusedbythiscomponentref_pskel
+  //
+
+  void deviceusedbythiscomponentref_pskel::
+  refid (const ::std::string&)
+  {
+  }
+
+  void deviceusedbythiscomponentref_pskel::
+  usesrefid (const ::std::string&)
+  {
+  }
+
+  // deviceusedbyapplication_pskel
+  //
+
+  void deviceusedbyapplication_pskel::
+  usesrefid (const ::std::string&)
+  {
+  }
+
+  // resourcefactoryproperties_pskel
+  //
+
+  void resourcefactoryproperties_pskel::
+  simpleref (ossie::SimplePropertyRef*)
+  {
+  }
+
+  void resourcefactoryproperties_pskel::
+  simplesequenceref (ossie::SimpleSequencePropertyRef*)
+  {
+  }
+
+  void resourcefactoryproperties_pskel::
+  structref (ossie::StructPropertyRef*)
+  {
+  }
+
+  void resourcefactoryproperties_pskel::
+  structsequenceref (ossie::StructSequencePropertyRef*)
+  {
+  }
+
+  void resourcefactoryproperties_pskel::
+  post_resourcefactoryproperties ()
+  {
+  }
+
+  // simpleref_pskel
+  //
+
+  void simpleref_pskel::
+  refid (const ::std::string&)
+  {
+  }
+
+  void simpleref_pskel::
+  value (const ::std::string&)
+  {
+  }
+
+  // simplesequenceref_pskel
+  //
+
+  void simplesequenceref_pskel::
+  values (const ::std::vector<std::string>&)
+  {
+  }
+
+  void simplesequenceref_pskel::
+  refid (const ::std::string&)
+  {
+  }
+
+  // structref_pskel
+  //
+
+  void structref_pskel::
+  simpleref (ossie::SimplePropertyRef*)
+  {
+  }
+
+  void structref_pskel::
+  simplesequenceref (ossie::SimpleSequencePropertyRef*)
+  {
+  }
+
+  void structref_pskel::
+  refid (const ::std::string&)
+  {
+  }
+
+  // structsequenceref_pskel
+  //
+
+  void structsequenceref_pskel::
+  structvalue (const ::std::map<std::string, ossie::ComponentProperty*>&)
+  {
+  }
+
+  void structsequenceref_pskel::
+  refid (const ::std::string&)
+  {
+  }
+
+  // structvalue_pskel
+  //
+
+  void structvalue_pskel::
+  simpleref (ossie::SimplePropertyRef*)
+  {
+  }
+
+  void structvalue_pskel::
+  simplesequenceref (ossie::SimpleSequencePropertyRef*)
+  {
+  }
+
+  // values_pskel
+  //
+
+  void values_pskel::
+  value (const ::std::string&)
+  {
+  }
+
+  // componentinstantiationref_pskel
+  //
+
+  void componentinstantiationref_pskel::
+  refid (const ::std::string&)
+  {
+  }
+
+  // findby_pskel
+  //
+
+  void findby_pskel::
+  namingservice (const ::std::string&)
+  {
+  }
+
+  void findby_pskel::
+  stringifiedobjectref (const ::std::string&)
+  {
+  }
+
+  void findby_pskel::
+  domainfinder (const ::std::pair<std::string, std::string>&)
+  {
+  }
+
+  // namingservice_pskel
+  //
+
+  void namingservice_pskel::
+  name (const ::std::string&)
+  {
+  }
+
+  // domainfinder_pskel
+  //
+
+  void domainfinder_pskel::
+  type (const ::std::string&)
+  {
+  }
+
+  void domainfinder_pskel::
+  name (const ::std::string&)
+  {
+  }
+
+  // hostcollocation_pskel
+  //
+
+  void hostcollocation_pskel::
+  componentplacement (const ::ossie::ComponentPlacement&)
+  {
+  }
+
+  void hostcollocation_pskel::
+  id (const ::std::string&)
+  {
+  }
+
+  void hostcollocation_pskel::
+  name (const ::std::string&)
+  {
+  }
+
+  // assemblycontroller_pskel
+  //
+
+  void assemblycontroller_pskel::
+  componentinstantiationref (const ::std::string&)
+  {
+  }
+
+  // connections_pskel
+  //
+
+  void connections_pskel::
+  connectinterface (const ::ossie::Connection&)
+  {
+  }
+
+  // connectinterface_pskel
+  //
+
+  void connectinterface_pskel::
+  usesport (const ::ossie::UsesPort&)
+  {
+  }
+
+  void connectinterface_pskel::
+  providesport (const ::ossie::ProvidesPort&)
+  {
+  }
+
+  void connectinterface_pskel::
+  componentsupportedinterface (const ::ossie::ComponentSupportedInterface&)
+  {
+  }
+
+  void connectinterface_pskel::
+  findby (const ::ossie::FindBy&)
+  {
+  }
+
+  void connectinterface_pskel::
+  id (const ::std::string&)
+  {
+  }
+
+  // usesport_pskel
+  //
+
+  void usesport_pskel::
+  usesidentifier (const ::std::string&)
+  {
+  }
+
+  void usesport_pskel::
+  componentinstantiationref (const ::std::string&)
+  {
+  }
+
+  void usesport_pskel::
+  devicethatloadedthiscomponentref (const ::std::string&)
+  {
+  }
+
+  void usesport_pskel::
+  deviceusedbythiscomponentref (const ::std::pair<std::string, std::string>&)
+  {
+  }
+
+  void usesport_pskel::
+  deviceusedbyapplication (const ::std::string&)
+  {
+  }
+
+  void usesport_pskel::
+  findby (const ::ossie::FindBy&)
+  {
+  }
+
+  // providesport_pskel
+  //
+
+  void providesport_pskel::
+  providesidentifier (const ::std::string&)
+  {
+  }
+
+  void providesport_pskel::
+  componentinstantiationref (const ::std::string&)
+  {
+  }
+
+  void providesport_pskel::
+  devicethatloadedthiscomponentref (const ::std::string&)
+  {
+  }
+
+  void providesport_pskel::
+  deviceusedbythiscomponentref (const ::std::pair<std::string, std::string>&)
+  {
+  }
+
+  void providesport_pskel::
+  deviceusedbyapplication (const ::std::string&)
+  {
+  }
+
+  void providesport_pskel::
+  findby (const ::ossie::FindBy&)
+  {
+  }
+
+  // componentsupportedinterface_pskel
+  //
+
+  void componentsupportedinterface_pskel::
+  supportedidentifier (const ::std::string&)
+  {
+  }
+
+  void componentsupportedinterface_pskel::
+  componentinstantiationref (const ::std::string&)
+  {
+  }
+
+  void componentsupportedinterface_pskel::
+  devicethatloadedthiscomponentref (const ::std::string&)
+  {
+  }
+
+  void componentsupportedinterface_pskel::
+  deviceusedbythiscomponentref (const ::std::pair<std::string, std::string>&)
+  {
+  }
+
+  void componentsupportedinterface_pskel::
+  deviceusedbyapplication (const ::std::string&)
+  {
+  }
+
+  void componentsupportedinterface_pskel::
+  findby (const ::ossie::FindBy&)
+  {
+  }
+
+  // externalports_pskel
+  //
+
+  void externalports_pskel::
+  port (const ossie::SoftwareAssembly::Port&)
+  {
+  }
+
+  // port_pskel
+  //
+
+  void port_pskel::
+  description (const ::std::string&)
+  {
+  }
+
+  void port_pskel::
+  usesidentifier (const ::std::string&)
+  {
+  }
+
+  void port_pskel::
+  providesidentifier (const ::std::string&)
+  {
+  }
+
+  void port_pskel::
+  supportedidentifier (const ::std::string&)
+  {
+  }
+
+  void port_pskel::
+  componentinstantiationref (const ::std::string&)
+  {
+  }
+
+  void port_pskel::
+  externalname (const ::std::string&)
+  {
+  }
+
+  // externalproperties_pskel
+  //
+
+  void externalproperties_pskel::
+  property (const ossie::SoftwareAssembly::Property&)
+  {
+  }
+
+  // property_pskel
+  //
+
+  void property_pskel::
+  comprefid (const ::std::string&)
+  {
+  }
+
+  void property_pskel::
+  propid (const ::std::string&)
+  {
+  }
+
+  void property_pskel::
+  externalpropid (const ::std::string&)
+  {
+  }
+
+  // usesdevicedependencies_pskel
+  //
+
+  void usesdevicedependencies_pskel::
+  usesdevice (const ossie::SoftwareAssembly::UsesDevice&)
+  {
+  }
+
+  // usesdevice_pskel
+  //
+
+  void usesdevice_pskel::
+  propertyref (const ossie::SoftwareAssembly::PropertyRef&)
+  {
+  }
+
+  void usesdevice_pskel::
+  simpleref (ossie::SimplePropertyRef*)
+  {
+  }
+
+  void usesdevice_pskel::
+  simplesequenceref (ossie::SimpleSequencePropertyRef*)
+  {
+  }
+
+  void usesdevice_pskel::
+  structref (ossie::StructPropertyRef*)
+  {
+  }
+
+  void usesdevice_pskel::
+  structsequenceref (ossie::StructSequencePropertyRef*)
+  {
+  }
+
+  void usesdevice_pskel::
+  id (const ::std::string&)
+  {
+  }
+
+  void usesdevice_pskel::
+  type (const ::std::string&)
+  {
+  }
+
+  // propertyref_pskel
+  //
+
+  void propertyref_pskel::
+  refid (const ::std::string&)
+  {
+  }
+
+  void propertyref_pskel::
+  value (const ::std::string&)
+  {
+  }
+}
+
+#include <cassert>
+
+namespace sad
+{
+  // Element validation and dispatch functions for softwareassembly_pskel.
+  //
+  bool softwareassembly_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "description" && ns.empty ())
+          s = 0UL;
+        else if (n == "componentfiles" && ns.empty ())
+          s = 1UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &softwareassembly_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "description",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool softwareassembly_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void softwareassembly_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void softwareassembly_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "description");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void softwareassembly_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "description" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->description_parser_;
+
+            if (this->description_parser_)
+              this->description_parser_->pre ();
+          }
+          else
+          {
+            if (this->description_parser_)
+            {
+              const ::std::string& tmp (this->description_parser_->post_string ());
+              this->description (tmp);
+            }
+
+            count = 0;
+            state = 1UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 1UL;
+          // Fall through.
+        }
+      }
+      case 1UL:
+      {
+        if (n == "componentfiles" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->componentfiles_parser_;
+
+            if (this->componentfiles_parser_)
+              this->componentfiles_parser_->pre ();
+          }
+          else
+          {
+            if (this->componentfiles_parser_)
+            {
+              const ::std::vector<ossie::ComponentFile>& tmp (this->componentfiles_parser_->post_componentfiles ());
+              this->componentfiles (tmp);
+            }
+
+            count = 0;
+            state = 2UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "componentfiles",
+              ns, n);
+          count = 0;
+          state = 2UL;
+          // Fall through.
+        }
+      }
+      case 2UL:
+      {
+        if (n == "partitioning" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->partitioning_parser_;
+
+            if (this->partitioning_parser_)
+              this->partitioning_parser_->pre ();
+          }
+          else
+          {
+            if (this->partitioning_parser_)
+            {
+              const ossie::SoftwareAssembly::Partitioning& tmp (this->partitioning_parser_->post_partitioning ());
+              this->partitioning (tmp);
+            }
+
+            count = 0;
+            state = 3UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "partitioning",
+              ns, n);
+          count = 0;
+          state = 3UL;
+          // Fall through.
+        }
+      }
+      case 3UL:
+      {
+        if (n == "assemblycontroller" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->assemblycontroller_parser_;
+
+            if (this->assemblycontroller_parser_)
+              this->assemblycontroller_parser_->pre ();
+          }
+          else
+          {
+            if (this->assemblycontroller_parser_)
+            {
+              const ::std::string& tmp (this->assemblycontroller_parser_->post_assemblycontroller ());
+              this->assemblycontroller (tmp);
+            }
+
+            count = 0;
+            state = 4UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "assemblycontroller",
+              ns, n);
+          count = 0;
+          state = 4UL;
+          // Fall through.
+        }
+      }
+      case 4UL:
+      {
+        if (n == "connections" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->connections_parser_;
+
+            if (this->connections_parser_)
+              this->connections_parser_->pre ();
+          }
+          else
+          {
+            if (this->connections_parser_)
+            {
+              const ::std::vector<ossie::Connection>& tmp (this->connections_parser_->post_connections ());
+              this->connections (tmp);
+            }
+
+            count = 0;
+            state = 5UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 5UL;
+          // Fall through.
+        }
+      }
+      case 5UL:
+      {
+        if (n == "externalports" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->externalports_parser_;
+
+            if (this->externalports_parser_)
+              this->externalports_parser_->pre ();
+          }
+          else
+          {
+            if (this->externalports_parser_)
+            {
+              const ::std::vector<ossie::SoftwareAssembly::Port>& tmp (this->externalports_parser_->post_externalports ());
+              this->externalports (tmp);
+            }
+
+            count = 0;
+            state = 6UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 6UL;
+          // Fall through.
+        }
+      }
+      case 6UL:
+      {
+        if (n == "externalproperties" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->externalproperties_parser_;
+
+            if (this->externalproperties_parser_)
+              this->externalproperties_parser_->pre ();
+          }
+          else
+          {
+            if (this->externalproperties_parser_)
+            {
+              const ::std::vector<ossie::SoftwareAssembly::Property>& tmp (this->externalproperties_parser_->post_externalproperties ());
+              this->externalproperties (tmp);
+            }
+
+            count = 0;
+            state = 7UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 7UL;
+          // Fall through.
+        }
+      }
+      case 7UL:
+      {
+        if (n == "usesdevicedependencies" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->usesdevicedependencies_parser_;
+
+            if (this->usesdevicedependencies_parser_)
+              this->usesdevicedependencies_parser_->pre ();
+          }
+          else
+          {
+            if (this->usesdevicedependencies_parser_)
+            {
+              const ::std::vector<ossie::SoftwareAssembly::UsesDevice>& tmp (this->usesdevicedependencies_parser_->post_usesdevicedependencies ());
+              this->usesdevicedependencies (tmp);
+            }
+
+            count++;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for componentfiles_pskel.
+  //
+  bool componentfiles_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "componentfile" && ns.empty ())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &componentfiles_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "componentfile",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool componentfiles_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void componentfiles_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void componentfiles_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "componentfile");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void componentfiles_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "componentfile" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->componentfile_parser_;
+
+            if (this->componentfile_parser_)
+              this->componentfile_parser_->pre ();
+          }
+          else
+          {
+            if (this->componentfile_parser_)
+            {
+              const ::ossie::ComponentFile& tmp (this->componentfile_parser_->post_componentfile ());
+              this->componentfile (tmp);
+            }
+
+            count++;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "componentfile",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for componentfile_pskel.
+  //
+  bool componentfile_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "localfile" && ns.empty ())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &componentfile_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "localfile",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool componentfile_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void componentfile_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void componentfile_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "localfile");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void componentfile_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "localfile" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->localfile_parser_;
+
+            if (this->localfile_parser_)
+              this->localfile_parser_->pre ();
+          }
+          else
+          {
+            if (this->localfile_parser_)
+            {
+              const ::std::string& tmp (this->localfile_parser_->post_localfile ());
+              this->localfile (tmp);
+            }
+
+            count = 0;
+            state = ~0UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "localfile",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for partitioning_pskel.
+  //
+  bool partitioning_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "componentplacement" && ns.empty ())
+          s = 0UL;
+        else if (n == "hostcollocation" && ns.empty ())
+          s = 1UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+
+          vd = vs.data + vs.size++;
+          vd->func = &partitioning_pskel::choice_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->choice_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool partitioning_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void partitioning_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void partitioning_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+
+    this->v_state_stack_.pop ();
+  }
+
+  void partitioning_pskel::
+  choice_0 (unsigned long& state,
+            unsigned long& count,
+            const ::xml_schema::ro_string& ns,
+            const ::xml_schema::ro_string& n,
+            const ::xml_schema::ro_string* t,
+            bool start)
+  {
+    XSD_UNUSED (count);
+    XSD_UNUSED (ns);
+    XSD_UNUSED (n);
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->componentplacement_parser_;
+
+          if (this->componentplacement_parser_)
+            this->componentplacement_parser_->pre ();
+        }
+        else
+        {
+          if (this->componentplacement_parser_)
+          {
+            const ::ossie::ComponentPlacement& tmp (this->componentplacement_parser_->post_componentplacement ());
+            this->componentplacement (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 1UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->hostcollocation_parser_;
+
+          if (this->hostcollocation_parser_)
+            this->hostcollocation_parser_->pre ();
+        }
+        else
+        {
+          if (this->hostcollocation_parser_)
+          {
+            const ::ossie::SoftwareAssembly::HostCollocation& tmp (this->hostcollocation_parser_->post_hostcollocation ());
+            this->hostcollocation (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+    }
+  }
+
+  // Element validation and dispatch functions for componentplacement_pskel.
+  //
+  bool componentplacement_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "componentfileref" && ns.empty ())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &componentplacement_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "componentfileref",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool componentplacement_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void componentplacement_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void componentplacement_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "componentfileref");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void componentplacement_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "componentfileref" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->componentfileref_parser_;
+
+            if (this->componentfileref_parser_)
+              this->componentfileref_parser_->pre ();
+          }
+          else
+          {
+            if (this->componentfileref_parser_)
+            {
+              const ::std::string& tmp (this->componentfileref_parser_->post_componentfileref ());
+              this->componentfileref (tmp);
+            }
+
+            count = 0;
+            state = 1UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "componentfileref",
+              ns, n);
+          count = 0;
+          state = 1UL;
+          // Fall through.
+        }
+      }
+      case 1UL:
+      {
+        if (n == "componentinstantiation" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->componentinstantiation_parser_;
+
+            if (this->componentinstantiation_parser_)
+              this->componentinstantiation_parser_->pre ();
+          }
+          else
+          {
+            if (this->componentinstantiation_parser_)
+            {
+              const ::ossie::ComponentInstantiation& tmp (this->componentinstantiation_parser_->post_componentinstantiation ());
+              this->componentinstantiation (tmp);
+            }
+
+            count++;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "componentinstantiation",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for componentinstantiation_pskel.
+  //
+  bool componentinstantiation_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "usagename" && ns.empty ())
+          s = 0UL;
+        else if (n == "componentproperties" && ns.empty ())
+          s = 1UL;
+        else if (n == "affinity" && ns.empty ())
+          s = 2UL;
+        else if (n == "loggingconfig" && ns.empty ())
+          s = 3UL;
+        else if (n == "findcomponent" && ns.empty ())
+          s = 4UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &componentinstantiation_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool componentinstantiation_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void componentinstantiation_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void componentinstantiation_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+
+    this->v_state_stack_.pop ();
+  }
+
+  void componentinstantiation_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "usagename" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->usagename_parser_;
+
+            if (this->usagename_parser_)
+              this->usagename_parser_->pre ();
+          }
+          else
+          {
+            if (this->usagename_parser_)
+            {
+              const ::std::string& tmp (this->usagename_parser_->post_string ());
+              this->usagename (tmp);
+            }
+
+            count = 0;
+            state = 1UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 1UL;
+          // Fall through.
+        }
+      }
+      case 1UL:
+      {
+        if (n == "componentproperties" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->componentproperties_parser_;
+
+            if (this->componentproperties_parser_)
+              this->componentproperties_parser_->pre ();
+          }
+          else
+          {
+            if (this->componentproperties_parser_)
+            {
+              const ::std::vector<ossie::ComponentProperty*>& tmp (this->componentproperties_parser_->post_componentproperties ());
+              this->componentproperties (tmp);
+            }
+
+            count = 0;
+            state = 2UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 2UL;
+          // Fall through.
+        }
+      }
+      case 2UL:
+      {
+        if (n == "affinity" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->affinity_parser_;
+
+            if (this->affinity_parser_)
+              this->affinity_parser_->pre ();
+          }
+          else
+          {
+            if (this->affinity_parser_)
+            {
+              const  ossie::ComponentInstantiation::AffinityProperties & tmp (this->affinity_parser_->post_affinity ());
+              this->affinity (tmp);
+            }
+
+            count = 0;
+            state = 3UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 3UL;
+          // Fall through.
+        }
+      }
+      case 3UL:
+      {
+        if (n == "loggingconfig" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->loggingconfig_parser_;
+
+            if (this->loggingconfig_parser_)
+              this->loggingconfig_parser_->pre ();
+          }
+          else
+          {
+            if (this->loggingconfig_parser_)
+            {
+              const  ossie::ComponentInstantiation::LoggingConfig & tmp (this->loggingconfig_parser_->post_loggingconfig ());
+              this->loggingconfig (tmp);
+            }
+
+            count = 0;
+            state = 4UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 4UL;
+          // Fall through.
+        }
+      }
+      case 4UL:
+      {
+        if (n == "findcomponent" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->findcomponent_parser_;
+
+            if (this->findcomponent_parser_)
+              this->findcomponent_parser_->pre ();
+          }
+          else
+          {
+            if (this->findcomponent_parser_)
+            {
+              const ::std::string& tmp (this->findcomponent_parser_->post_findcomponent ());
+              this->findcomponent (tmp);
+            }
+
+            count = 0;
+            state = ~0UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for affinity_pskel.
+  //
+  bool affinity_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "simpleref" && ns.empty ())
+          s = 0UL;
+        else if (n == "simplesequenceref" && ns.empty ())
+          s = 1UL;
+        else if (n == "structref" && ns.empty ())
+          s = 2UL;
+        else if (n == "structsequenceref" && ns.empty ())
+          s = 3UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+
+          vd = vs.data + vs.size++;
+          vd->func = &affinity_pskel::choice_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->choice_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "simpleref",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool affinity_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void affinity_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void affinity_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "simpleref");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void affinity_pskel::
+  choice_0 (unsigned long& state,
+            unsigned long& count,
+            const ::xml_schema::ro_string& ns,
+            const ::xml_schema::ro_string& n,
+            const ::xml_schema::ro_string* t,
+            bool start)
+  {
+    XSD_UNUSED (count);
+    XSD_UNUSED (ns);
+    XSD_UNUSED (n);
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->simpleref_parser_;
+
+          if (this->simpleref_parser_)
+            this->simpleref_parser_->pre ();
+        }
+        else
+        {
+          if (this->simpleref_parser_)
+          {
+            ossie::SimplePropertyRef* tmp (this->simpleref_parser_->post_simpleref ());
+            this->simpleref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 1UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->simplesequenceref_parser_;
+
+          if (this->simplesequenceref_parser_)
+            this->simplesequenceref_parser_->pre ();
+        }
+        else
+        {
+          if (this->simplesequenceref_parser_)
+          {
+            ossie::SimpleSequencePropertyRef* tmp (this->simplesequenceref_parser_->post_simplesequenceref ());
+            this->simplesequenceref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 2UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->structref_parser_;
+
+          if (this->structref_parser_)
+            this->structref_parser_->pre ();
+        }
+        else
+        {
+          if (this->structref_parser_)
+          {
+            ossie::StructPropertyRef* tmp (this->structref_parser_->post_structref ());
+            this->structref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 3UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->structsequenceref_parser_;
+
+          if (this->structsequenceref_parser_)
+            this->structsequenceref_parser_->pre ();
+        }
+        else
+        {
+          if (this->structsequenceref_parser_)
+          {
+            ossie::StructSequencePropertyRef* tmp (this->structsequenceref_parser_->post_structsequenceref ());
+            this->structsequenceref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+    }
+  }
+
+  // Element validation and dispatch functions for componentproperties_pskel.
+  //
+  bool componentproperties_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "simpleref" && ns.empty ())
+          s = 0UL;
+        else if (n == "simplesequenceref" && ns.empty ())
+          s = 1UL;
+        else if (n == "structref" && ns.empty ())
+          s = 2UL;
+        else if (n == "structsequenceref" && ns.empty ())
+          s = 3UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+
+          vd = vs.data + vs.size++;
+          vd->func = &componentproperties_pskel::choice_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->choice_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "simpleref",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool componentproperties_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void componentproperties_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void componentproperties_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "simpleref");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void componentproperties_pskel::
+  choice_0 (unsigned long& state,
+            unsigned long& count,
+            const ::xml_schema::ro_string& ns,
+            const ::xml_schema::ro_string& n,
+            const ::xml_schema::ro_string* t,
+            bool start)
+  {
+    XSD_UNUSED (count);
+    XSD_UNUSED (ns);
+    XSD_UNUSED (n);
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->simpleref_parser_;
+
+          if (this->simpleref_parser_)
+            this->simpleref_parser_->pre ();
+        }
+        else
+        {
+          if (this->simpleref_parser_)
+          {
+            ossie::SimplePropertyRef* tmp (this->simpleref_parser_->post_simpleref ());
+            this->simpleref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 1UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->simplesequenceref_parser_;
+
+          if (this->simplesequenceref_parser_)
+            this->simplesequenceref_parser_->pre ();
+        }
+        else
+        {
+          if (this->simplesequenceref_parser_)
+          {
+            ossie::SimpleSequencePropertyRef* tmp (this->simplesequenceref_parser_->post_simplesequenceref ());
+            this->simplesequenceref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 2UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->structref_parser_;
+
+          if (this->structref_parser_)
+            this->structref_parser_->pre ();
+        }
+        else
+        {
+          if (this->structref_parser_)
+          {
+            ossie::StructPropertyRef* tmp (this->structref_parser_->post_structref ());
+            this->structref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 3UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->structsequenceref_parser_;
+
+          if (this->structsequenceref_parser_)
+            this->structsequenceref_parser_->pre ();
+        }
+        else
+        {
+          if (this->structsequenceref_parser_)
+          {
+            ossie::StructSequencePropertyRef* tmp (this->structsequenceref_parser_->post_structsequenceref ());
+            this->structsequenceref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+    }
+  }
+
+  // Element validation and dispatch functions for findcomponent_pskel.
+  //
+  bool findcomponent_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "componentresourcefactoryref" && ns.empty ())
+          s = 0UL;
+        else if (n == "namingservice" && ns.empty ())
+          s = 1UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &findcomponent_pskel::choice_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->choice_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "componentresourcefactoryref",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool findcomponent_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void findcomponent_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void findcomponent_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "componentresourcefactoryref");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void findcomponent_pskel::
+  choice_0 (unsigned long& state,
+            unsigned long& count,
+            const ::xml_schema::ro_string& ns,
+            const ::xml_schema::ro_string& n,
+            const ::xml_schema::ro_string* t,
+            bool start)
+  {
+    XSD_UNUSED (count);
+    XSD_UNUSED (ns);
+    XSD_UNUSED (n);
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->componentresourcefactoryref_parser_;
+
+          if (this->componentresourcefactoryref_parser_)
+            this->componentresourcefactoryref_parser_->pre ();
+        }
+        else
+        {
+          if (this->componentresourcefactoryref_parser_)
+          {
+            this->componentresourcefactoryref_parser_->post_componentresourcefactoryref ();
+            this->componentresourcefactoryref ();
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 1UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->namingservice_parser_;
+
+          if (this->namingservice_parser_)
+            this->namingservice_parser_->pre ();
+        }
+        else
+        {
+          if (this->namingservice_parser_)
+          {
+            const ::std::string& tmp (this->namingservice_parser_->post_namingservice ());
+            this->namingservice (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+    }
+  }
+
+  // Element validation and dispatch functions for componentresourcefactoryref_pskel.
+  //
+  bool componentresourcefactoryref_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "resourcefactoryproperties" && ns.empty ())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &componentresourcefactoryref_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool componentresourcefactoryref_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void componentresourcefactoryref_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void componentresourcefactoryref_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+
+    this->v_state_stack_.pop ();
+  }
+
+  void componentresourcefactoryref_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "resourcefactoryproperties" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->resourcefactoryproperties_parser_;
+
+            if (this->resourcefactoryproperties_parser_)
+              this->resourcefactoryproperties_parser_->pre ();
+          }
+          else
+          {
+            if (this->resourcefactoryproperties_parser_)
+            {
+              this->resourcefactoryproperties_parser_->post_resourcefactoryproperties ();
+              this->resourcefactoryproperties ();
+            }
+
+            count = 0;
+            state = ~0UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for resourcefactoryproperties_pskel.
+  //
+  bool resourcefactoryproperties_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "simpleref" && ns.empty ())
+          s = 0UL;
+        else if (n == "simplesequenceref" && ns.empty ())
+          s = 1UL;
+        else if (n == "structref" && ns.empty ())
+          s = 2UL;
+        else if (n == "structsequenceref" && ns.empty ())
+          s = 3UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+
+          vd = vs.data + vs.size++;
+          vd->func = &resourcefactoryproperties_pskel::choice_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->choice_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "simpleref",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool resourcefactoryproperties_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void resourcefactoryproperties_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void resourcefactoryproperties_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "simpleref");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void resourcefactoryproperties_pskel::
+  choice_0 (unsigned long& state,
+            unsigned long& count,
+            const ::xml_schema::ro_string& ns,
+            const ::xml_schema::ro_string& n,
+            const ::xml_schema::ro_string* t,
+            bool start)
+  {
+    XSD_UNUSED (count);
+    XSD_UNUSED (ns);
+    XSD_UNUSED (n);
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->simpleref_parser_;
+
+          if (this->simpleref_parser_)
+            this->simpleref_parser_->pre ();
+        }
+        else
+        {
+          if (this->simpleref_parser_)
+          {
+            ossie::SimplePropertyRef* tmp (this->simpleref_parser_->post_simpleref ());
+            this->simpleref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 1UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->simplesequenceref_parser_;
+
+          if (this->simplesequenceref_parser_)
+            this->simplesequenceref_parser_->pre ();
+        }
+        else
+        {
+          if (this->simplesequenceref_parser_)
+          {
+            ossie::SimpleSequencePropertyRef* tmp (this->simplesequenceref_parser_->post_simplesequenceref ());
+            this->simplesequenceref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 2UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->structref_parser_;
+
+          if (this->structref_parser_)
+            this->structref_parser_->pre ();
+        }
+        else
+        {
+          if (this->structref_parser_)
+          {
+            ossie::StructPropertyRef* tmp (this->structref_parser_->post_structref ());
+            this->structref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 3UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->structsequenceref_parser_;
+
+          if (this->structsequenceref_parser_)
+            this->structsequenceref_parser_->pre ();
+        }
+        else
+        {
+          if (this->structsequenceref_parser_)
+          {
+            ossie::StructSequencePropertyRef* tmp (this->structsequenceref_parser_->post_structsequenceref ());
+            this->structsequenceref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+    }
+  }
+
+  // Element validation and dispatch functions for simplesequenceref_pskel.
+  //
+  bool simplesequenceref_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "values" && ns.empty ())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &simplesequenceref_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "values",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool simplesequenceref_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void simplesequenceref_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void simplesequenceref_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "values");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void simplesequenceref_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "values" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->values_parser_;
+
+            if (this->values_parser_)
+              this->values_parser_->pre ();
+          }
+          else
+          {
+            if (this->values_parser_)
+            {
+              const ::std::vector<std::string>& tmp (this->values_parser_->post_values ());
+              this->values (tmp);
+            }
+
+            count = 0;
+            state = ~0UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "values",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for structref_pskel.
+  //
+  bool structref_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if ((n == "simpleref" && ns.empty ()) ||
+            (n == "simplesequenceref" && ns.empty ()))
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &structref_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "simpleref",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool structref_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void structref_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void structref_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "simpleref");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void structref_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        unsigned long s (~0UL);
+
+        if (n == "simpleref" && ns.empty ())
+          s = 0UL;
+        else if (n == "simplesequenceref" && ns.empty ())
+          s = 1UL;
+
+        if (s != ~0UL)
+        {
+          assert (start);
+          count++;
+
+          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+          v_state_descr_& vd = vs.data[vs.size++];
+
+          vd.func = &structref_pskel::choice_0;
+          vd.state = s;
+          vd.count = 0;
+
+          this->choice_0 (vd.state, vd.count, ns, n, t, true);
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "simpleref",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  void structref_pskel::
+  choice_0 (unsigned long& state,
+            unsigned long& count,
+            const ::xml_schema::ro_string& ns,
+            const ::xml_schema::ro_string& n,
+            const ::xml_schema::ro_string* t,
+            bool start)
+  {
+    XSD_UNUSED (count);
+    XSD_UNUSED (ns);
+    XSD_UNUSED (n);
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->simpleref_parser_;
+
+          if (this->simpleref_parser_)
+            this->simpleref_parser_->pre ();
+        }
+        else
+        {
+          if (this->simpleref_parser_)
+          {
+            ossie::SimplePropertyRef* tmp (this->simpleref_parser_->post_simpleref ());
+            this->simpleref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 1UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->simplesequenceref_parser_;
+
+          if (this->simplesequenceref_parser_)
+            this->simplesequenceref_parser_->pre ();
+        }
+        else
+        {
+          if (this->simplesequenceref_parser_)
+          {
+            ossie::SimpleSequencePropertyRef* tmp (this->simplesequenceref_parser_->post_simplesequenceref ());
+            this->simplesequenceref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+    }
+  }
+
+  // Element validation and dispatch functions for structsequenceref_pskel.
+  //
+  bool structsequenceref_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "structvalue" && ns.empty ())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &structsequenceref_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "structvalue",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool structsequenceref_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void structsequenceref_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void structsequenceref_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "structvalue");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void structsequenceref_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "structvalue" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->structvalue_parser_;
+
+            if (this->structvalue_parser_)
+              this->structvalue_parser_->pre ();
+          }
+          else
+          {
+            if (this->structvalue_parser_)
+            {
+              const ::std::map<std::string, ossie::ComponentProperty*>& tmp (this->structvalue_parser_->post_structvalue ());
+              this->structvalue (tmp);
+            }
+
+            count++;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "structvalue",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for structvalue_pskel.
+  //
+  bool structvalue_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if ((n == "simpleref" && ns.empty ()) ||
+            (n == "simplesequenceref" && ns.empty ()))
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &structvalue_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "simpleref",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool structvalue_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void structvalue_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void structvalue_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "simpleref");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void structvalue_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        unsigned long s (~0UL);
+
+        if (n == "simpleref" && ns.empty ())
+          s = 0UL;
+        else if (n == "simplesequenceref" && ns.empty ())
+          s = 1UL;
+
+        if (s != ~0UL)
+        {
+          assert (start);
+          count++;
+
+          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+          v_state_descr_& vd = vs.data[vs.size++];
+
+          vd.func = &structvalue_pskel::choice_0;
+          vd.state = s;
+          vd.count = 0;
+
+          this->choice_0 (vd.state, vd.count, ns, n, t, true);
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "simpleref",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  void structvalue_pskel::
+  choice_0 (unsigned long& state,
+            unsigned long& count,
+            const ::xml_schema::ro_string& ns,
+            const ::xml_schema::ro_string& n,
+            const ::xml_schema::ro_string* t,
+            bool start)
+  {
+    XSD_UNUSED (count);
+    XSD_UNUSED (ns);
+    XSD_UNUSED (n);
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->simpleref_parser_;
+
+          if (this->simpleref_parser_)
+            this->simpleref_parser_->pre ();
+        }
+        else
+        {
+          if (this->simpleref_parser_)
+          {
+            ossie::SimplePropertyRef* tmp (this->simpleref_parser_->post_simpleref ());
+            this->simpleref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 1UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->simplesequenceref_parser_;
+
+          if (this->simplesequenceref_parser_)
+            this->simplesequenceref_parser_->pre ();
+        }
+        else
+        {
+          if (this->simplesequenceref_parser_)
+          {
+            ossie::SimpleSequencePropertyRef* tmp (this->simplesequenceref_parser_->post_simplesequenceref ());
+            this->simplesequenceref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+    }
+  }
+
+  // Element validation and dispatch functions for values_pskel.
+  //
+  bool values_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "value" && ns.empty ())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &values_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "value",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool values_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void values_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void values_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "value");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void values_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "value" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->value_parser_;
+
+            if (this->value_parser_)
+              this->value_parser_->pre ();
+          }
+          else
+          {
+            if (this->value_parser_)
+            {
+              const ::std::string& tmp (this->value_parser_->post_string ());
+              this->value (tmp);
+            }
+
+            count++;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "value",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for findby_pskel.
+  //
+  bool findby_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "namingservice" && ns.empty ())
+          s = 0UL;
+        else if (n == "stringifiedobjectref" && ns.empty ())
+          s = 1UL;
+        else if (n == "domainfinder" && ns.empty ())
+          s = 2UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &findby_pskel::choice_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->choice_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "namingservice",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool findby_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void findby_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void findby_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "namingservice");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void findby_pskel::
+  choice_0 (unsigned long& state,
+            unsigned long& count,
+            const ::xml_schema::ro_string& ns,
+            const ::xml_schema::ro_string& n,
+            const ::xml_schema::ro_string* t,
+            bool start)
+  {
+    XSD_UNUSED (count);
+    XSD_UNUSED (ns);
+    XSD_UNUSED (n);
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->namingservice_parser_;
+
+          if (this->namingservice_parser_)
+            this->namingservice_parser_->pre ();
+        }
+        else
+        {
+          if (this->namingservice_parser_)
+          {
+            const ::std::string& tmp (this->namingservice_parser_->post_namingservice ());
+            this->namingservice (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 1UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->stringifiedobjectref_parser_;
+
+          if (this->stringifiedobjectref_parser_)
+            this->stringifiedobjectref_parser_->pre ();
+        }
+        else
+        {
+          if (this->stringifiedobjectref_parser_)
+          {
+            const ::std::string& tmp (this->stringifiedobjectref_parser_->post_string ());
+            this->stringifiedobjectref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 2UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->domainfinder_parser_;
+
+          if (this->domainfinder_parser_)
+            this->domainfinder_parser_->pre ();
+        }
+        else
+        {
+          if (this->domainfinder_parser_)
+          {
+            const ::std::pair<std::string, std::string>& tmp (this->domainfinder_parser_->post_domainfinder ());
+            this->domainfinder (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+    }
+  }
+
+  // Element validation and dispatch functions for hostcollocation_pskel.
+  //
+  bool hostcollocation_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "componentplacement" && ns.empty ())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &hostcollocation_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "componentplacement",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool hostcollocation_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void hostcollocation_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void hostcollocation_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "componentplacement");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void hostcollocation_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "componentplacement" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->componentplacement_parser_;
+
+            if (this->componentplacement_parser_)
+              this->componentplacement_parser_->pre ();
+          }
+          else
+          {
+            if (this->componentplacement_parser_)
+            {
+              const ::ossie::ComponentPlacement& tmp (this->componentplacement_parser_->post_componentplacement ());
+              this->componentplacement (tmp);
+            }
+
+            count++;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "componentplacement",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for assemblycontroller_pskel.
+  //
+  bool assemblycontroller_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "componentinstantiationref" && ns.empty ())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &assemblycontroller_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "componentinstantiationref",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool assemblycontroller_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void assemblycontroller_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void assemblycontroller_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "componentinstantiationref");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void assemblycontroller_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "componentinstantiationref" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->componentinstantiationref_parser_;
+
+            if (this->componentinstantiationref_parser_)
+              this->componentinstantiationref_parser_->pre ();
+          }
+          else
+          {
+            if (this->componentinstantiationref_parser_)
+            {
+              const ::std::string& tmp (this->componentinstantiationref_parser_->post_componentinstantiationref ());
+              this->componentinstantiationref (tmp);
+            }
+
+            count = 0;
+            state = ~0UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "componentinstantiationref",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for connections_pskel.
+  //
+  bool connections_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "connectinterface" && ns.empty ())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &connections_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool connections_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void connections_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void connections_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+
+    this->v_state_stack_.pop ();
+  }
+
+  void connections_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "connectinterface" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->connectinterface_parser_;
+
+            if (this->connectinterface_parser_)
+              this->connectinterface_parser_->pre ();
+          }
+          else
+          {
+            if (this->connectinterface_parser_)
+            {
+              const ::ossie::Connection& tmp (this->connectinterface_parser_->post_connectinterface ());
+              this->connectinterface (tmp);
+            }
+
+            count++;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for connectinterface_pskel.
+  //
+  bool connectinterface_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "usesport" && ns.empty ())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &connectinterface_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "usesport",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool connectinterface_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void connectinterface_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void connectinterface_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "usesport");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void connectinterface_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "usesport" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->usesport_parser_;
+
+            if (this->usesport_parser_)
+              this->usesport_parser_->pre ();
+          }
+          else
+          {
+            if (this->usesport_parser_)
+            {
+              const ::ossie::UsesPort& tmp (this->usesport_parser_->post_usesport ());
+              this->usesport (tmp);
+            }
+
+            count = 0;
+            state = 1UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "usesport",
+              ns, n);
+          count = 0;
+          state = 1UL;
+          // Fall through.
+        }
+      }
+      case 1UL:
+      {
+        unsigned long s (~0UL);
+
+        if (n == "providesport" && ns.empty ())
+          s = 0UL;
+        else if (n == "componentsupportedinterface" && ns.empty ())
+          s = 1UL;
+        else if (n == "findby" && ns.empty ())
+          s = 2UL;
+
+        if (s != ~0UL)
+        {
+          assert (start);
+          count = 0;
+          state = ~0UL;
+
+          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+          v_state_descr_& vd = vs.data[vs.size++];
+
+          vd.func = &connectinterface_pskel::choice_0;
+          vd.state = s;
+          vd.count = 0;
+
+          this->choice_0 (vd.state, vd.count, ns, n, t, true);
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "providesport",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  void connectinterface_pskel::
+  choice_0 (unsigned long& state,
+            unsigned long& count,
+            const ::xml_schema::ro_string& ns,
+            const ::xml_schema::ro_string& n,
+            const ::xml_schema::ro_string* t,
+            bool start)
+  {
+    XSD_UNUSED (count);
+    XSD_UNUSED (ns);
+    XSD_UNUSED (n);
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->providesport_parser_;
+
+          if (this->providesport_parser_)
+            this->providesport_parser_->pre ();
+        }
+        else
+        {
+          if (this->providesport_parser_)
+          {
+            const ::ossie::ProvidesPort& tmp (this->providesport_parser_->post_providesport ());
+            this->providesport (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 1UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->componentsupportedinterface_parser_;
+
+          if (this->componentsupportedinterface_parser_)
+            this->componentsupportedinterface_parser_->pre ();
+        }
+        else
+        {
+          if (this->componentsupportedinterface_parser_)
+          {
+            const ::ossie::ComponentSupportedInterface& tmp (this->componentsupportedinterface_parser_->post_componentsupportedinterface ());
+            this->componentsupportedinterface (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 2UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->findby_parser_;
+
+          if (this->findby_parser_)
+            this->findby_parser_->pre ();
+        }
+        else
+        {
+          if (this->findby_parser_)
+          {
+            const ::ossie::FindBy& tmp (this->findby_parser_->post_findby ());
+            this->findby (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+    }
+  }
+
+  // Element validation and dispatch functions for usesport_pskel.
+  //
+  bool usesport_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "usesidentifier" && ns.empty ())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &usesport_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "usesidentifier",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool usesport_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void usesport_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void usesport_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "usesidentifier");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void usesport_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "usesidentifier" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->usesidentifier_parser_;
+
+            if (this->usesidentifier_parser_)
+              this->usesidentifier_parser_->pre ();
+          }
+          else
+          {
+            if (this->usesidentifier_parser_)
+            {
+              const ::std::string& tmp (this->usesidentifier_parser_->post_string ());
+              this->usesidentifier (tmp);
+            }
+
+            count = 0;
+            state = 1UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "usesidentifier",
+              ns, n);
+          count = 0;
+          state = 1UL;
+          // Fall through.
+        }
+      }
+      case 1UL:
+      {
+        unsigned long s (~0UL);
+
+        if (n == "componentinstantiationref" && ns.empty ())
+          s = 0UL;
+        else if (n == "devicethatloadedthiscomponentref" && ns.empty ())
+          s = 1UL;
+        else if (n == "deviceusedbythiscomponentref" && ns.empty ())
+          s = 2UL;
+        else if (n == "deviceusedbyapplication" && ns.empty ())
+          s = 3UL;
+        else if (n == "findby" && ns.empty ())
+          s = 4UL;
+
+        if (s != ~0UL)
+        {
+          assert (start);
+          count = 0;
+          state = ~0UL;
+
+          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+          v_state_descr_& vd = vs.data[vs.size++];
+
+          vd.func = &usesport_pskel::choice_0;
+          vd.state = s;
+          vd.count = 0;
+
+          this->choice_0 (vd.state, vd.count, ns, n, t, true);
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "componentinstantiationref",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  void usesport_pskel::
+  choice_0 (unsigned long& state,
+            unsigned long& count,
+            const ::xml_schema::ro_string& ns,
+            const ::xml_schema::ro_string& n,
+            const ::xml_schema::ro_string* t,
+            bool start)
+  {
+    XSD_UNUSED (count);
+    XSD_UNUSED (ns);
+    XSD_UNUSED (n);
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->componentinstantiationref_parser_;
+
+          if (this->componentinstantiationref_parser_)
+            this->componentinstantiationref_parser_->pre ();
+        }
+        else
+        {
+          if (this->componentinstantiationref_parser_)
+          {
+            const ::std::string& tmp (this->componentinstantiationref_parser_->post_componentinstantiationref ());
+            this->componentinstantiationref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 1UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->devicethatloadedthiscomponentref_parser_;
+
+          if (this->devicethatloadedthiscomponentref_parser_)
+            this->devicethatloadedthiscomponentref_parser_->pre ();
+        }
+        else
+        {
+          if (this->devicethatloadedthiscomponentref_parser_)
+          {
+            const ::std::string& tmp (this->devicethatloadedthiscomponentref_parser_->post_devicethatloadedthiscomponentref ());
+            this->devicethatloadedthiscomponentref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 2UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->deviceusedbythiscomponentref_parser_;
+
+          if (this->deviceusedbythiscomponentref_parser_)
+            this->deviceusedbythiscomponentref_parser_->pre ();
+        }
+        else
+        {
+          if (this->deviceusedbythiscomponentref_parser_)
+          {
+            const ::std::pair<std::string, std::string>& tmp (this->deviceusedbythiscomponentref_parser_->post_deviceusedbythiscomponentref ());
+            this->deviceusedbythiscomponentref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 3UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->deviceusedbyapplication_parser_;
+
+          if (this->deviceusedbyapplication_parser_)
+            this->deviceusedbyapplication_parser_->pre ();
+        }
+        else
+        {
+          if (this->deviceusedbyapplication_parser_)
+          {
+            const ::std::string& tmp (this->deviceusedbyapplication_parser_->post_deviceusedbyapplication ());
+            this->deviceusedbyapplication (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 4UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->findby_parser_;
+
+          if (this->findby_parser_)
+            this->findby_parser_->pre ();
+        }
+        else
+        {
+          if (this->findby_parser_)
+          {
+            const ::ossie::FindBy& tmp (this->findby_parser_->post_findby ());
+            this->findby (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+    }
+  }
+
+  // Element validation and dispatch functions for providesport_pskel.
+  //
+  bool providesport_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "providesidentifier" && ns.empty ())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &providesport_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "providesidentifier",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool providesport_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void providesport_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void providesport_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "providesidentifier");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void providesport_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "providesidentifier" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->providesidentifier_parser_;
+
+            if (this->providesidentifier_parser_)
+              this->providesidentifier_parser_->pre ();
+          }
+          else
+          {
+            if (this->providesidentifier_parser_)
+            {
+              const ::std::string& tmp (this->providesidentifier_parser_->post_string ());
+              this->providesidentifier (tmp);
+            }
+
+            count = 0;
+            state = 1UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "providesidentifier",
+              ns, n);
+          count = 0;
+          state = 1UL;
+          // Fall through.
+        }
+      }
+      case 1UL:
+      {
+        unsigned long s (~0UL);
+
+        if (n == "componentinstantiationref" && ns.empty ())
+          s = 0UL;
+        else if (n == "devicethatloadedthiscomponentref" && ns.empty ())
+          s = 1UL;
+        else if (n == "deviceusedbythiscomponentref" && ns.empty ())
+          s = 2UL;
+        else if (n == "deviceusedbyapplication" && ns.empty ())
+          s = 3UL;
+        else if (n == "findby" && ns.empty ())
+          s = 4UL;
+
+        if (s != ~0UL)
+        {
+          assert (start);
+          count = 0;
+          state = ~0UL;
+
+          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+          v_state_descr_& vd = vs.data[vs.size++];
+
+          vd.func = &providesport_pskel::choice_0;
+          vd.state = s;
+          vd.count = 0;
+
+          this->choice_0 (vd.state, vd.count, ns, n, t, true);
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "componentinstantiationref",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  void providesport_pskel::
+  choice_0 (unsigned long& state,
+            unsigned long& count,
+            const ::xml_schema::ro_string& ns,
+            const ::xml_schema::ro_string& n,
+            const ::xml_schema::ro_string* t,
+            bool start)
+  {
+    XSD_UNUSED (count);
+    XSD_UNUSED (ns);
+    XSD_UNUSED (n);
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->componentinstantiationref_parser_;
+
+          if (this->componentinstantiationref_parser_)
+            this->componentinstantiationref_parser_->pre ();
+        }
+        else
+        {
+          if (this->componentinstantiationref_parser_)
+          {
+            const ::std::string& tmp (this->componentinstantiationref_parser_->post_componentinstantiationref ());
+            this->componentinstantiationref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 1UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->devicethatloadedthiscomponentref_parser_;
+
+          if (this->devicethatloadedthiscomponentref_parser_)
+            this->devicethatloadedthiscomponentref_parser_->pre ();
+        }
+        else
+        {
+          if (this->devicethatloadedthiscomponentref_parser_)
+          {
+            const ::std::string& tmp (this->devicethatloadedthiscomponentref_parser_->post_devicethatloadedthiscomponentref ());
+            this->devicethatloadedthiscomponentref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 2UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->deviceusedbythiscomponentref_parser_;
+
+          if (this->deviceusedbythiscomponentref_parser_)
+            this->deviceusedbythiscomponentref_parser_->pre ();
+        }
+        else
+        {
+          if (this->deviceusedbythiscomponentref_parser_)
+          {
+            const ::std::pair<std::string, std::string>& tmp (this->deviceusedbythiscomponentref_parser_->post_deviceusedbythiscomponentref ());
+            this->deviceusedbythiscomponentref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 3UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->deviceusedbyapplication_parser_;
+
+          if (this->deviceusedbyapplication_parser_)
+            this->deviceusedbyapplication_parser_->pre ();
+        }
+        else
+        {
+          if (this->deviceusedbyapplication_parser_)
+          {
+            const ::std::string& tmp (this->deviceusedbyapplication_parser_->post_deviceusedbyapplication ());
+            this->deviceusedbyapplication (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 4UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->findby_parser_;
+
+          if (this->findby_parser_)
+            this->findby_parser_->pre ();
+        }
+        else
+        {
+          if (this->findby_parser_)
+          {
+            const ::ossie::FindBy& tmp (this->findby_parser_->post_findby ());
+            this->findby (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+    }
+  }
+
+  // Element validation and dispatch functions for componentsupportedinterface_pskel.
+  //
+  bool componentsupportedinterface_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "supportedidentifier" && ns.empty ())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &componentsupportedinterface_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "supportedidentifier",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool componentsupportedinterface_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void componentsupportedinterface_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void componentsupportedinterface_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "supportedidentifier");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void componentsupportedinterface_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "supportedidentifier" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->supportedidentifier_parser_;
+
+            if (this->supportedidentifier_parser_)
+              this->supportedidentifier_parser_->pre ();
+          }
+          else
+          {
+            if (this->supportedidentifier_parser_)
+            {
+              const ::std::string& tmp (this->supportedidentifier_parser_->post_string ());
+              this->supportedidentifier (tmp);
+            }
+
+            count = 0;
+            state = 1UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "supportedidentifier",
+              ns, n);
+          count = 0;
+          state = 1UL;
+          // Fall through.
+        }
+      }
+      case 1UL:
+      {
+        unsigned long s (~0UL);
+
+        if (n == "componentinstantiationref" && ns.empty ())
+          s = 0UL;
+        else if (n == "devicethatloadedthiscomponentref" && ns.empty ())
+          s = 1UL;
+        else if (n == "deviceusedbythiscomponentref" && ns.empty ())
+          s = 2UL;
+        else if (n == "deviceusedbyapplication" && ns.empty ())
+          s = 3UL;
+        else if (n == "findby" && ns.empty ())
+          s = 4UL;
+
+        if (s != ~0UL)
+        {
+          assert (start);
+          count = 0;
+          state = ~0UL;
+
+          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+          v_state_descr_& vd = vs.data[vs.size++];
+
+          vd.func = &componentsupportedinterface_pskel::choice_0;
+          vd.state = s;
+          vd.count = 0;
+
+          this->choice_0 (vd.state, vd.count, ns, n, t, true);
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "componentinstantiationref",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  void componentsupportedinterface_pskel::
+  choice_0 (unsigned long& state,
+            unsigned long& count,
+            const ::xml_schema::ro_string& ns,
+            const ::xml_schema::ro_string& n,
+            const ::xml_schema::ro_string* t,
+            bool start)
+  {
+    XSD_UNUSED (count);
+    XSD_UNUSED (ns);
+    XSD_UNUSED (n);
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->componentinstantiationref_parser_;
+
+          if (this->componentinstantiationref_parser_)
+            this->componentinstantiationref_parser_->pre ();
+        }
+        else
+        {
+          if (this->componentinstantiationref_parser_)
+          {
+            const ::std::string& tmp (this->componentinstantiationref_parser_->post_componentinstantiationref ());
+            this->componentinstantiationref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 1UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->devicethatloadedthiscomponentref_parser_;
+
+          if (this->devicethatloadedthiscomponentref_parser_)
+            this->devicethatloadedthiscomponentref_parser_->pre ();
+        }
+        else
+        {
+          if (this->devicethatloadedthiscomponentref_parser_)
+          {
+            const ::std::string& tmp (this->devicethatloadedthiscomponentref_parser_->post_devicethatloadedthiscomponentref ());
+            this->devicethatloadedthiscomponentref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 2UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->deviceusedbythiscomponentref_parser_;
+
+          if (this->deviceusedbythiscomponentref_parser_)
+            this->deviceusedbythiscomponentref_parser_->pre ();
+        }
+        else
+        {
+          if (this->deviceusedbythiscomponentref_parser_)
+          {
+            const ::std::pair<std::string, std::string>& tmp (this->deviceusedbythiscomponentref_parser_->post_deviceusedbythiscomponentref ());
+            this->deviceusedbythiscomponentref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 3UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->deviceusedbyapplication_parser_;
+
+          if (this->deviceusedbyapplication_parser_)
+            this->deviceusedbyapplication_parser_->pre ();
+        }
+        else
+        {
+          if (this->deviceusedbyapplication_parser_)
+          {
+            const ::std::string& tmp (this->deviceusedbyapplication_parser_->post_deviceusedbyapplication ());
+            this->deviceusedbyapplication (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 4UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->findby_parser_;
+
+          if (this->findby_parser_)
+            this->findby_parser_->pre ();
+        }
+        else
+        {
+          if (this->findby_parser_)
+          {
+            const ::ossie::FindBy& tmp (this->findby_parser_->post_findby ());
+            this->findby (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+    }
+  }
+
+  // Element validation and dispatch functions for externalports_pskel.
+  //
+  bool externalports_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "port" && ns.empty ())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &externalports_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "port",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool externalports_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void externalports_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void externalports_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "port");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void externalports_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "port" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->port_parser_;
+
+            if (this->port_parser_)
+              this->port_parser_->pre ();
+          }
+          else
+          {
+            if (this->port_parser_)
+            {
+              const ossie::SoftwareAssembly::Port& tmp (this->port_parser_->post_port ());
+              this->port (tmp);
+            }
+
+            count++;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "port",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for port_pskel.
+  //
+  bool port_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "description" && ns.empty ())
+          s = 0UL;
+        else if ((n == "usesidentifier" && ns.empty ()) ||
+                 (n == "providesidentifier" && ns.empty ()) ||
+                 (n == "supportedidentifier" && ns.empty ()))
+          s = 1UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &port_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "description",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool port_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void port_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void port_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "description");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void port_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "description" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->description_parser_;
+
+            if (this->description_parser_)
+              this->description_parser_->pre ();
+          }
+          else
+          {
+            if (this->description_parser_)
+            {
+              const ::std::string& tmp (this->description_parser_->post_string ());
+              this->description (tmp);
+            }
+
+            count = 0;
+            state = 1UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 1UL;
+          // Fall through.
+        }
+      }
+      case 1UL:
+      {
+        unsigned long s (~0UL);
+
+        if (n == "usesidentifier" && ns.empty ())
+          s = 0UL;
+        else if (n == "providesidentifier" && ns.empty ())
+          s = 1UL;
+        else if (n == "supportedidentifier" && ns.empty ())
+          s = 2UL;
+
+        if (s != ~0UL)
+        {
+          assert (start);
+          count = 0;
+          state = 2UL;
+
+          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+          v_state_descr_& vd = vs.data[vs.size++];
+
+          vd.func = &port_pskel::choice_0;
+          vd.state = s;
+          vd.count = 0;
+
+          this->choice_0 (vd.state, vd.count, ns, n, t, true);
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "usesidentifier",
+              ns, n);
+          count = 0;
+          state = 2UL;
+          // Fall through.
+        }
+      }
+      case 2UL:
+      {
+        if (n == "componentinstantiationref" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->componentinstantiationref_parser_;
+
+            if (this->componentinstantiationref_parser_)
+              this->componentinstantiationref_parser_->pre ();
+          }
+          else
+          {
+            if (this->componentinstantiationref_parser_)
+            {
+              const ::std::string& tmp (this->componentinstantiationref_parser_->post_componentinstantiationref ());
+              this->componentinstantiationref (tmp);
+            }
+
+            count = 0;
+            state = ~0UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "componentinstantiationref",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  void port_pskel::
+  choice_0 (unsigned long& state,
+            unsigned long& count,
+            const ::xml_schema::ro_string& ns,
+            const ::xml_schema::ro_string& n,
+            const ::xml_schema::ro_string* t,
+            bool start)
+  {
+    XSD_UNUSED (count);
+    XSD_UNUSED (ns);
+    XSD_UNUSED (n);
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->usesidentifier_parser_;
+
+          if (this->usesidentifier_parser_)
+            this->usesidentifier_parser_->pre ();
+        }
+        else
+        {
+          if (this->usesidentifier_parser_)
+          {
+            const ::std::string& tmp (this->usesidentifier_parser_->post_string ());
+            this->usesidentifier (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 1UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->providesidentifier_parser_;
+
+          if (this->providesidentifier_parser_)
+            this->providesidentifier_parser_->pre ();
+        }
+        else
+        {
+          if (this->providesidentifier_parser_)
+          {
+            const ::std::string& tmp (this->providesidentifier_parser_->post_string ());
+            this->providesidentifier (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 2UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->supportedidentifier_parser_;
+
+          if (this->supportedidentifier_parser_)
+            this->supportedidentifier_parser_->pre ();
+        }
+        else
+        {
+          if (this->supportedidentifier_parser_)
+          {
+            const ::std::string& tmp (this->supportedidentifier_parser_->post_string ());
+            this->supportedidentifier (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+    }
+  }
+
+  // Element validation and dispatch functions for externalproperties_pskel.
+  //
+  bool externalproperties_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "property" && ns.empty ())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &externalproperties_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "property",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool externalproperties_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void externalproperties_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void externalproperties_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "property");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void externalproperties_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "property" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->property_parser_;
+
+            if (this->property_parser_)
+              this->property_parser_->pre ();
+          }
+          else
+          {
+            if (this->property_parser_)
+            {
+              const ossie::SoftwareAssembly::Property& tmp (this->property_parser_->post_property ());
+              this->property (tmp);
+            }
+
+            count++;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "property",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for usesdevicedependencies_pskel.
+  //
+  bool usesdevicedependencies_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "usesdevice" && ns.empty ())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &usesdevicedependencies_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "usesdevice",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool usesdevicedependencies_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void usesdevicedependencies_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void usesdevicedependencies_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "usesdevice");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void usesdevicedependencies_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "usesdevice" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->usesdevice_parser_;
+
+            if (this->usesdevice_parser_)
+              this->usesdevice_parser_->pre ();
+          }
+          else
+          {
+            if (this->usesdevice_parser_)
+            {
+              const ossie::SoftwareAssembly::UsesDevice& tmp (this->usesdevice_parser_->post_usesdevice ());
+              this->usesdevice (tmp);
+            }
+
+            count++;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "usesdevice",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for usesdevice_pskel.
+  //
+  bool usesdevice_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "propertyref" && ns.empty ())
+          s = 0UL;
+        else if (n == "simpleref" && ns.empty ())
+          s = 1UL;
+        else if (n == "simplesequenceref" && ns.empty ())
+          s = 2UL;
+        else if (n == "structref" && ns.empty ())
+          s = 3UL;
+        else if (n == "structsequenceref" && ns.empty ())
+          s = 4UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+
+          vd = vs.data + vs.size++;
+          vd->func = &usesdevice_pskel::choice_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->choice_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "propertyref",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool usesdevice_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void usesdevice_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void usesdevice_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "propertyref");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void usesdevice_pskel::
+  choice_0 (unsigned long& state,
+            unsigned long& count,
+            const ::xml_schema::ro_string& ns,
+            const ::xml_schema::ro_string& n,
+            const ::xml_schema::ro_string* t,
+            bool start)
+  {
+    XSD_UNUSED (count);
+    XSD_UNUSED (ns);
+    XSD_UNUSED (n);
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->propertyref_parser_;
+
+          if (this->propertyref_parser_)
+            this->propertyref_parser_->pre ();
+        }
+        else
+        {
+          if (this->propertyref_parser_)
+          {
+            const ossie::SoftwareAssembly::PropertyRef& tmp (this->propertyref_parser_->post_propertyref ());
+            this->propertyref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 1UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->simpleref_parser_;
+
+          if (this->simpleref_parser_)
+            this->simpleref_parser_->pre ();
+        }
+        else
+        {
+          if (this->simpleref_parser_)
+          {
+            ossie::SimplePropertyRef* tmp (this->simpleref_parser_->post_simpleref ());
+            this->simpleref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 2UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->simplesequenceref_parser_;
+
+          if (this->simplesequenceref_parser_)
+            this->simplesequenceref_parser_->pre ();
+        }
+        else
+        {
+          if (this->simplesequenceref_parser_)
+          {
+            ossie::SimpleSequencePropertyRef* tmp (this->simplesequenceref_parser_->post_simplesequenceref ());
+            this->simplesequenceref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 3UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->structref_parser_;
+
+          if (this->structref_parser_)
+            this->structref_parser_->pre ();
+        }
+        else
+        {
+          if (this->structref_parser_)
+          {
+            ossie::StructPropertyRef* tmp (this->structref_parser_->post_structref ());
+            this->structref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 4UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->structsequenceref_parser_;
+
+          if (this->structsequenceref_parser_)
+            this->structsequenceref_parser_->pre ();
+        }
+        else
+        {
+          if (this->structsequenceref_parser_)
+          {
+            ossie::StructSequencePropertyRef* tmp (this->structsequenceref_parser_->post_structsequenceref ());
+            this->structsequenceref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+    }
+  }
+}
+
+namespace sad
+{
+  // Attribute validation and dispatch functions for softwareassembly_pskel.
+  //
+  bool softwareassembly_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "id" && ns.empty ())
+    {
+      if (this->id_parser_)
+      {
+        this->id_parser_->pre ();
+        this->id_parser_->_pre_impl ();
+        this->id_parser_->_characters (s);
+        this->id_parser_->_post_impl ();
+        const ::std::string& tmp (this->id_parser_->post_string ());
+        this->id (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->id = true;
+      return true;
+    }
+
+    if (n == "name" && ns.empty ())
+    {
+      if (this->name_parser_)
+      {
+        this->name_parser_->pre ();
+        this->name_parser_->_pre_impl ();
+        this->name_parser_->_characters (s);
+        this->name_parser_->_post_impl ();
+        const ::std::string& tmp (this->name_parser_->post_string ());
+        this->name (tmp);
+      }
+
+      return true;
+    }
+
+    if (n == "version" && ns.empty ())
+    {
+      if (this->version_parser_)
+      {
+        this->version_parser_->pre ();
+        this->version_parser_->_pre_impl ();
+        this->version_parser_->_characters (s);
+        this->version_parser_->_post_impl ();
+        const ::std::string& tmp (this->version_parser_->post_string ());
+        this->version (tmp);
+      }
+
+      return true;
+    }
+
+    return false;
+  }
+
+  void softwareassembly_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.id = false;
+  }
+
+  void softwareassembly_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.id)
+      this->_expected_attribute (
+        "", "id");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for componentfile_pskel.
+  //
+  bool componentfile_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "id" && ns.empty ())
+    {
+      if (this->id_parser_)
+      {
+        this->id_parser_->pre ();
+        this->id_parser_->_pre_impl ();
+        this->id_parser_->_characters (s);
+        this->id_parser_->_post_impl ();
+        const ::std::string& tmp (this->id_parser_->post_string ());
+        this->id (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->id = true;
+      return true;
+    }
+
+    if (n == "type" && ns.empty ())
+    {
+      if (this->type_parser_)
+      {
+        this->type_parser_->pre ();
+        this->type_parser_->_pre_impl ();
+        this->type_parser_->_characters (s);
+        this->type_parser_->_post_impl ();
+        const ::std::string& tmp (this->type_parser_->post_string ());
+        this->type (tmp);
+      }
+
+      return true;
+    }
+
+    return false;
+  }
+
+  void componentfile_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.id = false;
+  }
+
+  void componentfile_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.id)
+      this->_expected_attribute (
+        "", "id");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for localfile_pskel.
+  //
+  bool localfile_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "name" && ns.empty ())
+    {
+      if (this->name_parser_)
+      {
+        this->name_parser_->pre ();
+        this->name_parser_->_pre_impl ();
+        this->name_parser_->_characters (s);
+        this->name_parser_->_post_impl ();
+        const ::std::string& tmp (this->name_parser_->post_string ());
+        this->name (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->name = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void localfile_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.name = false;
+  }
+
+  void localfile_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.name)
+      this->_expected_attribute (
+        "", "name");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for componentfileref_pskel.
+  //
+  bool componentfileref_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "refid" && ns.empty ())
+    {
+      if (this->refid_parser_)
+      {
+        this->refid_parser_->pre ();
+        this->refid_parser_->_pre_impl ();
+        this->refid_parser_->_characters (s);
+        this->refid_parser_->_post_impl ();
+        const ::std::string& tmp (this->refid_parser_->post_string ());
+        this->refid (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->refid = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void componentfileref_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.refid = false;
+  }
+
+  void componentfileref_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.refid)
+      this->_expected_attribute (
+        "", "refid");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for componentinstantiation_pskel.
+  //
+  bool componentinstantiation_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "id" && ns.empty ())
+    {
+      if (this->id_parser_)
+      {
+        this->id_parser_->pre ();
+        this->id_parser_->_pre_impl ();
+        this->id_parser_->_characters (s);
+        this->id_parser_->_post_impl ();
+        const ::std::string& tmp (this->id_parser_->post_string ());
+        this->id (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->id = true;
+      return true;
+    }
+
+    if (n == "startorder" && ns.empty ())
+    {
+      if (this->startorder_parser_)
+      {
+        this->startorder_parser_->pre ();
+        this->startorder_parser_->_pre_impl ();
+        this->startorder_parser_->_characters (s);
+        this->startorder_parser_->_post_impl ();
+        const ::std::string& tmp (this->startorder_parser_->post_string ());
+        this->startorder (tmp);
+      }
+
+      return true;
+    }
+
+    return false;
+  }
+
+  void componentinstantiation_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.id = false;
+  }
+
+  void componentinstantiation_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.id)
+      this->_expected_attribute (
+        "", "id");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for loggingconfig_pskel.
+  //
+  bool loggingconfig_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "level" && ns.empty ())
+    {
+      if (this->level_parser_)
+      {
+        this->level_parser_->pre ();
+        this->level_parser_->_pre_impl ();
+        this->level_parser_->_characters (s);
+        this->level_parser_->_post_impl ();
+        const ::std::string& tmp (this->level_parser_->post_string ());
+        this->level (tmp);
+      }
+
+      return true;
+    }
+
+    return this->::xml_schema::string_pskel::_attribute_impl_phase_one (ns, n, s);
+  }
+
+  // Attribute validation and dispatch functions for componentresourcefactoryref_pskel.
+  //
+  bool componentresourcefactoryref_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "refid" && ns.empty ())
+    {
+      if (this->refid_parser_)
+      {
+        this->refid_parser_->pre ();
+        this->refid_parser_->_pre_impl ();
+        this->refid_parser_->_characters (s);
+        this->refid_parser_->_post_impl ();
+        const ::std::string& tmp (this->refid_parser_->post_string ());
+        this->refid (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->refid = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void componentresourcefactoryref_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.refid = false;
+  }
+
+  void componentresourcefactoryref_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.refid)
+      this->_expected_attribute (
+        "", "refid");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for devicethatloadedthiscomponentref_pskel.
+  //
+  bool devicethatloadedthiscomponentref_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "refid" && ns.empty ())
+    {
+      if (this->refid_parser_)
+      {
+        this->refid_parser_->pre ();
+        this->refid_parser_->_pre_impl ();
+        this->refid_parser_->_characters (s);
+        this->refid_parser_->_post_impl ();
+        const ::std::string& tmp (this->refid_parser_->post_string ());
+        this->refid (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->refid = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void devicethatloadedthiscomponentref_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.refid = false;
+  }
+
+  void devicethatloadedthiscomponentref_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.refid)
+      this->_expected_attribute (
+        "", "refid");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for deviceusedbythiscomponentref_pskel.
+  //
+  bool deviceusedbythiscomponentref_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "refid" && ns.empty ())
+    {
+      if (this->refid_parser_)
+      {
+        this->refid_parser_->pre ();
+        this->refid_parser_->_pre_impl ();
+        this->refid_parser_->_characters (s);
+        this->refid_parser_->_post_impl ();
+        const ::std::string& tmp (this->refid_parser_->post_string ());
+        this->refid (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->refid = true;
+      return true;
+    }
+
+    if (n == "usesrefid" && ns.empty ())
+    {
+      if (this->usesrefid_parser_)
+      {
+        this->usesrefid_parser_->pre ();
+        this->usesrefid_parser_->_pre_impl ();
+        this->usesrefid_parser_->_characters (s);
+        this->usesrefid_parser_->_post_impl ();
+        const ::std::string& tmp (this->usesrefid_parser_->post_string ());
+        this->usesrefid (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->usesrefid = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void deviceusedbythiscomponentref_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.refid = false;
+    as.usesrefid = false;
+  }
+
+  void deviceusedbythiscomponentref_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.refid)
+      this->_expected_attribute (
+        "", "refid");
+    if (!as.usesrefid)
+      this->_expected_attribute (
+        "", "usesrefid");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for deviceusedbyapplication_pskel.
+  //
+  bool deviceusedbyapplication_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "usesrefid" && ns.empty ())
+    {
+      if (this->usesrefid_parser_)
+      {
+        this->usesrefid_parser_->pre ();
+        this->usesrefid_parser_->_pre_impl ();
+        this->usesrefid_parser_->_characters (s);
+        this->usesrefid_parser_->_post_impl ();
+        const ::std::string& tmp (this->usesrefid_parser_->post_string ());
+        this->usesrefid (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->usesrefid = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void deviceusedbyapplication_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.usesrefid = false;
+  }
+
+  void deviceusedbyapplication_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.usesrefid)
+      this->_expected_attribute (
+        "", "usesrefid");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for simpleref_pskel.
+  //
+  bool simpleref_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "refid" && ns.empty ())
+    {
+      if (this->refid_parser_)
+      {
+        this->refid_parser_->pre ();
+        this->refid_parser_->_pre_impl ();
+        this->refid_parser_->_characters (s);
+        this->refid_parser_->_post_impl ();
+        const ::std::string& tmp (this->refid_parser_->post_string ());
+        this->refid (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->refid = true;
+      return true;
+    }
+
+    if (n == "value" && ns.empty ())
+    {
+      if (this->value_parser_)
+      {
+        this->value_parser_->pre ();
+        this->value_parser_->_pre_impl ();
+        this->value_parser_->_characters (s);
+        this->value_parser_->_post_impl ();
+        const ::std::string& tmp (this->value_parser_->post_string ());
+        this->value (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->value = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void simpleref_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.refid = false;
+    as.value = false;
+  }
+
+  void simpleref_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.refid)
+      this->_expected_attribute (
+        "", "refid");
+    if (!as.value)
+      this->_expected_attribute (
+        "", "value");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for simplesequenceref_pskel.
+  //
+  bool simplesequenceref_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "refid" && ns.empty ())
+    {
+      if (this->refid_parser_)
+      {
+        this->refid_parser_->pre ();
+        this->refid_parser_->_pre_impl ();
+        this->refid_parser_->_characters (s);
+        this->refid_parser_->_post_impl ();
+        const ::std::string& tmp (this->refid_parser_->post_string ());
+        this->refid (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->refid = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void simplesequenceref_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.refid = false;
+  }
+
+  void simplesequenceref_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.refid)
+      this->_expected_attribute (
+        "", "refid");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for structref_pskel.
+  //
+  bool structref_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "refid" && ns.empty ())
+    {
+      if (this->refid_parser_)
+      {
+        this->refid_parser_->pre ();
+        this->refid_parser_->_pre_impl ();
+        this->refid_parser_->_characters (s);
+        this->refid_parser_->_post_impl ();
+        const ::std::string& tmp (this->refid_parser_->post_string ());
+        this->refid (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->refid = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void structref_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.refid = false;
+  }
+
+  void structref_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.refid)
+      this->_expected_attribute (
+        "", "refid");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for structsequenceref_pskel.
+  //
+  bool structsequenceref_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "refid" && ns.empty ())
+    {
+      if (this->refid_parser_)
+      {
+        this->refid_parser_->pre ();
+        this->refid_parser_->_pre_impl ();
+        this->refid_parser_->_characters (s);
+        this->refid_parser_->_post_impl ();
+        const ::std::string& tmp (this->refid_parser_->post_string ());
+        this->refid (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->refid = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void structsequenceref_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.refid = false;
+  }
+
+  void structsequenceref_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.refid)
+      this->_expected_attribute (
+        "", "refid");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for componentinstantiationref_pskel.
+  //
+  bool componentinstantiationref_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "refid" && ns.empty ())
+    {
+      if (this->refid_parser_)
+      {
+        this->refid_parser_->pre ();
+        this->refid_parser_->_pre_impl ();
+        this->refid_parser_->_characters (s);
+        this->refid_parser_->_post_impl ();
+        const ::std::string& tmp (this->refid_parser_->post_string ());
+        this->refid (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->refid = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void componentinstantiationref_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.refid = false;
+  }
+
+  void componentinstantiationref_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.refid)
+      this->_expected_attribute (
+        "", "refid");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for namingservice_pskel.
+  //
+  bool namingservice_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "name" && ns.empty ())
+    {
+      if (this->name_parser_)
+      {
+        this->name_parser_->pre ();
+        this->name_parser_->_pre_impl ();
+        this->name_parser_->_characters (s);
+        this->name_parser_->_post_impl ();
+        const ::std::string& tmp (this->name_parser_->post_string ());
+        this->name (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->name = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void namingservice_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.name = false;
+  }
+
+  void namingservice_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.name)
+      this->_expected_attribute (
+        "", "name");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for domainfinder_pskel.
+  //
+  bool domainfinder_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "type" && ns.empty ())
+    {
+      if (this->type_parser_)
+      {
+        this->type_parser_->pre ();
+        this->type_parser_->_pre_impl ();
+        this->type_parser_->_characters (s);
+        this->type_parser_->_post_impl ();
+        const ::std::string& tmp (this->type_parser_->post_string ());
+        this->type (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->type = true;
+      return true;
+    }
+
+    if (n == "name" && ns.empty ())
+    {
+      if (this->name_parser_)
+      {
+        this->name_parser_->pre ();
+        this->name_parser_->_pre_impl ();
+        this->name_parser_->_characters (s);
+        this->name_parser_->_post_impl ();
+        const ::std::string& tmp (this->name_parser_->post_string ());
+        this->name (tmp);
+      }
+
+      return true;
+    }
+
+    return false;
+  }
+
+  void domainfinder_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.type = false;
+  }
+
+  void domainfinder_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.type)
+      this->_expected_attribute (
+        "", "type");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for hostcollocation_pskel.
+  //
+  bool hostcollocation_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "id" && ns.empty ())
+    {
+      if (this->id_parser_)
+      {
+        this->id_parser_->pre ();
+        this->id_parser_->_pre_impl ();
+        this->id_parser_->_characters (s);
+        this->id_parser_->_post_impl ();
+        const ::std::string& tmp (this->id_parser_->post_string ());
+        this->id (tmp);
+      }
+
+      return true;
+    }
+
+    if (n == "name" && ns.empty ())
+    {
+      if (this->name_parser_)
+      {
+        this->name_parser_->pre ();
+        this->name_parser_->_pre_impl ();
+        this->name_parser_->_characters (s);
+        this->name_parser_->_post_impl ();
+        const ::std::string& tmp (this->name_parser_->post_string ());
+        this->name (tmp);
+      }
+
+      return true;
+    }
+
+    return false;
+  }
+
+  // Attribute validation and dispatch functions for connectinterface_pskel.
+  //
+  bool connectinterface_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "id" && ns.empty ())
+    {
+      if (this->id_parser_)
+      {
+        this->id_parser_->pre ();
+        this->id_parser_->_pre_impl ();
+        this->id_parser_->_characters (s);
+        this->id_parser_->_post_impl ();
+        const ::std::string& tmp (this->id_parser_->post_string ());
+        this->id (tmp);
+      }
+
+      return true;
+    }
+
+    return false;
+  }
+
+  // Attribute validation and dispatch functions for port_pskel.
+  //
+  bool port_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "externalname" && ns.empty ())
+    {
+      if (this->externalname_parser_)
+      {
+        this->externalname_parser_->pre ();
+        this->externalname_parser_->_pre_impl ();
+        this->externalname_parser_->_characters (s);
+        this->externalname_parser_->_post_impl ();
+        const ::std::string& tmp (this->externalname_parser_->post_string ());
+        this->externalname (tmp);
+      }
+
+      return true;
+    }
+
+    return false;
+  }
+
+  // Attribute validation and dispatch functions for property_pskel.
+  //
+  bool property_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "comprefid" && ns.empty ())
+    {
+      if (this->comprefid_parser_)
+      {
+        this->comprefid_parser_->pre ();
+        this->comprefid_parser_->_pre_impl ();
+        this->comprefid_parser_->_characters (s);
+        this->comprefid_parser_->_post_impl ();
+        const ::std::string& tmp (this->comprefid_parser_->post_string ());
+        this->comprefid (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->comprefid = true;
+      return true;
+    }
+
+    if (n == "propid" && ns.empty ())
+    {
+      if (this->propid_parser_)
+      {
+        this->propid_parser_->pre ();
+        this->propid_parser_->_pre_impl ();
+        this->propid_parser_->_characters (s);
+        this->propid_parser_->_post_impl ();
+        const ::std::string& tmp (this->propid_parser_->post_string ());
+        this->propid (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->propid = true;
+      return true;
+    }
+
+    if (n == "externalpropid" && ns.empty ())
+    {
+      if (this->externalpropid_parser_)
+      {
+        this->externalpropid_parser_->pre ();
+        this->externalpropid_parser_->_pre_impl ();
+        this->externalpropid_parser_->_characters (s);
+        this->externalpropid_parser_->_post_impl ();
+        const ::std::string& tmp (this->externalpropid_parser_->post_string ());
+        this->externalpropid (tmp);
+      }
+
+      return true;
+    }
+
+    return false;
+  }
+
+  void property_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.comprefid = false;
+    as.propid = false;
+  }
+
+  void property_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.comprefid)
+      this->_expected_attribute (
+        "", "comprefid");
+    if (!as.propid)
+      this->_expected_attribute (
+        "", "propid");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for usesdevice_pskel.
+  //
+  bool usesdevice_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "id" && ns.empty ())
+    {
+      if (this->id_parser_)
+      {
+        this->id_parser_->pre ();
+        this->id_parser_->_pre_impl ();
+        this->id_parser_->_characters (s);
+        this->id_parser_->_post_impl ();
+        const ::std::string& tmp (this->id_parser_->post_string ());
+        this->id (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->id = true;
+      return true;
+    }
+
+    if (n == "type" && ns.empty ())
+    {
+      if (this->type_parser_)
+      {
+        this->type_parser_->pre ();
+        this->type_parser_->_pre_impl ();
+        this->type_parser_->_characters (s);
+        this->type_parser_->_post_impl ();
+        const ::std::string& tmp (this->type_parser_->post_string ());
+        this->type (tmp);
+      }
+
+      return true;
+    }
+
+    return false;
+  }
+
+  void usesdevice_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.id = false;
+  }
+
+  void usesdevice_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.id)
+      this->_expected_attribute (
+        "", "id");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for propertyref_pskel.
+  //
+  bool propertyref_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "refid" && ns.empty ())
+    {
+      if (this->refid_parser_)
+      {
+        this->refid_parser_->pre ();
+        this->refid_parser_->_pre_impl ();
+        this->refid_parser_->_characters (s);
+        this->refid_parser_->_post_impl ();
+        const ::std::string& tmp (this->refid_parser_->post_string ());
+        this->refid (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->refid = true;
+      return true;
+    }
+
+    if (n == "value" && ns.empty ())
+    {
+      if (this->value_parser_)
+      {
+        this->value_parser_->pre ();
+        this->value_parser_->_pre_impl ();
+        this->value_parser_->_characters (s);
+        this->value_parser_->_post_impl ();
+        const ::std::string& tmp (this->value_parser_->post_string ());
+        this->value (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->value = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void propertyref_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.refid = false;
+    as.value = false;
+  }
+
+  void propertyref_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.refid)
+      this->_expected_attribute (
+        "", "refid");
+    if (!as.value)
+      this->_expected_attribute (
+        "", "value");
+
+    this->v_state_attr_stack_.pop ();
+  }
+}
+
+namespace sad
+{
+}
+
+// Begin epilogue.
+//
+//
+// End epilogue.
+
diff --git src/control/parser/internal/sad-pskel.h src/control/parser/internal/sad-pskel.h
new file mode 100644
index 0000000..4d2dbd1
--- /dev/null
+++ src/control/parser/internal/sad-pskel.h
@@ -0,0 +1,4091 @@
+// Copyright (C) 2005-2010 Code Synthesis Tools CC
+//
+// This program was generated by CodeSynthesis XSD, an XML Schema to
+// C++ data binding compiler.
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 2 as
+// published by the Free Software Foundation.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+//
+// In addition, as a special exception, Code Synthesis Tools CC gives
+// permission to link this program with the Xerces-C++ library (or with
+// modified versions of Xerces-C++ that use the same license as Xerces-C++),
+// and distribute linked combinations including the two. You must obey
+// the GNU General Public License version 2 in all respects for all of
+// the code used other than Xerces-C++. If you modify this copy of the
+// program, you may extend this exception to your version of the program,
+// but you are not obligated to do so. If you do not wish to do so, delete
+// this exception statement from your version.
+//
+// Furthermore, Code Synthesis Tools CC makes a special exception for
+// the Free/Libre and Open Source Software (FLOSS) which is described
+// in the accompanying FLOSSE file.
+//
+
+#ifndef CXX______XML_XSD_SAD_PSKEL_H
+#define CXX______XML_XSD_SAD_PSKEL_H
+
+// Begin prologue.
+//
+//
+// End prologue.
+
+#include <xsd/cxx/config.hxx>
+
+#if (XSD_INT_VERSION != 3030000L)
+#error XSD runtime version mismatch
+#endif
+
+#include <xsd/cxx/pre.hxx>
+
+// Forward declarations
+//
+namespace sad
+{
+  class softwareassembly_pskel;
+  class componentfiles_pskel;
+  class componentfile_pskel;
+  class localfile_pskel;
+  class partitioning_pskel;
+  class componentplacement_pskel;
+  class componentfileref_pskel;
+  class componentinstantiation_pskel;
+  class loggingconfig_pskel;
+  class affinity_pskel;
+  class componentproperties_pskel;
+  class findcomponent_pskel;
+  class componentresourcefactoryref_pskel;
+  class devicethatloadedthiscomponentref_pskel;
+  class deviceusedbythiscomponentref_pskel;
+  class deviceusedbyapplication_pskel;
+  class resourcefactoryproperties_pskel;
+  class simpleref_pskel;
+  class simplesequenceref_pskel;
+  class structref_pskel;
+  class structsequenceref_pskel;
+  class structvalue_pskel;
+  class values_pskel;
+  class componentinstantiationref_pskel;
+  class findby_pskel;
+  class namingservice_pskel;
+  class domainfinder_pskel;
+  class hostcollocation_pskel;
+  class assemblycontroller_pskel;
+  class connections_pskel;
+  class connectinterface_pskel;
+  class usesport_pskel;
+  class providesport_pskel;
+  class componentsupportedinterface_pskel;
+  class externalports_pskel;
+  class port_pskel;
+  class externalproperties_pskel;
+  class property_pskel;
+  class usesdevicedependencies_pskel;
+  class usesdevice_pskel;
+  class propertyref_pskel;
+}
+
+
+#ifndef XSD_USE_CHAR
+#define XSD_USE_CHAR
+#endif
+
+#ifndef XSD_CXX_PARSER_USE_CHAR
+#define XSD_CXX_PARSER_USE_CHAR
+#endif
+
+#include <xsd/cxx/xml/error-handler.hxx>
+#include <xsd/cxx/parser/exceptions.hxx>
+#include <xsd/cxx/parser/elements.hxx>
+#include <xsd/cxx/parser/xml-schema.hxx>
+#include <xsd/cxx/parser/validating/parser.hxx>
+#include <xsd/cxx/parser/validating/exceptions.hxx>
+#include <xsd/cxx/parser/validating/xml-schema-pskel.hxx>
+#include <xsd/cxx/parser/validating/xml-schema-pimpl.hxx>
+#include <xsd/cxx/parser/expat/elements.hxx>
+
+#include "memory"
+#include "map"
+#include "../include/ossie/SoftwareAssembly.h"
+
+namespace xml_schema
+{
+  // Built-in XML Schema types mapping.
+  //
+  typedef ::xsd::cxx::parser::string_sequence< char > string_sequence;
+  typedef ::xsd::cxx::parser::qname< char > qname;
+  typedef ::xsd::cxx::parser::buffer buffer;
+  typedef ::xsd::cxx::parser::time_zone time_zone;
+  typedef ::xsd::cxx::parser::gday gday;
+  typedef ::xsd::cxx::parser::gmonth gmonth;
+  typedef ::xsd::cxx::parser::gyear gyear;
+  typedef ::xsd::cxx::parser::gmonth_day gmonth_day;
+  typedef ::xsd::cxx::parser::gyear_month gyear_month;
+  typedef ::xsd::cxx::parser::date date;
+  typedef ::xsd::cxx::parser::time time;
+  typedef ::xsd::cxx::parser::date_time date_time;
+  typedef ::xsd::cxx::parser::duration duration;
+
+  // Base parser skeletons.
+  //
+  typedef ::xsd::cxx::parser::parser_base< char > parser_base;
+  typedef ::xsd::cxx::parser::validating::empty_content< char > empty_content;
+  typedef ::xsd::cxx::parser::validating::simple_content< char > simple_content;
+  typedef ::xsd::cxx::parser::validating::complex_content< char > complex_content;
+  typedef ::xsd::cxx::parser::validating::list_base< char > list_base;
+
+  // Parser skeletons and implementations for the XML Schema
+  // built-in types.
+  //
+  typedef ::xsd::cxx::parser::validating::any_type_pskel< char > any_type_pskel;
+  typedef ::xsd::cxx::parser::validating::any_type_pimpl< char > any_type_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::any_simple_type_pskel< char > any_simple_type_pskel;
+  typedef ::xsd::cxx::parser::validating::any_simple_type_pimpl< char > any_simple_type_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::byte_pskel< char > byte_pskel;
+  typedef ::xsd::cxx::parser::validating::byte_pimpl< char > byte_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::unsigned_byte_pskel< char > unsigned_byte_pskel;
+  typedef ::xsd::cxx::parser::validating::unsigned_byte_pimpl< char > unsigned_byte_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::short_pskel< char > short_pskel;
+  typedef ::xsd::cxx::parser::validating::short_pimpl< char > short_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::unsigned_short_pskel< char > unsigned_short_pskel;
+  typedef ::xsd::cxx::parser::validating::unsigned_short_pimpl< char > unsigned_short_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::int_pskel< char > int_pskel;
+  typedef ::xsd::cxx::parser::validating::int_pimpl< char > int_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::unsigned_int_pskel< char > unsigned_int_pskel;
+  typedef ::xsd::cxx::parser::validating::unsigned_int_pimpl< char > unsigned_int_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::long_pskel< char > long_pskel;
+  typedef ::xsd::cxx::parser::validating::long_pimpl< char > long_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::unsigned_long_pskel< char > unsigned_long_pskel;
+  typedef ::xsd::cxx::parser::validating::unsigned_long_pimpl< char > unsigned_long_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::integer_pskel< char > integer_pskel;
+  typedef ::xsd::cxx::parser::validating::integer_pimpl< char > integer_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::non_positive_integer_pskel< char > non_positive_integer_pskel;
+  typedef ::xsd::cxx::parser::validating::non_positive_integer_pimpl< char > non_positive_integer_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::non_negative_integer_pskel< char > non_negative_integer_pskel;
+  typedef ::xsd::cxx::parser::validating::non_negative_integer_pimpl< char > non_negative_integer_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::positive_integer_pskel< char > positive_integer_pskel;
+  typedef ::xsd::cxx::parser::validating::positive_integer_pimpl< char > positive_integer_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::negative_integer_pskel< char > negative_integer_pskel;
+  typedef ::xsd::cxx::parser::validating::negative_integer_pimpl< char > negative_integer_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::boolean_pskel< char > boolean_pskel;
+  typedef ::xsd::cxx::parser::validating::boolean_pimpl< char > boolean_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::float_pskel< char > float_pskel;
+  typedef ::xsd::cxx::parser::validating::float_pimpl< char > float_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::double_pskel< char > double_pskel;
+  typedef ::xsd::cxx::parser::validating::double_pimpl< char > double_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::decimal_pskel< char > decimal_pskel;
+  typedef ::xsd::cxx::parser::validating::decimal_pimpl< char > decimal_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::string_pskel< char > string_pskel;
+  typedef ::xsd::cxx::parser::validating::string_pimpl< char > string_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::normalized_string_pskel< char > normalized_string_pskel;
+  typedef ::xsd::cxx::parser::validating::normalized_string_pimpl< char > normalized_string_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::token_pskel< char > token_pskel;
+  typedef ::xsd::cxx::parser::validating::token_pimpl< char > token_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::name_pskel< char > name_pskel;
+  typedef ::xsd::cxx::parser::validating::name_pimpl< char > name_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::nmtoken_pskel< char > nmtoken_pskel;
+  typedef ::xsd::cxx::parser::validating::nmtoken_pimpl< char > nmtoken_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::nmtokens_pskel< char > nmtokens_pskel;
+  typedef ::xsd::cxx::parser::validating::nmtokens_pimpl< char > nmtokens_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::ncname_pskel< char > ncname_pskel;
+  typedef ::xsd::cxx::parser::validating::ncname_pimpl< char > ncname_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::language_pskel< char > language_pskel;
+  typedef ::xsd::cxx::parser::validating::language_pimpl< char > language_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::id_pskel< char > id_pskel;
+  typedef ::xsd::cxx::parser::validating::id_pimpl< char > id_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::idref_pskel< char > idref_pskel;
+  typedef ::xsd::cxx::parser::validating::idref_pimpl< char > idref_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::idrefs_pskel< char > idrefs_pskel;
+  typedef ::xsd::cxx::parser::validating::idrefs_pimpl< char > idrefs_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::uri_pskel< char > uri_pskel;
+  typedef ::xsd::cxx::parser::validating::uri_pimpl< char > uri_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::qname_pskel< char > qname_pskel;
+  typedef ::xsd::cxx::parser::validating::qname_pimpl< char > qname_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::base64_binary_pskel< char > base64_binary_pskel;
+  typedef ::xsd::cxx::parser::validating::base64_binary_pimpl< char > base64_binary_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::hex_binary_pskel< char > hex_binary_pskel;
+  typedef ::xsd::cxx::parser::validating::hex_binary_pimpl< char > hex_binary_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::date_pskel< char > date_pskel;
+  typedef ::xsd::cxx::parser::validating::date_pimpl< char > date_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::date_time_pskel< char > date_time_pskel;
+  typedef ::xsd::cxx::parser::validating::date_time_pimpl< char > date_time_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::duration_pskel< char > duration_pskel;
+  typedef ::xsd::cxx::parser::validating::duration_pimpl< char > duration_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::gday_pskel< char > gday_pskel;
+  typedef ::xsd::cxx::parser::validating::gday_pimpl< char > gday_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::gmonth_pskel< char > gmonth_pskel;
+  typedef ::xsd::cxx::parser::validating::gmonth_pimpl< char > gmonth_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::gmonth_day_pskel< char > gmonth_day_pskel;
+  typedef ::xsd::cxx::parser::validating::gmonth_day_pimpl< char > gmonth_day_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::gyear_pskel< char > gyear_pskel;
+  typedef ::xsd::cxx::parser::validating::gyear_pimpl< char > gyear_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::gyear_month_pskel< char > gyear_month_pskel;
+  typedef ::xsd::cxx::parser::validating::gyear_month_pimpl< char > gyear_month_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::time_pskel< char > time_pskel;
+  typedef ::xsd::cxx::parser::validating::time_pimpl< char > time_pimpl;
+
+  // Exceptions. See libxsd/xsd/cxx/parser/exceptions.hxx for details.
+  //
+  typedef ::xsd::cxx::parser::exception< char > exception;
+
+  // Parsing diagnostics.
+  //
+  typedef ::xsd::cxx::parser::severity severity;
+  typedef ::xsd::cxx::parser::error< char > error;
+  typedef ::xsd::cxx::parser::diagnostics< char > diagnostics;
+  typedef ::xsd::cxx::parser::parsing< char > parsing;
+
+  // Error handler. See libxsd/xsd/cxx/xml/error-handler.hxx for details.
+  //
+  typedef ::xsd::cxx::xml::error_handler< char > error_handler;
+
+  // Read-only string.
+  //
+  typedef ::xsd::cxx::ro_string< char > ro_string;
+
+  // Document type. See libxsd/xsd/cxx/parser/expat/elements.hxx
+  // for details.
+  //
+  typedef ::xsd::cxx::parser::expat::document< char > document;
+}
+
+namespace sad
+{
+  class softwareassembly_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    description (const ::std::string&);
+
+    virtual void
+    componentfiles (const ::std::vector<ossie::ComponentFile>&);
+
+    virtual void
+    partitioning (const ossie::SoftwareAssembly::Partitioning&);
+
+    virtual void
+    assemblycontroller (const ::std::string&);
+
+    virtual void
+    connections (const ::std::vector<ossie::Connection>&);
+
+    virtual void
+    externalports (const ::std::vector<ossie::SoftwareAssembly::Port>&);
+
+    virtual void
+    externalproperties (const ::std::vector<ossie::SoftwareAssembly::Property>&);
+
+    virtual void
+    usesdevicedependencies (const ::std::vector<ossie::SoftwareAssembly::UsesDevice>&);
+
+    virtual void
+    id (const ::std::string&);
+
+    virtual void
+    name (const ::std::string&);
+
+    virtual void
+    version (const ::std::string&);
+
+    virtual ::std::auto_ptr<ossie::SoftwareAssembly::SAD>
+    post_softwareassembly () = 0;
+
+    // Parser construction API.
+    //
+    void
+    description_parser (::xml_schema::string_pskel&);
+
+    void
+    componentfiles_parser (::sad::componentfiles_pskel&);
+
+    void
+    partitioning_parser (::sad::partitioning_pskel&);
+
+    void
+    assemblycontroller_parser (::sad::assemblycontroller_pskel&);
+
+    void
+    connections_parser (::sad::connections_pskel&);
+
+    void
+    externalports_parser (::sad::externalports_pskel&);
+
+    void
+    externalproperties_parser (::sad::externalproperties_pskel&);
+
+    void
+    usesdevicedependencies_parser (::sad::usesdevicedependencies_pskel&);
+
+    void
+    id_parser (::xml_schema::string_pskel&);
+
+    void
+    name_parser (::xml_schema::string_pskel&);
+
+    void
+    version_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* description */,
+             ::sad::componentfiles_pskel& /* componentfiles */,
+             ::sad::partitioning_pskel& /* partitioning */,
+             ::sad::assemblycontroller_pskel& /* assemblycontroller */,
+             ::sad::connections_pskel& /* connections */,
+             ::sad::externalports_pskel& /* externalports */,
+             ::sad::externalproperties_pskel& /* externalproperties */,
+             ::sad::usesdevicedependencies_pskel& /* usesdevicedependencies */,
+             ::xml_schema::string_pskel& /* id */,
+             ::xml_schema::string_pskel& /* name */,
+             ::xml_schema::string_pskel& /* version */);
+
+    // Constructor.
+    //
+    softwareassembly_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* description_parser_;
+    ::sad::componentfiles_pskel* componentfiles_parser_;
+    ::sad::partitioning_pskel* partitioning_parser_;
+    ::sad::assemblycontroller_pskel* assemblycontroller_parser_;
+    ::sad::connections_pskel* connections_parser_;
+    ::sad::externalports_pskel* externalports_parser_;
+    ::sad::externalproperties_pskel* externalproperties_parser_;
+    ::sad::usesdevicedependencies_pskel* usesdevicedependencies_parser_;
+    ::xml_schema::string_pskel* id_parser_;
+    ::xml_schema::string_pskel* name_parser_;
+    ::xml_schema::string_pskel* version_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::sad::softwareassembly_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+
+    protected:
+    struct v_state_attr_
+    {
+      bool id;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class componentfiles_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    componentfile (const ::ossie::ComponentFile&);
+
+    virtual ::std::vector<ossie::ComponentFile>
+    post_componentfiles () = 0;
+
+    // Parser construction API.
+    //
+    void
+    componentfile_parser (::sad::componentfile_pskel&);
+
+    void
+    parsers (::sad::componentfile_pskel& /* componentfile */);
+
+    // Constructor.
+    //
+    componentfiles_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::sad::componentfile_pskel* componentfile_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::sad::componentfiles_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+  };
+
+  class componentfile_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    localfile (const ::std::string&);
+
+    virtual void
+    id (const ::std::string&);
+
+    virtual void
+    type (const ::std::string&);
+
+    virtual ::ossie::ComponentFile
+    post_componentfile () = 0;
+
+    // Parser construction API.
+    //
+    void
+    localfile_parser (::sad::localfile_pskel&);
+
+    void
+    id_parser (::xml_schema::string_pskel&);
+
+    void
+    type_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::sad::localfile_pskel& /* localfile */,
+             ::xml_schema::string_pskel& /* id */,
+             ::xml_schema::string_pskel& /* type */);
+
+    // Constructor.
+    //
+    componentfile_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::sad::localfile_pskel* localfile_parser_;
+    ::xml_schema::string_pskel* id_parser_;
+    ::xml_schema::string_pskel* type_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::sad::componentfile_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+
+    protected:
+    struct v_state_attr_
+    {
+      bool id;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class localfile_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    name (const ::std::string&);
+
+    virtual ::std::string
+    post_localfile () = 0;
+
+    // Parser construction API.
+    //
+    void
+    name_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* name */);
+
+    // Constructor.
+    //
+    localfile_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* name_parser_;
+
+    protected:
+    struct v_state_attr_
+    {
+      bool name;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class partitioning_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    componentplacement (const ::ossie::ComponentPlacement&);
+
+    virtual void
+    hostcollocation (const ::ossie::SoftwareAssembly::HostCollocation&);
+
+    virtual ossie::SoftwareAssembly::Partitioning
+    post_partitioning () = 0;
+
+    // Parser construction API.
+    //
+    void
+    componentplacement_parser (::sad::componentplacement_pskel&);
+
+    void
+    hostcollocation_parser (::sad::hostcollocation_pskel&);
+
+    void
+    parsers (::sad::componentplacement_pskel& /* componentplacement */,
+             ::sad::hostcollocation_pskel& /* hostcollocation */);
+
+    // Constructor.
+    //
+    partitioning_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::sad::componentplacement_pskel* componentplacement_parser_;
+    ::sad::hostcollocation_pskel* hostcollocation_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::sad::partitioning_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    choice_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start);
+  };
+
+  class componentplacement_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    componentfileref (const ::std::string&);
+
+    virtual void
+    componentinstantiation (const ::ossie::ComponentInstantiation&);
+
+    virtual ::ossie::ComponentPlacement
+    post_componentplacement () = 0;
+
+    // Parser construction API.
+    //
+    void
+    componentfileref_parser (::sad::componentfileref_pskel&);
+
+    void
+    componentinstantiation_parser (::sad::componentinstantiation_pskel&);
+
+    void
+    parsers (::sad::componentfileref_pskel& /* componentfileref */,
+             ::sad::componentinstantiation_pskel& /* componentinstantiation */);
+
+    // Constructor.
+    //
+    componentplacement_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::sad::componentfileref_pskel* componentfileref_parser_;
+    ::sad::componentinstantiation_pskel* componentinstantiation_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::sad::componentplacement_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+  };
+
+  class componentfileref_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    refid (const ::std::string&);
+
+    virtual ::std::string
+    post_componentfileref () = 0;
+
+    // Parser construction API.
+    //
+    void
+    refid_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* refid */);
+
+    // Constructor.
+    //
+    componentfileref_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* refid_parser_;
+
+    protected:
+    struct v_state_attr_
+    {
+      bool refid;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class componentinstantiation_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    usagename (const ::std::string&);
+
+    virtual void
+    componentproperties (const ::std::vector<ossie::ComponentProperty*>&);
+
+    virtual void
+    affinity (const  ossie::ComponentInstantiation::AffinityProperties &);
+
+    virtual void
+    loggingconfig (const  ossie::ComponentInstantiation::LoggingConfig &);
+
+    virtual void
+    findcomponent (const ::std::string&);
+
+    virtual void
+    id (const ::std::string&);
+
+    virtual void
+    startorder (const ::std::string&);
+
+    virtual ::ossie::ComponentInstantiation
+    post_componentinstantiation () = 0;
+
+    // Parser construction API.
+    //
+    void
+    usagename_parser (::xml_schema::string_pskel&);
+
+    void
+    componentproperties_parser (::sad::componentproperties_pskel&);
+
+    void
+    affinity_parser (::sad::affinity_pskel&);
+
+    void
+    loggingconfig_parser (::sad::loggingconfig_pskel&);
+
+    void
+    findcomponent_parser (::sad::findcomponent_pskel&);
+
+    void
+    id_parser (::xml_schema::string_pskel&);
+
+    void
+    startorder_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* usagename */,
+             ::sad::componentproperties_pskel& /* componentproperties */,
+             ::sad::affinity_pskel& /* affinity */,
+             ::sad::loggingconfig_pskel& /* loggingconfig */,
+             ::sad::findcomponent_pskel& /* findcomponent */,
+             ::xml_schema::string_pskel& /* id */,
+             ::xml_schema::string_pskel& /* startorder */);
+
+    // Constructor.
+    //
+    componentinstantiation_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* usagename_parser_;
+    ::sad::componentproperties_pskel* componentproperties_parser_;
+    ::sad::affinity_pskel* affinity_parser_;
+    ::sad::loggingconfig_pskel* loggingconfig_parser_;
+    ::sad::findcomponent_pskel* findcomponent_parser_;
+    ::xml_schema::string_pskel* id_parser_;
+    ::xml_schema::string_pskel* startorder_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::sad::componentinstantiation_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+
+    protected:
+    struct v_state_attr_
+    {
+      bool id;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class loggingconfig_pskel: public virtual ::xml_schema::string_pskel
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    level (const ::std::string&);
+
+    virtual  ossie::ComponentInstantiation::LoggingConfig 
+    post_loggingconfig () = 0;
+
+    // Parser construction API.
+    //
+    void
+    level_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* level */);
+
+    // Constructor.
+    //
+    loggingconfig_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* level_parser_;
+  };
+
+  class affinity_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    simpleref (ossie::SimplePropertyRef*);
+
+    virtual void
+    simplesequenceref (ossie::SimpleSequencePropertyRef*);
+
+    virtual void
+    structref (ossie::StructPropertyRef*);
+
+    virtual void
+    structsequenceref (ossie::StructSequencePropertyRef*);
+
+    virtual  ossie::ComponentInstantiation::AffinityProperties 
+    post_affinity () = 0;
+
+    // Parser construction API.
+    //
+    void
+    simpleref_parser (::sad::simpleref_pskel&);
+
+    void
+    simplesequenceref_parser (::sad::simplesequenceref_pskel&);
+
+    void
+    structref_parser (::sad::structref_pskel&);
+
+    void
+    structsequenceref_parser (::sad::structsequenceref_pskel&);
+
+    void
+    parsers (::sad::simpleref_pskel& /* simpleref */,
+             ::sad::simplesequenceref_pskel& /* simplesequenceref */,
+             ::sad::structref_pskel& /* structref */,
+             ::sad::structsequenceref_pskel& /* structsequenceref */);
+
+    // Constructor.
+    //
+    affinity_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::sad::simpleref_pskel* simpleref_parser_;
+    ::sad::simplesequenceref_pskel* simplesequenceref_parser_;
+    ::sad::structref_pskel* structref_parser_;
+    ::sad::structsequenceref_pskel* structsequenceref_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::sad::affinity_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    choice_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start);
+  };
+
+  class componentproperties_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    simpleref (ossie::SimplePropertyRef*);
+
+    virtual void
+    simplesequenceref (ossie::SimpleSequencePropertyRef*);
+
+    virtual void
+    structref (ossie::StructPropertyRef*);
+
+    virtual void
+    structsequenceref (ossie::StructSequencePropertyRef*);
+
+    virtual ::std::vector<ossie::ComponentProperty*>
+    post_componentproperties () = 0;
+
+    // Parser construction API.
+    //
+    void
+    simpleref_parser (::sad::simpleref_pskel&);
+
+    void
+    simplesequenceref_parser (::sad::simplesequenceref_pskel&);
+
+    void
+    structref_parser (::sad::structref_pskel&);
+
+    void
+    structsequenceref_parser (::sad::structsequenceref_pskel&);
+
+    void
+    parsers (::sad::simpleref_pskel& /* simpleref */,
+             ::sad::simplesequenceref_pskel& /* simplesequenceref */,
+             ::sad::structref_pskel& /* structref */,
+             ::sad::structsequenceref_pskel& /* structsequenceref */);
+
+    // Constructor.
+    //
+    componentproperties_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::sad::simpleref_pskel* simpleref_parser_;
+    ::sad::simplesequenceref_pskel* simplesequenceref_parser_;
+    ::sad::structref_pskel* structref_parser_;
+    ::sad::structsequenceref_pskel* structsequenceref_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::sad::componentproperties_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    choice_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start);
+  };
+
+  class findcomponent_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    componentresourcefactoryref ();
+
+    virtual void
+    namingservice (const ::std::string&);
+
+    virtual ::std::string
+    post_findcomponent () = 0;
+
+    // Parser construction API.
+    //
+    void
+    componentresourcefactoryref_parser (::sad::componentresourcefactoryref_pskel&);
+
+    void
+    namingservice_parser (::sad::namingservice_pskel&);
+
+    void
+    parsers (::sad::componentresourcefactoryref_pskel& /* componentresourcefactoryref */,
+             ::sad::namingservice_pskel& /* namingservice */);
+
+    // Constructor.
+    //
+    findcomponent_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::sad::componentresourcefactoryref_pskel* componentresourcefactoryref_parser_;
+    ::sad::namingservice_pskel* namingservice_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::sad::findcomponent_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    choice_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start);
+  };
+
+  class componentresourcefactoryref_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    resourcefactoryproperties ();
+
+    virtual void
+    refid (const ::std::string&);
+
+    virtual void
+    post_componentresourcefactoryref ();
+
+    // Parser construction API.
+    //
+    void
+    resourcefactoryproperties_parser (::sad::resourcefactoryproperties_pskel&);
+
+    void
+    refid_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::sad::resourcefactoryproperties_pskel& /* resourcefactoryproperties */,
+             ::xml_schema::string_pskel& /* refid */);
+
+    // Constructor.
+    //
+    componentresourcefactoryref_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::sad::resourcefactoryproperties_pskel* resourcefactoryproperties_parser_;
+    ::xml_schema::string_pskel* refid_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::sad::componentresourcefactoryref_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+
+    protected:
+    struct v_state_attr_
+    {
+      bool refid;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class devicethatloadedthiscomponentref_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    refid (const ::std::string&);
+
+    virtual ::std::string
+    post_devicethatloadedthiscomponentref () = 0;
+
+    // Parser construction API.
+    //
+    void
+    refid_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* refid */);
+
+    // Constructor.
+    //
+    devicethatloadedthiscomponentref_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* refid_parser_;
+
+    protected:
+    struct v_state_attr_
+    {
+      bool refid;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class deviceusedbythiscomponentref_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    refid (const ::std::string&);
+
+    virtual void
+    usesrefid (const ::std::string&);
+
+    virtual ::std::pair<std::string, std::string>
+    post_deviceusedbythiscomponentref () = 0;
+
+    // Parser construction API.
+    //
+    void
+    refid_parser (::xml_schema::string_pskel&);
+
+    void
+    usesrefid_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* refid */,
+             ::xml_schema::string_pskel& /* usesrefid */);
+
+    // Constructor.
+    //
+    deviceusedbythiscomponentref_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* refid_parser_;
+    ::xml_schema::string_pskel* usesrefid_parser_;
+
+    protected:
+    struct v_state_attr_
+    {
+      bool refid;
+      bool usesrefid;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class deviceusedbyapplication_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    usesrefid (const ::std::string&);
+
+    virtual ::std::string
+    post_deviceusedbyapplication () = 0;
+
+    // Parser construction API.
+    //
+    void
+    usesrefid_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* usesrefid */);
+
+    // Constructor.
+    //
+    deviceusedbyapplication_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* usesrefid_parser_;
+
+    protected:
+    struct v_state_attr_
+    {
+      bool usesrefid;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class resourcefactoryproperties_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    simpleref (ossie::SimplePropertyRef*);
+
+    virtual void
+    simplesequenceref (ossie::SimpleSequencePropertyRef*);
+
+    virtual void
+    structref (ossie::StructPropertyRef*);
+
+    virtual void
+    structsequenceref (ossie::StructSequencePropertyRef*);
+
+    virtual void
+    post_resourcefactoryproperties ();
+
+    // Parser construction API.
+    //
+    void
+    simpleref_parser (::sad::simpleref_pskel&);
+
+    void
+    simplesequenceref_parser (::sad::simplesequenceref_pskel&);
+
+    void
+    structref_parser (::sad::structref_pskel&);
+
+    void
+    structsequenceref_parser (::sad::structsequenceref_pskel&);
+
+    void
+    parsers (::sad::simpleref_pskel& /* simpleref */,
+             ::sad::simplesequenceref_pskel& /* simplesequenceref */,
+             ::sad::structref_pskel& /* structref */,
+             ::sad::structsequenceref_pskel& /* structsequenceref */);
+
+    // Constructor.
+    //
+    resourcefactoryproperties_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::sad::simpleref_pskel* simpleref_parser_;
+    ::sad::simplesequenceref_pskel* simplesequenceref_parser_;
+    ::sad::structref_pskel* structref_parser_;
+    ::sad::structsequenceref_pskel* structsequenceref_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::sad::resourcefactoryproperties_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    choice_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start);
+  };
+
+  class simpleref_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    refid (const ::std::string&);
+
+    virtual void
+    value (const ::std::string&);
+
+    virtual ossie::SimplePropertyRef*
+    post_simpleref () = 0;
+
+    // Parser construction API.
+    //
+    void
+    refid_parser (::xml_schema::string_pskel&);
+
+    void
+    value_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* refid */,
+             ::xml_schema::string_pskel& /* value */);
+
+    // Constructor.
+    //
+    simpleref_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* refid_parser_;
+    ::xml_schema::string_pskel* value_parser_;
+
+    protected:
+    struct v_state_attr_
+    {
+      bool refid;
+      bool value;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class simplesequenceref_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    values (const ::std::vector<std::string>&);
+
+    virtual void
+    refid (const ::std::string&);
+
+    virtual ossie::SimpleSequencePropertyRef*
+    post_simplesequenceref () = 0;
+
+    // Parser construction API.
+    //
+    void
+    values_parser (::sad::values_pskel&);
+
+    void
+    refid_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::sad::values_pskel& /* values */,
+             ::xml_schema::string_pskel& /* refid */);
+
+    // Constructor.
+    //
+    simplesequenceref_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::sad::values_pskel* values_parser_;
+    ::xml_schema::string_pskel* refid_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::sad::simplesequenceref_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+
+    protected:
+    struct v_state_attr_
+    {
+      bool refid;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class structref_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    simpleref (ossie::SimplePropertyRef*);
+
+    virtual void
+    simplesequenceref (ossie::SimpleSequencePropertyRef*);
+
+    virtual void
+    refid (const ::std::string&);
+
+    virtual ossie::StructPropertyRef*
+    post_structref () = 0;
+
+    // Parser construction API.
+    //
+    void
+    simpleref_parser (::sad::simpleref_pskel&);
+
+    void
+    simplesequenceref_parser (::sad::simplesequenceref_pskel&);
+
+    void
+    refid_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::sad::simpleref_pskel& /* simpleref */,
+             ::sad::simplesequenceref_pskel& /* simplesequenceref */,
+             ::xml_schema::string_pskel& /* refid */);
+
+    // Constructor.
+    //
+    structref_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::sad::simpleref_pskel* simpleref_parser_;
+    ::sad::simplesequenceref_pskel* simplesequenceref_parser_;
+    ::xml_schema::string_pskel* refid_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::sad::structref_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[3UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+
+    void
+    choice_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start);
+
+    protected:
+    struct v_state_attr_
+    {
+      bool refid;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class structsequenceref_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    structvalue (const ::std::map<std::string, ossie::ComponentProperty*>&);
+
+    virtual void
+    refid (const ::std::string&);
+
+    virtual ossie::StructSequencePropertyRef*
+    post_structsequenceref () = 0;
+
+    // Parser construction API.
+    //
+    void
+    structvalue_parser (::sad::structvalue_pskel&);
+
+    void
+    refid_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::sad::structvalue_pskel& /* structvalue */,
+             ::xml_schema::string_pskel& /* refid */);
+
+    // Constructor.
+    //
+    structsequenceref_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::sad::structvalue_pskel* structvalue_parser_;
+    ::xml_schema::string_pskel* refid_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::sad::structsequenceref_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+
+    protected:
+    struct v_state_attr_
+    {
+      bool refid;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class structvalue_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    simpleref (ossie::SimplePropertyRef*);
+
+    virtual void
+    simplesequenceref (ossie::SimpleSequencePropertyRef*);
+
+    virtual ::std::map<std::string, ossie::ComponentProperty*>
+    post_structvalue () = 0;
+
+    // Parser construction API.
+    //
+    void
+    simpleref_parser (::sad::simpleref_pskel&);
+
+    void
+    simplesequenceref_parser (::sad::simplesequenceref_pskel&);
+
+    void
+    parsers (::sad::simpleref_pskel& /* simpleref */,
+             ::sad::simplesequenceref_pskel& /* simplesequenceref */);
+
+    // Constructor.
+    //
+    structvalue_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::sad::simpleref_pskel* simpleref_parser_;
+    ::sad::simplesequenceref_pskel* simplesequenceref_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::sad::structvalue_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[3UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+
+    void
+    choice_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start);
+  };
+
+  class values_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    value (const ::std::string&);
+
+    virtual ::std::vector<std::string>
+    post_values () = 0;
+
+    // Parser construction API.
+    //
+    void
+    value_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* value */);
+
+    // Constructor.
+    //
+    values_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::xml_schema::string_pskel* value_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::sad::values_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+  };
+
+  class componentinstantiationref_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    refid (const ::std::string&);
+
+    virtual ::std::string
+    post_componentinstantiationref () = 0;
+
+    // Parser construction API.
+    //
+    void
+    refid_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* refid */);
+
+    // Constructor.
+    //
+    componentinstantiationref_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* refid_parser_;
+
+    protected:
+    struct v_state_attr_
+    {
+      bool refid;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class findby_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    namingservice (const ::std::string&);
+
+    virtual void
+    stringifiedobjectref (const ::std::string&);
+
+    virtual void
+    domainfinder (const ::std::pair<std::string, std::string>&);
+
+    virtual ::ossie::FindBy
+    post_findby () = 0;
+
+    // Parser construction API.
+    //
+    void
+    namingservice_parser (::sad::namingservice_pskel&);
+
+    void
+    stringifiedobjectref_parser (::xml_schema::string_pskel&);
+
+    void
+    domainfinder_parser (::sad::domainfinder_pskel&);
+
+    void
+    parsers (::sad::namingservice_pskel& /* namingservice */,
+             ::xml_schema::string_pskel& /* stringifiedobjectref */,
+             ::sad::domainfinder_pskel& /* domainfinder */);
+
+    // Constructor.
+    //
+    findby_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::sad::namingservice_pskel* namingservice_parser_;
+    ::xml_schema::string_pskel* stringifiedobjectref_parser_;
+    ::sad::domainfinder_pskel* domainfinder_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::sad::findby_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    choice_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start);
+  };
+
+  class namingservice_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    name (const ::std::string&);
+
+    virtual ::std::string
+    post_namingservice () = 0;
+
+    // Parser construction API.
+    //
+    void
+    name_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* name */);
+
+    // Constructor.
+    //
+    namingservice_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* name_parser_;
+
+    protected:
+    struct v_state_attr_
+    {
+      bool name;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class domainfinder_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    type (const ::std::string&);
+
+    virtual void
+    name (const ::std::string&);
+
+    virtual ::std::pair<std::string, std::string>
+    post_domainfinder () = 0;
+
+    // Parser construction API.
+    //
+    void
+    type_parser (::xml_schema::string_pskel&);
+
+    void
+    name_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* type */,
+             ::xml_schema::string_pskel& /* name */);
+
+    // Constructor.
+    //
+    domainfinder_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* type_parser_;
+    ::xml_schema::string_pskel* name_parser_;
+
+    protected:
+    struct v_state_attr_
+    {
+      bool type;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class hostcollocation_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    componentplacement (const ::ossie::ComponentPlacement&);
+
+    virtual void
+    id (const ::std::string&);
+
+    virtual void
+    name (const ::std::string&);
+
+    virtual ::ossie::SoftwareAssembly::HostCollocation
+    post_hostcollocation () = 0;
+
+    // Parser construction API.
+    //
+    void
+    componentplacement_parser (::sad::componentplacement_pskel&);
+
+    void
+    id_parser (::xml_schema::string_pskel&);
+
+    void
+    name_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::sad::componentplacement_pskel& /* componentplacement */,
+             ::xml_schema::string_pskel& /* id */,
+             ::xml_schema::string_pskel& /* name */);
+
+    // Constructor.
+    //
+    hostcollocation_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::sad::componentplacement_pskel* componentplacement_parser_;
+    ::xml_schema::string_pskel* id_parser_;
+    ::xml_schema::string_pskel* name_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::sad::hostcollocation_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+  };
+
+  class assemblycontroller_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    componentinstantiationref (const ::std::string&);
+
+    virtual ::std::string
+    post_assemblycontroller () = 0;
+
+    // Parser construction API.
+    //
+    void
+    componentinstantiationref_parser (::sad::componentinstantiationref_pskel&);
+
+    void
+    parsers (::sad::componentinstantiationref_pskel& /* componentinstantiationref */);
+
+    // Constructor.
+    //
+    assemblycontroller_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::sad::componentinstantiationref_pskel* componentinstantiationref_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::sad::assemblycontroller_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+  };
+
+  class connections_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    connectinterface (const ::ossie::Connection&);
+
+    virtual ::std::vector<ossie::Connection>
+    post_connections () = 0;
+
+    // Parser construction API.
+    //
+    void
+    connectinterface_parser (::sad::connectinterface_pskel&);
+
+    void
+    parsers (::sad::connectinterface_pskel& /* connectinterface */);
+
+    // Constructor.
+    //
+    connections_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::sad::connectinterface_pskel* connectinterface_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::sad::connections_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+  };
+
+  class connectinterface_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    usesport (const ::ossie::UsesPort&);
+
+    virtual void
+    providesport (const ::ossie::ProvidesPort&);
+
+    virtual void
+    componentsupportedinterface (const ::ossie::ComponentSupportedInterface&);
+
+    virtual void
+    findby (const ::ossie::FindBy&);
+
+    virtual void
+    id (const ::std::string&);
+
+    virtual ::ossie::Connection
+    post_connectinterface () = 0;
+
+    // Parser construction API.
+    //
+    void
+    usesport_parser (::sad::usesport_pskel&);
+
+    void
+    providesport_parser (::sad::providesport_pskel&);
+
+    void
+    componentsupportedinterface_parser (::sad::componentsupportedinterface_pskel&);
+
+    void
+    findby_parser (::sad::findby_pskel&);
+
+    void
+    id_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::sad::usesport_pskel& /* usesport */,
+             ::sad::providesport_pskel& /* providesport */,
+             ::sad::componentsupportedinterface_pskel& /* componentsupportedinterface */,
+             ::sad::findby_pskel& /* findby */,
+             ::xml_schema::string_pskel& /* id */);
+
+    // Constructor.
+    //
+    connectinterface_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::sad::usesport_pskel* usesport_parser_;
+    ::sad::providesport_pskel* providesport_parser_;
+    ::sad::componentsupportedinterface_pskel* componentsupportedinterface_parser_;
+    ::sad::findby_pskel* findby_parser_;
+    ::xml_schema::string_pskel* id_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::sad::connectinterface_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[3UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+
+    void
+    choice_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start);
+  };
+
+  class usesport_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    usesidentifier (const ::std::string&);
+
+    virtual void
+    componentinstantiationref (const ::std::string&);
+
+    virtual void
+    devicethatloadedthiscomponentref (const ::std::string&);
+
+    virtual void
+    deviceusedbythiscomponentref (const ::std::pair<std::string, std::string>&);
+
+    virtual void
+    deviceusedbyapplication (const ::std::string&);
+
+    virtual void
+    findby (const ::ossie::FindBy&);
+
+    virtual ::ossie::UsesPort
+    post_usesport () = 0;
+
+    // Parser construction API.
+    //
+    void
+    usesidentifier_parser (::xml_schema::string_pskel&);
+
+    void
+    componentinstantiationref_parser (::sad::componentinstantiationref_pskel&);
+
+    void
+    devicethatloadedthiscomponentref_parser (::sad::devicethatloadedthiscomponentref_pskel&);
+
+    void
+    deviceusedbythiscomponentref_parser (::sad::deviceusedbythiscomponentref_pskel&);
+
+    void
+    deviceusedbyapplication_parser (::sad::deviceusedbyapplication_pskel&);
+
+    void
+    findby_parser (::sad::findby_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* usesidentifier */,
+             ::sad::componentinstantiationref_pskel& /* componentinstantiationref */,
+             ::sad::devicethatloadedthiscomponentref_pskel& /* devicethatloadedthiscomponentref */,
+             ::sad::deviceusedbythiscomponentref_pskel& /* deviceusedbythiscomponentref */,
+             ::sad::deviceusedbyapplication_pskel& /* deviceusedbyapplication */,
+             ::sad::findby_pskel& /* findby */);
+
+    // Constructor.
+    //
+    usesport_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::xml_schema::string_pskel* usesidentifier_parser_;
+    ::sad::componentinstantiationref_pskel* componentinstantiationref_parser_;
+    ::sad::devicethatloadedthiscomponentref_pskel* devicethatloadedthiscomponentref_parser_;
+    ::sad::deviceusedbythiscomponentref_pskel* deviceusedbythiscomponentref_parser_;
+    ::sad::deviceusedbyapplication_pskel* deviceusedbyapplication_parser_;
+    ::sad::findby_pskel* findby_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::sad::usesport_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[3UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+
+    void
+    choice_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start);
+  };
+
+  class providesport_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    providesidentifier (const ::std::string&);
+
+    virtual void
+    componentinstantiationref (const ::std::string&);
+
+    virtual void
+    devicethatloadedthiscomponentref (const ::std::string&);
+
+    virtual void
+    deviceusedbythiscomponentref (const ::std::pair<std::string, std::string>&);
+
+    virtual void
+    deviceusedbyapplication (const ::std::string&);
+
+    virtual void
+    findby (const ::ossie::FindBy&);
+
+    virtual ::ossie::ProvidesPort
+    post_providesport () = 0;
+
+    // Parser construction API.
+    //
+    void
+    providesidentifier_parser (::xml_schema::string_pskel&);
+
+    void
+    componentinstantiationref_parser (::sad::componentinstantiationref_pskel&);
+
+    void
+    devicethatloadedthiscomponentref_parser (::sad::devicethatloadedthiscomponentref_pskel&);
+
+    void
+    deviceusedbythiscomponentref_parser (::sad::deviceusedbythiscomponentref_pskel&);
+
+    void
+    deviceusedbyapplication_parser (::sad::deviceusedbyapplication_pskel&);
+
+    void
+    findby_parser (::sad::findby_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* providesidentifier */,
+             ::sad::componentinstantiationref_pskel& /* componentinstantiationref */,
+             ::sad::devicethatloadedthiscomponentref_pskel& /* devicethatloadedthiscomponentref */,
+             ::sad::deviceusedbythiscomponentref_pskel& /* deviceusedbythiscomponentref */,
+             ::sad::deviceusedbyapplication_pskel& /* deviceusedbyapplication */,
+             ::sad::findby_pskel& /* findby */);
+
+    // Constructor.
+    //
+    providesport_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::xml_schema::string_pskel* providesidentifier_parser_;
+    ::sad::componentinstantiationref_pskel* componentinstantiationref_parser_;
+    ::sad::devicethatloadedthiscomponentref_pskel* devicethatloadedthiscomponentref_parser_;
+    ::sad::deviceusedbythiscomponentref_pskel* deviceusedbythiscomponentref_parser_;
+    ::sad::deviceusedbyapplication_pskel* deviceusedbyapplication_parser_;
+    ::sad::findby_pskel* findby_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::sad::providesport_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[3UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+
+    void
+    choice_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start);
+  };
+
+  class componentsupportedinterface_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    supportedidentifier (const ::std::string&);
+
+    virtual void
+    componentinstantiationref (const ::std::string&);
+
+    virtual void
+    devicethatloadedthiscomponentref (const ::std::string&);
+
+    virtual void
+    deviceusedbythiscomponentref (const ::std::pair<std::string, std::string>&);
+
+    virtual void
+    deviceusedbyapplication (const ::std::string&);
+
+    virtual void
+    findby (const ::ossie::FindBy&);
+
+    virtual ::ossie::ComponentSupportedInterface
+    post_componentsupportedinterface () = 0;
+
+    // Parser construction API.
+    //
+    void
+    supportedidentifier_parser (::xml_schema::string_pskel&);
+
+    void
+    componentinstantiationref_parser (::sad::componentinstantiationref_pskel&);
+
+    void
+    devicethatloadedthiscomponentref_parser (::sad::devicethatloadedthiscomponentref_pskel&);
+
+    void
+    deviceusedbythiscomponentref_parser (::sad::deviceusedbythiscomponentref_pskel&);
+
+    void
+    deviceusedbyapplication_parser (::sad::deviceusedbyapplication_pskel&);
+
+    void
+    findby_parser (::sad::findby_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* supportedidentifier */,
+             ::sad::componentinstantiationref_pskel& /* componentinstantiationref */,
+             ::sad::devicethatloadedthiscomponentref_pskel& /* devicethatloadedthiscomponentref */,
+             ::sad::deviceusedbythiscomponentref_pskel& /* deviceusedbythiscomponentref */,
+             ::sad::deviceusedbyapplication_pskel& /* deviceusedbyapplication */,
+             ::sad::findby_pskel& /* findby */);
+
+    // Constructor.
+    //
+    componentsupportedinterface_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::xml_schema::string_pskel* supportedidentifier_parser_;
+    ::sad::componentinstantiationref_pskel* componentinstantiationref_parser_;
+    ::sad::devicethatloadedthiscomponentref_pskel* devicethatloadedthiscomponentref_parser_;
+    ::sad::deviceusedbythiscomponentref_pskel* deviceusedbythiscomponentref_parser_;
+    ::sad::deviceusedbyapplication_pskel* deviceusedbyapplication_parser_;
+    ::sad::findby_pskel* findby_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::sad::componentsupportedinterface_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[3UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+
+    void
+    choice_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start);
+  };
+
+  class externalports_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    port (const ossie::SoftwareAssembly::Port&);
+
+    virtual ::std::vector<ossie::SoftwareAssembly::Port>
+    post_externalports () = 0;
+
+    // Parser construction API.
+    //
+    void
+    port_parser (::sad::port_pskel&);
+
+    void
+    parsers (::sad::port_pskel& /* port */);
+
+    // Constructor.
+    //
+    externalports_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::sad::port_pskel* port_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::sad::externalports_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+  };
+
+  class port_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    description (const ::std::string&);
+
+    virtual void
+    usesidentifier (const ::std::string&);
+
+    virtual void
+    providesidentifier (const ::std::string&);
+
+    virtual void
+    supportedidentifier (const ::std::string&);
+
+    virtual void
+    componentinstantiationref (const ::std::string&);
+
+    virtual void
+    externalname (const ::std::string&);
+
+    virtual ossie::SoftwareAssembly::Port
+    post_port () = 0;
+
+    // Parser construction API.
+    //
+    void
+    description_parser (::xml_schema::string_pskel&);
+
+    void
+    usesidentifier_parser (::xml_schema::string_pskel&);
+
+    void
+    providesidentifier_parser (::xml_schema::string_pskel&);
+
+    void
+    supportedidentifier_parser (::xml_schema::string_pskel&);
+
+    void
+    componentinstantiationref_parser (::sad::componentinstantiationref_pskel&);
+
+    void
+    externalname_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* description */,
+             ::xml_schema::string_pskel& /* usesidentifier */,
+             ::xml_schema::string_pskel& /* providesidentifier */,
+             ::xml_schema::string_pskel& /* supportedidentifier */,
+             ::sad::componentinstantiationref_pskel& /* componentinstantiationref */,
+             ::xml_schema::string_pskel& /* externalname */);
+
+    // Constructor.
+    //
+    port_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* description_parser_;
+    ::xml_schema::string_pskel* usesidentifier_parser_;
+    ::xml_schema::string_pskel* providesidentifier_parser_;
+    ::xml_schema::string_pskel* supportedidentifier_parser_;
+    ::sad::componentinstantiationref_pskel* componentinstantiationref_parser_;
+    ::xml_schema::string_pskel* externalname_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::sad::port_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[3UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+
+    void
+    choice_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start);
+  };
+
+  class externalproperties_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    property (const ossie::SoftwareAssembly::Property&);
+
+    virtual ::std::vector<ossie::SoftwareAssembly::Property>
+    post_externalproperties () = 0;
+
+    // Parser construction API.
+    //
+    void
+    property_parser (::sad::property_pskel&);
+
+    void
+    parsers (::sad::property_pskel& /* property */);
+
+    // Constructor.
+    //
+    externalproperties_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::sad::property_pskel* property_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::sad::externalproperties_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+  };
+
+  class property_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    comprefid (const ::std::string&);
+
+    virtual void
+    propid (const ::std::string&);
+
+    virtual void
+    externalpropid (const ::std::string&);
+
+    virtual ossie::SoftwareAssembly::Property
+    post_property () = 0;
+
+    // Parser construction API.
+    //
+    void
+    comprefid_parser (::xml_schema::string_pskel&);
+
+    void
+    propid_parser (::xml_schema::string_pskel&);
+
+    void
+    externalpropid_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* comprefid */,
+             ::xml_schema::string_pskel& /* propid */,
+             ::xml_schema::string_pskel& /* externalpropid */);
+
+    // Constructor.
+    //
+    property_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* comprefid_parser_;
+    ::xml_schema::string_pskel* propid_parser_;
+    ::xml_schema::string_pskel* externalpropid_parser_;
+
+    protected:
+    struct v_state_attr_
+    {
+      bool comprefid;
+      bool propid;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class usesdevicedependencies_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    usesdevice (const ossie::SoftwareAssembly::UsesDevice&);
+
+    virtual ::std::vector<ossie::SoftwareAssembly::UsesDevice>
+    post_usesdevicedependencies () = 0;
+
+    // Parser construction API.
+    //
+    void
+    usesdevice_parser (::sad::usesdevice_pskel&);
+
+    void
+    parsers (::sad::usesdevice_pskel& /* usesdevice */);
+
+    // Constructor.
+    //
+    usesdevicedependencies_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::sad::usesdevice_pskel* usesdevice_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::sad::usesdevicedependencies_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+  };
+
+  class usesdevice_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    propertyref (const ossie::SoftwareAssembly::PropertyRef&);
+
+    virtual void
+    simpleref (ossie::SimplePropertyRef*);
+
+    virtual void
+    simplesequenceref (ossie::SimpleSequencePropertyRef*);
+
+    virtual void
+    structref (ossie::StructPropertyRef*);
+
+    virtual void
+    structsequenceref (ossie::StructSequencePropertyRef*);
+
+    virtual void
+    id (const ::std::string&);
+
+    virtual void
+    type (const ::std::string&);
+
+    virtual ossie::SoftwareAssembly::UsesDevice
+    post_usesdevice () = 0;
+
+    // Parser construction API.
+    //
+    void
+    propertyref_parser (::sad::propertyref_pskel&);
+
+    void
+    simpleref_parser (::sad::simpleref_pskel&);
+
+    void
+    simplesequenceref_parser (::sad::simplesequenceref_pskel&);
+
+    void
+    structref_parser (::sad::structref_pskel&);
+
+    void
+    structsequenceref_parser (::sad::structsequenceref_pskel&);
+
+    void
+    id_parser (::xml_schema::string_pskel&);
+
+    void
+    type_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::sad::propertyref_pskel& /* propertyref */,
+             ::sad::simpleref_pskel& /* simpleref */,
+             ::sad::simplesequenceref_pskel& /* simplesequenceref */,
+             ::sad::structref_pskel& /* structref */,
+             ::sad::structsequenceref_pskel& /* structsequenceref */,
+             ::xml_schema::string_pskel& /* id */,
+             ::xml_schema::string_pskel& /* type */);
+
+    // Constructor.
+    //
+    usesdevice_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::sad::propertyref_pskel* propertyref_parser_;
+    ::sad::simpleref_pskel* simpleref_parser_;
+    ::sad::simplesequenceref_pskel* simplesequenceref_parser_;
+    ::sad::structref_pskel* structref_parser_;
+    ::sad::structsequenceref_pskel* structsequenceref_parser_;
+    ::xml_schema::string_pskel* id_parser_;
+    ::xml_schema::string_pskel* type_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::sad::usesdevice_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    choice_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start);
+
+    protected:
+    struct v_state_attr_
+    {
+      bool id;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class propertyref_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    refid (const ::std::string&);
+
+    virtual void
+    value (const ::std::string&);
+
+    virtual ossie::SoftwareAssembly::PropertyRef
+    post_propertyref () = 0;
+
+    // Parser construction API.
+    //
+    void
+    refid_parser (::xml_schema::string_pskel&);
+
+    void
+    value_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* refid */,
+             ::xml_schema::string_pskel& /* value */);
+
+    // Constructor.
+    //
+    propertyref_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* refid_parser_;
+    ::xml_schema::string_pskel* value_parser_;
+
+    protected:
+    struct v_state_attr_
+    {
+      bool refid;
+      bool value;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+}
+
+#include <xsd/cxx/post.hxx>
+
+// Begin epilogue.
+//
+//
+// End epilogue.
+
+#endif // CXX______XML_XSD_SAD_PSKEL_H
diff --git src/control/parser/internal/scd-pskel.cpp src/control/parser/internal/scd-pskel.cpp
new file mode 100644
index 0000000..85f99ce
--- /dev/null
+++ src/control/parser/internal/scd-pskel.cpp
@@ -0,0 +1,2941 @@
+// Copyright (C) 2005-2010 Code Synthesis Tools CC
+//
+// This program was generated by CodeSynthesis XSD, an XML Schema to
+// C++ data binding compiler.
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 2 as
+// published by the Free Software Foundation.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+//
+// In addition, as a special exception, Code Synthesis Tools CC gives
+// permission to link this program with the Xerces-C++ library (or with
+// modified versions of Xerces-C++ that use the same license as Xerces-C++),
+// and distribute linked combinations including the two. You must obey
+// the GNU General Public License version 2 in all respects for all of
+// the code used other than Xerces-C++. If you modify this copy of the
+// program, you may extend this exception to your version of the program,
+// but you are not obligated to do so. If you do not wish to do so, delete
+// this exception statement from your version.
+//
+// Furthermore, Code Synthesis Tools CC makes a special exception for
+// the Free/Libre and Open Source Software (FLOSS) which is described
+// in the accompanying FLOSSE file.
+//
+
+// Begin prologue.
+//
+//
+// End prologue.
+
+#include "scd-pskel.h"
+
+namespace scd
+{
+  // softwarecomponent_pskel
+  //
+
+  void softwarecomponent_pskel::
+  corbaversion_parser (::xml_schema::string_pskel& p)
+  {
+    this->corbaversion_parser_ = &p;
+  }
+
+  void softwarecomponent_pskel::
+  componentrepid_parser (::scd::componentRepId_pskel& p)
+  {
+    this->componentrepid_parser_ = &p;
+  }
+
+  void softwarecomponent_pskel::
+  componenttype_parser (::xml_schema::string_pskel& p)
+  {
+    this->componenttype_parser_ = &p;
+  }
+
+  void softwarecomponent_pskel::
+  componentfeatures_parser (::scd::componentFeatures_pskel& p)
+  {
+    this->componentfeatures_parser_ = &p;
+  }
+
+  void softwarecomponent_pskel::
+  interfaces_parser (::scd::interfaces_pskel& p)
+  {
+    this->interfaces_parser_ = &p;
+  }
+
+  void softwarecomponent_pskel::
+  propertyfile_parser (::scd::propertyFile_pskel& p)
+  {
+    this->propertyfile_parser_ = &p;
+  }
+
+  void softwarecomponent_pskel::
+  parsers (::xml_schema::string_pskel& corbaversion,
+           ::scd::componentRepId_pskel& componentrepid,
+           ::xml_schema::string_pskel& componenttype,
+           ::scd::componentFeatures_pskel& componentfeatures,
+           ::scd::interfaces_pskel& interfaces,
+           ::scd::propertyFile_pskel& propertyfile)
+  {
+    this->corbaversion_parser_ = &corbaversion;
+    this->componentrepid_parser_ = &componentrepid;
+    this->componenttype_parser_ = &componenttype;
+    this->componentfeatures_parser_ = &componentfeatures;
+    this->interfaces_parser_ = &interfaces;
+    this->propertyfile_parser_ = &propertyfile;
+  }
+
+  softwarecomponent_pskel::
+  softwarecomponent_pskel ()
+  : corbaversion_parser_ (0),
+    componentrepid_parser_ (0),
+    componenttype_parser_ (0),
+    componentfeatures_parser_ (0),
+    interfaces_parser_ (0),
+    propertyfile_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // propertyFile_pskel
+  //
+
+  void propertyFile_pskel::
+  localfile_parser (::scd::localFile_pskel& p)
+  {
+    this->localfile_parser_ = &p;
+  }
+
+  void propertyFile_pskel::
+  type_parser (::xml_schema::string_pskel& p)
+  {
+    this->type_parser_ = &p;
+  }
+
+  void propertyFile_pskel::
+  parsers (::scd::localFile_pskel& localfile,
+           ::xml_schema::string_pskel& type)
+  {
+    this->localfile_parser_ = &localfile;
+    this->type_parser_ = &type;
+  }
+
+  propertyFile_pskel::
+  propertyFile_pskel ()
+  : localfile_parser_ (0),
+    type_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // localFile_pskel
+  //
+
+  void localFile_pskel::
+  name_parser (::xml_schema::string_pskel& p)
+  {
+    this->name_parser_ = &p;
+  }
+
+  void localFile_pskel::
+  parsers (::xml_schema::string_pskel& name)
+  {
+    this->name_parser_ = &name;
+  }
+
+  localFile_pskel::
+  localFile_pskel ()
+  : name_parser_ (0),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // componentRepId_pskel
+  //
+
+  void componentRepId_pskel::
+  repid_parser (::xml_schema::string_pskel& p)
+  {
+    this->repid_parser_ = &p;
+  }
+
+  void componentRepId_pskel::
+  parsers (::xml_schema::string_pskel& repid)
+  {
+    this->repid_parser_ = &repid;
+  }
+
+  componentRepId_pskel::
+  componentRepId_pskel ()
+  : repid_parser_ (0),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // componentFeatures_pskel
+  //
+
+  void componentFeatures_pskel::
+  supportsinterface_parser (::scd::supportsInterface_pskel& p)
+  {
+    this->supportsinterface_parser_ = &p;
+  }
+
+  void componentFeatures_pskel::
+  ports_parser (::scd::ports_pskel& p)
+  {
+    this->ports_parser_ = &p;
+  }
+
+  void componentFeatures_pskel::
+  parsers (::scd::supportsInterface_pskel& supportsinterface,
+           ::scd::ports_pskel& ports)
+  {
+    this->supportsinterface_parser_ = &supportsinterface;
+    this->ports_parser_ = &ports;
+  }
+
+  componentFeatures_pskel::
+  componentFeatures_pskel ()
+  : supportsinterface_parser_ (0),
+    ports_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // supportsInterface_pskel
+  //
+
+  void supportsInterface_pskel::
+  repid_parser (::xml_schema::string_pskel& p)
+  {
+    this->repid_parser_ = &p;
+  }
+
+  void supportsInterface_pskel::
+  supportsname_parser (::xml_schema::string_pskel& p)
+  {
+    this->supportsname_parser_ = &p;
+  }
+
+  void supportsInterface_pskel::
+  parsers (::xml_schema::string_pskel& repid,
+           ::xml_schema::string_pskel& supportsname)
+  {
+    this->repid_parser_ = &repid;
+    this->supportsname_parser_ = &supportsname;
+  }
+
+  supportsInterface_pskel::
+  supportsInterface_pskel ()
+  : repid_parser_ (0),
+    supportsname_parser_ (0),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // ports_pskel
+  //
+
+  void ports_pskel::
+  provides_parser (::scd::provides_pskel& p)
+  {
+    this->provides_parser_ = &p;
+  }
+
+  void ports_pskel::
+  uses_parser (::scd::uses_pskel& p)
+  {
+    this->uses_parser_ = &p;
+  }
+
+  void ports_pskel::
+  parsers (::scd::provides_pskel& provides,
+           ::scd::uses_pskel& uses)
+  {
+    this->provides_parser_ = &provides;
+    this->uses_parser_ = &uses;
+  }
+
+  ports_pskel::
+  ports_pskel ()
+  : provides_parser_ (0),
+    uses_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // provides_pskel
+  //
+
+  void provides_pskel::
+  description_parser (::xml_schema::string_pskel& p)
+  {
+    this->description_parser_ = &p;
+  }
+
+  void provides_pskel::
+  porttype_parser (::scd::portType_pskel& p)
+  {
+    this->porttype_parser_ = &p;
+  }
+
+  void provides_pskel::
+  repid_parser (::xml_schema::string_pskel& p)
+  {
+    this->repid_parser_ = &p;
+  }
+
+  void provides_pskel::
+  providesname_parser (::xml_schema::string_pskel& p)
+  {
+    this->providesname_parser_ = &p;
+  }
+
+  void provides_pskel::
+  parsers (::xml_schema::string_pskel& description,
+           ::scd::portType_pskel& porttype,
+           ::xml_schema::string_pskel& repid,
+           ::xml_schema::string_pskel& providesname)
+  {
+    this->description_parser_ = &description;
+    this->porttype_parser_ = &porttype;
+    this->repid_parser_ = &repid;
+    this->providesname_parser_ = &providesname;
+  }
+
+  provides_pskel::
+  provides_pskel ()
+  : description_parser_ (0),
+    porttype_parser_ (0),
+    repid_parser_ (0),
+    providesname_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // uses_pskel
+  //
+
+  void uses_pskel::
+  description_parser (::xml_schema::string_pskel& p)
+  {
+    this->description_parser_ = &p;
+  }
+
+  void uses_pskel::
+  porttype_parser (::scd::portType_pskel& p)
+  {
+    this->porttype_parser_ = &p;
+  }
+
+  void uses_pskel::
+  repid_parser (::xml_schema::string_pskel& p)
+  {
+    this->repid_parser_ = &p;
+  }
+
+  void uses_pskel::
+  usesname_parser (::xml_schema::string_pskel& p)
+  {
+    this->usesname_parser_ = &p;
+  }
+
+  void uses_pskel::
+  parsers (::xml_schema::string_pskel& description,
+           ::scd::portType_pskel& porttype,
+           ::xml_schema::string_pskel& repid,
+           ::xml_schema::string_pskel& usesname)
+  {
+    this->description_parser_ = &description;
+    this->porttype_parser_ = &porttype;
+    this->repid_parser_ = &repid;
+    this->usesname_parser_ = &usesname;
+  }
+
+  uses_pskel::
+  uses_pskel ()
+  : description_parser_ (0),
+    porttype_parser_ (0),
+    repid_parser_ (0),
+    usesname_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // portType_pskel
+  //
+
+  void portType_pskel::
+  type_parser (::scd::type_pskel& p)
+  {
+    this->type_parser_ = &p;
+  }
+
+  void portType_pskel::
+  parsers (::scd::type_pskel& type)
+  {
+    this->type_parser_ = &type;
+  }
+
+  portType_pskel::
+  portType_pskel ()
+  : type_parser_ (0),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // interfaces_pskel
+  //
+
+  void interfaces_pskel::
+  interface_parser (::scd::interface_pskel& p)
+  {
+    this->interface_parser_ = &p;
+  }
+
+  void interfaces_pskel::
+  parsers (::scd::interface_pskel& interface)
+  {
+    this->interface_parser_ = &interface;
+  }
+
+  interfaces_pskel::
+  interfaces_pskel ()
+  : interface_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // interface_pskel
+  //
+
+  void interface_pskel::
+  inheritsinterface_parser (::scd::inheritsInterface_pskel& p)
+  {
+    this->inheritsinterface_parser_ = &p;
+  }
+
+  void interface_pskel::
+  repid_parser (::xml_schema::string_pskel& p)
+  {
+    this->repid_parser_ = &p;
+  }
+
+  void interface_pskel::
+  name_parser (::xml_schema::string_pskel& p)
+  {
+    this->name_parser_ = &p;
+  }
+
+  void interface_pskel::
+  parsers (::scd::inheritsInterface_pskel& inheritsinterface,
+           ::xml_schema::string_pskel& repid,
+           ::xml_schema::string_pskel& name)
+  {
+    this->inheritsinterface_parser_ = &inheritsinterface;
+    this->repid_parser_ = &repid;
+    this->name_parser_ = &name;
+  }
+
+  interface_pskel::
+  interface_pskel ()
+  : inheritsinterface_parser_ (0),
+    repid_parser_ (0),
+    name_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // inheritsInterface_pskel
+  //
+
+  void inheritsInterface_pskel::
+  repid_parser (::xml_schema::string_pskel& p)
+  {
+    this->repid_parser_ = &p;
+  }
+
+  void inheritsInterface_pskel::
+  parsers (::xml_schema::string_pskel& repid)
+  {
+    this->repid_parser_ = &repid;
+  }
+
+  inheritsInterface_pskel::
+  inheritsInterface_pskel ()
+  : repid_parser_ (0),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+}
+
+namespace scd
+{
+  // softwarecomponent_pskel
+  //
+
+  void softwarecomponent_pskel::
+  corbaversion (const ::std::string&)
+  {
+  }
+
+  void softwarecomponent_pskel::
+  componentrepid ()
+  {
+  }
+
+  void softwarecomponent_pskel::
+  componenttype (const ::std::string&)
+  {
+  }
+
+  void softwarecomponent_pskel::
+  componentfeatures ()
+  {
+  }
+
+  void softwarecomponent_pskel::
+  interfaces ()
+  {
+  }
+
+  void softwarecomponent_pskel::
+  propertyfile ()
+  {
+  }
+
+  // propertyFile_pskel
+  //
+
+  void propertyFile_pskel::
+  localfile ()
+  {
+  }
+
+  void propertyFile_pskel::
+  type (const ::std::string&)
+  {
+  }
+
+  void propertyFile_pskel::
+  post_propertyFile ()
+  {
+  }
+
+  // localFile_pskel
+  //
+
+  void localFile_pskel::
+  name (const ::std::string&)
+  {
+  }
+
+  void localFile_pskel::
+  post_localFile ()
+  {
+  }
+
+  // componentRepId_pskel
+  //
+
+  void componentRepId_pskel::
+  repid (const ::std::string&)
+  {
+  }
+
+  void componentRepId_pskel::
+  post_componentRepId ()
+  {
+  }
+
+  // componentFeatures_pskel
+  //
+
+  void componentFeatures_pskel::
+  supportsinterface ()
+  {
+  }
+
+  void componentFeatures_pskel::
+  ports ()
+  {
+  }
+
+  void componentFeatures_pskel::
+  post_componentFeatures ()
+  {
+  }
+
+  // supportsInterface_pskel
+  //
+
+  void supportsInterface_pskel::
+  repid (const ::std::string&)
+  {
+  }
+
+  void supportsInterface_pskel::
+  supportsname (const ::std::string&)
+  {
+  }
+
+  void supportsInterface_pskel::
+  post_supportsInterface ()
+  {
+  }
+
+  // ports_pskel
+  //
+
+  void ports_pskel::
+  provides ()
+  {
+  }
+
+  void ports_pskel::
+  uses ()
+  {
+  }
+
+  void ports_pskel::
+  post_ports ()
+  {
+  }
+
+  // provides_pskel
+  //
+
+  void provides_pskel::
+  description (const ::std::string&)
+  {
+  }
+
+  void provides_pskel::
+  porttype ()
+  {
+  }
+
+  void provides_pskel::
+  repid (const ::std::string&)
+  {
+  }
+
+  void provides_pskel::
+  providesname (const ::std::string&)
+  {
+  }
+
+  void provides_pskel::
+  post_provides ()
+  {
+  }
+
+  // uses_pskel
+  //
+
+  void uses_pskel::
+  description (const ::std::string&)
+  {
+  }
+
+  void uses_pskel::
+  porttype ()
+  {
+  }
+
+  void uses_pskel::
+  repid (const ::std::string&)
+  {
+  }
+
+  void uses_pskel::
+  usesname (const ::std::string&)
+  {
+  }
+
+  void uses_pskel::
+  post_uses ()
+  {
+  }
+
+  // portType_pskel
+  //
+
+  void portType_pskel::
+  type ()
+  {
+  }
+
+  void portType_pskel::
+  post_portType ()
+  {
+  }
+
+  // interfaces_pskel
+  //
+
+  void interfaces_pskel::
+  interface ()
+  {
+  }
+
+  void interfaces_pskel::
+  post_interfaces ()
+  {
+  }
+
+  // interface_pskel
+  //
+
+  void interface_pskel::
+  inheritsinterface ()
+  {
+  }
+
+  void interface_pskel::
+  repid (const ::std::string&)
+  {
+  }
+
+  void interface_pskel::
+  name (const ::std::string&)
+  {
+  }
+
+  void interface_pskel::
+  post_interface ()
+  {
+  }
+
+  // inheritsInterface_pskel
+  //
+
+  void inheritsInterface_pskel::
+  repid (const ::std::string&)
+  {
+  }
+
+  void inheritsInterface_pskel::
+  post_inheritsInterface ()
+  {
+  }
+
+  // type_pskel
+  //
+
+  void type_pskel::
+  post_type ()
+  {
+  }
+}
+
+#include <cassert>
+
+namespace scd
+{
+  // Element validation and dispatch functions for softwarecomponent_pskel.
+  //
+  bool softwarecomponent_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "corbaversion" && ns.empty ())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &softwarecomponent_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "corbaversion",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool softwarecomponent_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void softwarecomponent_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void softwarecomponent_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "corbaversion");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void softwarecomponent_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "corbaversion" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->corbaversion_parser_;
+
+            if (this->corbaversion_parser_)
+              this->corbaversion_parser_->pre ();
+          }
+          else
+          {
+            if (this->corbaversion_parser_)
+            {
+              const ::std::string& tmp (this->corbaversion_parser_->post_string ());
+              this->corbaversion (tmp);
+            }
+
+            count = 0;
+            state = 1UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "corbaversion",
+              ns, n);
+          count = 0;
+          state = 1UL;
+          // Fall through.
+        }
+      }
+      case 1UL:
+      {
+        if (n == "componentrepid" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->componentrepid_parser_;
+
+            if (this->componentrepid_parser_)
+              this->componentrepid_parser_->pre ();
+          }
+          else
+          {
+            if (this->componentrepid_parser_)
+            {
+              this->componentrepid_parser_->post_componentRepId ();
+              this->componentrepid ();
+            }
+
+            count = 0;
+            state = 2UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "componentrepid",
+              ns, n);
+          count = 0;
+          state = 2UL;
+          // Fall through.
+        }
+      }
+      case 2UL:
+      {
+        if (n == "componenttype" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->componenttype_parser_;
+
+            if (this->componenttype_parser_)
+              this->componenttype_parser_->pre ();
+          }
+          else
+          {
+            if (this->componenttype_parser_)
+            {
+              const ::std::string& tmp (this->componenttype_parser_->post_string ());
+              this->componenttype (tmp);
+            }
+
+            count = 0;
+            state = 3UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "componenttype",
+              ns, n);
+          count = 0;
+          state = 3UL;
+          // Fall through.
+        }
+      }
+      case 3UL:
+      {
+        if (n == "componentfeatures" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->componentfeatures_parser_;
+
+            if (this->componentfeatures_parser_)
+              this->componentfeatures_parser_->pre ();
+          }
+          else
+          {
+            if (this->componentfeatures_parser_)
+            {
+              this->componentfeatures_parser_->post_componentFeatures ();
+              this->componentfeatures ();
+            }
+
+            count = 0;
+            state = 4UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "componentfeatures",
+              ns, n);
+          count = 0;
+          state = 4UL;
+          // Fall through.
+        }
+      }
+      case 4UL:
+      {
+        if (n == "interfaces" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->interfaces_parser_;
+
+            if (this->interfaces_parser_)
+              this->interfaces_parser_->pre ();
+          }
+          else
+          {
+            if (this->interfaces_parser_)
+            {
+              this->interfaces_parser_->post_interfaces ();
+              this->interfaces ();
+            }
+
+            count = 0;
+            state = 5UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "interfaces",
+              ns, n);
+          count = 0;
+          state = 5UL;
+          // Fall through.
+        }
+      }
+      case 5UL:
+      {
+        if (n == "propertyfile" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->propertyfile_parser_;
+
+            if (this->propertyfile_parser_)
+              this->propertyfile_parser_->pre ();
+          }
+          else
+          {
+            if (this->propertyfile_parser_)
+            {
+              this->propertyfile_parser_->post_propertyFile ();
+              this->propertyfile ();
+            }
+
+            count = 0;
+            state = ~0UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for propertyFile_pskel.
+  //
+  bool propertyFile_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "localfile" && ns.empty ())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &propertyFile_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "localfile",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool propertyFile_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void propertyFile_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void propertyFile_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "localfile");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void propertyFile_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "localfile" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->localfile_parser_;
+
+            if (this->localfile_parser_)
+              this->localfile_parser_->pre ();
+          }
+          else
+          {
+            if (this->localfile_parser_)
+            {
+              this->localfile_parser_->post_localFile ();
+              this->localfile ();
+            }
+
+            count = 0;
+            state = ~0UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "localfile",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for componentFeatures_pskel.
+  //
+  bool componentFeatures_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "supportsinterface" && ns.empty ())
+          s = 0UL;
+        else if (n == "ports" && ns.empty ())
+          s = 1UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &componentFeatures_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "supportsinterface",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool componentFeatures_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void componentFeatures_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void componentFeatures_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "supportsinterface");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void componentFeatures_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "supportsinterface" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->supportsinterface_parser_;
+
+            if (this->supportsinterface_parser_)
+              this->supportsinterface_parser_->pre ();
+          }
+          else
+          {
+            if (this->supportsinterface_parser_)
+            {
+              this->supportsinterface_parser_->post_supportsInterface ();
+              this->supportsinterface ();
+            }
+
+            count++;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 1UL;
+          // Fall through.
+        }
+      }
+      case 1UL:
+      {
+        if (n == "ports" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->ports_parser_;
+
+            if (this->ports_parser_)
+              this->ports_parser_->pre ();
+          }
+          else
+          {
+            if (this->ports_parser_)
+            {
+              this->ports_parser_->post_ports ();
+              this->ports ();
+            }
+
+            count = 0;
+            state = ~0UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "ports",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for ports_pskel.
+  //
+  bool ports_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "provides" && ns.empty ())
+          s = 0UL;
+        else if (n == "uses" && ns.empty ())
+          s = 1UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+
+          vd = vs.data + vs.size++;
+          vd->func = &ports_pskel::choice_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->choice_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool ports_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void ports_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void ports_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+
+    this->v_state_stack_.pop ();
+  }
+
+  void ports_pskel::
+  choice_0 (unsigned long& state,
+            unsigned long& count,
+            const ::xml_schema::ro_string& ns,
+            const ::xml_schema::ro_string& n,
+            const ::xml_schema::ro_string* t,
+            bool start)
+  {
+    XSD_UNUSED (count);
+    XSD_UNUSED (ns);
+    XSD_UNUSED (n);
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->provides_parser_;
+
+          if (this->provides_parser_)
+            this->provides_parser_->pre ();
+        }
+        else
+        {
+          if (this->provides_parser_)
+          {
+            this->provides_parser_->post_provides ();
+            this->provides ();
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 1UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->uses_parser_;
+
+          if (this->uses_parser_)
+            this->uses_parser_->pre ();
+        }
+        else
+        {
+          if (this->uses_parser_)
+          {
+            this->uses_parser_->post_uses ();
+            this->uses ();
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+    }
+  }
+
+  // Element validation and dispatch functions for provides_pskel.
+  //
+  bool provides_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "description" && ns.empty ())
+          s = 0UL;
+        else if (n == "porttype" && ns.empty ())
+          s = 1UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &provides_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool provides_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void provides_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void provides_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+
+    this->v_state_stack_.pop ();
+  }
+
+  void provides_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "description" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->description_parser_;
+
+            if (this->description_parser_)
+              this->description_parser_->pre ();
+          }
+          else
+          {
+            if (this->description_parser_)
+            {
+              const ::std::string& tmp (this->description_parser_->post_string ());
+              this->description (tmp);
+            }
+
+            count = 0;
+            state = 1UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 1UL;
+          // Fall through.
+        }
+      }
+      case 1UL:
+      {
+        if (n == "porttype" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->porttype_parser_;
+
+            if (this->porttype_parser_)
+              this->porttype_parser_->pre ();
+          }
+          else
+          {
+            if (this->porttype_parser_)
+            {
+              this->porttype_parser_->post_portType ();
+              this->porttype ();
+            }
+
+            count++;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for uses_pskel.
+  //
+  bool uses_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "description" && ns.empty ())
+          s = 0UL;
+        else if (n == "porttype" && ns.empty ())
+          s = 1UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &uses_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool uses_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void uses_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void uses_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+
+    this->v_state_stack_.pop ();
+  }
+
+  void uses_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "description" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->description_parser_;
+
+            if (this->description_parser_)
+              this->description_parser_->pre ();
+          }
+          else
+          {
+            if (this->description_parser_)
+            {
+              const ::std::string& tmp (this->description_parser_->post_string ());
+              this->description (tmp);
+            }
+
+            count = 0;
+            state = 1UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 1UL;
+          // Fall through.
+        }
+      }
+      case 1UL:
+      {
+        if (n == "porttype" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->porttype_parser_;
+
+            if (this->porttype_parser_)
+              this->porttype_parser_->pre ();
+          }
+          else
+          {
+            if (this->porttype_parser_)
+            {
+              this->porttype_parser_->post_portType ();
+              this->porttype ();
+            }
+
+            count++;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for interfaces_pskel.
+  //
+  bool interfaces_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "interface" && ns.empty ())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &interfaces_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "interface",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool interfaces_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void interfaces_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void interfaces_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "interface");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void interfaces_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "interface" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->interface_parser_;
+
+            if (this->interface_parser_)
+              this->interface_parser_->pre ();
+          }
+          else
+          {
+            if (this->interface_parser_)
+            {
+              this->interface_parser_->post_interface ();
+              this->interface ();
+            }
+
+            count++;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "interface",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for interface_pskel.
+  //
+  bool interface_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "inheritsinterface" && ns.empty ())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &interface_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool interface_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void interface_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void interface_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+
+    this->v_state_stack_.pop ();
+  }
+
+  void interface_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "inheritsinterface" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->inheritsinterface_parser_;
+
+            if (this->inheritsinterface_parser_)
+              this->inheritsinterface_parser_->pre ();
+          }
+          else
+          {
+            if (this->inheritsinterface_parser_)
+            {
+              this->inheritsinterface_parser_->post_inheritsInterface ();
+              this->inheritsinterface ();
+            }
+
+            count++;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+}
+
+namespace scd
+{
+  // Attribute validation and dispatch functions for propertyFile_pskel.
+  //
+  bool propertyFile_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "type" && ns.empty ())
+    {
+      if (this->type_parser_)
+      {
+        this->type_parser_->pre ();
+        this->type_parser_->_pre_impl ();
+        this->type_parser_->_characters (s);
+        this->type_parser_->_post_impl ();
+        const ::std::string& tmp (this->type_parser_->post_string ());
+        this->type (tmp);
+      }
+
+      return true;
+    }
+
+    return false;
+  }
+
+  // Attribute validation and dispatch functions for localFile_pskel.
+  //
+  bool localFile_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "name" && ns.empty ())
+    {
+      if (this->name_parser_)
+      {
+        this->name_parser_->pre ();
+        this->name_parser_->_pre_impl ();
+        this->name_parser_->_characters (s);
+        this->name_parser_->_post_impl ();
+        const ::std::string& tmp (this->name_parser_->post_string ());
+        this->name (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->name = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void localFile_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.name = false;
+  }
+
+  void localFile_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.name)
+      this->_expected_attribute (
+        "", "name");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for componentRepId_pskel.
+  //
+  bool componentRepId_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "repid" && ns.empty ())
+    {
+      if (this->repid_parser_)
+      {
+        this->repid_parser_->pre ();
+        this->repid_parser_->_pre_impl ();
+        this->repid_parser_->_characters (s);
+        this->repid_parser_->_post_impl ();
+        const ::std::string& tmp (this->repid_parser_->post_string ());
+        this->repid (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->repid = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void componentRepId_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.repid = false;
+  }
+
+  void componentRepId_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.repid)
+      this->_expected_attribute (
+        "", "repid");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for supportsInterface_pskel.
+  //
+  bool supportsInterface_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "repid" && ns.empty ())
+    {
+      if (this->repid_parser_)
+      {
+        this->repid_parser_->pre ();
+        this->repid_parser_->_pre_impl ();
+        this->repid_parser_->_characters (s);
+        this->repid_parser_->_post_impl ();
+        const ::std::string& tmp (this->repid_parser_->post_string ());
+        this->repid (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->repid = true;
+      return true;
+    }
+
+    if (n == "supportsname" && ns.empty ())
+    {
+      if (this->supportsname_parser_)
+      {
+        this->supportsname_parser_->pre ();
+        this->supportsname_parser_->_pre_impl ();
+        this->supportsname_parser_->_characters (s);
+        this->supportsname_parser_->_post_impl ();
+        const ::std::string& tmp (this->supportsname_parser_->post_string ());
+        this->supportsname (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->supportsname = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void supportsInterface_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.repid = false;
+    as.supportsname = false;
+  }
+
+  void supportsInterface_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.repid)
+      this->_expected_attribute (
+        "", "repid");
+    if (!as.supportsname)
+      this->_expected_attribute (
+        "", "supportsname");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for provides_pskel.
+  //
+  bool provides_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "repid" && ns.empty ())
+    {
+      if (this->repid_parser_)
+      {
+        this->repid_parser_->pre ();
+        this->repid_parser_->_pre_impl ();
+        this->repid_parser_->_characters (s);
+        this->repid_parser_->_post_impl ();
+        const ::std::string& tmp (this->repid_parser_->post_string ());
+        this->repid (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->repid = true;
+      return true;
+    }
+
+    if (n == "providesname" && ns.empty ())
+    {
+      if (this->providesname_parser_)
+      {
+        this->providesname_parser_->pre ();
+        this->providesname_parser_->_pre_impl ();
+        this->providesname_parser_->_characters (s);
+        this->providesname_parser_->_post_impl ();
+        const ::std::string& tmp (this->providesname_parser_->post_string ());
+        this->providesname (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->providesname = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void provides_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.repid = false;
+    as.providesname = false;
+  }
+
+  void provides_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.repid)
+      this->_expected_attribute (
+        "", "repid");
+    if (!as.providesname)
+      this->_expected_attribute (
+        "", "providesname");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for uses_pskel.
+  //
+  bool uses_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "repid" && ns.empty ())
+    {
+      if (this->repid_parser_)
+      {
+        this->repid_parser_->pre ();
+        this->repid_parser_->_pre_impl ();
+        this->repid_parser_->_characters (s);
+        this->repid_parser_->_post_impl ();
+        const ::std::string& tmp (this->repid_parser_->post_string ());
+        this->repid (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->repid = true;
+      return true;
+    }
+
+    if (n == "usesname" && ns.empty ())
+    {
+      if (this->usesname_parser_)
+      {
+        this->usesname_parser_->pre ();
+        this->usesname_parser_->_pre_impl ();
+        this->usesname_parser_->_characters (s);
+        this->usesname_parser_->_post_impl ();
+        const ::std::string& tmp (this->usesname_parser_->post_string ());
+        this->usesname (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->usesname = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void uses_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.repid = false;
+    as.usesname = false;
+  }
+
+  void uses_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.repid)
+      this->_expected_attribute (
+        "", "repid");
+    if (!as.usesname)
+      this->_expected_attribute (
+        "", "usesname");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for portType_pskel.
+  //
+  bool portType_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "type" && ns.empty ())
+    {
+      if (this->type_parser_)
+      {
+        this->type_parser_->pre ();
+        this->type_parser_->_pre_impl ();
+        this->type_parser_->_characters (s);
+        this->type_parser_->_post_impl ();
+        this->type_parser_->post_type ();
+        this->type ();
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->type = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void portType_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.type = false;
+  }
+
+  void portType_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.type)
+      this->_expected_attribute (
+        "", "type");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for interface_pskel.
+  //
+  bool interface_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "repid" && ns.empty ())
+    {
+      if (this->repid_parser_)
+      {
+        this->repid_parser_->pre ();
+        this->repid_parser_->_pre_impl ();
+        this->repid_parser_->_characters (s);
+        this->repid_parser_->_post_impl ();
+        const ::std::string& tmp (this->repid_parser_->post_string ());
+        this->repid (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->repid = true;
+      return true;
+    }
+
+    if (n == "name" && ns.empty ())
+    {
+      if (this->name_parser_)
+      {
+        this->name_parser_->pre ();
+        this->name_parser_->_pre_impl ();
+        this->name_parser_->_characters (s);
+        this->name_parser_->_post_impl ();
+        const ::std::string& tmp (this->name_parser_->post_string ());
+        this->name (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->name = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void interface_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.repid = false;
+    as.name = false;
+  }
+
+  void interface_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.repid)
+      this->_expected_attribute (
+        "", "repid");
+    if (!as.name)
+      this->_expected_attribute (
+        "", "name");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for inheritsInterface_pskel.
+  //
+  bool inheritsInterface_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "repid" && ns.empty ())
+    {
+      if (this->repid_parser_)
+      {
+        this->repid_parser_->pre ();
+        this->repid_parser_->_pre_impl ();
+        this->repid_parser_->_characters (s);
+        this->repid_parser_->_post_impl ();
+        const ::std::string& tmp (this->repid_parser_->post_string ());
+        this->repid (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->repid = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void inheritsInterface_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.repid = false;
+  }
+
+  void inheritsInterface_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.repid)
+      this->_expected_attribute (
+        "", "repid");
+
+    this->v_state_attr_stack_.pop ();
+  }
+}
+
+namespace scd
+{
+}
+
+// Begin epilogue.
+//
+//
+// End epilogue.
+
diff --git src/control/parser/internal/scd-pskel.h src/control/parser/internal/scd-pskel.h
new file mode 100644
index 0000000..1e20b1e
--- /dev/null
+++ src/control/parser/internal/scd-pskel.h
@@ -0,0 +1,1408 @@
+// Copyright (C) 2005-2010 Code Synthesis Tools CC
+//
+// This program was generated by CodeSynthesis XSD, an XML Schema to
+// C++ data binding compiler.
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 2 as
+// published by the Free Software Foundation.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+//
+// In addition, as a special exception, Code Synthesis Tools CC gives
+// permission to link this program with the Xerces-C++ library (or with
+// modified versions of Xerces-C++ that use the same license as Xerces-C++),
+// and distribute linked combinations including the two. You must obey
+// the GNU General Public License version 2 in all respects for all of
+// the code used other than Xerces-C++. If you modify this copy of the
+// program, you may extend this exception to your version of the program,
+// but you are not obligated to do so. If you do not wish to do so, delete
+// this exception statement from your version.
+//
+// Furthermore, Code Synthesis Tools CC makes a special exception for
+// the Free/Libre and Open Source Software (FLOSS) which is described
+// in the accompanying FLOSSE file.
+//
+
+#ifndef CXX______XML_XSD_SCD_PSKEL_H
+#define CXX______XML_XSD_SCD_PSKEL_H
+
+// Begin prologue.
+//
+//
+// End prologue.
+
+#include <xsd/cxx/config.hxx>
+
+#if (XSD_INT_VERSION != 3030000L)
+#error XSD runtime version mismatch
+#endif
+
+#include <xsd/cxx/pre.hxx>
+
+// Forward declarations
+//
+namespace scd
+{
+  class softwarecomponent_pskel;
+  class propertyFile_pskel;
+  class localFile_pskel;
+  class componentRepId_pskel;
+  class componentFeatures_pskel;
+  class supportsInterface_pskel;
+  class ports_pskel;
+  class provides_pskel;
+  class uses_pskel;
+  class portType_pskel;
+  class interfaces_pskel;
+  class interface_pskel;
+  class inheritsInterface_pskel;
+  class type_pskel;
+}
+
+
+#ifndef XSD_USE_CHAR
+#define XSD_USE_CHAR
+#endif
+
+#ifndef XSD_CXX_PARSER_USE_CHAR
+#define XSD_CXX_PARSER_USE_CHAR
+#endif
+
+#include <xsd/cxx/xml/error-handler.hxx>
+#include <xsd/cxx/parser/exceptions.hxx>
+#include <xsd/cxx/parser/elements.hxx>
+#include <xsd/cxx/parser/xml-schema.hxx>
+#include <xsd/cxx/parser/validating/parser.hxx>
+#include <xsd/cxx/parser/validating/exceptions.hxx>
+#include <xsd/cxx/parser/validating/xml-schema-pskel.hxx>
+#include <xsd/cxx/parser/validating/xml-schema-pimpl.hxx>
+#include <xsd/cxx/parser/expat/elements.hxx>
+
+#include "memory"
+#include "../../include/ossie/ComponentDescriptor.h"
+
+namespace xml_schema
+{
+  // Built-in XML Schema types mapping.
+  //
+  typedef ::xsd::cxx::parser::string_sequence< char > string_sequence;
+  typedef ::xsd::cxx::parser::qname< char > qname;
+  typedef ::xsd::cxx::parser::buffer buffer;
+  typedef ::xsd::cxx::parser::time_zone time_zone;
+  typedef ::xsd::cxx::parser::gday gday;
+  typedef ::xsd::cxx::parser::gmonth gmonth;
+  typedef ::xsd::cxx::parser::gyear gyear;
+  typedef ::xsd::cxx::parser::gmonth_day gmonth_day;
+  typedef ::xsd::cxx::parser::gyear_month gyear_month;
+  typedef ::xsd::cxx::parser::date date;
+  typedef ::xsd::cxx::parser::time time;
+  typedef ::xsd::cxx::parser::date_time date_time;
+  typedef ::xsd::cxx::parser::duration duration;
+
+  // Base parser skeletons.
+  //
+  typedef ::xsd::cxx::parser::parser_base< char > parser_base;
+  typedef ::xsd::cxx::parser::validating::empty_content< char > empty_content;
+  typedef ::xsd::cxx::parser::validating::simple_content< char > simple_content;
+  typedef ::xsd::cxx::parser::validating::complex_content< char > complex_content;
+  typedef ::xsd::cxx::parser::validating::list_base< char > list_base;
+
+  // Parser skeletons and implementations for the XML Schema
+  // built-in types.
+  //
+  typedef ::xsd::cxx::parser::validating::any_type_pskel< char > any_type_pskel;
+  typedef ::xsd::cxx::parser::validating::any_type_pimpl< char > any_type_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::any_simple_type_pskel< char > any_simple_type_pskel;
+  typedef ::xsd::cxx::parser::validating::any_simple_type_pimpl< char > any_simple_type_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::byte_pskel< char > byte_pskel;
+  typedef ::xsd::cxx::parser::validating::byte_pimpl< char > byte_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::unsigned_byte_pskel< char > unsigned_byte_pskel;
+  typedef ::xsd::cxx::parser::validating::unsigned_byte_pimpl< char > unsigned_byte_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::short_pskel< char > short_pskel;
+  typedef ::xsd::cxx::parser::validating::short_pimpl< char > short_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::unsigned_short_pskel< char > unsigned_short_pskel;
+  typedef ::xsd::cxx::parser::validating::unsigned_short_pimpl< char > unsigned_short_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::int_pskel< char > int_pskel;
+  typedef ::xsd::cxx::parser::validating::int_pimpl< char > int_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::unsigned_int_pskel< char > unsigned_int_pskel;
+  typedef ::xsd::cxx::parser::validating::unsigned_int_pimpl< char > unsigned_int_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::long_pskel< char > long_pskel;
+  typedef ::xsd::cxx::parser::validating::long_pimpl< char > long_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::unsigned_long_pskel< char > unsigned_long_pskel;
+  typedef ::xsd::cxx::parser::validating::unsigned_long_pimpl< char > unsigned_long_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::integer_pskel< char > integer_pskel;
+  typedef ::xsd::cxx::parser::validating::integer_pimpl< char > integer_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::non_positive_integer_pskel< char > non_positive_integer_pskel;
+  typedef ::xsd::cxx::parser::validating::non_positive_integer_pimpl< char > non_positive_integer_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::non_negative_integer_pskel< char > non_negative_integer_pskel;
+  typedef ::xsd::cxx::parser::validating::non_negative_integer_pimpl< char > non_negative_integer_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::positive_integer_pskel< char > positive_integer_pskel;
+  typedef ::xsd::cxx::parser::validating::positive_integer_pimpl< char > positive_integer_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::negative_integer_pskel< char > negative_integer_pskel;
+  typedef ::xsd::cxx::parser::validating::negative_integer_pimpl< char > negative_integer_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::boolean_pskel< char > boolean_pskel;
+  typedef ::xsd::cxx::parser::validating::boolean_pimpl< char > boolean_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::float_pskel< char > float_pskel;
+  typedef ::xsd::cxx::parser::validating::float_pimpl< char > float_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::double_pskel< char > double_pskel;
+  typedef ::xsd::cxx::parser::validating::double_pimpl< char > double_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::decimal_pskel< char > decimal_pskel;
+  typedef ::xsd::cxx::parser::validating::decimal_pimpl< char > decimal_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::string_pskel< char > string_pskel;
+  typedef ::xsd::cxx::parser::validating::string_pimpl< char > string_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::normalized_string_pskel< char > normalized_string_pskel;
+  typedef ::xsd::cxx::parser::validating::normalized_string_pimpl< char > normalized_string_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::token_pskel< char > token_pskel;
+  typedef ::xsd::cxx::parser::validating::token_pimpl< char > token_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::name_pskel< char > name_pskel;
+  typedef ::xsd::cxx::parser::validating::name_pimpl< char > name_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::nmtoken_pskel< char > nmtoken_pskel;
+  typedef ::xsd::cxx::parser::validating::nmtoken_pimpl< char > nmtoken_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::nmtokens_pskel< char > nmtokens_pskel;
+  typedef ::xsd::cxx::parser::validating::nmtokens_pimpl< char > nmtokens_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::ncname_pskel< char > ncname_pskel;
+  typedef ::xsd::cxx::parser::validating::ncname_pimpl< char > ncname_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::language_pskel< char > language_pskel;
+  typedef ::xsd::cxx::parser::validating::language_pimpl< char > language_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::id_pskel< char > id_pskel;
+  typedef ::xsd::cxx::parser::validating::id_pimpl< char > id_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::idref_pskel< char > idref_pskel;
+  typedef ::xsd::cxx::parser::validating::idref_pimpl< char > idref_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::idrefs_pskel< char > idrefs_pskel;
+  typedef ::xsd::cxx::parser::validating::idrefs_pimpl< char > idrefs_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::uri_pskel< char > uri_pskel;
+  typedef ::xsd::cxx::parser::validating::uri_pimpl< char > uri_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::qname_pskel< char > qname_pskel;
+  typedef ::xsd::cxx::parser::validating::qname_pimpl< char > qname_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::base64_binary_pskel< char > base64_binary_pskel;
+  typedef ::xsd::cxx::parser::validating::base64_binary_pimpl< char > base64_binary_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::hex_binary_pskel< char > hex_binary_pskel;
+  typedef ::xsd::cxx::parser::validating::hex_binary_pimpl< char > hex_binary_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::date_pskel< char > date_pskel;
+  typedef ::xsd::cxx::parser::validating::date_pimpl< char > date_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::date_time_pskel< char > date_time_pskel;
+  typedef ::xsd::cxx::parser::validating::date_time_pimpl< char > date_time_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::duration_pskel< char > duration_pskel;
+  typedef ::xsd::cxx::parser::validating::duration_pimpl< char > duration_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::gday_pskel< char > gday_pskel;
+  typedef ::xsd::cxx::parser::validating::gday_pimpl< char > gday_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::gmonth_pskel< char > gmonth_pskel;
+  typedef ::xsd::cxx::parser::validating::gmonth_pimpl< char > gmonth_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::gmonth_day_pskel< char > gmonth_day_pskel;
+  typedef ::xsd::cxx::parser::validating::gmonth_day_pimpl< char > gmonth_day_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::gyear_pskel< char > gyear_pskel;
+  typedef ::xsd::cxx::parser::validating::gyear_pimpl< char > gyear_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::gyear_month_pskel< char > gyear_month_pskel;
+  typedef ::xsd::cxx::parser::validating::gyear_month_pimpl< char > gyear_month_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::time_pskel< char > time_pskel;
+  typedef ::xsd::cxx::parser::validating::time_pimpl< char > time_pimpl;
+
+  // Exceptions. See libxsd/xsd/cxx/parser/exceptions.hxx for details.
+  //
+  typedef ::xsd::cxx::parser::exception< char > exception;
+
+  // Parsing diagnostics.
+  //
+  typedef ::xsd::cxx::parser::severity severity;
+  typedef ::xsd::cxx::parser::error< char > error;
+  typedef ::xsd::cxx::parser::diagnostics< char > diagnostics;
+  typedef ::xsd::cxx::parser::parsing< char > parsing;
+
+  // Error handler. See libxsd/xsd/cxx/xml/error-handler.hxx for details.
+  //
+  typedef ::xsd::cxx::xml::error_handler< char > error_handler;
+
+  // Read-only string.
+  //
+  typedef ::xsd::cxx::ro_string< char > ro_string;
+
+  // Document type. See libxsd/xsd/cxx/parser/expat/elements.hxx
+  // for details.
+  //
+  typedef ::xsd::cxx::parser::expat::document< char > document;
+}
+
+namespace scd
+{
+  class softwarecomponent_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    corbaversion (const ::std::string&);
+
+    virtual void
+    componentrepid ();
+
+    virtual void
+    componenttype (const ::std::string&);
+
+    virtual void
+    componentfeatures ();
+
+    virtual void
+    interfaces ();
+
+    virtual void
+    propertyfile ();
+
+    virtual std::auto_ptr<ossie::ComponentDescriptor::SCD>
+    post_softwarecomponent () = 0;
+
+    // Parser construction API.
+    //
+    void
+    corbaversion_parser (::xml_schema::string_pskel&);
+
+    void
+    componentrepid_parser (::scd::componentRepId_pskel&);
+
+    void
+    componenttype_parser (::xml_schema::string_pskel&);
+
+    void
+    componentfeatures_parser (::scd::componentFeatures_pskel&);
+
+    void
+    interfaces_parser (::scd::interfaces_pskel&);
+
+    void
+    propertyfile_parser (::scd::propertyFile_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* corbaversion */,
+             ::scd::componentRepId_pskel& /* componentrepid */,
+             ::xml_schema::string_pskel& /* componenttype */,
+             ::scd::componentFeatures_pskel& /* componentfeatures */,
+             ::scd::interfaces_pskel& /* interfaces */,
+             ::scd::propertyFile_pskel& /* propertyfile */);
+
+    // Constructor.
+    //
+    softwarecomponent_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::xml_schema::string_pskel* corbaversion_parser_;
+    ::scd::componentRepId_pskel* componentrepid_parser_;
+    ::xml_schema::string_pskel* componenttype_parser_;
+    ::scd::componentFeatures_pskel* componentfeatures_parser_;
+    ::scd::interfaces_pskel* interfaces_parser_;
+    ::scd::propertyFile_pskel* propertyfile_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::scd::softwarecomponent_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+  };
+
+  class propertyFile_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    localfile ();
+
+    virtual void
+    type (const ::std::string&);
+
+    virtual void
+    post_propertyFile ();
+
+    // Parser construction API.
+    //
+    void
+    localfile_parser (::scd::localFile_pskel&);
+
+    void
+    type_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::scd::localFile_pskel& /* localfile */,
+             ::xml_schema::string_pskel& /* type */);
+
+    // Constructor.
+    //
+    propertyFile_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::scd::localFile_pskel* localfile_parser_;
+    ::xml_schema::string_pskel* type_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::scd::propertyFile_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+  };
+
+  class localFile_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    name (const ::std::string&);
+
+    virtual void
+    post_localFile ();
+
+    // Parser construction API.
+    //
+    void
+    name_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* name */);
+
+    // Constructor.
+    //
+    localFile_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* name_parser_;
+
+    protected:
+    struct v_state_attr_
+    {
+      bool name;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class componentRepId_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    repid (const ::std::string&);
+
+    virtual void
+    post_componentRepId ();
+
+    // Parser construction API.
+    //
+    void
+    repid_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* repid */);
+
+    // Constructor.
+    //
+    componentRepId_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* repid_parser_;
+
+    protected:
+    struct v_state_attr_
+    {
+      bool repid;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class componentFeatures_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    supportsinterface ();
+
+    virtual void
+    ports ();
+
+    virtual void
+    post_componentFeatures ();
+
+    // Parser construction API.
+    //
+    void
+    supportsinterface_parser (::scd::supportsInterface_pskel&);
+
+    void
+    ports_parser (::scd::ports_pskel&);
+
+    void
+    parsers (::scd::supportsInterface_pskel& /* supportsinterface */,
+             ::scd::ports_pskel& /* ports */);
+
+    // Constructor.
+    //
+    componentFeatures_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::scd::supportsInterface_pskel* supportsinterface_parser_;
+    ::scd::ports_pskel* ports_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::scd::componentFeatures_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+  };
+
+  class supportsInterface_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    repid (const ::std::string&);
+
+    virtual void
+    supportsname (const ::std::string&);
+
+    virtual void
+    post_supportsInterface ();
+
+    // Parser construction API.
+    //
+    void
+    repid_parser (::xml_schema::string_pskel&);
+
+    void
+    supportsname_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* repid */,
+             ::xml_schema::string_pskel& /* supportsname */);
+
+    // Constructor.
+    //
+    supportsInterface_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* repid_parser_;
+    ::xml_schema::string_pskel* supportsname_parser_;
+
+    protected:
+    struct v_state_attr_
+    {
+      bool repid;
+      bool supportsname;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class ports_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    provides ();
+
+    virtual void
+    uses ();
+
+    virtual void
+    post_ports ();
+
+    // Parser construction API.
+    //
+    void
+    provides_parser (::scd::provides_pskel&);
+
+    void
+    uses_parser (::scd::uses_pskel&);
+
+    void
+    parsers (::scd::provides_pskel& /* provides */,
+             ::scd::uses_pskel& /* uses */);
+
+    // Constructor.
+    //
+    ports_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::scd::provides_pskel* provides_parser_;
+    ::scd::uses_pskel* uses_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::scd::ports_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    choice_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start);
+  };
+
+  class provides_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    description (const ::std::string&);
+
+    virtual void
+    porttype ();
+
+    virtual void
+    repid (const ::std::string&);
+
+    virtual void
+    providesname (const ::std::string&);
+
+    virtual void
+    post_provides ();
+
+    // Parser construction API.
+    //
+    void
+    description_parser (::xml_schema::string_pskel&);
+
+    void
+    porttype_parser (::scd::portType_pskel&);
+
+    void
+    repid_parser (::xml_schema::string_pskel&);
+
+    void
+    providesname_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* description */,
+             ::scd::portType_pskel& /* porttype */,
+             ::xml_schema::string_pskel& /* repid */,
+             ::xml_schema::string_pskel& /* providesname */);
+
+    // Constructor.
+    //
+    provides_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* description_parser_;
+    ::scd::portType_pskel* porttype_parser_;
+    ::xml_schema::string_pskel* repid_parser_;
+    ::xml_schema::string_pskel* providesname_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::scd::provides_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+
+    protected:
+    struct v_state_attr_
+    {
+      bool repid;
+      bool providesname;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class uses_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    description (const ::std::string&);
+
+    virtual void
+    porttype ();
+
+    virtual void
+    repid (const ::std::string&);
+
+    virtual void
+    usesname (const ::std::string&);
+
+    virtual void
+    post_uses ();
+
+    // Parser construction API.
+    //
+    void
+    description_parser (::xml_schema::string_pskel&);
+
+    void
+    porttype_parser (::scd::portType_pskel&);
+
+    void
+    repid_parser (::xml_schema::string_pskel&);
+
+    void
+    usesname_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* description */,
+             ::scd::portType_pskel& /* porttype */,
+             ::xml_schema::string_pskel& /* repid */,
+             ::xml_schema::string_pskel& /* usesname */);
+
+    // Constructor.
+    //
+    uses_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* description_parser_;
+    ::scd::portType_pskel* porttype_parser_;
+    ::xml_schema::string_pskel* repid_parser_;
+    ::xml_schema::string_pskel* usesname_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::scd::uses_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+
+    protected:
+    struct v_state_attr_
+    {
+      bool repid;
+      bool usesname;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class portType_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    type ();
+
+    virtual void
+    post_portType ();
+
+    // Parser construction API.
+    //
+    void
+    type_parser (::scd::type_pskel&);
+
+    void
+    parsers (::scd::type_pskel& /* type */);
+
+    // Constructor.
+    //
+    portType_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::scd::type_pskel* type_parser_;
+
+    protected:
+    struct v_state_attr_
+    {
+      bool type;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class interfaces_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    interface ();
+
+    virtual void
+    post_interfaces ();
+
+    // Parser construction API.
+    //
+    void
+    interface_parser (::scd::interface_pskel&);
+
+    void
+    parsers (::scd::interface_pskel& /* interface */);
+
+    // Constructor.
+    //
+    interfaces_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::scd::interface_pskel* interface_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::scd::interfaces_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+  };
+
+  class interface_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    inheritsinterface ();
+
+    virtual void
+    repid (const ::std::string&);
+
+    virtual void
+    name (const ::std::string&);
+
+    virtual void
+    post_interface ();
+
+    // Parser construction API.
+    //
+    void
+    inheritsinterface_parser (::scd::inheritsInterface_pskel&);
+
+    void
+    repid_parser (::xml_schema::string_pskel&);
+
+    void
+    name_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::scd::inheritsInterface_pskel& /* inheritsinterface */,
+             ::xml_schema::string_pskel& /* repid */,
+             ::xml_schema::string_pskel& /* name */);
+
+    // Constructor.
+    //
+    interface_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::scd::inheritsInterface_pskel* inheritsinterface_parser_;
+    ::xml_schema::string_pskel* repid_parser_;
+    ::xml_schema::string_pskel* name_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::scd::interface_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+
+    protected:
+    struct v_state_attr_
+    {
+      bool repid;
+      bool name;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class inheritsInterface_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    repid (const ::std::string&);
+
+    virtual void
+    post_inheritsInterface ();
+
+    // Parser construction API.
+    //
+    void
+    repid_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* repid */);
+
+    // Constructor.
+    //
+    inheritsInterface_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* repid_parser_;
+
+    protected:
+    struct v_state_attr_
+    {
+      bool repid;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class type_pskel: public virtual ::xml_schema::nmtoken_pskel
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    post_type ();
+  };
+}
+
+#include <xsd/cxx/post.hxx>
+
+// Begin epilogue.
+//
+//
+// End epilogue.
+
+#endif // CXX______XML_XSD_SCD_PSKEL_H
diff --git src/control/parser/internal/spd-pskel.cpp src/control/parser/internal/spd-pskel.cpp
new file mode 100644
index 0000000..832b7ac
--- /dev/null
+++ src/control/parser/internal/spd-pskel.cpp
@@ -0,0 +1,6217 @@
+// Copyright (C) 2005-2010 Code Synthesis Tools CC
+//
+// This program was generated by CodeSynthesis XSD, an XML Schema to
+// C++ data binding compiler.
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 2 as
+// published by the Free Software Foundation.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+//
+// In addition, as a special exception, Code Synthesis Tools CC gives
+// permission to link this program with the Xerces-C++ library (or with
+// modified versions of Xerces-C++ that use the same license as Xerces-C++),
+// and distribute linked combinations including the two. You must obey
+// the GNU General Public License version 2 in all respects for all of
+// the code used other than Xerces-C++. If you modify this copy of the
+// program, you may extend this exception to your version of the program,
+// but you are not obligated to do so. If you do not wish to do so, delete
+// this exception statement from your version.
+//
+// Furthermore, Code Synthesis Tools CC makes a special exception for
+// the Free/Libre and Open Source Software (FLOSS) which is described
+// in the accompanying FLOSSE file.
+//
+
+// Begin prologue.
+//
+//
+// End prologue.
+
+#include "spd-pskel.h"
+
+namespace spd
+{
+  // softPkg_pskel
+  //
+
+  void softPkg_pskel::
+  title_parser (::xml_schema::string_pskel& p)
+  {
+    this->title_parser_ = &p;
+  }
+
+  void softPkg_pskel::
+  author_parser (::spd::author_pskel& p)
+  {
+    this->author_parser_ = &p;
+  }
+
+  void softPkg_pskel::
+  description_parser (::xml_schema::string_pskel& p)
+  {
+    this->description_parser_ = &p;
+  }
+
+  void softPkg_pskel::
+  propertyfile_parser (::spd::propertyFile_pskel& p)
+  {
+    this->propertyfile_parser_ = &p;
+  }
+
+  void softPkg_pskel::
+  descriptor_parser (::spd::descriptor_pskel& p)
+  {
+    this->descriptor_parser_ = &p;
+  }
+
+  void softPkg_pskel::
+  implementation_parser (::spd::implementation_pskel& p)
+  {
+    this->implementation_parser_ = &p;
+  }
+
+  void softPkg_pskel::
+  usesdevice_parser (::spd::usesDevice_pskel& p)
+  {
+    this->usesdevice_parser_ = &p;
+  }
+
+  void softPkg_pskel::
+  id_parser (::xml_schema::string_pskel& p)
+  {
+    this->id_parser_ = &p;
+  }
+
+  void softPkg_pskel::
+  name_parser (::xml_schema::string_pskel& p)
+  {
+    this->name_parser_ = &p;
+  }
+
+  void softPkg_pskel::
+  type_parser (::xml_schema::string_pskel& p)
+  {
+    this->type_parser_ = &p;
+  }
+
+  void softPkg_pskel::
+  version_parser (::xml_schema::string_pskel& p)
+  {
+    this->version_parser_ = &p;
+  }
+
+  void softPkg_pskel::
+  parsers (::xml_schema::string_pskel& title,
+           ::spd::author_pskel& author,
+           ::xml_schema::string_pskel& description,
+           ::spd::propertyFile_pskel& propertyfile,
+           ::spd::descriptor_pskel& descriptor,
+           ::spd::implementation_pskel& implementation,
+           ::spd::usesDevice_pskel& usesdevice,
+           ::xml_schema::string_pskel& id,
+           ::xml_schema::string_pskel& name,
+           ::xml_schema::string_pskel& type,
+           ::xml_schema::string_pskel& version)
+  {
+    this->title_parser_ = &title;
+    this->author_parser_ = &author;
+    this->description_parser_ = &description;
+    this->propertyfile_parser_ = &propertyfile;
+    this->descriptor_parser_ = &descriptor;
+    this->implementation_parser_ = &implementation;
+    this->usesdevice_parser_ = &usesdevice;
+    this->id_parser_ = &id;
+    this->name_parser_ = &name;
+    this->type_parser_ = &type;
+    this->version_parser_ = &version;
+  }
+
+  softPkg_pskel::
+  softPkg_pskel ()
+  : title_parser_ (0),
+    author_parser_ (0),
+    description_parser_ (0),
+    propertyfile_parser_ (0),
+    descriptor_parser_ (0),
+    implementation_parser_ (0),
+    usesdevice_parser_ (0),
+    id_parser_ (0),
+    name_parser_ (0),
+    type_parser_ (0),
+    version_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // localFile_pskel
+  //
+
+  void localFile_pskel::
+  name_parser (::xml_schema::string_pskel& p)
+  {
+    this->name_parser_ = &p;
+  }
+
+  void localFile_pskel::
+  parsers (::xml_schema::string_pskel& name)
+  {
+    this->name_parser_ = &name;
+  }
+
+  localFile_pskel::
+  localFile_pskel ()
+  : name_parser_ (0),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // propertyFile_pskel
+  //
+
+  void propertyFile_pskel::
+  localfile_parser (::spd::localFile_pskel& p)
+  {
+    this->localfile_parser_ = &p;
+  }
+
+  void propertyFile_pskel::
+  type_parser (::xml_schema::string_pskel& p)
+  {
+    this->type_parser_ = &p;
+  }
+
+  void propertyFile_pskel::
+  parsers (::spd::localFile_pskel& localfile,
+           ::xml_schema::string_pskel& type)
+  {
+    this->localfile_parser_ = &localfile;
+    this->type_parser_ = &type;
+  }
+
+  propertyFile_pskel::
+  propertyFile_pskel ()
+  : localfile_parser_ (0),
+    type_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // author_pskel
+  //
+
+  void author_pskel::
+  name_parser (::xml_schema::string_pskel& p)
+  {
+    this->name_parser_ = &p;
+  }
+
+  void author_pskel::
+  company_parser (::xml_schema::string_pskel& p)
+  {
+    this->company_parser_ = &p;
+  }
+
+  void author_pskel::
+  webpage_parser (::xml_schema::uri_pskel& p)
+  {
+    this->webpage_parser_ = &p;
+  }
+
+  void author_pskel::
+  parsers (::xml_schema::string_pskel& name,
+           ::xml_schema::string_pskel& company,
+           ::xml_schema::uri_pskel& webpage)
+  {
+    this->name_parser_ = &name;
+    this->company_parser_ = &company;
+    this->webpage_parser_ = &webpage;
+  }
+
+  author_pskel::
+  author_pskel ()
+  : name_parser_ (0),
+    company_parser_ (0),
+    webpage_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // descriptor_pskel
+  //
+
+  void descriptor_pskel::
+  localfile_parser (::spd::localFile_pskel& p)
+  {
+    this->localfile_parser_ = &p;
+  }
+
+  void descriptor_pskel::
+  name_parser (::xml_schema::string_pskel& p)
+  {
+    this->name_parser_ = &p;
+  }
+
+  void descriptor_pskel::
+  parsers (::spd::localFile_pskel& localfile,
+           ::xml_schema::string_pskel& name)
+  {
+    this->localfile_parser_ = &localfile;
+    this->name_parser_ = &name;
+  }
+
+  descriptor_pskel::
+  descriptor_pskel ()
+  : localfile_parser_ (0),
+    name_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // implementation_pskel
+  //
+
+  void implementation_pskel::
+  description_parser (::xml_schema::string_pskel& p)
+  {
+    this->description_parser_ = &p;
+  }
+
+  void implementation_pskel::
+  propertyfile_parser (::spd::propertyFile_pskel& p)
+  {
+    this->propertyfile_parser_ = &p;
+  }
+
+  void implementation_pskel::
+  code_parser (::spd::code_pskel& p)
+  {
+    this->code_parser_ = &p;
+  }
+
+  void implementation_pskel::
+  compiler_parser (::spd::compiler_pskel& p)
+  {
+    this->compiler_parser_ = &p;
+  }
+
+  void implementation_pskel::
+  programminglanguage_parser (::spd::programmingLanguage_pskel& p)
+  {
+    this->programminglanguage_parser_ = &p;
+  }
+
+  void implementation_pskel::
+  humanlanguage_parser (::spd::humanLanguage_pskel& p)
+  {
+    this->humanlanguage_parser_ = &p;
+  }
+
+  void implementation_pskel::
+  runtime_parser (::spd::runtime_pskel& p)
+  {
+    this->runtime_parser_ = &p;
+  }
+
+  void implementation_pskel::
+  os_parser (::spd::os_pskel& p)
+  {
+    this->os_parser_ = &p;
+  }
+
+  void implementation_pskel::
+  processor_parser (::spd::processor_pskel& p)
+  {
+    this->processor_parser_ = &p;
+  }
+
+  void implementation_pskel::
+  dependency_parser (::spd::dependency_pskel& p)
+  {
+    this->dependency_parser_ = &p;
+  }
+
+  void implementation_pskel::
+  usesdevice_parser (::spd::usesDevice_pskel& p)
+  {
+    this->usesdevice_parser_ = &p;
+  }
+
+  void implementation_pskel::
+  id_parser (::xml_schema::string_pskel& p)
+  {
+    this->id_parser_ = &p;
+  }
+
+  void implementation_pskel::
+  aepcompliance_parser (::spd::aepcompliance_pskel& p)
+  {
+    this->aepcompliance_parser_ = &p;
+  }
+
+  void implementation_pskel::
+  parsers (::xml_schema::string_pskel& description,
+           ::spd::propertyFile_pskel& propertyfile,
+           ::spd::code_pskel& code,
+           ::spd::compiler_pskel& compiler,
+           ::spd::programmingLanguage_pskel& programminglanguage,
+           ::spd::humanLanguage_pskel& humanlanguage,
+           ::spd::runtime_pskel& runtime,
+           ::spd::os_pskel& os,
+           ::spd::processor_pskel& processor,
+           ::spd::dependency_pskel& dependency,
+           ::spd::usesDevice_pskel& usesdevice,
+           ::xml_schema::string_pskel& id,
+           ::spd::aepcompliance_pskel& aepcompliance)
+  {
+    this->description_parser_ = &description;
+    this->propertyfile_parser_ = &propertyfile;
+    this->code_parser_ = &code;
+    this->compiler_parser_ = &compiler;
+    this->programminglanguage_parser_ = &programminglanguage;
+    this->humanlanguage_parser_ = &humanlanguage;
+    this->runtime_parser_ = &runtime;
+    this->os_parser_ = &os;
+    this->processor_parser_ = &processor;
+    this->dependency_parser_ = &dependency;
+    this->usesdevice_parser_ = &usesdevice;
+    this->id_parser_ = &id;
+    this->aepcompliance_parser_ = &aepcompliance;
+  }
+
+  implementation_pskel::
+  implementation_pskel ()
+  : description_parser_ (0),
+    propertyfile_parser_ (0),
+    code_parser_ (0),
+    compiler_parser_ (0),
+    programminglanguage_parser_ (0),
+    humanlanguage_parser_ (0),
+    runtime_parser_ (0),
+    os_parser_ (0),
+    processor_parser_ (0),
+    dependency_parser_ (0),
+    usesdevice_parser_ (0),
+    id_parser_ (0),
+    aepcompliance_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // code_pskel
+  //
+
+  void code_pskel::
+  localfile_parser (::spd::localFile_pskel& p)
+  {
+    this->localfile_parser_ = &p;
+  }
+
+  void code_pskel::
+  entrypoint_parser (::xml_schema::string_pskel& p)
+  {
+    this->entrypoint_parser_ = &p;
+  }
+
+  void code_pskel::
+  stacksize_parser (::xml_schema::unsigned_long_pskel& p)
+  {
+    this->stacksize_parser_ = &p;
+  }
+
+  void code_pskel::
+  priority_parser (::xml_schema::unsigned_long_pskel& p)
+  {
+    this->priority_parser_ = &p;
+  }
+
+  void code_pskel::
+  type_parser (::spd::codeFileType_pskel& p)
+  {
+    this->type_parser_ = &p;
+  }
+
+  void code_pskel::
+  parsers (::spd::localFile_pskel& localfile,
+           ::xml_schema::string_pskel& entrypoint,
+           ::xml_schema::unsigned_long_pskel& stacksize,
+           ::xml_schema::unsigned_long_pskel& priority,
+           ::spd::codeFileType_pskel& type)
+  {
+    this->localfile_parser_ = &localfile;
+    this->entrypoint_parser_ = &entrypoint;
+    this->stacksize_parser_ = &stacksize;
+    this->priority_parser_ = &priority;
+    this->type_parser_ = &type;
+  }
+
+  code_pskel::
+  code_pskel ()
+  : localfile_parser_ (0),
+    entrypoint_parser_ (0),
+    stacksize_parser_ (0),
+    priority_parser_ (0),
+    type_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // compiler_pskel
+  //
+
+  void compiler_pskel::
+  name_parser (::xml_schema::string_pskel& p)
+  {
+    this->name_parser_ = &p;
+  }
+
+  void compiler_pskel::
+  version_parser (::xml_schema::string_pskel& p)
+  {
+    this->version_parser_ = &p;
+  }
+
+  void compiler_pskel::
+  parsers (::xml_schema::string_pskel& name,
+           ::xml_schema::string_pskel& version)
+  {
+    this->name_parser_ = &name;
+    this->version_parser_ = &version;
+  }
+
+  compiler_pskel::
+  compiler_pskel ()
+  : name_parser_ (0),
+    version_parser_ (0),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // programmingLanguage_pskel
+  //
+
+  void programmingLanguage_pskel::
+  name_parser (::xml_schema::string_pskel& p)
+  {
+    this->name_parser_ = &p;
+  }
+
+  void programmingLanguage_pskel::
+  version_parser (::xml_schema::string_pskel& p)
+  {
+    this->version_parser_ = &p;
+  }
+
+  void programmingLanguage_pskel::
+  parsers (::xml_schema::string_pskel& name,
+           ::xml_schema::string_pskel& version)
+  {
+    this->name_parser_ = &name;
+    this->version_parser_ = &version;
+  }
+
+  programmingLanguage_pskel::
+  programmingLanguage_pskel ()
+  : name_parser_ (0),
+    version_parser_ (0),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // humanLanguage_pskel
+  //
+
+  void humanLanguage_pskel::
+  name_parser (::xml_schema::string_pskel& p)
+  {
+    this->name_parser_ = &p;
+  }
+
+  void humanLanguage_pskel::
+  parsers (::xml_schema::string_pskel& name)
+  {
+    this->name_parser_ = &name;
+  }
+
+  humanLanguage_pskel::
+  humanLanguage_pskel ()
+  : name_parser_ (0),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // os_pskel
+  //
+
+  void os_pskel::
+  name_parser (::xml_schema::string_pskel& p)
+  {
+    this->name_parser_ = &p;
+  }
+
+  void os_pskel::
+  version_parser (::xml_schema::string_pskel& p)
+  {
+    this->version_parser_ = &p;
+  }
+
+  void os_pskel::
+  parsers (::xml_schema::string_pskel& name,
+           ::xml_schema::string_pskel& version)
+  {
+    this->name_parser_ = &name;
+    this->version_parser_ = &version;
+  }
+
+  os_pskel::
+  os_pskel ()
+  : name_parser_ (0),
+    version_parser_ (0),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // processor_pskel
+  //
+
+  void processor_pskel::
+  name_parser (::xml_schema::string_pskel& p)
+  {
+    this->name_parser_ = &p;
+  }
+
+  void processor_pskel::
+  parsers (::xml_schema::string_pskel& name)
+  {
+    this->name_parser_ = &name;
+  }
+
+  processor_pskel::
+  processor_pskel ()
+  : name_parser_ (0),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // dependency_pskel
+  //
+
+  void dependency_pskel::
+  softpkgref_parser (::spd::softPkgRef_pskel& p)
+  {
+    this->softpkgref_parser_ = &p;
+  }
+
+  void dependency_pskel::
+  propertyref_parser (::spd::propertyRef_pskel& p)
+  {
+    this->propertyref_parser_ = &p;
+  }
+
+  void dependency_pskel::
+  simpleref_parser (::spd::simpleref_pskel& p)
+  {
+    this->simpleref_parser_ = &p;
+  }
+
+  void dependency_pskel::
+  simplesequenceref_parser (::spd::simplesequenceref_pskel& p)
+  {
+    this->simplesequenceref_parser_ = &p;
+  }
+
+  void dependency_pskel::
+  structref_parser (::spd::structref_pskel& p)
+  {
+    this->structref_parser_ = &p;
+  }
+
+  void dependency_pskel::
+  structsequenceref_parser (::spd::structsequenceref_pskel& p)
+  {
+    this->structsequenceref_parser_ = &p;
+  }
+
+  void dependency_pskel::
+  type_parser (::xml_schema::string_pskel& p)
+  {
+    this->type_parser_ = &p;
+  }
+
+  void dependency_pskel::
+  parsers (::spd::softPkgRef_pskel& softpkgref,
+           ::spd::propertyRef_pskel& propertyref,
+           ::spd::simpleref_pskel& simpleref,
+           ::spd::simplesequenceref_pskel& simplesequenceref,
+           ::spd::structref_pskel& structref,
+           ::spd::structsequenceref_pskel& structsequenceref,
+           ::xml_schema::string_pskel& type)
+  {
+    this->softpkgref_parser_ = &softpkgref;
+    this->propertyref_parser_ = &propertyref;
+    this->simpleref_parser_ = &simpleref;
+    this->simplesequenceref_parser_ = &simplesequenceref;
+    this->structref_parser_ = &structref;
+    this->structsequenceref_parser_ = &structsequenceref;
+    this->type_parser_ = &type;
+  }
+
+  dependency_pskel::
+  dependency_pskel ()
+  : softpkgref_parser_ (0),
+    propertyref_parser_ (0),
+    simpleref_parser_ (0),
+    simplesequenceref_parser_ (0),
+    structref_parser_ (0),
+    structsequenceref_parser_ (0),
+    type_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // runtime_pskel
+  //
+
+  void runtime_pskel::
+  name_parser (::xml_schema::string_pskel& p)
+  {
+    this->name_parser_ = &p;
+  }
+
+  void runtime_pskel::
+  version_parser (::xml_schema::string_pskel& p)
+  {
+    this->version_parser_ = &p;
+  }
+
+  void runtime_pskel::
+  parsers (::xml_schema::string_pskel& name,
+           ::xml_schema::string_pskel& version)
+  {
+    this->name_parser_ = &name;
+    this->version_parser_ = &version;
+  }
+
+  runtime_pskel::
+  runtime_pskel ()
+  : name_parser_ (0),
+    version_parser_ (0),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // propertyRef_pskel
+  //
+
+  void propertyRef_pskel::
+  refid_parser (::xml_schema::string_pskel& p)
+  {
+    this->refid_parser_ = &p;
+  }
+
+  void propertyRef_pskel::
+  value_parser (::xml_schema::string_pskel& p)
+  {
+    this->value_parser_ = &p;
+  }
+
+  void propertyRef_pskel::
+  parsers (::xml_schema::string_pskel& refid,
+           ::xml_schema::string_pskel& value)
+  {
+    this->refid_parser_ = &refid;
+    this->value_parser_ = &value;
+  }
+
+  propertyRef_pskel::
+  propertyRef_pskel ()
+  : refid_parser_ (0),
+    value_parser_ (0),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // softPkgRef_pskel
+  //
+
+  void softPkgRef_pskel::
+  localfile_parser (::spd::localFile_pskel& p)
+  {
+    this->localfile_parser_ = &p;
+  }
+
+  void softPkgRef_pskel::
+  implref_parser (::spd::implRef_pskel& p)
+  {
+    this->implref_parser_ = &p;
+  }
+
+  void softPkgRef_pskel::
+  parsers (::spd::localFile_pskel& localfile,
+           ::spd::implRef_pskel& implref)
+  {
+    this->localfile_parser_ = &localfile;
+    this->implref_parser_ = &implref;
+  }
+
+  softPkgRef_pskel::
+  softPkgRef_pskel ()
+  : localfile_parser_ (0),
+    implref_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // implRef_pskel
+  //
+
+  void implRef_pskel::
+  refid_parser (::xml_schema::string_pskel& p)
+  {
+    this->refid_parser_ = &p;
+  }
+
+  void implRef_pskel::
+  parsers (::xml_schema::string_pskel& refid)
+  {
+    this->refid_parser_ = &refid;
+  }
+
+  implRef_pskel::
+  implRef_pskel ()
+  : refid_parser_ (0),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // usesDevice_pskel
+  //
+
+  void usesDevice_pskel::
+  propertyref_parser (::spd::propertyRef_pskel& p)
+  {
+    this->propertyref_parser_ = &p;
+  }
+
+  void usesDevice_pskel::
+  simpleref_parser (::spd::simpleref_pskel& p)
+  {
+    this->simpleref_parser_ = &p;
+  }
+
+  void usesDevice_pskel::
+  simplesequenceref_parser (::spd::simplesequenceref_pskel& p)
+  {
+    this->simplesequenceref_parser_ = &p;
+  }
+
+  void usesDevice_pskel::
+  structref_parser (::spd::structref_pskel& p)
+  {
+    this->structref_parser_ = &p;
+  }
+
+  void usesDevice_pskel::
+  structsequenceref_parser (::spd::structsequenceref_pskel& p)
+  {
+    this->structsequenceref_parser_ = &p;
+  }
+
+  void usesDevice_pskel::
+  id_parser (::xml_schema::string_pskel& p)
+  {
+    this->id_parser_ = &p;
+  }
+
+  void usesDevice_pskel::
+  type_parser (::xml_schema::string_pskel& p)
+  {
+    this->type_parser_ = &p;
+  }
+
+  void usesDevice_pskel::
+  parsers (::spd::propertyRef_pskel& propertyref,
+           ::spd::simpleref_pskel& simpleref,
+           ::spd::simplesequenceref_pskel& simplesequenceref,
+           ::spd::structref_pskel& structref,
+           ::spd::structsequenceref_pskel& structsequenceref,
+           ::xml_schema::string_pskel& id,
+           ::xml_schema::string_pskel& type)
+  {
+    this->propertyref_parser_ = &propertyref;
+    this->simpleref_parser_ = &simpleref;
+    this->simplesequenceref_parser_ = &simplesequenceref;
+    this->structref_parser_ = &structref;
+    this->structsequenceref_parser_ = &structsequenceref;
+    this->id_parser_ = &id;
+    this->type_parser_ = &type;
+  }
+
+  usesDevice_pskel::
+  usesDevice_pskel ()
+  : propertyref_parser_ (0),
+    simpleref_parser_ (0),
+    simplesequenceref_parser_ (0),
+    structref_parser_ (0),
+    structsequenceref_parser_ (0),
+    id_parser_ (0),
+    type_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // simpleref_pskel
+  //
+
+  void simpleref_pskel::
+  refid_parser (::xml_schema::string_pskel& p)
+  {
+    this->refid_parser_ = &p;
+  }
+
+  void simpleref_pskel::
+  value_parser (::xml_schema::string_pskel& p)
+  {
+    this->value_parser_ = &p;
+  }
+
+  void simpleref_pskel::
+  parsers (::xml_schema::string_pskel& refid,
+           ::xml_schema::string_pskel& value)
+  {
+    this->refid_parser_ = &refid;
+    this->value_parser_ = &value;
+  }
+
+  simpleref_pskel::
+  simpleref_pskel ()
+  : refid_parser_ (0),
+    value_parser_ (0),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // simplesequenceref_pskel
+  //
+
+  void simplesequenceref_pskel::
+  values_parser (::spd::values_pskel& p)
+  {
+    this->values_parser_ = &p;
+  }
+
+  void simplesequenceref_pskel::
+  refid_parser (::xml_schema::string_pskel& p)
+  {
+    this->refid_parser_ = &p;
+  }
+
+  void simplesequenceref_pskel::
+  parsers (::spd::values_pskel& values,
+           ::xml_schema::string_pskel& refid)
+  {
+    this->values_parser_ = &values;
+    this->refid_parser_ = &refid;
+  }
+
+  simplesequenceref_pskel::
+  simplesequenceref_pskel ()
+  : values_parser_ (0),
+    refid_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // structref_pskel
+  //
+
+  void structref_pskel::
+  simpleref_parser (::spd::simpleref_pskel& p)
+  {
+    this->simpleref_parser_ = &p;
+  }
+
+  void structref_pskel::
+  simplesequenceref_parser (::spd::simplesequenceref_pskel& p)
+  {
+    this->simplesequenceref_parser_ = &p;
+  }
+
+  void structref_pskel::
+  refid_parser (::xml_schema::string_pskel& p)
+  {
+    this->refid_parser_ = &p;
+  }
+
+  void structref_pskel::
+  parsers (::spd::simpleref_pskel& simpleref,
+           ::spd::simplesequenceref_pskel& simplesequenceref,
+           ::xml_schema::string_pskel& refid)
+  {
+    this->simpleref_parser_ = &simpleref;
+    this->simplesequenceref_parser_ = &simplesequenceref;
+    this->refid_parser_ = &refid;
+  }
+
+  structref_pskel::
+  structref_pskel ()
+  : simpleref_parser_ (0),
+    simplesequenceref_parser_ (0),
+    refid_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // structsequenceref_pskel
+  //
+
+  void structsequenceref_pskel::
+  structvalue_parser (::spd::structvalue_pskel& p)
+  {
+    this->structvalue_parser_ = &p;
+  }
+
+  void structsequenceref_pskel::
+  refid_parser (::xml_schema::string_pskel& p)
+  {
+    this->refid_parser_ = &p;
+  }
+
+  void structsequenceref_pskel::
+  parsers (::spd::structvalue_pskel& structvalue,
+           ::xml_schema::string_pskel& refid)
+  {
+    this->structvalue_parser_ = &structvalue;
+    this->refid_parser_ = &refid;
+  }
+
+  structsequenceref_pskel::
+  structsequenceref_pskel ()
+  : structvalue_parser_ (0),
+    refid_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_),
+    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
+  {
+  }
+
+  // structvalue_pskel
+  //
+
+  void structvalue_pskel::
+  simpleref_parser (::spd::simpleref_pskel& p)
+  {
+    this->simpleref_parser_ = &p;
+  }
+
+  void structvalue_pskel::
+  simplesequenceref_parser (::spd::simplesequenceref_pskel& p)
+  {
+    this->simplesequenceref_parser_ = &p;
+  }
+
+  void structvalue_pskel::
+  parsers (::spd::simpleref_pskel& simpleref,
+           ::spd::simplesequenceref_pskel& simplesequenceref)
+  {
+    this->simpleref_parser_ = &simpleref;
+    this->simplesequenceref_parser_ = &simplesequenceref;
+  }
+
+  structvalue_pskel::
+  structvalue_pskel ()
+  : simpleref_parser_ (0),
+    simplesequenceref_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+
+  // values_pskel
+  //
+
+  void values_pskel::
+  value_parser (::xml_schema::string_pskel& p)
+  {
+    this->value_parser_ = &p;
+  }
+
+  void values_pskel::
+  parsers (::xml_schema::string_pskel& value)
+  {
+    this->value_parser_ = &value;
+  }
+
+  values_pskel::
+  values_pskel ()
+  : value_parser_ (0),
+    v_state_stack_ (sizeof (v_state_), &v_state_first_)
+  {
+  }
+}
+
+namespace spd
+{
+  // softPkg_pskel
+  //
+
+  void softPkg_pskel::
+  title (const ::std::string&)
+  {
+  }
+
+  void softPkg_pskel::
+  author (const ossie::SPD::Author&)
+  {
+  }
+
+  void softPkg_pskel::
+  description (const ::std::string&)
+  {
+  }
+
+  void softPkg_pskel::
+  propertyfile (const ::std::string&)
+  {
+  }
+
+  void softPkg_pskel::
+  descriptor (const ::std::string&)
+  {
+  }
+
+  void softPkg_pskel::
+  implementation (const ossie::SPD::Implementation&)
+  {
+  }
+
+  void softPkg_pskel::
+  usesdevice (const ossie::SPD::UsesDevice&)
+  {
+  }
+
+  void softPkg_pskel::
+  id (const ::std::string&)
+  {
+  }
+
+  void softPkg_pskel::
+  name (const ::std::string&)
+  {
+  }
+
+  void softPkg_pskel::
+  type (const ::std::string&)
+  {
+  }
+
+  void softPkg_pskel::
+  version (const ::std::string&)
+  {
+  }
+
+  // localFile_pskel
+  //
+
+  void localFile_pskel::
+  name (const ::std::string&)
+  {
+  }
+
+  // propertyFile_pskel
+  //
+
+  void propertyFile_pskel::
+  localfile (const ::std::string&)
+  {
+  }
+
+  void propertyFile_pskel::
+  type (const ::std::string&)
+  {
+  }
+
+  // author_pskel
+  //
+
+  void author_pskel::
+  name (const ::std::string&)
+  {
+  }
+
+  void author_pskel::
+  company (const ::std::string&)
+  {
+  }
+
+  void author_pskel::
+  webpage (const ::std::string&)
+  {
+  }
+
+  // descriptor_pskel
+  //
+
+  void descriptor_pskel::
+  localfile (const ::std::string&)
+  {
+  }
+
+  void descriptor_pskel::
+  name (const ::std::string&)
+  {
+  }
+
+  // implementation_pskel
+  //
+
+  void implementation_pskel::
+  description (const ::std::string&)
+  {
+  }
+
+  void implementation_pskel::
+  propertyfile (const ::std::string&)
+  {
+  }
+
+  void implementation_pskel::
+  code (const ossie::SPD::Code&)
+  {
+  }
+
+  void implementation_pskel::
+  compiler (const ossie::SPD::NameVersionPair&)
+  {
+  }
+
+  void implementation_pskel::
+  programminglanguage ()
+  {
+  }
+
+  void implementation_pskel::
+  humanlanguage ()
+  {
+  }
+
+  void implementation_pskel::
+  runtime (const ossie::SPD::NameVersionPair&)
+  {
+  }
+
+  void implementation_pskel::
+  os (const ossie::SPD::NameVersionPair&)
+  {
+  }
+
+  void implementation_pskel::
+  processor (const ::std::string&)
+  {
+  }
+
+  void implementation_pskel::
+  dependency (ossie::SPD::DependencyRef*)
+  {
+  }
+
+  void implementation_pskel::
+  usesdevice (const ossie::SPD::UsesDevice&)
+  {
+  }
+
+  void implementation_pskel::
+  id (const ::std::string&)
+  {
+  }
+
+  void implementation_pskel::
+  aepcompliance ()
+  {
+  }
+
+  // code_pskel
+  //
+
+  void code_pskel::
+  localfile (const ::std::string&)
+  {
+  }
+
+  void code_pskel::
+  entrypoint (const ::std::string&)
+  {
+  }
+
+  void code_pskel::
+  stacksize (unsigned long long)
+  {
+  }
+
+  void code_pskel::
+  priority (unsigned long long)
+  {
+  }
+
+  void code_pskel::
+  type (const ::std::string&)
+  {
+  }
+
+  // codeFileType_pskel
+  //
+
+  ::std::string codeFileType_pskel::
+  post_codeFileType ()
+  {
+    return post_nmtoken ();
+  }
+
+  // compiler_pskel
+  //
+
+  void compiler_pskel::
+  name (const ::std::string&)
+  {
+  }
+
+  void compiler_pskel::
+  version (const ::std::string&)
+  {
+  }
+
+  // programmingLanguage_pskel
+  //
+
+  void programmingLanguage_pskel::
+  name (const ::std::string&)
+  {
+  }
+
+  void programmingLanguage_pskel::
+  version (const ::std::string&)
+  {
+  }
+
+  void programmingLanguage_pskel::
+  post_programmingLanguage ()
+  {
+  }
+
+  // humanLanguage_pskel
+  //
+
+  void humanLanguage_pskel::
+  name (const ::std::string&)
+  {
+  }
+
+  void humanLanguage_pskel::
+  post_humanLanguage ()
+  {
+  }
+
+  // os_pskel
+  //
+
+  void os_pskel::
+  name (const ::std::string&)
+  {
+  }
+
+  void os_pskel::
+  version (const ::std::string&)
+  {
+  }
+
+  // processor_pskel
+  //
+
+  void processor_pskel::
+  name (const ::std::string&)
+  {
+  }
+
+  // dependency_pskel
+  //
+
+  void dependency_pskel::
+  softpkgref (const ossie::SPD::SoftPkgRef&)
+  {
+  }
+
+  void dependency_pskel::
+  propertyref (const ossie::SPD::PropertyRef&)
+  {
+  }
+
+  void dependency_pskel::
+  simpleref (ossie::SimplePropertyRef*)
+  {
+  }
+
+  void dependency_pskel::
+  simplesequenceref (ossie::SimpleSequencePropertyRef*)
+  {
+  }
+
+  void dependency_pskel::
+  structref (ossie::StructPropertyRef*)
+  {
+  }
+
+  void dependency_pskel::
+  structsequenceref (ossie::StructSequencePropertyRef*)
+  {
+  }
+
+  void dependency_pskel::
+  type (const ::std::string&)
+  {
+  }
+
+  // runtime_pskel
+  //
+
+  void runtime_pskel::
+  name (const ::std::string&)
+  {
+  }
+
+  void runtime_pskel::
+  version (const ::std::string&)
+  {
+  }
+
+  // propertyRef_pskel
+  //
+
+  void propertyRef_pskel::
+  refid (const ::std::string&)
+  {
+  }
+
+  void propertyRef_pskel::
+  value (const ::std::string&)
+  {
+  }
+
+  // softPkgRef_pskel
+  //
+
+  void softPkgRef_pskel::
+  localfile (const ::std::string&)
+  {
+  }
+
+  void softPkgRef_pskel::
+  implref (const ::std::string&)
+  {
+  }
+
+  // implRef_pskel
+  //
+
+  void implRef_pskel::
+  refid (const ::std::string&)
+  {
+  }
+
+  // usesDevice_pskel
+  //
+
+  void usesDevice_pskel::
+  propertyref (const ossie::SPD::PropertyRef&)
+  {
+  }
+
+  void usesDevice_pskel::
+  simpleref (ossie::SimplePropertyRef*)
+  {
+  }
+
+  void usesDevice_pskel::
+  simplesequenceref (ossie::SimpleSequencePropertyRef*)
+  {
+  }
+
+  void usesDevice_pskel::
+  structref (ossie::StructPropertyRef*)
+  {
+  }
+
+  void usesDevice_pskel::
+  structsequenceref (ossie::StructSequencePropertyRef*)
+  {
+  }
+
+  void usesDevice_pskel::
+  id (const ::std::string&)
+  {
+  }
+
+  void usesDevice_pskel::
+  type (const ::std::string&)
+  {
+  }
+
+  // simpleref_pskel
+  //
+
+  void simpleref_pskel::
+  refid (const ::std::string&)
+  {
+  }
+
+  void simpleref_pskel::
+  value (const ::std::string&)
+  {
+  }
+
+  // simplesequenceref_pskel
+  //
+
+  void simplesequenceref_pskel::
+  values (const ::std::vector<std::string>&)
+  {
+  }
+
+  void simplesequenceref_pskel::
+  refid (const ::std::string&)
+  {
+  }
+
+  // structref_pskel
+  //
+
+  void structref_pskel::
+  simpleref (ossie::SimplePropertyRef*)
+  {
+  }
+
+  void structref_pskel::
+  simplesequenceref (ossie::SimpleSequencePropertyRef*)
+  {
+  }
+
+  void structref_pskel::
+  refid (const ::std::string&)
+  {
+  }
+
+  // structsequenceref_pskel
+  //
+
+  void structsequenceref_pskel::
+  structvalue (const ::std::map<std::string, ossie::ComponentProperty*>&)
+  {
+  }
+
+  void structsequenceref_pskel::
+  refid (const ::std::string&)
+  {
+  }
+
+  // structvalue_pskel
+  //
+
+  void structvalue_pskel::
+  simpleref (ossie::SimplePropertyRef*)
+  {
+  }
+
+  void structvalue_pskel::
+  simplesequenceref (ossie::SimpleSequencePropertyRef*)
+  {
+  }
+
+  // values_pskel
+  //
+
+  void values_pskel::
+  value (const ::std::string&)
+  {
+  }
+
+  // aepcompliance_pskel
+  //
+
+  void aepcompliance_pskel::
+  post_aepcompliance ()
+  {
+  }
+}
+
+#include <cassert>
+
+namespace spd
+{
+  // Element validation and dispatch functions for softPkg_pskel.
+  //
+  bool softPkg_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "title" && ns.empty ())
+          s = 0UL;
+        else if (n == "author" && ns.empty ())
+          s = 1UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &softPkg_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "title",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool softPkg_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void softPkg_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void softPkg_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "title");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void softPkg_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "title" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->title_parser_;
+
+            if (this->title_parser_)
+              this->title_parser_->pre ();
+          }
+          else
+          {
+            if (this->title_parser_)
+            {
+              const ::std::string& tmp (this->title_parser_->post_string ());
+              this->title (tmp);
+            }
+
+            count = 0;
+            state = 1UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 1UL;
+          // Fall through.
+        }
+      }
+      case 1UL:
+      {
+        if (n == "author" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->author_parser_;
+
+            if (this->author_parser_)
+              this->author_parser_->pre ();
+          }
+          else
+          {
+            if (this->author_parser_)
+            {
+              const ossie::SPD::Author& tmp (this->author_parser_->post_author ());
+              this->author (tmp);
+            }
+
+            count++;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "author",
+              ns, n);
+          count = 0;
+          state = 2UL;
+          // Fall through.
+        }
+      }
+      case 2UL:
+      {
+        if (n == "description" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->description_parser_;
+
+            if (this->description_parser_)
+              this->description_parser_->pre ();
+          }
+          else
+          {
+            if (this->description_parser_)
+            {
+              const ::std::string& tmp (this->description_parser_->post_string ());
+              this->description (tmp);
+            }
+
+            count = 0;
+            state = 3UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 3UL;
+          // Fall through.
+        }
+      }
+      case 3UL:
+      {
+        if (n == "propertyfile" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->propertyfile_parser_;
+
+            if (this->propertyfile_parser_)
+              this->propertyfile_parser_->pre ();
+          }
+          else
+          {
+            if (this->propertyfile_parser_)
+            {
+              const ::std::string& tmp (this->propertyfile_parser_->post_propertyFile ());
+              this->propertyfile (tmp);
+            }
+
+            count = 0;
+            state = 4UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 4UL;
+          // Fall through.
+        }
+      }
+      case 4UL:
+      {
+        if (n == "descriptor" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->descriptor_parser_;
+
+            if (this->descriptor_parser_)
+              this->descriptor_parser_->pre ();
+          }
+          else
+          {
+            if (this->descriptor_parser_)
+            {
+              const ::std::string& tmp (this->descriptor_parser_->post_descriptor ());
+              this->descriptor (tmp);
+            }
+
+            count = 0;
+            state = 5UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 5UL;
+          // Fall through.
+        }
+      }
+      case 5UL:
+      {
+        if (n == "implementation" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->implementation_parser_;
+
+            if (this->implementation_parser_)
+              this->implementation_parser_->pre ();
+          }
+          else
+          {
+            if (this->implementation_parser_)
+            {
+              const ossie::SPD::Implementation& tmp (this->implementation_parser_->post_implementation ());
+              this->implementation (tmp);
+            }
+
+            count++;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "implementation",
+              ns, n);
+          count = 0;
+          state = 6UL;
+          // Fall through.
+        }
+      }
+      case 6UL:
+      {
+        if (n == "usesdevice" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->usesdevice_parser_;
+
+            if (this->usesdevice_parser_)
+              this->usesdevice_parser_->pre ();
+          }
+          else
+          {
+            if (this->usesdevice_parser_)
+            {
+              const ossie::SPD::UsesDevice& tmp (this->usesdevice_parser_->post_usesDevice ());
+              this->usesdevice (tmp);
+            }
+
+            count++;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for propertyFile_pskel.
+  //
+  bool propertyFile_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "localfile" && ns.empty ())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &propertyFile_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "localfile",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool propertyFile_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void propertyFile_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void propertyFile_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "localfile");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void propertyFile_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "localfile" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->localfile_parser_;
+
+            if (this->localfile_parser_)
+              this->localfile_parser_->pre ();
+          }
+          else
+          {
+            if (this->localfile_parser_)
+            {
+              const ::std::string& tmp (this->localfile_parser_->post_localFile ());
+              this->localfile (tmp);
+            }
+
+            count = 0;
+            state = ~0UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "localfile",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for author_pskel.
+  //
+  bool author_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "name" && ns.empty ())
+          s = 0UL;
+        else if (n == "company" && ns.empty ())
+          s = 1UL;
+        else if (n == "webpage" && ns.empty ())
+          s = 2UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &author_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool author_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void author_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void author_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+
+    this->v_state_stack_.pop ();
+  }
+
+  void author_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "name" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->name_parser_;
+
+            if (this->name_parser_)
+              this->name_parser_->pre ();
+          }
+          else
+          {
+            if (this->name_parser_)
+            {
+              const ::std::string& tmp (this->name_parser_->post_string ());
+              this->name (tmp);
+            }
+
+            count++;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 1UL;
+          // Fall through.
+        }
+      }
+      case 1UL:
+      {
+        if (n == "company" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->company_parser_;
+
+            if (this->company_parser_)
+              this->company_parser_->pre ();
+          }
+          else
+          {
+            if (this->company_parser_)
+            {
+              const ::std::string& tmp (this->company_parser_->post_string ());
+              this->company (tmp);
+            }
+
+            count = 0;
+            state = 2UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 2UL;
+          // Fall through.
+        }
+      }
+      case 2UL:
+      {
+        if (n == "webpage" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->webpage_parser_;
+
+            if (this->webpage_parser_)
+              this->webpage_parser_->pre ();
+          }
+          else
+          {
+            if (this->webpage_parser_)
+            {
+              const ::std::string& tmp (this->webpage_parser_->post_uri ());
+              this->webpage (tmp);
+            }
+
+            count = 0;
+            state = ~0UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for descriptor_pskel.
+  //
+  bool descriptor_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "localfile" && ns.empty ())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &descriptor_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "localfile",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool descriptor_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void descriptor_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void descriptor_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "localfile");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void descriptor_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "localfile" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->localfile_parser_;
+
+            if (this->localfile_parser_)
+              this->localfile_parser_->pre ();
+          }
+          else
+          {
+            if (this->localfile_parser_)
+            {
+              const ::std::string& tmp (this->localfile_parser_->post_localFile ());
+              this->localfile (tmp);
+            }
+
+            count = 0;
+            state = ~0UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "localfile",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for implementation_pskel.
+  //
+  bool implementation_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "description" && ns.empty ())
+          s = 0UL;
+        else if (n == "propertyfile" && ns.empty ())
+          s = 1UL;
+        else if (n == "code" && ns.empty ())
+          s = 2UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &implementation_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "description",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool implementation_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void implementation_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void implementation_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "description");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void implementation_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "description" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->description_parser_;
+
+            if (this->description_parser_)
+              this->description_parser_->pre ();
+          }
+          else
+          {
+            if (this->description_parser_)
+            {
+              const ::std::string& tmp (this->description_parser_->post_string ());
+              this->description (tmp);
+            }
+
+            count = 0;
+            state = 1UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 1UL;
+          // Fall through.
+        }
+      }
+      case 1UL:
+      {
+        if (n == "propertyfile" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->propertyfile_parser_;
+
+            if (this->propertyfile_parser_)
+              this->propertyfile_parser_->pre ();
+          }
+          else
+          {
+            if (this->propertyfile_parser_)
+            {
+              const ::std::string& tmp (this->propertyfile_parser_->post_propertyFile ());
+              this->propertyfile (tmp);
+            }
+
+            count = 0;
+            state = 2UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 2UL;
+          // Fall through.
+        }
+      }
+      case 2UL:
+      {
+        if (n == "code" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->code_parser_;
+
+            if (this->code_parser_)
+              this->code_parser_->pre ();
+          }
+          else
+          {
+            if (this->code_parser_)
+            {
+              const ossie::SPD::Code& tmp (this->code_parser_->post_code ());
+              this->code (tmp);
+            }
+
+            count = 0;
+            state = 3UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "code",
+              ns, n);
+          count = 0;
+          state = 3UL;
+          // Fall through.
+        }
+      }
+      case 3UL:
+      {
+        if (n == "compiler" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->compiler_parser_;
+
+            if (this->compiler_parser_)
+              this->compiler_parser_->pre ();
+          }
+          else
+          {
+            if (this->compiler_parser_)
+            {
+              const ossie::SPD::NameVersionPair& tmp (this->compiler_parser_->post_compiler ());
+              this->compiler (tmp);
+            }
+
+            count = 0;
+            state = 4UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 4UL;
+          // Fall through.
+        }
+      }
+      case 4UL:
+      {
+        if (n == "programminglanguage" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->programminglanguage_parser_;
+
+            if (this->programminglanguage_parser_)
+              this->programminglanguage_parser_->pre ();
+          }
+          else
+          {
+            if (this->programminglanguage_parser_)
+            {
+              this->programminglanguage_parser_->post_programmingLanguage ();
+              this->programminglanguage ();
+            }
+
+            count = 0;
+            state = 5UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 5UL;
+          // Fall through.
+        }
+      }
+      case 5UL:
+      {
+        if (n == "humanlanguage" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->humanlanguage_parser_;
+
+            if (this->humanlanguage_parser_)
+              this->humanlanguage_parser_->pre ();
+          }
+          else
+          {
+            if (this->humanlanguage_parser_)
+            {
+              this->humanlanguage_parser_->post_humanLanguage ();
+              this->humanlanguage ();
+            }
+
+            count = 0;
+            state = 6UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 6UL;
+          // Fall through.
+        }
+      }
+      case 6UL:
+      {
+        if (n == "runtime" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->runtime_parser_;
+
+            if (this->runtime_parser_)
+              this->runtime_parser_->pre ();
+          }
+          else
+          {
+            if (this->runtime_parser_)
+            {
+              const ossie::SPD::NameVersionPair& tmp (this->runtime_parser_->post_runtime ());
+              this->runtime (tmp);
+            }
+
+            count = 0;
+            state = 7UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 7UL;
+          // Fall through.
+        }
+      }
+      case 7UL:
+      {
+        unsigned long s (~0UL);
+
+        if (n == "os" && ns.empty ())
+          s = 0UL;
+        else if (n == "processor" && ns.empty ())
+          s = 1UL;
+        else if (n == "dependency" && ns.empty ())
+          s = 2UL;
+
+        if (s != ~0UL)
+        {
+          assert (start);
+          count++;
+
+          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+          v_state_descr_& vd = vs.data[vs.size++];
+
+          vd.func = &implementation_pskel::choice_0;
+          vd.state = s;
+          vd.count = 0;
+
+          this->choice_0 (vd.state, vd.count, ns, n, t, true);
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "os",
+              ns, n);
+          count = 0;
+          state = 8UL;
+          // Fall through.
+        }
+      }
+      case 8UL:
+      {
+        if (n == "usesdevice" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->usesdevice_parser_;
+
+            if (this->usesdevice_parser_)
+              this->usesdevice_parser_->pre ();
+          }
+          else
+          {
+            if (this->usesdevice_parser_)
+            {
+              const ossie::SPD::UsesDevice& tmp (this->usesdevice_parser_->post_usesDevice ());
+              this->usesdevice (tmp);
+            }
+
+            count++;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  void implementation_pskel::
+  choice_0 (unsigned long& state,
+            unsigned long& count,
+            const ::xml_schema::ro_string& ns,
+            const ::xml_schema::ro_string& n,
+            const ::xml_schema::ro_string* t,
+            bool start)
+  {
+    XSD_UNUSED (count);
+    XSD_UNUSED (ns);
+    XSD_UNUSED (n);
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->os_parser_;
+
+          if (this->os_parser_)
+            this->os_parser_->pre ();
+        }
+        else
+        {
+          if (this->os_parser_)
+          {
+            const ossie::SPD::NameVersionPair& tmp (this->os_parser_->post_os ());
+            this->os (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 1UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->processor_parser_;
+
+          if (this->processor_parser_)
+            this->processor_parser_->pre ();
+        }
+        else
+        {
+          if (this->processor_parser_)
+          {
+            const ::std::string& tmp (this->processor_parser_->post_processor ());
+            this->processor (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 2UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->dependency_parser_;
+
+          if (this->dependency_parser_)
+            this->dependency_parser_->pre ();
+        }
+        else
+        {
+          if (this->dependency_parser_)
+          {
+            ossie::SPD::DependencyRef* tmp (this->dependency_parser_->post_dependency ());
+            this->dependency (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+    }
+  }
+
+  // Element validation and dispatch functions for code_pskel.
+  //
+  bool code_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "localfile" && ns.empty ())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &code_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "localfile",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool code_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void code_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void code_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "localfile");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void code_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "localfile" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->localfile_parser_;
+
+            if (this->localfile_parser_)
+              this->localfile_parser_->pre ();
+          }
+          else
+          {
+            if (this->localfile_parser_)
+            {
+              const ::std::string& tmp (this->localfile_parser_->post_localFile ());
+              this->localfile (tmp);
+            }
+
+            count = 0;
+            state = 1UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "localfile",
+              ns, n);
+          count = 0;
+          state = 1UL;
+          // Fall through.
+        }
+      }
+      case 1UL:
+      {
+        if (n == "entrypoint" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->entrypoint_parser_;
+
+            if (this->entrypoint_parser_)
+              this->entrypoint_parser_->pre ();
+          }
+          else
+          {
+            if (this->entrypoint_parser_)
+            {
+              const ::std::string& tmp (this->entrypoint_parser_->post_string ());
+              this->entrypoint (tmp);
+            }
+
+            count = 0;
+            state = 2UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 2UL;
+          // Fall through.
+        }
+      }
+      case 2UL:
+      {
+        if (n == "stacksize" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->stacksize_parser_;
+
+            if (this->stacksize_parser_)
+              this->stacksize_parser_->pre ();
+          }
+          else
+          {
+            if (this->stacksize_parser_)
+            {
+              unsigned long long tmp (this->stacksize_parser_->post_unsigned_long ());
+              this->stacksize (tmp);
+            }
+
+            count = 0;
+            state = 3UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = 3UL;
+          // Fall through.
+        }
+      }
+      case 3UL:
+      {
+        if (n == "priority" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->priority_parser_;
+
+            if (this->priority_parser_)
+              this->priority_parser_->pre ();
+          }
+          else
+          {
+            if (this->priority_parser_)
+            {
+              unsigned long long tmp (this->priority_parser_->post_unsigned_long ());
+              this->priority (tmp);
+            }
+
+            count = 0;
+            state = ~0UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for dependency_pskel.
+  //
+  bool dependency_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "softpkgref" && ns.empty ())
+          s = 0UL;
+        else if (n == "propertyref" && ns.empty ())
+          s = 1UL;
+        else if (n == "simpleref" && ns.empty ())
+          s = 2UL;
+        else if (n == "simplesequenceref" && ns.empty ())
+          s = 3UL;
+        else if (n == "structref" && ns.empty ())
+          s = 4UL;
+        else if (n == "structsequenceref" && ns.empty ())
+          s = 5UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &dependency_pskel::choice_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->choice_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "softpkgref",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool dependency_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void dependency_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void dependency_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "softpkgref");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void dependency_pskel::
+  choice_0 (unsigned long& state,
+            unsigned long& count,
+            const ::xml_schema::ro_string& ns,
+            const ::xml_schema::ro_string& n,
+            const ::xml_schema::ro_string* t,
+            bool start)
+  {
+    XSD_UNUSED (count);
+    XSD_UNUSED (ns);
+    XSD_UNUSED (n);
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->softpkgref_parser_;
+
+          if (this->softpkgref_parser_)
+            this->softpkgref_parser_->pre ();
+        }
+        else
+        {
+          if (this->softpkgref_parser_)
+          {
+            const ossie::SPD::SoftPkgRef& tmp (this->softpkgref_parser_->post_softPkgRef ());
+            this->softpkgref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 1UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->propertyref_parser_;
+
+          if (this->propertyref_parser_)
+            this->propertyref_parser_->pre ();
+        }
+        else
+        {
+          if (this->propertyref_parser_)
+          {
+            const ossie::SPD::PropertyRef& tmp (this->propertyref_parser_->post_propertyRef ());
+            this->propertyref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 2UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->simpleref_parser_;
+
+          if (this->simpleref_parser_)
+            this->simpleref_parser_->pre ();
+        }
+        else
+        {
+          if (this->simpleref_parser_)
+          {
+            ossie::SimplePropertyRef* tmp (this->simpleref_parser_->post_simpleref ());
+            this->simpleref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 3UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->simplesequenceref_parser_;
+
+          if (this->simplesequenceref_parser_)
+            this->simplesequenceref_parser_->pre ();
+        }
+        else
+        {
+          if (this->simplesequenceref_parser_)
+          {
+            ossie::SimpleSequencePropertyRef* tmp (this->simplesequenceref_parser_->post_simplesequenceref ());
+            this->simplesequenceref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 4UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->structref_parser_;
+
+          if (this->structref_parser_)
+            this->structref_parser_->pre ();
+        }
+        else
+        {
+          if (this->structref_parser_)
+          {
+            ossie::StructPropertyRef* tmp (this->structref_parser_->post_structref ());
+            this->structref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 5UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->structsequenceref_parser_;
+
+          if (this->structsequenceref_parser_)
+            this->structsequenceref_parser_->pre ();
+        }
+        else
+        {
+          if (this->structsequenceref_parser_)
+          {
+            ossie::StructSequencePropertyRef* tmp (this->structsequenceref_parser_->post_structsequenceref ());
+            this->structsequenceref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+    }
+  }
+
+  // Element validation and dispatch functions for softPkgRef_pskel.
+  //
+  bool softPkgRef_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "localfile" && ns.empty ())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &softPkgRef_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "localfile",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool softPkgRef_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void softPkgRef_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void softPkgRef_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "localfile");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void softPkgRef_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "localfile" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->localfile_parser_;
+
+            if (this->localfile_parser_)
+              this->localfile_parser_->pre ();
+          }
+          else
+          {
+            if (this->localfile_parser_)
+            {
+              const ::std::string& tmp (this->localfile_parser_->post_localFile ());
+              this->localfile (tmp);
+            }
+
+            count = 0;
+            state = 1UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "localfile",
+              ns, n);
+          count = 0;
+          state = 1UL;
+          // Fall through.
+        }
+      }
+      case 1UL:
+      {
+        if (n == "implref" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->implref_parser_;
+
+            if (this->implref_parser_)
+              this->implref_parser_->pre ();
+          }
+          else
+          {
+            if (this->implref_parser_)
+            {
+              const ::std::string& tmp (this->implref_parser_->post_implRef ());
+              this->implref (tmp);
+            }
+
+            count = 0;
+            state = ~0UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for usesDevice_pskel.
+  //
+  bool usesDevice_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "propertyref" && ns.empty ())
+          s = 0UL;
+        else if (n == "simpleref" && ns.empty ())
+          s = 1UL;
+        else if (n == "simplesequenceref" && ns.empty ())
+          s = 2UL;
+        else if (n == "structref" && ns.empty ())
+          s = 3UL;
+        else if (n == "structsequenceref" && ns.empty ())
+          s = 4UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+
+          vd = vs.data + vs.size++;
+          vd->func = &usesDevice_pskel::choice_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->choice_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "propertyref",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool usesDevice_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void usesDevice_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void usesDevice_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "propertyref");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void usesDevice_pskel::
+  choice_0 (unsigned long& state,
+            unsigned long& count,
+            const ::xml_schema::ro_string& ns,
+            const ::xml_schema::ro_string& n,
+            const ::xml_schema::ro_string* t,
+            bool start)
+  {
+    XSD_UNUSED (count);
+    XSD_UNUSED (ns);
+    XSD_UNUSED (n);
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->propertyref_parser_;
+
+          if (this->propertyref_parser_)
+            this->propertyref_parser_->pre ();
+        }
+        else
+        {
+          if (this->propertyref_parser_)
+          {
+            const ossie::SPD::PropertyRef& tmp (this->propertyref_parser_->post_propertyRef ());
+            this->propertyref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 1UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->simpleref_parser_;
+
+          if (this->simpleref_parser_)
+            this->simpleref_parser_->pre ();
+        }
+        else
+        {
+          if (this->simpleref_parser_)
+          {
+            ossie::SimplePropertyRef* tmp (this->simpleref_parser_->post_simpleref ());
+            this->simpleref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 2UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->simplesequenceref_parser_;
+
+          if (this->simplesequenceref_parser_)
+            this->simplesequenceref_parser_->pre ();
+        }
+        else
+        {
+          if (this->simplesequenceref_parser_)
+          {
+            ossie::SimpleSequencePropertyRef* tmp (this->simplesequenceref_parser_->post_simplesequenceref ());
+            this->simplesequenceref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 3UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->structref_parser_;
+
+          if (this->structref_parser_)
+            this->structref_parser_->pre ();
+        }
+        else
+        {
+          if (this->structref_parser_)
+          {
+            ossie::StructPropertyRef* tmp (this->structref_parser_->post_structref ());
+            this->structref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 4UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->structsequenceref_parser_;
+
+          if (this->structsequenceref_parser_)
+            this->structsequenceref_parser_->pre ();
+        }
+        else
+        {
+          if (this->structsequenceref_parser_)
+          {
+            ossie::StructSequencePropertyRef* tmp (this->structsequenceref_parser_->post_structsequenceref ());
+            this->structsequenceref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+    }
+  }
+
+  // Element validation and dispatch functions for simplesequenceref_pskel.
+  //
+  bool simplesequenceref_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "values" && ns.empty ())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &simplesequenceref_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "values",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool simplesequenceref_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void simplesequenceref_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void simplesequenceref_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "values");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void simplesequenceref_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "values" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->values_parser_;
+
+            if (this->values_parser_)
+              this->values_parser_->pre ();
+          }
+          else
+          {
+            if (this->values_parser_)
+            {
+              const ::std::vector<std::string>& tmp (this->values_parser_->post_values ());
+              this->values (tmp);
+            }
+
+            count = 0;
+            state = ~0UL;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "values",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for structref_pskel.
+  //
+  bool structref_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if ((n == "simpleref" && ns.empty ()) ||
+            (n == "simplesequenceref" && ns.empty ()))
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &structref_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "simpleref",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool structref_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void structref_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void structref_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "simpleref");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void structref_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        unsigned long s (~0UL);
+
+        if (n == "simpleref" && ns.empty ())
+          s = 0UL;
+        else if (n == "simplesequenceref" && ns.empty ())
+          s = 1UL;
+
+        if (s != ~0UL)
+        {
+          assert (start);
+          count++;
+
+          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+          v_state_descr_& vd = vs.data[vs.size++];
+
+          vd.func = &structref_pskel::choice_0;
+          vd.state = s;
+          vd.count = 0;
+
+          this->choice_0 (vd.state, vd.count, ns, n, t, true);
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "simpleref",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  void structref_pskel::
+  choice_0 (unsigned long& state,
+            unsigned long& count,
+            const ::xml_schema::ro_string& ns,
+            const ::xml_schema::ro_string& n,
+            const ::xml_schema::ro_string* t,
+            bool start)
+  {
+    XSD_UNUSED (count);
+    XSD_UNUSED (ns);
+    XSD_UNUSED (n);
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->simpleref_parser_;
+
+          if (this->simpleref_parser_)
+            this->simpleref_parser_->pre ();
+        }
+        else
+        {
+          if (this->simpleref_parser_)
+          {
+            ossie::SimplePropertyRef* tmp (this->simpleref_parser_->post_simpleref ());
+            this->simpleref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 1UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->simplesequenceref_parser_;
+
+          if (this->simplesequenceref_parser_)
+            this->simplesequenceref_parser_->pre ();
+        }
+        else
+        {
+          if (this->simplesequenceref_parser_)
+          {
+            ossie::SimpleSequencePropertyRef* tmp (this->simplesequenceref_parser_->post_simplesequenceref ());
+            this->simplesequenceref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+    }
+  }
+
+  // Element validation and dispatch functions for structsequenceref_pskel.
+  //
+  bool structsequenceref_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "structvalue" && ns.empty ())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &structsequenceref_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "structvalue",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool structsequenceref_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void structsequenceref_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void structsequenceref_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "structvalue");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void structsequenceref_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "structvalue" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->structvalue_parser_;
+
+            if (this->structvalue_parser_)
+              this->structvalue_parser_->pre ();
+          }
+          else
+          {
+            if (this->structvalue_parser_)
+            {
+              const ::std::map<std::string, ossie::ComponentProperty*>& tmp (this->structvalue_parser_->post_structvalue ());
+              this->structvalue (tmp);
+            }
+
+            count++;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "structvalue",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  // Element validation and dispatch functions for structvalue_pskel.
+  //
+  bool structvalue_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if ((n == "simpleref" && ns.empty ()) ||
+            (n == "simplesequenceref" && ns.empty ()))
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &structvalue_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "simpleref",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool structvalue_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void structvalue_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void structvalue_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "simpleref");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void structvalue_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        unsigned long s (~0UL);
+
+        if (n == "simpleref" && ns.empty ())
+          s = 0UL;
+        else if (n == "simplesequenceref" && ns.empty ())
+          s = 1UL;
+
+        if (s != ~0UL)
+        {
+          assert (start);
+          count++;
+
+          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+          v_state_descr_& vd = vs.data[vs.size++];
+
+          vd.func = &structvalue_pskel::choice_0;
+          vd.state = s;
+          vd.count = 0;
+
+          this->choice_0 (vd.state, vd.count, ns, n, t, true);
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "simpleref",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+
+  void structvalue_pskel::
+  choice_0 (unsigned long& state,
+            unsigned long& count,
+            const ::xml_schema::ro_string& ns,
+            const ::xml_schema::ro_string& n,
+            const ::xml_schema::ro_string* t,
+            bool start)
+  {
+    XSD_UNUSED (count);
+    XSD_UNUSED (ns);
+    XSD_UNUSED (n);
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->simpleref_parser_;
+
+          if (this->simpleref_parser_)
+            this->simpleref_parser_->pre ();
+        }
+        else
+        {
+          if (this->simpleref_parser_)
+          {
+            ossie::SimplePropertyRef* tmp (this->simpleref_parser_->post_simpleref ());
+            this->simpleref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+      case 1UL:
+      {
+        if (start)
+        {
+          this->::xml_schema::complex_content::context_.top ().parser_ = this->simplesequenceref_parser_;
+
+          if (this->simplesequenceref_parser_)
+            this->simplesequenceref_parser_->pre ();
+        }
+        else
+        {
+          if (this->simplesequenceref_parser_)
+          {
+            ossie::SimpleSequencePropertyRef* tmp (this->simplesequenceref_parser_->post_simplesequenceref ());
+            this->simplesequenceref (tmp);
+          }
+
+          state = ~0UL;
+        }
+
+        break;
+      }
+    }
+  }
+
+  // Element validation and dispatch functions for values_pskel.
+  //
+  bool values_pskel::
+  _start_element_impl (const ::xml_schema::ro_string& ns,
+                       const ::xml_schema::ro_string& n,
+                       const ::xml_schema::ro_string* t)
+  {
+    XSD_UNUSED (t);
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    if (vd->func == 0 && vd->state == 0)
+    {
+      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
+        return true;
+      else
+        vd->state = 1;
+    }
+
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);
+
+      vd = vs.data + (vs.size - 1);
+
+      if (vd->state == ~0UL)
+        vd = vs.data + (--vs.size - 1);
+      else
+        break;
+    }
+
+    if (vd->func == 0)
+    {
+      if (vd->state != ~0UL)
+      {
+        unsigned long s = ~0UL;
+
+        if (n == "value" && ns.empty ())
+          s = 0UL;
+
+        if (s != ~0UL)
+        {
+          vd->count++;
+          vd->state = ~0UL;
+
+          vd = vs.data + vs.size++;
+          vd->func = &values_pskel::sequence_0;
+          vd->state = s;
+          vd->count = 0;
+
+          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
+        }
+        else
+        {
+          if (vd->count < 1UL)
+            this->_expected_element (
+              "", "value",
+              ns, n);
+          return false;
+        }
+      }
+      else
+        return false;
+    }
+
+    return true;
+  }
+
+  bool values_pskel::
+  _end_element_impl (const ::xml_schema::ro_string& ns,
+                     const ::xml_schema::ro_string& n)
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size - 1];
+
+    if (vd.func == 0 && vd.state == 0)
+    {
+      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
+        assert (false);
+      return true;
+    }
+
+    assert (vd.func != 0);
+    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);
+
+    if (vd.state == ~0UL)
+      vs.size--;
+
+    return true;
+  }
+
+  void values_pskel::
+  _pre_e_validate ()
+  {
+    this->v_state_stack_.push ();
+    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;
+
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_& vd = vs.data[vs.size++];
+
+    vd.func = 0;
+    vd.state = 0;
+    vd.count = 0;
+  }
+
+  void values_pskel::
+  _post_e_validate ()
+  {
+    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
+    v_state_descr_* vd = vs.data + (vs.size - 1);
+
+    ::xml_schema::ro_string empty;
+    while (vd->func != 0)
+    {
+      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
+      assert (vd->state == ~0UL);
+      vd = vs.data + (--vs.size - 1);
+    }
+
+    if (vd->count < 1UL)
+      this->_expected_element (
+        "", "value");
+
+    this->v_state_stack_.pop ();
+  }
+
+  void values_pskel::
+  sequence_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start)
+  {
+    XSD_UNUSED (t);
+
+    switch (state)
+    {
+      case 0UL:
+      {
+        if (n == "value" && ns.empty ())
+        {
+          if (start)
+          {
+            this->::xml_schema::complex_content::context_.top ().parser_ = this->value_parser_;
+
+            if (this->value_parser_)
+              this->value_parser_->pre ();
+          }
+          else
+          {
+            if (this->value_parser_)
+            {
+              const ::std::string& tmp (this->value_parser_->post_string ());
+              this->value (tmp);
+            }
+
+            count++;
+          }
+
+          break;
+        }
+        else
+        {
+          assert (start);
+          if (count < 1UL)
+            this->_expected_element (
+              "", "value",
+              ns, n);
+          count = 0;
+          state = ~0UL;
+          // Fall through.
+        }
+      }
+      case ~0UL:
+        break;
+    }
+  }
+}
+
+namespace spd
+{
+  // Attribute validation and dispatch functions for softPkg_pskel.
+  //
+  bool softPkg_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "id" && ns.empty ())
+    {
+      if (this->id_parser_)
+      {
+        this->id_parser_->pre ();
+        this->id_parser_->_pre_impl ();
+        this->id_parser_->_characters (s);
+        this->id_parser_->_post_impl ();
+        const ::std::string& tmp (this->id_parser_->post_string ());
+        this->id (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->id = true;
+      return true;
+    }
+
+    if (n == "name" && ns.empty ())
+    {
+      if (this->name_parser_)
+      {
+        this->name_parser_->pre ();
+        this->name_parser_->_pre_impl ();
+        this->name_parser_->_characters (s);
+        this->name_parser_->_post_impl ();
+        const ::std::string& tmp (this->name_parser_->post_string ());
+        this->name (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->name = true;
+      return true;
+    }
+
+    if (n == "type" && ns.empty ())
+    {
+      if (this->type_parser_)
+      {
+        this->type_parser_->pre ();
+        this->type_parser_->_pre_impl ();
+        this->type_parser_->_characters (s);
+        this->type_parser_->_post_impl ();
+        const ::std::string& tmp (this->type_parser_->post_string ());
+        this->type (tmp);
+      }
+
+      return true;
+    }
+
+    if (n == "version" && ns.empty ())
+    {
+      if (this->version_parser_)
+      {
+        this->version_parser_->pre ();
+        this->version_parser_->_pre_impl ();
+        this->version_parser_->_characters (s);
+        this->version_parser_->_post_impl ();
+        const ::std::string& tmp (this->version_parser_->post_string ());
+        this->version (tmp);
+      }
+
+      return true;
+    }
+
+    return false;
+  }
+
+  void softPkg_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.id = false;
+    as.name = false;
+  }
+
+  void softPkg_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.id)
+      this->_expected_attribute (
+        "", "id");
+    if (!as.name)
+      this->_expected_attribute (
+        "", "name");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for localFile_pskel.
+  //
+  bool localFile_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "name" && ns.empty ())
+    {
+      if (this->name_parser_)
+      {
+        this->name_parser_->pre ();
+        this->name_parser_->_pre_impl ();
+        this->name_parser_->_characters (s);
+        this->name_parser_->_post_impl ();
+        const ::std::string& tmp (this->name_parser_->post_string ());
+        this->name (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->name = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void localFile_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.name = false;
+  }
+
+  void localFile_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.name)
+      this->_expected_attribute (
+        "", "name");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for propertyFile_pskel.
+  //
+  bool propertyFile_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "type" && ns.empty ())
+    {
+      if (this->type_parser_)
+      {
+        this->type_parser_->pre ();
+        this->type_parser_->_pre_impl ();
+        this->type_parser_->_characters (s);
+        this->type_parser_->_post_impl ();
+        const ::std::string& tmp (this->type_parser_->post_string ());
+        this->type (tmp);
+      }
+
+      return true;
+    }
+
+    return false;
+  }
+
+  // Attribute validation and dispatch functions for descriptor_pskel.
+  //
+  bool descriptor_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "name" && ns.empty ())
+    {
+      if (this->name_parser_)
+      {
+        this->name_parser_->pre ();
+        this->name_parser_->_pre_impl ();
+        this->name_parser_->_characters (s);
+        this->name_parser_->_post_impl ();
+        const ::std::string& tmp (this->name_parser_->post_string ());
+        this->name (tmp);
+      }
+
+      return true;
+    }
+
+    return false;
+  }
+
+  // Attribute validation and dispatch functions for implementation_pskel.
+  //
+  bool implementation_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "id" && ns.empty ())
+    {
+      if (this->id_parser_)
+      {
+        this->id_parser_->pre ();
+        this->id_parser_->_pre_impl ();
+        this->id_parser_->_characters (s);
+        this->id_parser_->_post_impl ();
+        const ::std::string& tmp (this->id_parser_->post_string ());
+        this->id (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->id = true;
+      return true;
+    }
+
+    if (n == "aepcompliance" && ns.empty ())
+    {
+      if (this->aepcompliance_parser_)
+      {
+        this->aepcompliance_parser_->pre ();
+        this->aepcompliance_parser_->_pre_impl ();
+        this->aepcompliance_parser_->_characters (s);
+        this->aepcompliance_parser_->_post_impl ();
+        this->aepcompliance_parser_->post_aepcompliance ();
+        this->aepcompliance ();
+      }
+
+      return true;
+    }
+
+    return false;
+  }
+
+  void implementation_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.id = false;
+  }
+
+  void implementation_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.id)
+      this->_expected_attribute (
+        "", "id");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for code_pskel.
+  //
+  bool code_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "type" && ns.empty ())
+    {
+      if (this->type_parser_)
+      {
+        this->type_parser_->pre ();
+        this->type_parser_->_pre_impl ();
+        this->type_parser_->_characters (s);
+        this->type_parser_->_post_impl ();
+        const ::std::string& tmp (this->type_parser_->post_codeFileType ());
+        this->type (tmp);
+      }
+
+      return true;
+    }
+
+    return false;
+  }
+
+  // Attribute validation and dispatch functions for compiler_pskel.
+  //
+  bool compiler_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "name" && ns.empty ())
+    {
+      if (this->name_parser_)
+      {
+        this->name_parser_->pre ();
+        this->name_parser_->_pre_impl ();
+        this->name_parser_->_characters (s);
+        this->name_parser_->_post_impl ();
+        const ::std::string& tmp (this->name_parser_->post_string ());
+        this->name (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->name = true;
+      return true;
+    }
+
+    if (n == "version" && ns.empty ())
+    {
+      if (this->version_parser_)
+      {
+        this->version_parser_->pre ();
+        this->version_parser_->_pre_impl ();
+        this->version_parser_->_characters (s);
+        this->version_parser_->_post_impl ();
+        const ::std::string& tmp (this->version_parser_->post_string ());
+        this->version (tmp);
+      }
+
+      return true;
+    }
+
+    return false;
+  }
+
+  void compiler_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.name = false;
+  }
+
+  void compiler_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.name)
+      this->_expected_attribute (
+        "", "name");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for programmingLanguage_pskel.
+  //
+  bool programmingLanguage_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "name" && ns.empty ())
+    {
+      if (this->name_parser_)
+      {
+        this->name_parser_->pre ();
+        this->name_parser_->_pre_impl ();
+        this->name_parser_->_characters (s);
+        this->name_parser_->_post_impl ();
+        const ::std::string& tmp (this->name_parser_->post_string ());
+        this->name (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->name = true;
+      return true;
+    }
+
+    if (n == "version" && ns.empty ())
+    {
+      if (this->version_parser_)
+      {
+        this->version_parser_->pre ();
+        this->version_parser_->_pre_impl ();
+        this->version_parser_->_characters (s);
+        this->version_parser_->_post_impl ();
+        const ::std::string& tmp (this->version_parser_->post_string ());
+        this->version (tmp);
+      }
+
+      return true;
+    }
+
+    return false;
+  }
+
+  void programmingLanguage_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.name = false;
+  }
+
+  void programmingLanguage_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.name)
+      this->_expected_attribute (
+        "", "name");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for humanLanguage_pskel.
+  //
+  bool humanLanguage_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "name" && ns.empty ())
+    {
+      if (this->name_parser_)
+      {
+        this->name_parser_->pre ();
+        this->name_parser_->_pre_impl ();
+        this->name_parser_->_characters (s);
+        this->name_parser_->_post_impl ();
+        const ::std::string& tmp (this->name_parser_->post_string ());
+        this->name (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->name = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void humanLanguage_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.name = false;
+  }
+
+  void humanLanguage_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.name)
+      this->_expected_attribute (
+        "", "name");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for os_pskel.
+  //
+  bool os_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "name" && ns.empty ())
+    {
+      if (this->name_parser_)
+      {
+        this->name_parser_->pre ();
+        this->name_parser_->_pre_impl ();
+        this->name_parser_->_characters (s);
+        this->name_parser_->_post_impl ();
+        const ::std::string& tmp (this->name_parser_->post_string ());
+        this->name (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->name = true;
+      return true;
+    }
+
+    if (n == "version" && ns.empty ())
+    {
+      if (this->version_parser_)
+      {
+        this->version_parser_->pre ();
+        this->version_parser_->_pre_impl ();
+        this->version_parser_->_characters (s);
+        this->version_parser_->_post_impl ();
+        const ::std::string& tmp (this->version_parser_->post_string ());
+        this->version (tmp);
+      }
+
+      return true;
+    }
+
+    return false;
+  }
+
+  void os_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.name = false;
+  }
+
+  void os_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.name)
+      this->_expected_attribute (
+        "", "name");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for processor_pskel.
+  //
+  bool processor_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "name" && ns.empty ())
+    {
+      if (this->name_parser_)
+      {
+        this->name_parser_->pre ();
+        this->name_parser_->_pre_impl ();
+        this->name_parser_->_characters (s);
+        this->name_parser_->_post_impl ();
+        const ::std::string& tmp (this->name_parser_->post_string ());
+        this->name (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->name = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void processor_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.name = false;
+  }
+
+  void processor_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.name)
+      this->_expected_attribute (
+        "", "name");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for dependency_pskel.
+  //
+  bool dependency_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "type" && ns.empty ())
+    {
+      if (this->type_parser_)
+      {
+        this->type_parser_->pre ();
+        this->type_parser_->_pre_impl ();
+        this->type_parser_->_characters (s);
+        this->type_parser_->_post_impl ();
+        const ::std::string& tmp (this->type_parser_->post_string ());
+        this->type (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->type = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void dependency_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.type = false;
+  }
+
+  void dependency_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.type)
+      this->_expected_attribute (
+        "", "type");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for runtime_pskel.
+  //
+  bool runtime_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "name" && ns.empty ())
+    {
+      if (this->name_parser_)
+      {
+        this->name_parser_->pre ();
+        this->name_parser_->_pre_impl ();
+        this->name_parser_->_characters (s);
+        this->name_parser_->_post_impl ();
+        const ::std::string& tmp (this->name_parser_->post_string ());
+        this->name (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->name = true;
+      return true;
+    }
+
+    if (n == "version" && ns.empty ())
+    {
+      if (this->version_parser_)
+      {
+        this->version_parser_->pre ();
+        this->version_parser_->_pre_impl ();
+        this->version_parser_->_characters (s);
+        this->version_parser_->_post_impl ();
+        const ::std::string& tmp (this->version_parser_->post_string ());
+        this->version (tmp);
+      }
+
+      return true;
+    }
+
+    return false;
+  }
+
+  void runtime_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.name = false;
+  }
+
+  void runtime_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.name)
+      this->_expected_attribute (
+        "", "name");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for propertyRef_pskel.
+  //
+  bool propertyRef_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "refid" && ns.empty ())
+    {
+      if (this->refid_parser_)
+      {
+        this->refid_parser_->pre ();
+        this->refid_parser_->_pre_impl ();
+        this->refid_parser_->_characters (s);
+        this->refid_parser_->_post_impl ();
+        const ::std::string& tmp (this->refid_parser_->post_string ());
+        this->refid (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->refid = true;
+      return true;
+    }
+
+    if (n == "value" && ns.empty ())
+    {
+      if (this->value_parser_)
+      {
+        this->value_parser_->pre ();
+        this->value_parser_->_pre_impl ();
+        this->value_parser_->_characters (s);
+        this->value_parser_->_post_impl ();
+        const ::std::string& tmp (this->value_parser_->post_string ());
+        this->value (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->value = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void propertyRef_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.refid = false;
+    as.value = false;
+  }
+
+  void propertyRef_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.refid)
+      this->_expected_attribute (
+        "", "refid");
+    if (!as.value)
+      this->_expected_attribute (
+        "", "value");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for implRef_pskel.
+  //
+  bool implRef_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "refid" && ns.empty ())
+    {
+      if (this->refid_parser_)
+      {
+        this->refid_parser_->pre ();
+        this->refid_parser_->_pre_impl ();
+        this->refid_parser_->_characters (s);
+        this->refid_parser_->_post_impl ();
+        const ::std::string& tmp (this->refid_parser_->post_string ());
+        this->refid (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->refid = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void implRef_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.refid = false;
+  }
+
+  void implRef_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.refid)
+      this->_expected_attribute (
+        "", "refid");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for usesDevice_pskel.
+  //
+  bool usesDevice_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "id" && ns.empty ())
+    {
+      if (this->id_parser_)
+      {
+        this->id_parser_->pre ();
+        this->id_parser_->_pre_impl ();
+        this->id_parser_->_characters (s);
+        this->id_parser_->_post_impl ();
+        const ::std::string& tmp (this->id_parser_->post_string ());
+        this->id (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->id = true;
+      return true;
+    }
+
+    if (n == "type" && ns.empty ())
+    {
+      if (this->type_parser_)
+      {
+        this->type_parser_->pre ();
+        this->type_parser_->_pre_impl ();
+        this->type_parser_->_characters (s);
+        this->type_parser_->_post_impl ();
+        const ::std::string& tmp (this->type_parser_->post_string ());
+        this->type (tmp);
+      }
+
+      return true;
+    }
+
+    return false;
+  }
+
+  void usesDevice_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.id = false;
+  }
+
+  void usesDevice_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.id)
+      this->_expected_attribute (
+        "", "id");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for simpleref_pskel.
+  //
+  bool simpleref_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "refid" && ns.empty ())
+    {
+      if (this->refid_parser_)
+      {
+        this->refid_parser_->pre ();
+        this->refid_parser_->_pre_impl ();
+        this->refid_parser_->_characters (s);
+        this->refid_parser_->_post_impl ();
+        const ::std::string& tmp (this->refid_parser_->post_string ());
+        this->refid (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->refid = true;
+      return true;
+    }
+
+    if (n == "value" && ns.empty ())
+    {
+      if (this->value_parser_)
+      {
+        this->value_parser_->pre ();
+        this->value_parser_->_pre_impl ();
+        this->value_parser_->_characters (s);
+        this->value_parser_->_post_impl ();
+        const ::std::string& tmp (this->value_parser_->post_string ());
+        this->value (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->value = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void simpleref_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.refid = false;
+    as.value = false;
+  }
+
+  void simpleref_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.refid)
+      this->_expected_attribute (
+        "", "refid");
+    if (!as.value)
+      this->_expected_attribute (
+        "", "value");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for simplesequenceref_pskel.
+  //
+  bool simplesequenceref_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "refid" && ns.empty ())
+    {
+      if (this->refid_parser_)
+      {
+        this->refid_parser_->pre ();
+        this->refid_parser_->_pre_impl ();
+        this->refid_parser_->_characters (s);
+        this->refid_parser_->_post_impl ();
+        const ::std::string& tmp (this->refid_parser_->post_string ());
+        this->refid (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->refid = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void simplesequenceref_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.refid = false;
+  }
+
+  void simplesequenceref_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.refid)
+      this->_expected_attribute (
+        "", "refid");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for structref_pskel.
+  //
+  bool structref_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "refid" && ns.empty ())
+    {
+      if (this->refid_parser_)
+      {
+        this->refid_parser_->pre ();
+        this->refid_parser_->_pre_impl ();
+        this->refid_parser_->_characters (s);
+        this->refid_parser_->_post_impl ();
+        const ::std::string& tmp (this->refid_parser_->post_string ());
+        this->refid (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->refid = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void structref_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.refid = false;
+  }
+
+  void structref_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.refid)
+      this->_expected_attribute (
+        "", "refid");
+
+    this->v_state_attr_stack_.pop ();
+  }
+
+  // Attribute validation and dispatch functions for structsequenceref_pskel.
+  //
+  bool structsequenceref_pskel::
+  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
+                             const ::xml_schema::ro_string& n,
+                             const ::xml_schema::ro_string& s)
+  {
+    if (n == "refid" && ns.empty ())
+    {
+      if (this->refid_parser_)
+      {
+        this->refid_parser_->pre ();
+        this->refid_parser_->_pre_impl ();
+        this->refid_parser_->_characters (s);
+        this->refid_parser_->_post_impl ();
+        const ::std::string& tmp (this->refid_parser_->post_string ());
+        this->refid (tmp);
+      }
+
+      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->refid = true;
+      return true;
+    }
+
+    return false;
+  }
+
+  void structsequenceref_pskel::
+  _pre_a_validate ()
+  {
+    this->v_state_attr_stack_.push ();
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    as.refid = false;
+  }
+
+  void structsequenceref_pskel::
+  _post_a_validate ()
+  {
+    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());
+
+    if (!as.refid)
+      this->_expected_attribute (
+        "", "refid");
+
+    this->v_state_attr_stack_.pop ();
+  }
+}
+
+namespace spd
+{
+}
+
+// Begin epilogue.
+//
+//
+// End epilogue.
+
diff --git src/control/parser/internal/spd-pskel.h src/control/parser/internal/spd-pskel.h
new file mode 100644
index 0000000..1fe2ff9
--- /dev/null
+++ src/control/parser/internal/spd-pskel.h
@@ -0,0 +1,2595 @@
+// Copyright (C) 2005-2010 Code Synthesis Tools CC
+//
+// This program was generated by CodeSynthesis XSD, an XML Schema to
+// C++ data binding compiler.
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 2 as
+// published by the Free Software Foundation.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+//
+// In addition, as a special exception, Code Synthesis Tools CC gives
+// permission to link this program with the Xerces-C++ library (or with
+// modified versions of Xerces-C++ that use the same license as Xerces-C++),
+// and distribute linked combinations including the two. You must obey
+// the GNU General Public License version 2 in all respects for all of
+// the code used other than Xerces-C++. If you modify this copy of the
+// program, you may extend this exception to your version of the program,
+// but you are not obligated to do so. If you do not wish to do so, delete
+// this exception statement from your version.
+//
+// Furthermore, Code Synthesis Tools CC makes a special exception for
+// the Free/Libre and Open Source Software (FLOSS) which is described
+// in the accompanying FLOSSE file.
+//
+
+#ifndef CXX______XML_XSD_SPD_PSKEL_H
+#define CXX______XML_XSD_SPD_PSKEL_H
+
+// Begin prologue.
+//
+//
+// End prologue.
+
+#include <xsd/cxx/config.hxx>
+
+#if (XSD_INT_VERSION != 3030000L)
+#error XSD runtime version mismatch
+#endif
+
+#include <xsd/cxx/pre.hxx>
+
+// Forward declarations
+//
+namespace spd
+{
+  class softPkg_pskel;
+  class localFile_pskel;
+  class propertyFile_pskel;
+  class author_pskel;
+  class descriptor_pskel;
+  class implementation_pskel;
+  class code_pskel;
+  class codeFileType_pskel;
+  class compiler_pskel;
+  class programmingLanguage_pskel;
+  class humanLanguage_pskel;
+  class os_pskel;
+  class processor_pskel;
+  class dependency_pskel;
+  class runtime_pskel;
+  class propertyRef_pskel;
+  class softPkgRef_pskel;
+  class implRef_pskel;
+  class usesDevice_pskel;
+  class simpleref_pskel;
+  class simplesequenceref_pskel;
+  class structref_pskel;
+  class structsequenceref_pskel;
+  class structvalue_pskel;
+  class values_pskel;
+  class aepcompliance_pskel;
+}
+
+
+#ifndef XSD_USE_CHAR
+#define XSD_USE_CHAR
+#endif
+
+#ifndef XSD_CXX_PARSER_USE_CHAR
+#define XSD_CXX_PARSER_USE_CHAR
+#endif
+
+#include <xsd/cxx/xml/error-handler.hxx>
+#include <xsd/cxx/parser/exceptions.hxx>
+#include <xsd/cxx/parser/elements.hxx>
+#include <xsd/cxx/parser/xml-schema.hxx>
+#include <xsd/cxx/parser/validating/parser.hxx>
+#include <xsd/cxx/parser/validating/exceptions.hxx>
+#include <xsd/cxx/parser/validating/xml-schema-pskel.hxx>
+#include <xsd/cxx/parser/validating/xml-schema-pimpl.hxx>
+#include <xsd/cxx/parser/expat/elements.hxx>
+
+#include "vector"
+#include "utility"
+#include "memory"
+#include "map"
+#include "../../include/ossie/componentProfile.h"
+#include "../../include/ossie/SoftPkg.h"
+
+namespace xml_schema
+{
+  // Built-in XML Schema types mapping.
+  //
+  typedef ::xsd::cxx::parser::string_sequence< char > string_sequence;
+  typedef ::xsd::cxx::parser::qname< char > qname;
+  typedef ::xsd::cxx::parser::buffer buffer;
+  typedef ::xsd::cxx::parser::time_zone time_zone;
+  typedef ::xsd::cxx::parser::gday gday;
+  typedef ::xsd::cxx::parser::gmonth gmonth;
+  typedef ::xsd::cxx::parser::gyear gyear;
+  typedef ::xsd::cxx::parser::gmonth_day gmonth_day;
+  typedef ::xsd::cxx::parser::gyear_month gyear_month;
+  typedef ::xsd::cxx::parser::date date;
+  typedef ::xsd::cxx::parser::time time;
+  typedef ::xsd::cxx::parser::date_time date_time;
+  typedef ::xsd::cxx::parser::duration duration;
+
+  // Base parser skeletons.
+  //
+  typedef ::xsd::cxx::parser::parser_base< char > parser_base;
+  typedef ::xsd::cxx::parser::validating::empty_content< char > empty_content;
+  typedef ::xsd::cxx::parser::validating::simple_content< char > simple_content;
+  typedef ::xsd::cxx::parser::validating::complex_content< char > complex_content;
+  typedef ::xsd::cxx::parser::validating::list_base< char > list_base;
+
+  // Parser skeletons and implementations for the XML Schema
+  // built-in types.
+  //
+  typedef ::xsd::cxx::parser::validating::any_type_pskel< char > any_type_pskel;
+  typedef ::xsd::cxx::parser::validating::any_type_pimpl< char > any_type_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::any_simple_type_pskel< char > any_simple_type_pskel;
+  typedef ::xsd::cxx::parser::validating::any_simple_type_pimpl< char > any_simple_type_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::byte_pskel< char > byte_pskel;
+  typedef ::xsd::cxx::parser::validating::byte_pimpl< char > byte_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::unsigned_byte_pskel< char > unsigned_byte_pskel;
+  typedef ::xsd::cxx::parser::validating::unsigned_byte_pimpl< char > unsigned_byte_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::short_pskel< char > short_pskel;
+  typedef ::xsd::cxx::parser::validating::short_pimpl< char > short_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::unsigned_short_pskel< char > unsigned_short_pskel;
+  typedef ::xsd::cxx::parser::validating::unsigned_short_pimpl< char > unsigned_short_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::int_pskel< char > int_pskel;
+  typedef ::xsd::cxx::parser::validating::int_pimpl< char > int_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::unsigned_int_pskel< char > unsigned_int_pskel;
+  typedef ::xsd::cxx::parser::validating::unsigned_int_pimpl< char > unsigned_int_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::long_pskel< char > long_pskel;
+  typedef ::xsd::cxx::parser::validating::long_pimpl< char > long_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::unsigned_long_pskel< char > unsigned_long_pskel;
+  typedef ::xsd::cxx::parser::validating::unsigned_long_pimpl< char > unsigned_long_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::integer_pskel< char > integer_pskel;
+  typedef ::xsd::cxx::parser::validating::integer_pimpl< char > integer_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::non_positive_integer_pskel< char > non_positive_integer_pskel;
+  typedef ::xsd::cxx::parser::validating::non_positive_integer_pimpl< char > non_positive_integer_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::non_negative_integer_pskel< char > non_negative_integer_pskel;
+  typedef ::xsd::cxx::parser::validating::non_negative_integer_pimpl< char > non_negative_integer_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::positive_integer_pskel< char > positive_integer_pskel;
+  typedef ::xsd::cxx::parser::validating::positive_integer_pimpl< char > positive_integer_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::negative_integer_pskel< char > negative_integer_pskel;
+  typedef ::xsd::cxx::parser::validating::negative_integer_pimpl< char > negative_integer_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::boolean_pskel< char > boolean_pskel;
+  typedef ::xsd::cxx::parser::validating::boolean_pimpl< char > boolean_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::float_pskel< char > float_pskel;
+  typedef ::xsd::cxx::parser::validating::float_pimpl< char > float_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::double_pskel< char > double_pskel;
+  typedef ::xsd::cxx::parser::validating::double_pimpl< char > double_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::decimal_pskel< char > decimal_pskel;
+  typedef ::xsd::cxx::parser::validating::decimal_pimpl< char > decimal_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::string_pskel< char > string_pskel;
+  typedef ::xsd::cxx::parser::validating::string_pimpl< char > string_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::normalized_string_pskel< char > normalized_string_pskel;
+  typedef ::xsd::cxx::parser::validating::normalized_string_pimpl< char > normalized_string_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::token_pskel< char > token_pskel;
+  typedef ::xsd::cxx::parser::validating::token_pimpl< char > token_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::name_pskel< char > name_pskel;
+  typedef ::xsd::cxx::parser::validating::name_pimpl< char > name_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::nmtoken_pskel< char > nmtoken_pskel;
+  typedef ::xsd::cxx::parser::validating::nmtoken_pimpl< char > nmtoken_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::nmtokens_pskel< char > nmtokens_pskel;
+  typedef ::xsd::cxx::parser::validating::nmtokens_pimpl< char > nmtokens_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::ncname_pskel< char > ncname_pskel;
+  typedef ::xsd::cxx::parser::validating::ncname_pimpl< char > ncname_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::language_pskel< char > language_pskel;
+  typedef ::xsd::cxx::parser::validating::language_pimpl< char > language_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::id_pskel< char > id_pskel;
+  typedef ::xsd::cxx::parser::validating::id_pimpl< char > id_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::idref_pskel< char > idref_pskel;
+  typedef ::xsd::cxx::parser::validating::idref_pimpl< char > idref_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::idrefs_pskel< char > idrefs_pskel;
+  typedef ::xsd::cxx::parser::validating::idrefs_pimpl< char > idrefs_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::uri_pskel< char > uri_pskel;
+  typedef ::xsd::cxx::parser::validating::uri_pimpl< char > uri_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::qname_pskel< char > qname_pskel;
+  typedef ::xsd::cxx::parser::validating::qname_pimpl< char > qname_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::base64_binary_pskel< char > base64_binary_pskel;
+  typedef ::xsd::cxx::parser::validating::base64_binary_pimpl< char > base64_binary_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::hex_binary_pskel< char > hex_binary_pskel;
+  typedef ::xsd::cxx::parser::validating::hex_binary_pimpl< char > hex_binary_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::date_pskel< char > date_pskel;
+  typedef ::xsd::cxx::parser::validating::date_pimpl< char > date_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::date_time_pskel< char > date_time_pskel;
+  typedef ::xsd::cxx::parser::validating::date_time_pimpl< char > date_time_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::duration_pskel< char > duration_pskel;
+  typedef ::xsd::cxx::parser::validating::duration_pimpl< char > duration_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::gday_pskel< char > gday_pskel;
+  typedef ::xsd::cxx::parser::validating::gday_pimpl< char > gday_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::gmonth_pskel< char > gmonth_pskel;
+  typedef ::xsd::cxx::parser::validating::gmonth_pimpl< char > gmonth_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::gmonth_day_pskel< char > gmonth_day_pskel;
+  typedef ::xsd::cxx::parser::validating::gmonth_day_pimpl< char > gmonth_day_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::gyear_pskel< char > gyear_pskel;
+  typedef ::xsd::cxx::parser::validating::gyear_pimpl< char > gyear_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::gyear_month_pskel< char > gyear_month_pskel;
+  typedef ::xsd::cxx::parser::validating::gyear_month_pimpl< char > gyear_month_pimpl;
+
+  typedef ::xsd::cxx::parser::validating::time_pskel< char > time_pskel;
+  typedef ::xsd::cxx::parser::validating::time_pimpl< char > time_pimpl;
+
+  // Exceptions. See libxsd/xsd/cxx/parser/exceptions.hxx for details.
+  //
+  typedef ::xsd::cxx::parser::exception< char > exception;
+
+  // Parsing diagnostics.
+  //
+  typedef ::xsd::cxx::parser::severity severity;
+  typedef ::xsd::cxx::parser::error< char > error;
+  typedef ::xsd::cxx::parser::diagnostics< char > diagnostics;
+  typedef ::xsd::cxx::parser::parsing< char > parsing;
+
+  // Error handler. See libxsd/xsd/cxx/xml/error-handler.hxx for details.
+  //
+  typedef ::xsd::cxx::xml::error_handler< char > error_handler;
+
+  // Read-only string.
+  //
+  typedef ::xsd::cxx::ro_string< char > ro_string;
+
+  // Document type. See libxsd/xsd/cxx/parser/expat/elements.hxx
+  // for details.
+  //
+  typedef ::xsd::cxx::parser::expat::document< char > document;
+}
+
+namespace spd
+{
+  class softPkg_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    title (const ::std::string&);
+
+    virtual void
+    author (const ossie::SPD::Author&);
+
+    virtual void
+    description (const ::std::string&);
+
+    virtual void
+    propertyfile (const ::std::string&);
+
+    virtual void
+    descriptor (const ::std::string&);
+
+    virtual void
+    implementation (const ossie::SPD::Implementation&);
+
+    virtual void
+    usesdevice (const ossie::SPD::UsesDevice&);
+
+    virtual void
+    id (const ::std::string&);
+
+    virtual void
+    name (const ::std::string&);
+
+    virtual void
+    type (const ::std::string&);
+
+    virtual void
+    version (const ::std::string&);
+
+    virtual std::auto_ptr<ossie::SPD>
+    post_softPkg () = 0;
+
+    // Parser construction API.
+    //
+    void
+    title_parser (::xml_schema::string_pskel&);
+
+    void
+    author_parser (::spd::author_pskel&);
+
+    void
+    description_parser (::xml_schema::string_pskel&);
+
+    void
+    propertyfile_parser (::spd::propertyFile_pskel&);
+
+    void
+    descriptor_parser (::spd::descriptor_pskel&);
+
+    void
+    implementation_parser (::spd::implementation_pskel&);
+
+    void
+    usesdevice_parser (::spd::usesDevice_pskel&);
+
+    void
+    id_parser (::xml_schema::string_pskel&);
+
+    void
+    name_parser (::xml_schema::string_pskel&);
+
+    void
+    type_parser (::xml_schema::string_pskel&);
+
+    void
+    version_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* title */,
+             ::spd::author_pskel& /* author */,
+             ::xml_schema::string_pskel& /* description */,
+             ::spd::propertyFile_pskel& /* propertyfile */,
+             ::spd::descriptor_pskel& /* descriptor */,
+             ::spd::implementation_pskel& /* implementation */,
+             ::spd::usesDevice_pskel& /* usesdevice */,
+             ::xml_schema::string_pskel& /* id */,
+             ::xml_schema::string_pskel& /* name */,
+             ::xml_schema::string_pskel& /* type */,
+             ::xml_schema::string_pskel& /* version */);
+
+    // Constructor.
+    //
+    softPkg_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* title_parser_;
+    ::spd::author_pskel* author_parser_;
+    ::xml_schema::string_pskel* description_parser_;
+    ::spd::propertyFile_pskel* propertyfile_parser_;
+    ::spd::descriptor_pskel* descriptor_parser_;
+    ::spd::implementation_pskel* implementation_parser_;
+    ::spd::usesDevice_pskel* usesdevice_parser_;
+    ::xml_schema::string_pskel* id_parser_;
+    ::xml_schema::string_pskel* name_parser_;
+    ::xml_schema::string_pskel* type_parser_;
+    ::xml_schema::string_pskel* version_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::spd::softPkg_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+
+    protected:
+    struct v_state_attr_
+    {
+      bool id;
+      bool name;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class localFile_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    name (const ::std::string&);
+
+    virtual ::std::string
+    post_localFile () = 0;
+
+    // Parser construction API.
+    //
+    void
+    name_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* name */);
+
+    // Constructor.
+    //
+    localFile_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* name_parser_;
+
+    protected:
+    struct v_state_attr_
+    {
+      bool name;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class propertyFile_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    localfile (const ::std::string&);
+
+    virtual void
+    type (const ::std::string&);
+
+    virtual ::std::string
+    post_propertyFile () = 0;
+
+    // Parser construction API.
+    //
+    void
+    localfile_parser (::spd::localFile_pskel&);
+
+    void
+    type_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::spd::localFile_pskel& /* localfile */,
+             ::xml_schema::string_pskel& /* type */);
+
+    // Constructor.
+    //
+    propertyFile_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::spd::localFile_pskel* localfile_parser_;
+    ::xml_schema::string_pskel* type_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::spd::propertyFile_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+  };
+
+  class author_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    name (const ::std::string&);
+
+    virtual void
+    company (const ::std::string&);
+
+    virtual void
+    webpage (const ::std::string&);
+
+    virtual ossie::SPD::Author
+    post_author () = 0;
+
+    // Parser construction API.
+    //
+    void
+    name_parser (::xml_schema::string_pskel&);
+
+    void
+    company_parser (::xml_schema::string_pskel&);
+
+    void
+    webpage_parser (::xml_schema::uri_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* name */,
+             ::xml_schema::string_pskel& /* company */,
+             ::xml_schema::uri_pskel& /* webpage */);
+
+    // Constructor.
+    //
+    author_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::xml_schema::string_pskel* name_parser_;
+    ::xml_schema::string_pskel* company_parser_;
+    ::xml_schema::uri_pskel* webpage_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::spd::author_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+  };
+
+  class descriptor_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    localfile (const ::std::string&);
+
+    virtual void
+    name (const ::std::string&);
+
+    virtual ::std::string
+    post_descriptor () = 0;
+
+    // Parser construction API.
+    //
+    void
+    localfile_parser (::spd::localFile_pskel&);
+
+    void
+    name_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::spd::localFile_pskel& /* localfile */,
+             ::xml_schema::string_pskel& /* name */);
+
+    // Constructor.
+    //
+    descriptor_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::spd::localFile_pskel* localfile_parser_;
+    ::xml_schema::string_pskel* name_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::spd::descriptor_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+  };
+
+  class implementation_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    description (const ::std::string&);
+
+    virtual void
+    propertyfile (const ::std::string&);
+
+    virtual void
+    code (const ossie::SPD::Code&);
+
+    virtual void
+    compiler (const ossie::SPD::NameVersionPair&);
+
+    virtual void
+    programminglanguage ();
+
+    virtual void
+    humanlanguage ();
+
+    virtual void
+    runtime (const ossie::SPD::NameVersionPair&);
+
+    virtual void
+    os (const ossie::SPD::NameVersionPair&);
+
+    virtual void
+    processor (const ::std::string&);
+
+    virtual void
+    dependency (ossie::SPD::DependencyRef*);
+
+    virtual void
+    usesdevice (const ossie::SPD::UsesDevice&);
+
+    virtual void
+    id (const ::std::string&);
+
+    virtual void
+    aepcompliance ();
+
+    virtual ossie::SPD::Implementation
+    post_implementation () = 0;
+
+    // Parser construction API.
+    //
+    void
+    description_parser (::xml_schema::string_pskel&);
+
+    void
+    propertyfile_parser (::spd::propertyFile_pskel&);
+
+    void
+    code_parser (::spd::code_pskel&);
+
+    void
+    compiler_parser (::spd::compiler_pskel&);
+
+    void
+    programminglanguage_parser (::spd::programmingLanguage_pskel&);
+
+    void
+    humanlanguage_parser (::spd::humanLanguage_pskel&);
+
+    void
+    runtime_parser (::spd::runtime_pskel&);
+
+    void
+    os_parser (::spd::os_pskel&);
+
+    void
+    processor_parser (::spd::processor_pskel&);
+
+    void
+    dependency_parser (::spd::dependency_pskel&);
+
+    void
+    usesdevice_parser (::spd::usesDevice_pskel&);
+
+    void
+    id_parser (::xml_schema::string_pskel&);
+
+    void
+    aepcompliance_parser (::spd::aepcompliance_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* description */,
+             ::spd::propertyFile_pskel& /* propertyfile */,
+             ::spd::code_pskel& /* code */,
+             ::spd::compiler_pskel& /* compiler */,
+             ::spd::programmingLanguage_pskel& /* programminglanguage */,
+             ::spd::humanLanguage_pskel& /* humanlanguage */,
+             ::spd::runtime_pskel& /* runtime */,
+             ::spd::os_pskel& /* os */,
+             ::spd::processor_pskel& /* processor */,
+             ::spd::dependency_pskel& /* dependency */,
+             ::spd::usesDevice_pskel& /* usesdevice */,
+             ::xml_schema::string_pskel& /* id */,
+             ::spd::aepcompliance_pskel& /* aepcompliance */);
+
+    // Constructor.
+    //
+    implementation_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* description_parser_;
+    ::spd::propertyFile_pskel* propertyfile_parser_;
+    ::spd::code_pskel* code_parser_;
+    ::spd::compiler_pskel* compiler_parser_;
+    ::spd::programmingLanguage_pskel* programminglanguage_parser_;
+    ::spd::humanLanguage_pskel* humanlanguage_parser_;
+    ::spd::runtime_pskel* runtime_parser_;
+    ::spd::os_pskel* os_parser_;
+    ::spd::processor_pskel* processor_parser_;
+    ::spd::dependency_pskel* dependency_parser_;
+    ::spd::usesDevice_pskel* usesdevice_parser_;
+    ::xml_schema::string_pskel* id_parser_;
+    ::spd::aepcompliance_pskel* aepcompliance_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::spd::implementation_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[3UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+
+    void
+    choice_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start);
+
+    protected:
+    struct v_state_attr_
+    {
+      bool id;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class code_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    localfile (const ::std::string&);
+
+    virtual void
+    entrypoint (const ::std::string&);
+
+    virtual void
+    stacksize (unsigned long long);
+
+    virtual void
+    priority (unsigned long long);
+
+    virtual void
+    type (const ::std::string&);
+
+    virtual ossie::SPD::Code
+    post_code () = 0;
+
+    // Parser construction API.
+    //
+    void
+    localfile_parser (::spd::localFile_pskel&);
+
+    void
+    entrypoint_parser (::xml_schema::string_pskel&);
+
+    void
+    stacksize_parser (::xml_schema::unsigned_long_pskel&);
+
+    void
+    priority_parser (::xml_schema::unsigned_long_pskel&);
+
+    void
+    type_parser (::spd::codeFileType_pskel&);
+
+    void
+    parsers (::spd::localFile_pskel& /* localfile */,
+             ::xml_schema::string_pskel& /* entrypoint */,
+             ::xml_schema::unsigned_long_pskel& /* stacksize */,
+             ::xml_schema::unsigned_long_pskel& /* priority */,
+             ::spd::codeFileType_pskel& /* type */);
+
+    // Constructor.
+    //
+    code_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::spd::localFile_pskel* localfile_parser_;
+    ::xml_schema::string_pskel* entrypoint_parser_;
+    ::xml_schema::unsigned_long_pskel* stacksize_parser_;
+    ::xml_schema::unsigned_long_pskel* priority_parser_;
+    ::spd::codeFileType_pskel* type_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::spd::code_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+  };
+
+  class codeFileType_pskel: public virtual ::xml_schema::nmtoken_pskel
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual ::std::string
+    post_codeFileType ();
+  };
+
+  class compiler_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    name (const ::std::string&);
+
+    virtual void
+    version (const ::std::string&);
+
+    virtual ossie::SPD::NameVersionPair
+    post_compiler () = 0;
+
+    // Parser construction API.
+    //
+    void
+    name_parser (::xml_schema::string_pskel&);
+
+    void
+    version_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* name */,
+             ::xml_schema::string_pskel& /* version */);
+
+    // Constructor.
+    //
+    compiler_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* name_parser_;
+    ::xml_schema::string_pskel* version_parser_;
+
+    protected:
+    struct v_state_attr_
+    {
+      bool name;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class programmingLanguage_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    name (const ::std::string&);
+
+    virtual void
+    version (const ::std::string&);
+
+    virtual void
+    post_programmingLanguage ();
+
+    // Parser construction API.
+    //
+    void
+    name_parser (::xml_schema::string_pskel&);
+
+    void
+    version_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* name */,
+             ::xml_schema::string_pskel& /* version */);
+
+    // Constructor.
+    //
+    programmingLanguage_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* name_parser_;
+    ::xml_schema::string_pskel* version_parser_;
+
+    protected:
+    struct v_state_attr_
+    {
+      bool name;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class humanLanguage_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    name (const ::std::string&);
+
+    virtual void
+    post_humanLanguage ();
+
+    // Parser construction API.
+    //
+    void
+    name_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* name */);
+
+    // Constructor.
+    //
+    humanLanguage_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* name_parser_;
+
+    protected:
+    struct v_state_attr_
+    {
+      bool name;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class os_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    name (const ::std::string&);
+
+    virtual void
+    version (const ::std::string&);
+
+    virtual ossie::SPD::NameVersionPair
+    post_os () = 0;
+
+    // Parser construction API.
+    //
+    void
+    name_parser (::xml_schema::string_pskel&);
+
+    void
+    version_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* name */,
+             ::xml_schema::string_pskel& /* version */);
+
+    // Constructor.
+    //
+    os_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* name_parser_;
+    ::xml_schema::string_pskel* version_parser_;
+
+    protected:
+    struct v_state_attr_
+    {
+      bool name;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class processor_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    name (const ::std::string&);
+
+    virtual ::std::string
+    post_processor () = 0;
+
+    // Parser construction API.
+    //
+    void
+    name_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* name */);
+
+    // Constructor.
+    //
+    processor_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* name_parser_;
+
+    protected:
+    struct v_state_attr_
+    {
+      bool name;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class dependency_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    softpkgref (const ossie::SPD::SoftPkgRef&);
+
+    virtual void
+    propertyref (const ossie::SPD::PropertyRef&);
+
+    virtual void
+    simpleref (ossie::SimplePropertyRef*);
+
+    virtual void
+    simplesequenceref (ossie::SimpleSequencePropertyRef*);
+
+    virtual void
+    structref (ossie::StructPropertyRef*);
+
+    virtual void
+    structsequenceref (ossie::StructSequencePropertyRef*);
+
+    virtual void
+    type (const ::std::string&);
+
+    virtual ossie::SPD::DependencyRef*
+    post_dependency () = 0;
+
+    // Parser construction API.
+    //
+    void
+    softpkgref_parser (::spd::softPkgRef_pskel&);
+
+    void
+    propertyref_parser (::spd::propertyRef_pskel&);
+
+    void
+    simpleref_parser (::spd::simpleref_pskel&);
+
+    void
+    simplesequenceref_parser (::spd::simplesequenceref_pskel&);
+
+    void
+    structref_parser (::spd::structref_pskel&);
+
+    void
+    structsequenceref_parser (::spd::structsequenceref_pskel&);
+
+    void
+    type_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::spd::softPkgRef_pskel& /* softpkgref */,
+             ::spd::propertyRef_pskel& /* propertyref */,
+             ::spd::simpleref_pskel& /* simpleref */,
+             ::spd::simplesequenceref_pskel& /* simplesequenceref */,
+             ::spd::structref_pskel& /* structref */,
+             ::spd::structsequenceref_pskel& /* structsequenceref */,
+             ::xml_schema::string_pskel& /* type */);
+
+    // Constructor.
+    //
+    dependency_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::spd::softPkgRef_pskel* softpkgref_parser_;
+    ::spd::propertyRef_pskel* propertyref_parser_;
+    ::spd::simpleref_pskel* simpleref_parser_;
+    ::spd::simplesequenceref_pskel* simplesequenceref_parser_;
+    ::spd::structref_pskel* structref_parser_;
+    ::spd::structsequenceref_pskel* structsequenceref_parser_;
+    ::xml_schema::string_pskel* type_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::spd::dependency_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    choice_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start);
+
+    protected:
+    struct v_state_attr_
+    {
+      bool type;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class runtime_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    name (const ::std::string&);
+
+    virtual void
+    version (const ::std::string&);
+
+    virtual ossie::SPD::NameVersionPair
+    post_runtime () = 0;
+
+    // Parser construction API.
+    //
+    void
+    name_parser (::xml_schema::string_pskel&);
+
+    void
+    version_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* name */,
+             ::xml_schema::string_pskel& /* version */);
+
+    // Constructor.
+    //
+    runtime_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* name_parser_;
+    ::xml_schema::string_pskel* version_parser_;
+
+    protected:
+    struct v_state_attr_
+    {
+      bool name;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class propertyRef_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    refid (const ::std::string&);
+
+    virtual void
+    value (const ::std::string&);
+
+    virtual ossie::SPD::PropertyRef
+    post_propertyRef () = 0;
+
+    // Parser construction API.
+    //
+    void
+    refid_parser (::xml_schema::string_pskel&);
+
+    void
+    value_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* refid */,
+             ::xml_schema::string_pskel& /* value */);
+
+    // Constructor.
+    //
+    propertyRef_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* refid_parser_;
+    ::xml_schema::string_pskel* value_parser_;
+
+    protected:
+    struct v_state_attr_
+    {
+      bool refid;
+      bool value;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class softPkgRef_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    localfile (const ::std::string&);
+
+    virtual void
+    implref (const ::std::string&);
+
+    virtual ossie::SPD::SoftPkgRef
+    post_softPkgRef () = 0;
+
+    // Parser construction API.
+    //
+    void
+    localfile_parser (::spd::localFile_pskel&);
+
+    void
+    implref_parser (::spd::implRef_pskel&);
+
+    void
+    parsers (::spd::localFile_pskel& /* localfile */,
+             ::spd::implRef_pskel& /* implref */);
+
+    // Constructor.
+    //
+    softPkgRef_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::spd::localFile_pskel* localfile_parser_;
+    ::spd::implRef_pskel* implref_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::spd::softPkgRef_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+  };
+
+  class implRef_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    refid (const ::std::string&);
+
+    virtual ::std::string
+    post_implRef () = 0;
+
+    // Parser construction API.
+    //
+    void
+    refid_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* refid */);
+
+    // Constructor.
+    //
+    implRef_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* refid_parser_;
+
+    protected:
+    struct v_state_attr_
+    {
+      bool refid;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class usesDevice_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    propertyref (const ossie::SPD::PropertyRef&);
+
+    virtual void
+    simpleref (ossie::SimplePropertyRef*);
+
+    virtual void
+    simplesequenceref (ossie::SimpleSequencePropertyRef*);
+
+    virtual void
+    structref (ossie::StructPropertyRef*);
+
+    virtual void
+    structsequenceref (ossie::StructSequencePropertyRef*);
+
+    virtual void
+    id (const ::std::string&);
+
+    virtual void
+    type (const ::std::string&);
+
+    virtual ossie::SPD::UsesDevice
+    post_usesDevice () = 0;
+
+    // Parser construction API.
+    //
+    void
+    propertyref_parser (::spd::propertyRef_pskel&);
+
+    void
+    simpleref_parser (::spd::simpleref_pskel&);
+
+    void
+    simplesequenceref_parser (::spd::simplesequenceref_pskel&);
+
+    void
+    structref_parser (::spd::structref_pskel&);
+
+    void
+    structsequenceref_parser (::spd::structsequenceref_pskel&);
+
+    void
+    id_parser (::xml_schema::string_pskel&);
+
+    void
+    type_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::spd::propertyRef_pskel& /* propertyref */,
+             ::spd::simpleref_pskel& /* simpleref */,
+             ::spd::simplesequenceref_pskel& /* simplesequenceref */,
+             ::spd::structref_pskel& /* structref */,
+             ::spd::structsequenceref_pskel& /* structsequenceref */,
+             ::xml_schema::string_pskel& /* id */,
+             ::xml_schema::string_pskel& /* type */);
+
+    // Constructor.
+    //
+    usesDevice_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::spd::propertyRef_pskel* propertyref_parser_;
+    ::spd::simpleref_pskel* simpleref_parser_;
+    ::spd::simplesequenceref_pskel* simplesequenceref_parser_;
+    ::spd::structref_pskel* structref_parser_;
+    ::spd::structsequenceref_pskel* structsequenceref_parser_;
+    ::xml_schema::string_pskel* id_parser_;
+    ::xml_schema::string_pskel* type_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::spd::usesDevice_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    choice_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start);
+
+    protected:
+    struct v_state_attr_
+    {
+      bool id;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class simpleref_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    refid (const ::std::string&);
+
+    virtual void
+    value (const ::std::string&);
+
+    virtual ossie::SimplePropertyRef*
+    post_simpleref () = 0;
+
+    // Parser construction API.
+    //
+    void
+    refid_parser (::xml_schema::string_pskel&);
+
+    void
+    value_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* refid */,
+             ::xml_schema::string_pskel& /* value */);
+
+    // Constructor.
+    //
+    simpleref_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::xml_schema::string_pskel* refid_parser_;
+    ::xml_schema::string_pskel* value_parser_;
+
+    protected:
+    struct v_state_attr_
+    {
+      bool refid;
+      bool value;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class simplesequenceref_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    values (const ::std::vector<std::string>&);
+
+    virtual void
+    refid (const ::std::string&);
+
+    virtual ossie::SimpleSequencePropertyRef*
+    post_simplesequenceref () = 0;
+
+    // Parser construction API.
+    //
+    void
+    values_parser (::spd::values_pskel&);
+
+    void
+    refid_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::spd::values_pskel& /* values */,
+             ::xml_schema::string_pskel& /* refid */);
+
+    // Constructor.
+    //
+    simplesequenceref_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::spd::values_pskel* values_parser_;
+    ::xml_schema::string_pskel* refid_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::spd::simplesequenceref_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+
+    protected:
+    struct v_state_attr_
+    {
+      bool refid;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class structref_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    simpleref (ossie::SimplePropertyRef*);
+
+    virtual void
+    simplesequenceref (ossie::SimpleSequencePropertyRef*);
+
+    virtual void
+    refid (const ::std::string&);
+
+    virtual ossie::StructPropertyRef*
+    post_structref () = 0;
+
+    // Parser construction API.
+    //
+    void
+    simpleref_parser (::spd::simpleref_pskel&);
+
+    void
+    simplesequenceref_parser (::spd::simplesequenceref_pskel&);
+
+    void
+    refid_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::spd::simpleref_pskel& /* simpleref */,
+             ::spd::simplesequenceref_pskel& /* simplesequenceref */,
+             ::xml_schema::string_pskel& /* refid */);
+
+    // Constructor.
+    //
+    structref_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::spd::simpleref_pskel* simpleref_parser_;
+    ::spd::simplesequenceref_pskel* simplesequenceref_parser_;
+    ::xml_schema::string_pskel* refid_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::spd::structref_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[3UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+
+    void
+    choice_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start);
+
+    protected:
+    struct v_state_attr_
+    {
+      bool refid;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class structsequenceref_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    structvalue (const ::std::map<std::string, ossie::ComponentProperty*>&);
+
+    virtual void
+    refid (const ::std::string&);
+
+    virtual ossie::StructSequencePropertyRef*
+    post_structsequenceref () = 0;
+
+    // Parser construction API.
+    //
+    void
+    structvalue_parser (::spd::structvalue_pskel&);
+
+    void
+    refid_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::spd::structvalue_pskel& /* structvalue */,
+             ::xml_schema::string_pskel& /* refid */);
+
+    // Constructor.
+    //
+    structsequenceref_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    virtual bool
+    _attribute_impl_phase_one (const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&,
+                               const ::xml_schema::ro_string&);
+
+
+    protected:
+    ::spd::structvalue_pskel* structvalue_parser_;
+    ::xml_schema::string_pskel* refid_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::spd::structsequenceref_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+
+    protected:
+    struct v_state_attr_
+    {
+      bool refid;
+    };
+
+    v_state_attr_ v_state_attr_first_;
+    ::xsd::cxx::parser::pod_stack v_state_attr_stack_;
+
+    virtual void
+    _pre_a_validate ();
+
+    virtual void
+    _post_a_validate ();
+  };
+
+  class structvalue_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    simpleref (ossie::SimplePropertyRef*);
+
+    virtual void
+    simplesequenceref (ossie::SimpleSequencePropertyRef*);
+
+    virtual ::std::map<std::string, ossie::ComponentProperty*>
+    post_structvalue () = 0;
+
+    // Parser construction API.
+    //
+    void
+    simpleref_parser (::spd::simpleref_pskel&);
+
+    void
+    simplesequenceref_parser (::spd::simplesequenceref_pskel&);
+
+    void
+    parsers (::spd::simpleref_pskel& /* simpleref */,
+             ::spd::simplesequenceref_pskel& /* simplesequenceref */);
+
+    // Constructor.
+    //
+    structvalue_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::spd::simpleref_pskel* simpleref_parser_;
+    ::spd::simplesequenceref_pskel* simplesequenceref_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::spd::structvalue_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[3UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+
+    void
+    choice_0 (unsigned long& state,
+              unsigned long& count,
+              const ::xml_schema::ro_string& ns,
+              const ::xml_schema::ro_string& n,
+              const ::xml_schema::ro_string* t,
+              bool start);
+  };
+
+  class values_pskel: public ::xml_schema::complex_content
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    value (const ::std::string&);
+
+    virtual ::std::vector<std::string>
+    post_values () = 0;
+
+    // Parser construction API.
+    //
+    void
+    value_parser (::xml_schema::string_pskel&);
+
+    void
+    parsers (::xml_schema::string_pskel& /* value */);
+
+    // Constructor.
+    //
+    values_pskel ();
+
+    // Implementation.
+    //
+    protected:
+    virtual bool
+    _start_element_impl (const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string&,
+                         const ::xml_schema::ro_string*);
+
+    virtual bool
+    _end_element_impl (const ::xml_schema::ro_string&,
+                       const ::xml_schema::ro_string&);
+
+    protected:
+    ::xml_schema::string_pskel* value_parser_;
+
+    protected:
+    struct v_state_descr_
+    {
+      void (::spd::values_pskel::*func) (
+        unsigned long&,
+        unsigned long&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string&,
+        const ::xml_schema::ro_string*,
+        bool);
+      unsigned long state;
+      unsigned long count;
+    };
+
+    struct v_state_
+    {
+      v_state_descr_ data[2UL];
+      unsigned long size;
+    };
+
+    v_state_ v_state_first_;
+    ::xsd::cxx::parser::pod_stack v_state_stack_;
+
+    virtual void
+    _pre_e_validate ();
+
+    virtual void
+    _post_e_validate ();
+
+    void
+    sequence_0 (unsigned long& state,
+                unsigned long& count,
+                const ::xml_schema::ro_string& ns,
+                const ::xml_schema::ro_string& n,
+                const ::xml_schema::ro_string* t,
+                bool start);
+  };
+
+  class aepcompliance_pskel: public virtual ::xml_schema::nmtoken_pskel
+  {
+    public:
+    // Parser callbacks. Override them in your implementation.
+    //
+    // virtual void
+    // pre ();
+
+    virtual void
+    post_aepcompliance ();
+  };
+}
+
+#include <xsd/cxx/post.hxx>
+
+// Begin epilogue.
+//
+//
+// End epilogue.
+
+#endif // CXX______XML_XSD_SPD_PSKEL_H
